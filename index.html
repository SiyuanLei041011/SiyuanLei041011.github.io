<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/20/LC-3Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/11/20/LC-3Lab/" class="post-title-link" itemprop="url">LC-3Lab</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-11-20T00:00:00+08:00">2025-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-28 14:24:03" itemprop="dateModified" datetime="2026-02-28T14:24:03+08:00">2026-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一次实验">第一次实验</h2>
<h3 id="习题1">习题1</h3>
<p>比较R2和R3的内容, 并将最大值放入R1寄存器, 如果两个数相同,
则要求R1等于0. 要求程序起始地址为<code>x3000</code>,
程序完成后正常结束.</p>
<h4 id="实验步骤与实验思路">实验步骤与实验思路:</h4>
<p>首先写好起始地址<code>.ORIG x3000</code>和结束语句<code>.END</code>.</p>
<p>比较两个寄存器的内容的大小可以用减法, 但是LC-3指令集没有提供减法运算,
所以具体做法是, 先对<code>R3</code>取反再加一,
放到<code>R0</code>寄存器里面, 然后和<code>R2</code>相加,
结果放在<code>R0</code>寄存器里面.</p>
<p>根据减法的结果(正数, 负数,
零)跳转(也就是使用<code>BR</code>指令)到对应的后续操作. 如果是正数,
说明<code>R2</code>大, 把<code>R2</code>放到<code>R1</code>里面;
如果是零, 说明两个数相等, 把<code>R1</code>清零即可; 如果是负数,
就把<code>R3</code>的值放入<code>R1</code>里面.</p>
<h4 id="具体实现">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic1.png" /></p>
<p>具体的实现代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    NOT R0, R3</span><br><span class="line">    ADD R0, R0, #1  ;取R3的补码, 放到R0里面</span><br><span class="line">    ADD R0, R2, R0  ;计算R2-R0, 结果放到R0里面</span><br><span class="line">    </span><br><span class="line">    BRz ZERO        ;如果结果为0, 则跳转到ZERO, 把R0的内容放到R1里面</span><br><span class="line">    BRp POSITIVE    ;如果结果为正, 则跳转到POSITIVE, 把R2放到R1里面</span><br><span class="line">    BRn NEGATIVE    ;如果结果为负, 则跳转到NEGATIVE, 把R3放到R1里面</span><br><span class="line"></span><br><span class="line">ZERO:</span><br><span class="line">    AND R1, R0, #0  ;把R1清零</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">POSITIVE:</span><br><span class="line">    ADD R1, R2, #0  ;把R2放到R1里面</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">NEGATIVE:</span><br><span class="line">    ADD R1, R3, #0  ;把R3放到R1里面</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程">运行过程</h4>
<p>设置<code>R2=5, R3=3</code>.</p>
<figure>
<img src="/images/LC-3/experiment1/step1.png" alt="图1.1" />
<figcaption aria-hidden="true">图1.1</figcaption>
</figure>
<p>可以看到<code>R0=R2-R3=2</code>, <code>R1=5</code></p>
<figure>
<img src="/images/LC-3/experiment1/step2.png" alt="图1.2" />
<figcaption aria-hidden="true">图1.2</figcaption>
</figure>
<p>设置<code>R2=6, R3=8</code>, 可以得到<code>R0=R2-R3=-2</code>,
<code>R1=8</code></p>
<figure>
<img src="/images/LC-3/experiment1/step3.png" alt="图1.3" />
<figcaption aria-hidden="true">图1.3</figcaption>
</figure>
<p>设置<code>R2=R3=-6</code>, 可以得到<code>R0=R2-R3=0</code>,
<code>R1=0</code></p>
<figure>
<img src="/images/LC-3/experiment1/step4.png" alt="图1.4" />
<figcaption aria-hidden="true">图1.4</figcaption>
</figure>
<h3 id="习题2">习题2</h3>
<p>实现两个正整数的除法, 要求程序从<code>x3000</code>开始执行,
被除数位于<code>x4000</code>, 除数位于<code>x4001</code>,
商放在<code>x5000</code>, 余数放在<code>x5001</code>.</p>
<h4 id="实验步骤与实验思路-1">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>根据题目要求, 先给指定的地址标签(<code>NUM1 .FILL x4000</code>,
<code>NUM2 .FILL x4001</code>, <code>QUOTIENT .FILL x5000</code>,
<code>REMAINDER .FILL x5001</code>), 方便以后使用.
我们把被除数放在<code>R1</code>里面, 除数放在<code>R2</code>里面.
两个正整数的除法就是, 用被除数减去除数, 看看可以减多少次,
所以选用<code>R3</code>作为计数器, 也就是存放商的寄存器.</p>
<p>我们用<code>R1</code>减去<code>R2</code>,
减法的结果放到<code>R1</code>里面, 如果减完为正,
说明还可以继续除以<code>R2</code>, 所以应该继续减法; 如果减完为零,
说明<code>R2</code>整除<code>R1</code>; 如果减完为负, 说明存在余数,
这时直接用这个负数加上被减数就得到余数.</p>
<h4 id="具体实现-1">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic2.png" /></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    LDI R1, NUM1  ;加载被除数到R1中</span><br><span class="line">    LDI R2, NUM2  ;加载除数到R2中</span><br><span class="line">    </span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用来计数R1可以被R2减多少次</span><br><span class="line">    NOT R2, R2</span><br><span class="line">    ADD R2, R2, #1   ;对R2取反加一</span><br><span class="line"></span><br><span class="line">DIV:</span><br><span class="line">    ADD R3, R3, #1   ;计数器先加上1</span><br><span class="line">    ADD R1, R1, R2   ;用R1减去R2, 结果存放在R1里面</span><br><span class="line">    BRp DIV          ;如果结果为正, 则重复循环</span><br><span class="line">    BRz FINISH       ;如果结果为零, 则跳转到FINISH, 说明R2整除R1, 余数为0</span><br><span class="line"></span><br><span class="line">    ADD R3 R3 -1     ;如果结果为负, 说明减过头了, 把计数器减去1</span><br><span class="line">    NOT R2 R2</span><br><span class="line">    ADD R2 R2 1</span><br><span class="line">    ADD R2 R1 R2     ;这里是计算余数, 把余数放到R2里面</span><br><span class="line">    STI R2 REMAINDER ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3 QUOTIENT  ;把商R3放到地址x5000处</span><br><span class="line">    BRp EOP</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    AND R2, R2, #0      ;把余数设为0</span><br><span class="line">    STI R2, REMAINDER   ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3, QUOTIENT    ;把商放到地址x5000处</span><br><span class="line">EOP: </span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">NUM1      .FILL x4000</span><br><span class="line">NUM2      .FILL x4001</span><br><span class="line">QUOTIENT  .FILL x5000</span><br><span class="line">REMAINDER .FILL x5001</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程-1">运行过程</h4>
<p>先将程序加载到LC-3模拟器, 如图所示</p>
<figure>
<img src="/images/LC-3/experiment2/step1.png" alt="图2.1" />
<figcaption aria-hidden="true">图2.1</figcaption>
</figure>
<p>设置地址<code>x4000</code>处的内容为<code>x0019</code>,
地址<code>x4001</code>处的内容为<code>x0005</code></p>
<figure>
<img src="/images/LC-3/experiment2/step2.png" alt="图2.2" />
<figcaption aria-hidden="true">图2.2</figcaption>
</figure>
<p>运行LD指令后, 可以看到<code>R1=25, R2=5</code></p>
<figure>
<img src="/images/LC-3/experiment2/step3.png" alt="图2.3" />
<figcaption aria-hidden="true">图2.3</figcaption>
</figure>
<p>计算一次减法, 可以看到<code>R1=20, R2=-5</code>,
计数器<code>R3=1</code></p>
<figure>
<img src="/images/LC-3/experiment2/step4.png" alt="图2.4" />
<figcaption aria-hidden="true">图2.4</figcaption>
</figure>
<p>计算两次减法, 可以看到<code>R1=15, R2=-5</code>,
计数器<code>R3=2</code></p>
<figure>
<img src="/images/LC-3/experiment2/step5.png" alt="图2.5" />
<figcaption aria-hidden="true">图2.5</figcaption>
</figure>
<p>计算三次减法, 可以看到<code>R1=10, R2=-5</code>,
计数器<code>R3=3</code></p>
<figure>
<img src="/images/LC-3/experiment2/step6.png" alt="图2.6" />
<figcaption aria-hidden="true">图2.6</figcaption>
</figure>
<p>计算四次减法, 可以看到<code>R1=5, R2=-5</code>,
计数器<code>R3=4</code></p>
<figure>
<img src="/images/LC-3/experiment2/step7.png" alt="图2.7" />
<figcaption aria-hidden="true">图2.7</figcaption>
</figure>
<p>计算五次减法, 可以看到<code>R1=0, R2=-5</code>,
计数器<code>R3=5</code></p>
<figure>
<img src="/images/LC-3/experiment2/step8.png" alt="图2.8" />
<figcaption aria-hidden="true">图2.8</figcaption>
</figure>
<p><code>R2</code>整除<code>R1</code>, 程序跳转到<code>FINISH</code>,
把<code>R2</code>和<code>R3</code>分别存储到<code>QUOTIENT</code>和<code>REMAINDER</code>地址处</p>
<p>(这里我发现自己当时把商和余数的地址写反了,
但是这对于之前的过程不影响)</p>
<figure>
<img src="/images/LC-3/experiment2/step9.png" alt="图2.9" />
<figcaption aria-hidden="true">图2.9</figcaption>
</figure>
<p>可以看到<code>x5000</code>处为余数0, <code>x5001</code>处为商5</p>
<figure>
<img src="/images/LC-3/experiment2/step10.png" alt="图2.10" />
<figcaption aria-hidden="true">图2.10</figcaption>
</figure>
<p>设置地址<code>x4000</code>处的内容为<code>x0007</code>,
地址<code>x4001</code>处的内容为<code>x0003</code></p>
<figure>
<img src="/images/LC-3/experiment2/step11.png" alt="图2.11" />
<figcaption aria-hidden="true">图2.11</figcaption>
</figure>
<p>计算一次减法, 可以看到<code>R1=4, R2=-3</code>,
计数器<code>R3=1</code></p>
<figure>
<img src="/images/LC-3/experiment2/step12.png" alt="图2.12" />
<figcaption aria-hidden="true">图2.12</figcaption>
</figure>
<p>计算两次减法, 可以看到<code>R1=1, R2=-3</code>,
计数器<code>R3=2</code></p>
<figure>
<img src="/images/LC-3/experiment2/step13.png" alt="图2.13" />
<figcaption aria-hidden="true">图2.13</figcaption>
</figure>
<p>计算三次减法, 可以看到<code>R1=-2, R2=-3</code>,
计数器<code>R3=3</code></p>
<figure>
<img src="/images/LC-3/experiment2/step14.png" alt="图2.14" />
<figcaption aria-hidden="true">图2.14</figcaption>
</figure>
<p>这是被减数<code>R1</code>小于0, 说明减过头了, 把<code>R3</code>减去1,
然后计算<code>R1+|R2|</code>得到余数, 放进<code>R2</code>中</p>
<figure>
<img src="/images/LC-3/experiment2/step15.png" alt="图2.15" />
<figcaption aria-hidden="true">图2.15</figcaption>
</figure>
<p>可以看到<code>x5000</code>处为商2, <code>x5001</code>处为余数1</p>
<figure>
<img src="/images/LC-3/experiment2/step16.png" alt="图2.16" />
<figcaption aria-hidden="true">图2.16</figcaption>
</figure>
<h3 id="习题3">习题3</h3>
<p>从键盘输入一个值, 范围是数字<code>0~9</code>,
字母<code>a~z</code>以及<code>A~Z</code>.
检查从<code>x3100</code>开始的十个内存单元中是否有该数值, 如果有,
则设置<code>R0=1</code>, 如果没有, 则设置<code>R0=0</code>.
程序存放于<code>x3000</code>地址.</p>
<h4 id="实验步骤与实验思路-2">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.
根据题目要求,
可以使用<code>TRAP x20</code>和<code>TRAP x21</code>进行键盘字符的读取和回显,
读取的字符的ASCII码存放到<code>R0</code>里.
我们把<code>R0</code>的值先装到<code>R1</code>里面便于后续比较,
而<code>R0</code>本身用于存放比较的结果.
我们设置<code>R2</code>作为指针指向搜索的起始地址<code>x3100</code>,
<code>R3</code>作为计数器, 计数十次.</p>
<p>做好上述的准备工作后, 下面我们编写主要的循环.</p>
<p>记循环开始处为<code>LOOP</code>, 在开始处,
首先把<code>R2</code>指向的地址的值给<code>R4</code>,
为了比较<code>R4</code>里面的值是否和<code>R1</code>中的相等,
我们采用减法, 也就是先对<code>R4</code>取反加一,
放到<code>R5</code>里面, 然后用<code>R1</code>加上<code>R5</code>,
如果结果为零, 则跳转到<code>YES</code>处,
这里的<code>YES</code>就是把<code>R0</code>置为<code>1</code>的语句;
如果结果非零, 就更新指针<code>R2</code>和计数器<code>R3</code>,
然后跳回到循环开始的位置进行下一个地址处的比较.
如果<code>R3</code>为零时仍然未找到, 就无条件跳转至<code>NO</code>处,
这里的<code>NO</code>就是把<code>R0</code>置为<code>0</code>,
最后结束程序.</p>
<h4 id="具体实现-2">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic3.png" /></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    TRAP x20   ;从键盘读取字符存放到R0</span><br><span class="line">    TRAP x21   ;回显用户输入的字符</span><br><span class="line">    </span><br><span class="line">    ADD R1, R0, #0   ;把R0的内容放入R1便于后续的比较</span><br><span class="line">    AND R3, R3, #0   ;把计数器R3清零</span><br><span class="line">    ADD R3, R3, #10  ;计数10次</span><br><span class="line">    </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向起始地址x3100</span><br><span class="line"></span><br><span class="line">    AND R0, R0, #0   ;把R0清零, 用于存放比较的结果</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    LDR R4, R2, #0   ;把指针R2指向的地址内容放到R4里面进行后续比较</span><br><span class="line">    NOT R5, R4</span><br><span class="line">    ADD R5, R5, #1   ;对R4取补码, 放入R5中</span><br><span class="line">    ADD R5, R1, R5   ;用R1减去R5, 结果放入R5中</span><br><span class="line">    BRz YES          ;如果结果为0, 则说明该内存单元的内容和输入字符是一样的, 程序跳转到YES</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1   ;如果结果不为零, 则继续循环, 把指针加一</span><br><span class="line">    ADD R3, R3, #-1  ;计数器减一</span><br><span class="line">    BRp LOOP         ;如果计数器R3的值仍然大于零, 则重复循环, 直到等于零</span><br><span class="line">    </span><br><span class="line">    AND R0, R0, #0   ;如果循环了10次, 仍然没有找到内存中有相同的字符, 则把R0清零</span><br><span class="line">    BRnzp FINISH     ;跳转到程序结束</span><br><span class="line"></span><br><span class="line">YES:</span><br><span class="line">    ADD R0, R0, #1   ;把R0加1, 说明找到了</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS .FILL x3100</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程-2">运行过程</h4>
<p>如图,
在地址<code>x3100~x3109</code>处放入内容<code>123456789A</code></p>
<figure>
<img src="/images/LC-3/experiment3/step1.png" alt="图3.1" />
<figcaption aria-hidden="true">图3.1</figcaption>
</figure>
<p>输入<code>2</code>并回显, 把输入的内容放入<code>R1</code>中,
<code>R2</code>指向起始地址<code>x3100</code>,
其内容放入<code>R4</code>中, 然后比较<code>R4</code>和<code>R1</code>,
不为零, 继续循环</p>
<figure>
<img src="/images/LC-3/experiment3/step2.png" alt="图3.2" />
<figcaption aria-hidden="true">图3.2</figcaption>
</figure>
<p>第二次循环中, <code>R4</code>和<code>R1</code>的值相等,
程序跳转到<code>YES</code>, 把<code>R0</code>置为1</p>
<figure>
<img src="/images/LC-3/experiment3/step3.png" alt="图3.3" />
<figcaption aria-hidden="true">图3.3</figcaption>
</figure>
<p>在地址<code>x3100~x3109</code>处放入内容<code>Helloworld</code></p>
<figure>
<img src="/images/LC-3/experiment3/step4.png" alt="图3.4" />
<figcaption aria-hidden="true">图3.4</figcaption>
</figure>
<p>输入<code>A</code>并运行, 当<code>R2</code>指向<code>x310A</code>时,
没有相同的字符, <code>R0</code>置为0, 与预期一致</p>
<figure>
<img src="/images/LC-3/experiment3/step5.png" alt="图3.5" />
<figcaption aria-hidden="true">图3.5</figcaption>
</figure>
<h2 id="第二次实验">第二次实验</h2>
<h3 id="习题4">习题4</h3>
<p>从键盘读取一个字符, 并且统计一个文件中该字符出现的次数,
最后在显示器上显示该数值. 假设一个文件中任意字符的出现次数很小,
即最多只有9次. 文件存放于内存<code>x4000</code>地址起始的内存位置,
内容仅包含<code>1~9, a~z, A~Z</code>.</p>
<h4 id="实验步骤与实验思路-3">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
<code>R0</code>用于读取和输出结果, <code>R1</code>存储键盘输入的结果,
用于和文件的内容比较, <code>R2</code>用作指针,
<code>R3</code>用作计数器. 首先进行初始化:
从键盘读取一个字符放入<code>R0</code>并回显,
把从键盘读取的内容放到<code>R1</code>里面, 供后续的比较,
指针<code>R2</code>指向文件的起始地址<code>x4000</code>,
把<code>R3</code>清零.</p>
<p>做好上述准备工作后, 我们开始编写主要的循环.</p>
<p>循环的开始记为<code>LOOP</code>,
首先把<code>R2</code>指针指向的地址的内容放到<code>R0</code>里面,
如果此时<code>R2</code>指向的地址的内容为空,
则直接跳转到<code>FINISH</code>显示结果; 如果内容不为空,
那么开始进行比较, 首先对<code>R1</code>取补码放到<code>R4</code>里面,
用<code>R0</code>加上<code>R4</code>, 如果结果不为零,
则跳转到<code>NO</code>,
这里<code>NO</code>就是将指针<code>R2</code>加一, 并且返回循环的开头;
如果结果为零, 则将计数器<code>R3</code>加一, 指针<code>R2</code>加一,
然后继续循环.</p>
<p>由于文件的结尾处为<code>0</code>,
所以当<code>R2</code>指向文件的结尾时, 循环结束,
程序跳转到<code>FINISH</code>,
此时计数器<code>R3</code>的内容就是文件中特定字符出现的次数,
但是如果想要把具体的数字打印到屏幕上,
则需要将<code>R3</code>内的数字转换成对应的ASCII码,
一个简单的方式就是加上<code>0</code>的ASCII码,
然后放入<code>R0</code>进行输出即可.</p>
<h4 id="具体实现-3">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic4.png" /></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20         ;从键盘读取字符放到R0里面</span><br><span class="line">    TRAP x21         ;回显</span><br><span class="line">    ADD R1, R0, #0   ;把读取的字符放到R1里面, 便于后续的比较  </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向文件起始位置x4000</span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用作计数器 </span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    LDR R0, R2, #0   ;把指针R2指向的地址内容放入R0</span><br><span class="line">    BRz FINISH       ;如果读到0, 说明文件结束, 跳转到FINISH</span><br><span class="line">    </span><br><span class="line">    NOT R4, R1</span><br><span class="line">    ADD R4, R4, #1   ;把输入的内容R1取补码后放入R4</span><br><span class="line">    ADD R4, R0, R4   ;用R0-R4, 用于比较文件内容是否和输入内容相等</span><br><span class="line">    BRnp NO          ;如果结果非零, 说明不相等, 跳转到NO</span><br><span class="line"></span><br><span class="line">    ADD R3, R3, #1   ;如果结果为零, 说明相等, 计数器R3加一</span><br><span class="line">    </span><br><span class="line">NO:</span><br><span class="line">    ADD R2, R2, #1     ;指针R2加一</span><br><span class="line">    BRnzp LOOP         ;重复循环</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    LD R0, ZERO_ASCII  ;把&#x27;0&#x27;的ASCII码放入R0</span><br><span class="line">    ADD R0, R0, R3     ;R0=&#x27;0&#x27;+R3</span><br><span class="line">    TRAP x21           ;显示R0的内容到屏幕上</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS    .FILL x4000</span><br><span class="line">ZERO_ASCII .FILL x30    ;&#x27;0&#x27;的ASCII</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程-3">运行过程</h4>
<p>把程序加载到LC-3模拟器</p>
<figure>
<img src="/images/LC-3/experiment4/step1.png" alt="图4.1" />
<figcaption aria-hidden="true">图4.1</figcaption>
</figure>
<p>在地址<code>x4000~x400B</code>处设置内容为<code>1, 1, 4, 5, 1, 4, 1, 9, 1, 9, 8, 1, 0</code></p>
<figure>
<img src="/images/LC-3/experiment4/step2.png" alt="图4.2" />
<figcaption aria-hidden="true">图4.2</figcaption>
</figure>
<p>在键盘上输入<code>1</code>并回显</p>
<figure>
<img src="/images/LC-3/experiment4/step3.png" alt="图4.3" />
<figcaption aria-hidden="true">图4.3</figcaption>
</figure>
<p><code>R2</code>作为指针指向起始地址<code>x4001</code>,
<code>R0</code>内放入<code>R2</code>所指向的地址的内容,
计算<code>R0-R1</code>, 如果为0, 那么计数器<code>R3</code>就加一,
后续过程类似</p>
<figure>
<img src="/images/LC-3/experiment4/step4.png" alt="图4.4" />
<figcaption aria-hidden="true">图4.4</figcaption>
</figure>
<p>当<code>R2</code>指向<code>x400C</code>时, 其内容是空字符, 程序结束,
计数器<code>R3=6</code>, 符合预期</p>
<figure>
<img src="/images/LC-3/experiment4/step5.png" alt="图4.5" />
<figcaption aria-hidden="true">图4.5</figcaption>
</figure>
<p>设置地址<code>x4000~x400C</code>的内容为<code>Hello, world!</code></p>
<figure>
<img src="/images/LC-3/experiment4/step6.png" alt="图4.6" />
<figcaption aria-hidden="true">图4.6</figcaption>
</figure>
<p>键盘输入<code>l</code>并回显</p>
<figure>
<img src="/images/LC-3/experiment4/step7.png" alt="图4.7" />
<figcaption aria-hidden="true">图4.7</figcaption>
</figure>
<p>把<code>R0</code>的内容放入<code>R1</code>, <code>R2</code>作为指针,
其指向的内容放在<code>R0</code>中, 字符的比较过程同上</p>
<figure>
<img src="/images/LC-3/experiment4/step8.png" alt="图4.8" />
<figcaption aria-hidden="true">图4.8</figcaption>
</figure>
<figure>
<img src="/images/LC-3/experiment4/step9.png" alt="图4.9" />
<figcaption aria-hidden="true">图4.9</figcaption>
</figure>
<p>当<code>R2</code>指向<code>x400D</code>时, 程序结束,
计数器<code>R3=3</code>, 和预期一致</p>
<figure>
<img src="/images/LC-3/experiment4/step10.png" alt="图4.10" />
<figcaption aria-hidden="true">图4.10</figcaption>
</figure>
<h3 id="习题5">习题5</h3>
<p>将键盘编写的十进制或者十六进制常数(前缀<code>#</code>代表十进制,
前缀<code>x</code>代表十六进制)转换为二进制表达方式,
并且打印出来(假设常数表示时, 十进制或十六进制的数字不超过两个).
例如键盘输入<code>x2A</code>时, 程序输出<code>00101010</code>,
键盘输入<code>#12</code>时, 程序输出<code>00001100</code>.</p>
<h4 id="实验步骤与实验思路-4">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>我们需要解决如下的几个问题:</p>
<ol type="1">
<li>如何根据输入的前缀是<code>#</code>或<code>x</code>来判断后续输入的是十进制还是十六进制?</li>
<li>如何判断输入的是单个字符还是两个字符?</li>
<li>如何把输入字符的ASCII码转化成对应的数值?</li>
<li>如何把对应的数值转化成二进制数?</li>
</ol>
<h5 id="问题1的解决方案">问题1的解决方案</h5>
<p>首先把<code>#</code>读取到<code>R1</code>寄存器中,
输入内容放到<code>R0</code>寄存器中, 计算<code>R0-R1</code>,
结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>#</code>, 如果是,
那么程序跳转到<code>DEC_MODE</code>处理十进制输入; 如果不是,
那么程序继续往下执行, 把<code>x</code>读取到<code>R1</code>寄存器中,
计算<code>R0-R1</code>, 结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>x</code>, 如果是,
那么程序跳转到<code>HEX_MODE</code>处理十六进制输入; 如果不是,
那么为无效输入, 程序直接结束, 跳转到<code>END</code>.</p>
<p>代码实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">TRAP x21           ;回显</span><br><span class="line"></span><br><span class="line">;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line"></span><br><span class="line">;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line"></span><br><span class="line">BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br></pre></td></tr></table></figure>
<h5 id="问题2的解决方案">问题2的解决方案</h5>
<h6 id="十进制输入">十进制输入</h6>
<p>先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
现在判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>DEC_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5, 因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;调用子程序, 将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0       ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line"></span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0       ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R4, R0, #0       ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0       ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3       ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ; 计算 10 × 十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br></pre></td></tr></table></figure>
<p>这里我们顺便把处理单个字符的子程序<code>DEC_SINGLE</code>和把ASCII码转换成对应数值的子程序<code>ASCII _TO_DECIMAL</code>写好:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEC_SINGLE:</span><br><span class="line">    ; 使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R2, R0, #0       ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY  ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<h6 id="十六进制输入">十六进制输入</h6>
<p>和十进制类似,先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>HEX_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ; 计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br></pre></td></tr></table></figure>
<h5 id="问题3的解决方案">问题3的解决方案</h5>
<p>在上面的问题2中,
我们已经用到了子程序<code>ASCII_TO_DECIMAL</code>和<code>ASCII_TO_HEX</code>,
其作用是把我们输入字符的ASCII码分别转换成对应的数值.</p>
<p>这里我们先来看一下ASCII的编码系统, 从而确定字符转换的程序.</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>示例</th>
<th>ASCII码(十进制)</th>
<th>ASCII码(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字字符</td>
<td>‘0’</td>
<td>48</td>
<td>x30</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘1’</td>
<td>49</td>
<td>x31</td>
</tr>
<tr>
<td>数字字符</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘9’</td>
<td>57</td>
<td>x39</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘A’</td>
<td>65</td>
<td>x41</td>
</tr>
<tr>
<td>大写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘Z’</td>
<td>90</td>
<td>x5A</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘a’</td>
<td>97</td>
<td>x61</td>
</tr>
<tr>
<td>小写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘z’</td>
<td>122</td>
<td>x7A</td>
</tr>
</tbody>
</table>
<p>当我们从键盘输入时, 存储到<code>R0</code>寄存器的是ASCII码,
而不是数值本身, 所以我们应该进行数值的转换, 对于数字,
根据上表可知只需要用数字字符对应的ASCII码直接减去<code>0</code>对应的ASCII码就可以得到该数字字符对应的数值了.
同样地, 对于十六进制大写字母,
只需要用大写字母对应的ASCII码直接减去’A’对应的ASCII码就可以得到该大写字母对应的数值了.</p>
<h6 id="十进制转换">十进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h6 id="十六进制转换">十六进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">; 处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h5 id="问题4的解决方案">问题4的解决方案</h5>
<p>接下来我们考虑如何将数值转换成对应的二进制码.
这里我们采用位检测和移位算法, 首先输入数值,
设置计数器的值为8(因为输出的是8位二进制数), 检查当前最高位,
如果最高位是1, 那么输出1, 然后左移一位; 如果最高位是0, 那么输出0,
然后左移一位. 此时把计数器减一, 如果计数器的值大于零, 那么继续循环,
直到完整循环了8次, 也就是输出8位二进制数了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    AND R1, R1, #0     ;初始化循环计数器R1</span><br><span class="line">    ADD R1, R1, #8     ;设置R1=8, 循环8次</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0     ;设置条件码, 检查R2的符号位</span><br><span class="line">    BRn OUTPUT_ONE     ;如果最高位为1(负数)，跳转到输出&#x27;1&#x27;</span><br><span class="line">    </span><br><span class="line">    ;如果最高位为0, 输出&#x27;0&#x27;</span><br><span class="line">    LD R0, ZERO_ASCII  ;R0=&#x27;0&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;0&#x27;</span><br><span class="line">    BRnzp SHIFT_NEXT   ;跳转到移位处理</span><br><span class="line"></span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII   ;R0=&#x27;1&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2     ;R2左移一位</span><br><span class="line">    ADD R1, R1, #-1    ;计数器减1</span><br><span class="line">    BRp LOOP           ;如果计数器大于0, 继续循环</span><br><span class="line">    </span><br><span class="line">    ;输出换行, 使结果更清晰</span><br><span class="line">    LD R0, NEWLINE     ;R0=换行符</span><br><span class="line">    TRAP x21           ;输出换行</span><br></pre></td></tr></table></figure>
<p>后来我在debug的时候发现有个问题, LC-3是16位机器,
假如我输入<code>#12</code>(也就是十进制数<code>12</code>,
其二进制数为<code>0000_0000_0000_1100</code>), 循环8次后输出全是0,
永远也不可能输出1, 而我们仅仅关心低8位.
所以应该先把<code>R2</code>左移8位, 把低8位变成高8位,
改正后的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br></pre></td></tr></table></figure>
<h4 id="具体实现-4">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic5.png" /></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">    LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">    BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">    LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">    BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line">    </span><br><span class="line">    BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br><span class="line"></span><br><span class="line">;*************************************************</span><br><span class="line">;****************下面是十进制模式******************</span><br><span class="line">;*************************************************</span><br><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5，因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;调用子程序，将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0          ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0          ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R4, R0, #0          ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0     ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3     ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ;计算10×十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是处理单个十进制数字的子程序</span><br><span class="line">DEC_SINGLE:</span><br><span class="line">    ;使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R2, R0, #0          ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY     ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;***************************************************</span><br><span class="line">;****************下面是十六进制模式******************</span><br><span class="line">;***************************************************</span><br><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ; 读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ; 保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ; 检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ;计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是单个十六进制数字的处理</span><br><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br><span class="line"></span><br><span class="line">;*****************************************************</span><br><span class="line">;****************下面是二进制输出程序******************</span><br><span class="line">;*****************************************************</span><br><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移, 使得低8位变成高8位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    HALT               ;程序结束</span><br><span class="line"></span><br><span class="line">;********************************************************</span><br><span class="line">;***************子程序: ASCII转十进制数值*****************</span><br><span class="line">;********************************************************</span><br><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;*********************************************************</span><br><span class="line">;**************子程序: ASCII转十六进制数值*****************</span><br><span class="line">;*********************************************************</span><br><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">;处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;数据定义</span><br><span class="line">DEC           .FILL x23   ;&#x27;#&#x27;的ASCII码</span><br><span class="line">HEX           .FILL x78   ;&#x27;x&#x27;的ASCII码</span><br><span class="line">ZERO_ASCII    .FILL x30   ;&#x27;0&#x27;的ASCII码</span><br><span class="line">ONE_ASCII     .FILL x31   ;&#x27;1&#x27;的ASCII码</span><br><span class="line">A_ASCII       .FILL x41   ;&#x27;A&#x27;的ASCII码</span><br><span class="line">ENTER_KEY     .FILL x0A   ;回车键的ASCII码</span><br><span class="line"></span><br><span class="line">SAVE_R1       .BLKW 1     ;用于保存R1</span><br><span class="line">SAVE_R2       .BLKW 1     ;用于保存R2</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程-4">运行过程</h4>
<p>把程序加载到LC-3模拟器</p>
<figure>
<img src="/images/LC-3/experiment5/step1.png" alt="图5.1" />
<figcaption aria-hidden="true">图5.1</figcaption>
</figure>
<p>输入<code>#</code>并回显, 程序跳转到十进制模式</p>
<figure>
<img src="/images/LC-3/experiment5/step2.png" alt="图5.2" />
<figcaption aria-hidden="true">图5.2</figcaption>
</figure>
<p>依次输入<code>1</code>和<code>2</code>并回显,
<code>1</code>保存在<code>R6</code>中,
<code>2</code>保存在<code>R5</code>中,
如图<code>R6=x0031, R5=x0032</code></p>
<figure>
<img src="/images/LC-3/experiment5/step3.png" alt="图5.3" />
<figcaption aria-hidden="true">图5.3</figcaption>
</figure>
<p>运行<code>ASCII_TO_DECIMAL</code>, 输入的数字字符转化成对应的数值,
分别存放在<code>R3</code>和<code>R4</code>中,
如图<code>R3=1, R4=2</code>, 计算<code>R3×10+R4</code>,
结果放进<code>R2</code>中, 即<code>R2=x000C</code>;
且为了进行二进制输出, 我们把<code>R2</code>左移了8位,
所以<code>R2=x0C00</code>.</p>
<figure>
<img src="/images/LC-3/experiment5/step4.png" alt="图5.4" />
<figcaption aria-hidden="true">图5.4</figcaption>
</figure>
<p>输出结果为<code>00001100</code>, 与预期一致</p>
<figure>
<img src="/images/LC-3/experiment5/step5.png" alt="图5.5" />
<figcaption aria-hidden="true">图5.5</figcaption>
</figure>
<p>下面测试的是<code>#9[空格]</code></p>
<figure>
<img src="/images/LC-3/experiment5/step6.png" alt="图5.6" />
<figcaption aria-hidden="true">图5.6</figcaption>
</figure>
<p>左移8位后, <code>R2=x0900</code></p>
<figure>
<img src="/images/LC-3/experiment5/step7.png" alt="图5.7" />
<figcaption aria-hidden="true">图5.7</figcaption>
</figure>
<p>二进制输出为<code>00001001</code>, 与预期一致</p>
<figure>
<img src="/images/LC-3/experiment5/step8.png" alt="图5.8" />
<figcaption aria-hidden="true">图5.8</figcaption>
</figure>
<p>下面测试十六进制, 输入<code>x</code>, 程序跳转至十六进制模式</p>
<figure>
<img src="/images/LC-3/experiment5/step9.png" alt="图5.9" />
<figcaption aria-hidden="true">图5.9</figcaption>
</figure>
<p>输入<code>xA6</code>, 输出<code>10100110</code></p>
<figure>
<img src="/images/LC-3/experiment5/step10.png" alt="图5.10" />
<figcaption aria-hidden="true">图5.10</figcaption>
</figure>
<p>输入<code>xC[空格]</code>, 输出<code>00001100</code></p>
<figure>
<img src="/images/LC-3/experiment5/step11.png" alt="图5.11" />
<figcaption aria-hidden="true">图5.11</figcaption>
</figure>
<h3 id="习题6">习题6</h3>
<p>采用轮询方式的控制外设,
通过键盘进行输入并在控制台屏幕显示大写的字母<code>A~I</code>,
要求利用LC-3处理器提供的如下表所示的设备端口,
使用设备端口寄存器来实现键盘输入与显示终端显示的功能.
设备端口寄存器的内存映射如下:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Location</th>
<th>I/O Register</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xFE00</code></td>
<td>键盘状态寄存器(KBSR)</td>
<td>当键盘接收到一个新字符时, 位[15]为1.</td>
</tr>
<tr>
<td><code>xFE02</code></td>
<td>键盘数据寄存器(KBDR)</td>
<td>位[7:0]包含键盘上键入的最后一个字符.</td>
</tr>
<tr>
<td><code>xFE04</code></td>
<td>显示状态寄存器(DSR)</td>
<td>当设备准备在屏幕上显示另一个字符时, 位[15]是1.</td>
</tr>
<tr>
<td><code>xFE06</code></td>
<td>显示数据寄存器(DDR)</td>
<td>写入位[7:0]的字符将显示在屏幕上.</td>
</tr>
</tbody>
</table>
<h4 id="实验步骤与实验思路-5">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
由于我们使用轮询的方式控制外设,
所以先考虑如何实现键盘输入和显示器输出的轮询,
思路就是<code>R0</code>读取键盘状态寄存器<code>KBSR</code>(<code>LDI R0 KBSR_ADDRESS</code>,
<code>KBSR_ADDRESS .FILL xFE00</code>), 如果最高位是0, 表示没有新的字符,
继续轮询; 如果最高位是1(也就是说<code>KBSR</code>寄存器的内容是负数),
表示有新字符,
这时<code>R0</code>读取键盘数据寄存器<code>KBDR</code>进行后续的操作(<code>LDI R0 KBDR_ADDRESS</code>,
<code>KBDR_ADDRESS .FILL xFE02</code>). 类似地, 对于输出轮询,
<code>R1</code>读取显示状态寄存器<code>DSR</code>(<code>LDI R1 DSR_ADDRESS</code>,
<code>DSR_ADDRESS .FILL xFE04</code>), 如果最高位是0, 表示显示器忙,
继续轮询; 如果最高位是1(也就是说<code>DSR</code>寄存器的内容是负数),
表示显示器准备就绪,
这时<code>R1</code>读取显示数据寄存器<code>DDR</code>进行显示(<code>LDI R1 DDR_ADDRESS</code>,
<code>DDR_ADDRESS .FILL xFE06</code>).</p>
<p>我们期望在键盘上依次输入<code>A~I</code>,
期望在显示器上依次回显<code>A~I</code>,
所以我们可以先把一个寄存器依次初始化为<code>A, B, ..., I</code>,
然后依次和我们的输入相比, 如果一致, 则输出该字符; 如果不一致,
则要求重新输入.</p>
<h4 id="具体实现-5">具体实现</h4>
<p>流程图如下:</p>
<p><img src="/images/LC-3/mermaid/pic6.png" /></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">MAIN:</span><br><span class="line">    LD R2, A_ASCII  ;把&#x27;A&#x27;的ASCII码放到R2里面, 和输入进行比较</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    TRAP x20        ;读取输入到R0</span><br><span class="line">    NOT R1, R2</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R0, R1  ;计算R0-R2判断输入和期望是否一致, 结果放入R1</span><br><span class="line">    BRnp LOOP       ;如果结果不为零, 说明不一致, 重新输入</span><br><span class="line">    </span><br><span class="line">    ADD R3, R0, #0  ;如果一致, 把R0放入R3输出</span><br><span class="line">    TRAP x21        ;输出</span><br><span class="line">    </span><br><span class="line">    LD R1, I_ASCII  ;把&#x27;I&#x27;的ASCII码放到R1里面, 和输入进行比较</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R2, R1  ;计算R2-R1, 判断当前输入字符是否为&#x27;I&#x27;</span><br><span class="line">    BRz FINISH      ;如果是, 那么程序结束</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1  ;如果不是, 那么R2＋1, 即R2初始化为下一个期望得到的字符</span><br><span class="line">    BRnzp LOOP      ;输入</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">A_ASCII .FILL x41           ; &#x27;A&#x27;的ASCII码</span><br><span class="line">I_ASCII .FILL x49           ; &#x27;I&#x27;的ASCII码</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="运行过程-5">运行过程</h4>
<p>把程序加载进LC-3模拟器</p>
<figure>
<img src="/images/LC-3/experiment6/step1.png" alt="图6.1" />
<figcaption aria-hidden="true">图6.1</figcaption>
</figure>
<p>输入字符<code>A</code>, 成功输出</p>
<figure>
<img src="/images/LC-3/experiment6/step2.png" alt="图6.2" />
<figcaption aria-hidden="true">图6.2</figcaption>
</figure>
<p>输入字符<code>g</code>, 未输出</p>
<figure>
<img src="/images/LC-3/experiment6/step3.png" alt="图6.3" />
<figcaption aria-hidden="true">图6.3</figcaption>
</figure>
<p>下面依次输入字符<code>BCDEFGHI</code>, 都成功回显,
当输入为<code>I</code>时, 回显后程序结束</p>
<figure>
<img src="/images/LC-3/experiment6/step4.png" alt="图6.4" />
<figcaption aria-hidden="true">图6.4</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/07/First/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/07/First/" class="post-title-link" itemprop="url">First</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-07 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-07T00:00:00+08:00">2025-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-09 14:47:25" itemprop="dateModified" datetime="2025-05-09T14:47:25+08:00">2025-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>量子力学</p>
<p><span class="math inline">\(\hat{H}\Psi=E\Psi\)</span></p>
<p>这是薛定谔方程.</p>
<blockquote>
<p>Hilbert Space <span
class="math inline">\(\langle\phi|\mathcal{O}|\psi\rangle\)</span></p>
</blockquote>
<p><span class="math inline">\(P^{-1}AP=A&#39;\)</span></p>
<p><span
class="math inline">\(\displaystyle\int_{-\infty}^{+\infty}e^{-x^2}\mathrm{d}x\)</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/07/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/07/Python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">Python数据分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-07 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-07T00:00:00+08:00">2025-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-19 20:09:23" itemprop="dateModified" datetime="2025-08-19T20:09:23+08:00">2025-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="准备工作">准备工作</h2>
<h3 id="ipython">IPython</h3>
<p>在cmd命令行输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipython</span><br></pre></td></tr></table></figure>
<p>安装ipython.安装完成后在控制台输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipyhton</span><br></pre></td></tr></table></figure>
<p>进入ipython交互式环境.</p>
<p>输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>退出环境.</p>
<h3 id="jupyter">Jupyter</h3>
<p>在cmd命令行输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook</span><br><span class="line">pip install jupyterlab-language-pack-zh-CN</span><br></pre></td></tr></table></figure>
<p>安装Jupyter Notebook和中文语言包.</p>
<p>安装完成后在控制台输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>浏览器就会自动打开Jupyter界面.</p>
<h3 id="numpy">numpy</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>
<h3 id="pandas">pandas</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure>
<h2 id="基本操作">基本操作</h2>
<h3 id="numpy基本操作">numpy基本操作</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np //导入numpy</span><br><span class="line"></span><br><span class="line">array=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])//生成矩阵</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number of dim:&#x27;</span>, array.ndim)//秩</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;shape:&#x27;</span>, array.shape)//形状</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;size:&#x27;</span>, array.size)//元素个数</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.<span class="built_in">int</span>)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.int32)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.int64)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.<span class="built_in">float</span>)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.float16)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.float32)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.dtype)//格式</span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">c = np.zeros((<span class="number">3</span>,<span class="number">4</span>))//生成三行四列零矩阵</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">d = np.ones((<span class="number">3</span>,<span class="number">5</span>))//生成三行五列全为一的矩阵</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">e = np.empty((<span class="number">3</span>,<span class="number">4</span>))//生成元素几乎为零的矩阵</span><br><span class="line"></span><br><span class="line">f = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)//生成[<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>]</span><br><span class="line">g = np.arange(<span class="number">12</span>)//生成[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">h = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">i = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)//生成从<span class="number">1</span>到<span class="number">10</span>的五段的线段</span><br><span class="line">j = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>).reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">c = a-b</span><br><span class="line">c = a+b</span><br><span class="line">c = b**<span class="number">2</span>//平方</span><br><span class="line">c = <span class="number">10</span>*np.sin(a)//对a的每个值求sin后再乘以<span class="number">10</span></span><br><span class="line">c = <span class="number">10</span>*np.cos(a)//对a的每个值求cos后再乘以<span class="number">10</span></span><br><span class="line">c = <span class="number">10</span>*np.tan(a)//对a的每个值求tan后再乘以<span class="number">10</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">print</span>(b&lt;<span class="number">3</span>)//输出[<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>]</span><br><span class="line">d = <span class="built_in">print</span>(b==<span class="number">3</span>)//输出[<span class="literal">False</span>,<span class="literal">False</span>,<span class="literal">False</span>,<span class="literal">True</span>]</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">c = a*b//元素乘法</span><br><span class="line">c = np.dot(a,b)//矩阵乘法</span><br><span class="line">c = a.dot(b)//同上</span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">4</span>))//从<span class="number">0</span>到<span class="number">1</span>的随机数</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a))//所有元素求和</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a,axis=<span class="number">1</span>))//在每一行求和</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(a,axis=<span class="number">0</span>))//在每一列求和</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">min</span>(a))//求最大值</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">max</span>(a))//求最小值</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.argmin(A))//最小值索引</span><br><span class="line"><span class="built_in">print</span>(np.argmax(A))//最大值索引</span><br><span class="line"><span class="built_in">print</span>(np.mean(A))//平均值</span><br><span class="line"><span class="built_in">print</span>(A.mean())//同上</span><br><span class="line"><span class="built_in">print</span>(np.mean(A,axis=<span class="number">0</span>))//对每一列求平均值</span><br><span class="line"><span class="built_in">print</span>(np.mean(A,axis=<span class="number">1</span>))//对每一行求平均值</span><br><span class="line"><span class="built_in">print</span>(np.average(A))//同上</span><br><span class="line"><span class="built_in">print</span>(np.median(A))//中位数</span><br><span class="line"><span class="built_in">print</span>(np.cumsum(A))//逐步累加</span><br><span class="line"><span class="built_in">print</span>(np.diff(A))//相邻两个数之差</span><br><span class="line"><span class="built_in">print</span>(np.nonzero(A))//非零元素的索引</span><br><span class="line"><span class="built_in">print</span>(np.sort(A))//每一行从小到大排序</span><br><span class="line"><span class="built_in">print</span>(np.transpose(A))//矩阵转置</span><br><span class="line"><span class="built_in">print</span>(A.T)//同上</span><br><span class="line"><span class="built_in">print</span>((A.T).dot(A))//转置后与原矩阵相乘</span><br><span class="line"><span class="built_in">print</span>(np.clip(A, <span class="number">3</span>, <span class="number">9</span>))//所有小于<span class="number">5</span>的元素置为<span class="number">5</span>,所有大于<span class="number">9</span>的元素置为<span class="number">9</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">15</span>,<span class="number">3</span>,-<span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">15</span>,<span class="number">3</span>,-<span class="number">1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A[<span class="number">0</span>])//输出第零个值</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">2</span>])//输出第二行</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">2</span>,:])//同上</span><br><span class="line"><span class="built_in">print</span>(B[:,<span class="number">1</span>])//输出第一列</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>,<span class="number">1</span>:<span class="number">3</span>])//取出第一行,第一列到第三列</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>][<span class="number">1</span>])//输出第一行第一列</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>,<span class="number">1</span>])//同上</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> B:</span><br><span class="line">    <span class="built_in">print</span>(row)//打印每一行</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> B.T:</span><br><span class="line">    <span class="built_in">print</span>(column)//打印每一列</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.flatten())//转换成一行</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> B.flat://转换成一行</span><br><span class="line">    <span class="built_in">print</span>(item)//打印所有元素</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">C = np.vstack((A,B))//vertical stack竖直合并</span><br><span class="line">D = np.hstack((A,B))//horizontal stack横向合并</span><br><span class="line"><span class="built_in">print</span>(np.vstack((A,B)))//将A和B竖直合并</span><br><span class="line"><span class="built_in">print</span>(A.shape, C.shape, D.shape)</span><br><span class="line"><span class="built_in">print</span>(A[np.newaxis,:])//增加行维数</span><br><span class="line"><span class="built_in">print</span>(A[:,np.newaxis])//增加列维数</span><br><span class="line"></span><br><span class="line">A = A[:,np.newaxis]</span><br><span class="line">B = B[:,np.newaxis]</span><br><span class="line">C = np.vstack((A,B))</span><br><span class="line">D = np.hstack((A,B))</span><br><span class="line"></span><br><span class="line">C = np.concatenate((A,B,B,A), axis=<span class="number">0</span>)//纵向合并</span><br><span class="line">C = np.concatenate((A,B,B,A), axis=<span class="number">1</span>)//横向合并</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.split(A,<span class="number">2</span>,axis=<span class="number">1</span>))//把原矩阵按照列等分成两份</span><br><span class="line"><span class="built_in">print</span>(np.split(A,<span class="number">3</span>,axis=<span class="number">0</span>))//把原矩阵按照行等分成三份</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.vsplit(A,<span class="number">3</span>))//把原矩阵按照行等分成三份</span><br><span class="line"><span class="built_in">print</span>(np.hsplit(A,<span class="number">2</span>))//把原矩阵按照列等分成两份</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">4</span>)//a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span>//此时a=[<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b <span class="keyword">is</span> a//输出<span class="literal">True</span></span><br><span class="line">c <span class="keyword">is</span> a//输出<span class="literal">True</span></span><br><span class="line">d <span class="keyword">is</span> a//输出<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">d[<span class="number">1</span>:<span class="number">3</span>]=[<span class="number">22</span>,<span class="number">33</span>]//d=[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a <span class="keyword">is</span> d//输出<span class="literal">True</span></span><br><span class="line">b <span class="keyword">is</span> d//输出<span class="literal">True</span></span><br><span class="line">c <span class="keyword">is</span> d//输出<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">b = a.copy()//deep copy,将a的值复制给b</span><br><span class="line"></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">44</span>//a=[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>]</span><br><span class="line">b <span class="keyword">is</span> a//输出<span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="pandas基本操作">pandas基本操作</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,np.nan,<span class="number">7</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(<span class="string">&#x27;20160101&#x27;</span>, periodes=<span class="number">6</span>)//连续打印六天的日期,从<span class="string">&#x27;2016-01-01&#x27;</span>开始</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), index=dates, columns=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1.</span>,</span><br><span class="line">                    <span class="string">&#x27;B&#x27;</span>:pd.Timestamp(<span class="string">&#x27;20130102&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;C&#x27;</span>:pd.Series(<span class="number">1</span>,index=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)),dtype=<span class="string">&#x27;float32&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;D&#x27;</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>,dtype=<span class="string">&#x27;int32&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;E&#x27;</span>:pd.Categorical([<span class="string">&quot;test&quot;</span>,<span class="string">&quot;train&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;train&quot;</span>]),</span><br><span class="line">                    <span class="string">&#x27;F&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line">df2.dtypes</span><br><span class="line">df2.index</span><br><span class="line">df2.columns</span><br><span class="line">df2.values</span><br><span class="line">df2.describe()</span><br><span class="line">df2.T</span><br><span class="line">df2.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)//列排序,倒序排列</span><br><span class="line">df2.sort_values(by=<span class="string">&#x27;E&#x27;</span>)//按照<span class="string">&#x27;E&#x27;</span>进行排序</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%83%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%83%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:结构体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 20:13:54" itemprop="dateModified" datetime="2025-08-06T20:13:54+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="复合类型与结构体">复合类型与结构体</h2>
<p>在编程语言中，最基本的、不可再分的数据类型称为基本类型（Primitive
Type），例如整型、浮点型；根据语法规则由基本类型组合而成的类型称为复合类型（Compound
Type），例如字符串是由很多字符组成的。有些场合下要把复合类型当作一个整体来用，而另外一些场合下需要分解组成这个复合类型的各种基本类型，复合类型的这种两面性为数据抽象（Data
Abstraction）奠定了基础。[SICP]指出，在学习一门编程语言时要特别注意以下三个方面：</p>
<p>这门语言提供了哪些Primitive，比如基本类型，比如基本运算符、表达式和语句。</p>
<p>这门语言提供了哪些组合规则，比如基本类型如何组成复合类型，比如简单的表达式和语句如何组成复杂的表达式和语句。</p>
<p>这门语言提供了哪些抽象机制，包括数据抽象和过程抽象（Procedure
Abstraction）。</p>
<p>本章以结构体为例讲解数据类型的组合和数据抽象。至于过程抽象，我们在第
2 节
“if/else语句”已经见过最简单的形式，就是把一组语句用一个函数名封装起来，当作一个整体使用，本章将介绍更复杂的过程抽象。</p>
<p>现在我们用C语言表示一个复数。从直角座标系来看，复数由实部和虚部组成，从极座标系来看，复数由模和辐角组成，两种座标系可以相互转换.</p>
<p>如果用实部和虚部表示一个复数，我们可以写成由两个<code>double</code>型组成的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一句定义了标识符<code>complex_struct</code>（同样遵循标识符的命名规则），这种标识符在C语言中称为<code>Tag</code>，<code>struct complex_struct &#123; double x, y; &#125;</code>整个可以看作一个类型名[12]，就像<code>int</code>或<code>double</code>一样，只不过它是一个复合类型，如果用这个类型名来定义变量，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125; z1, z2;</span><br></pre></td></tr></table></figure>
<p>这样<code>z1</code>和<code>z2</code>就是两个变量名，变量定义后面带个<code>;</code>号是我们早就习惯的。但即使像先前的例子那样只定义了<code>complex_struct</code>这个<code>Tag</code>而不定义变量，<code>&#125;</code>后面的<code>;</code>号也不能少。这点一定要注意，类型定义也是一种声明，声明都要以<code>;</code>号结尾，结构体类型定义的<code>&#125;</code>后面少<code>;</code>号是初学者常犯的错误。不管是用上面两种形式的哪一种定义了<code>complex_struct</code>这个<code>Tag</code>，以后都可以直接用<code>struct complex_struct</code>来代替类型名了。例如可以这样定义另外两个复数变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z3</span>, <span class="title">z4</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果在定义结构体类型的同时定义了变量，也可以不必写<code>Tag</code>，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125; z1, z2;</span><br></pre></td></tr></table></figure>
<p>但这样就没办法再次引用这个结构体类型了，因为它没有名字。每个复数变量都有两个成员（Member）<code>x</code>和<code>y</code>，可以用.运算符（<code>.</code>号，Period）来访问，这两个成员的存储空间是相邻的[13]，合在一起组成复数变量的存储空间。看下面的例子：</p>
<p>例 定义和访问结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span> <span class="type">double</span> x, y; &#125; z;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">3.0</span>;	</span><br><span class="line">    z.x = x;</span><br><span class="line">    z.y = <span class="number">4.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (z.y &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;z=%f%fi\n&quot;</span>, z.x, z.y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;z=%f+%fi\n&quot;</span>, z.x, z.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上例中变量<code>x</code>和变量<code>z</code>的成员<code>x</code>的名字并不冲突，因为变量<code>z</code>的成员<code>x</code>只能通过表达式<code>z.x</code>来访问，编译器可以从语法上区分哪个<code>x</code>是变量<code>x</code>，哪个<code>x</code>是变量<code>z</code>的成员<code>x</code>，第
3 节
“变量的存储布局”会讲到这两个标识符<code>x</code>属于不同的命名空间。结构体<code>Tag</code>也可以定义在全局作用域中，这样定义的<code>Tag</code>在其定义之后的各函数中都可以使用。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span> <span class="type">double</span> x, y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体变量也可以在定义时初始化，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span> =</span> &#123; <span class="number">3.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>Initializer中的数据依次赋给结构体的各成员。如果Initializer中的数据比结构体的成员多，编译器会报错，但如果只是末尾多个逗号则不算错。如果Initializer中的数据比结构体的成员少，未指定的成员将用<code>0</code>来初始化，就像未初始化的全局变量一样。例如以下几种形式的初始化都是合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x = <span class="number">3.0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z1</span> =</span> &#123; x, <span class="number">4.0</span>, &#125;; <span class="comment">/* z1.x=3.0, z1.y=4.0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z2</span> =</span> &#123; <span class="number">3.0</span>, &#125;; <span class="comment">/* z2.x=3.0, z2.y=0.0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z3</span> =</span> &#123; <span class="number">0</span> &#125;; <span class="comment">/* z3.x=0.0, z3.y=0.0 */</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>z1</code>必须是局部变量才能用另一个变量<code>x</code>的值来初始化它的成员，如果是全局变量就只能用常量表达式来初始化。这也是C99的新特性，C89只允许在<code>&#123;&#125;</code>中使用常量表达式来初始化，无论是初始化全局变量还是局部变量。</p>
<p><code>&#123;&#125;</code>这种语法不能用于结构体的赋值，例如这样是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z1</span>;</span></span><br><span class="line">z1 = &#123; <span class="number">3.0</span>, <span class="number">4.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>以前我们初始化基本类型的变量所使用的Initializer都是表达式，表达式当然也可以用来赋值，但现在这种由<code>&#123;&#125;</code>括起来的Initializer并不是表达式，所以不能用来赋值[14]。Initializer的语法总结如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Initializer → 表达式</span><br><span class="line">Initializer → &#123; 初始化列表 &#125; </span><br><span class="line">初始化列表 → Designated-Initializer, Designated-Initializer, ...</span><br><span class="line">（最后一个Designated-Initializer末尾可以有一个多余的,号）</span><br><span class="line">Designated-Initializer → Initializer</span><br><span class="line">Designated-Initializer → .标识符 = Initializer</span><br><span class="line">Designated-Initializer → [常量表达式] = Initializer</span><br></pre></td></tr></table></figure>
<p>Designated
Initializer是C99引入的新特性，用于初始化稀疏（Sparse）结构体和稀疏数组很方便。有些时候结构体或数组中只有某一个或某几个成员需要初始化，其它成员都用0初始化即可，用Designated
Initializer语法可以针对每个成员做初始化（Memberwise
Initialization），很方便。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z1</span> =</span> &#123; .y = <span class="number">4.0</span> &#125;; <span class="comment">/* z1.x=0.0, z1.y=4.0 */</span></span><br></pre></td></tr></table></figure>
<p>数组的Memberwise Initialization语法将在下一章介绍。</p>
<p>结构体类型用在表达式中有很多限制，不像基本类型那么自由，比如<code>+ - * /</code>等算术运算符和<code>&amp;&amp; || !</code>等逻辑运算符都不能作用于结构体类型，<code>if</code>语句、<code>while</code>语句中的控制表达式的值也不能是结构体类型。严格来说，可以做算术运算的类型称为算术类型<code>（Arithmetic Type）</code>，算术类型包括整型和浮点型。可以表示零和非零，可以参与逻辑与、或、非运算或者做控制表达式的类型称为标量类型（Scalar
Type），标量类型包括算术类型和以后要讲的指针类型，详见图 23.5
“C语言类型总结”。</p>
<p>结构体变量之间使用赋值运算符是允许的，用一个结构体变量初始化另一个结构体变量也是允许的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z1</span> =</span> &#123; <span class="number">3.0</span>, <span class="number">4.0</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z2</span> =</span> z1;</span><br><span class="line">z1 = z2;</span><br></pre></td></tr></table></figure>
<p>同样地，<code>z2</code>必须是局部变量才能用变量<code>z1</code>的值来初始化。既然结构体变量之间可以相互赋值和初始化，也就可以当作函数的参数和返回值来传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">add_complex</span><span class="params">(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2)</span></span><br><span class="line">&#123;</span><br><span class="line">    z1.x = z1.x + z2.x;</span><br><span class="line">    z1.y = z1.y + z2.y;</span><br><span class="line">    <span class="keyword">return</span> z1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数实现了两个复数相加，如果在<code>main</code>函数中这样调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span> =</span> &#123; <span class="number">3.0</span>, <span class="number">4.0</span> &#125;;</span><br><span class="line">z = add_complex(z, z);</span><br></pre></td></tr></table></figure>
<p>那么调用传参的过程如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\struct.parameter.png"
alt="结构体传参" />
<figcaption aria-hidden="true">结构体传参</figcaption>
</figure>
<p>变量<code>z</code>在<code>main</code>函数的栈帧上，参数<code>z1</code>和<code>z2</code>在<code>add_complex</code>函数的栈帧上，<code>z</code>的值分别赋给<code>z1</code>和<code>z2</code>。在这个函数里，<code>z2</code>的实部和虚部被累加到<code>z1</code>中，然后<code>return z1;</code>可以看成是：</p>
<p>用z1初始化一个临时变量。</p>
<p>函数返回并释放栈帧。</p>
<p>把临时变量的值赋给变量<code>z</code>，释放临时变量。</p>
<p>由<code>.</code>运算符组成的表达式能不能做左值取决于<code>.</code>运算符左边的表达式能不能做左值。在上面的例子中，<code>z</code>是一个变量，可以做左值，因此表达式<code>z.x</code>也可以做左值，但表达式<code>add_complex(z, z).x</code>只能做右值而不能做左值，因为表达式<code>add_complex(z, z)</code>不能做左值。</p>
<h2 id="数据抽象">数据抽象</h2>
<p>现在我们来实现一个完整的复数运算程序。在上一节我们已经定义了复数的结构体类型，现在需要围绕它定义一些函数。复数可以用直角座标或极座标表示，直角座标做加减法比较方便，极座标做乘除法比较方便。如果我们定义的复数结构体是直角座标的，那么应该提供极座标的转换函数，以便在需要的时候可以方便地取它的模和辐角：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">real_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">img_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">magnitude</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(z.x * z.x + z.y * z.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">angle</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan2</span>(z.y, z.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我们还提供两个函数用来构造复数变量，既可以提供直角座标也可以提供极座标，在函数中自动做相应的转换然后返回构造的复数变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_real_img</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.x = x;</span><br><span class="line">    z.y = y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_mag_ang</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> A)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.x = r * <span class="built_in">cos</span>(A);</span><br><span class="line">    z.y = r * <span class="built_in">sin</span>(A);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上就可以实现复数的加减乘除运算了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">add_complex</span><span class="params">(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_from_real_img(real_part(z1) + real_part(z2),</span><br><span class="line">                  img_part(z1) + img_part(z2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">sub_complex</span><span class="params">(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_from_real_img(real_part(z1) - real_part(z2),</span><br><span class="line">                  img_part(z1) - img_part(z2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">mul_complex</span><span class="params">(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_from_mag_ang(magnitude(z1) * magnitude(z2),</span><br><span class="line">                 angle(z1) + angle(z2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">div_complex</span><span class="params">(<span class="keyword">struct</span> complex_struct z1, <span class="keyword">struct</span> complex_struct z2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_from_mag_ang(magnitude(z1) / magnitude(z2),</span><br><span class="line">                 angle(z1) - angle(z2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，复数加减乘除运算的实现并没有直接访问结构体complex_struct的成员x和y，而是把它看成一个整体，通过调用相关函数来取它的直角座标和极座标。这样就可以非常方便地替换掉结构体complex_struct的存储表示，例如改为用极座标来存储：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> r, A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">real_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.r * <span class="built_in">cos</span>(z.A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">img_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.r * <span class="built_in">sin</span>(z.A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">magnitude</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">angle</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_real_img</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.A = <span class="built_in">atan2</span>(y, x);</span><br><span class="line">    z.r = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_mag_ang</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> A)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.r = r;</span><br><span class="line">    z.A = A;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然结构体<code>complex_struct</code>的存储表示做了这样的改动，<code>add_complex</code>、<code>sub_complex</code>、<code>mul_complex</code>、<code>div_complex</code>这几个复数运算的函数却不需要做任何改动，仍然可以用，原因在于这几个函数只把结构体<code>complex_struct</code>当作一个整体来使用，而没有直接访问它的成员，因此也不依赖于它有哪些成员。我们结合下图具体分析一下。</p>
<p><img src="C:\blog\Blog\images\C\struct.abstraction.png" /></p>
<p>这里是一种抽象的思想。其实“抽象”这个概念并没有那么抽象，简单地说就是“提取公因式”：ab+ac=a(b+c)。如果a变了，ab和ac这两项都需要改，但如果写成a(b+c)的形式就只需要改其中一个因子。</p>
<p>在我们的复数运算程序中，复数有可能用直角座标或极座标来表示，我们把这个有可能变动的因素提取出来组成复数存储表示层：<code>real_part</code>、<code>img_part</code>、<code>magnitude</code>、<code>angle</code>、<code>make_from_real_img</code>、<code>make_from_mag_ang</code>。这一层看到的数据是结构体的两个成员x和y，或者r和A，如果改变了结构体的实现就要改变这一层函数的实现，但函数接口不改变，因此调用这一层函数接口的复数运算层也不需要改变。复数运算层看到的数据只是一个抽象的“复数”的概念，知道它有直角座标和极座标，可以调用复数存储表示层的函数得到这些座标。再往上看，其它使用复数运算的程序看到的数据是一个更为抽象的“复数”的概念，只知道它是一个数，像整数、小数一样可以加减乘除，甚至连它有直角座标和极座标也不需要知道。</p>
<p>这里的复数存储表示层和复数运算层称为抽象层（Abstraction
Layer），从底层往上层来看，复数越来越抽象了，把所有这些层组合在一起就是一个完整的系统。组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都只局限在某一层，而不会波及整个系统。著名的计算机科学家Butler
Lampson说过：“All problems in computer science can be solved by another
level of indirection.”这里的indirection其实就是abstraction的意思。</p>
<h2 id="数据类型标志">数据类型标志</h2>
<p>在上一节中，我们通过一个复数存储表示抽象层把<code>complex_struct</code>结构体的存储格式和上层的复数运算函数隔开，<code>complex_struct</code>结构体既可以采用直角座标也可以采用极座标存储。但有时候需要同时支持两种存储格式，比如先前已经采集了一些数据存在计算机中，有些数据是以极座标存储的，有些数据是以直角座标存储的，如果要把这些数据都存到<code>complex_struct</code>结构体中怎么办？一种办法是规定<code>complex_struct</code>结构体采用直角座标格式，直角座标的数据可以直接存入<code>complex_struct</code>结构体，而极座标的数据先转成直角座标再存，但由于浮点数的精度有限，转换总是会损失精度的。这里介绍另一种办法，<code>complex_struct</code>结构体由一个数据类型标志和两个浮点数组成，如果数据类型标志为<code>0</code>，那么两个浮点数就表示直角座标，如果数据类型标志为<code>1</code>，那么两个浮点数就表示极座标。这样，直角座标和极座标的数据都可以适配（Adapt）到<code>complex_struct</code>结构体中，无需转换和损失精度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">coordinate_type</span> &#123;</span> RECTANGULAR, POLAR &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">coordinate_type</span> <span class="title">t</span>;</span></span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>enum</code>关键字的作用和<code>struct</code>关键字类似，把<code>coordinate_type</code>这个标识符定义为一个<code>Tag</code>，<code>struct complex_struct</code>表示一个结构体类型，而<code>enum coordinate_type</code>表示一个枚举（Enumeration）类型。枚举类型的成员是常量，它们的值由编译器自动分配，例如定义了上面的枚举类型之后，<code>RECTANGULAR</code>就表示常量<code>0</code>，<code>POLAR</code>表示常量<code>1</code>。如果不希望从<code>0</code>开始分配，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">coordinate_type</span> &#123;</span> RECTANGULAR = <span class="number">1</span>, POLAR &#125;;</span><br></pre></td></tr></table></figure>
<p>这样，<code>RECTANGULAR</code>就表示常量<code>1</code>，而<code>POLAR</code>表示常量<code>2</code>。枚举常量也是一种整型，其值在编译时确定，因此也可以出现在常量表达式中，可以用于初始化全局变量或者作为<code>case</code>分支的判断条件。</p>
<p>有一点需要注意，虽然结构体的成员名和变量名不在同一命名空间中，但枚举的成员名却和变量名在同一命名空间中，所以会出现命名冲突。例如这样是不合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">coordinate_type</span> &#123;</span> RECTANGULAR = <span class="number">1</span>, POLAR &#125;;</span><br><span class="line">    <span class="type">int</span> RECTANGULAR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, RECTANGULAR, POLAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>complex_struct</code>结构体的格式变了，就需要修改复数存储表示层的函数，但只要保持函数接口不变就不会影响到上层函数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_real_img</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.t = RECTANGULAR;</span><br><span class="line">    z.a = x;</span><br><span class="line">    z.b = y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> complex_struct <span class="title function_">make_from_mag_ang</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> A)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">z</span>;</span></span><br><span class="line">    z.t = POLAR;</span><br><span class="line">    z.a = r;</span><br><span class="line">    z.b = A;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套结构体">嵌套结构体</h2>
<p>结构体也是一种递归定义：结构体的成员具有某种数据类型，而结构体本身也是一种数据类型。换句话说，结构体的成员可以是另一个结构体，即结构体可以嵌套定义。例如我们在复数的基础上定义复平面上的线段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">start</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> <span class="title">end</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从第 1 节
“复合类型与结构体”讲的Initializer的语法可以看出，Initializer也可以嵌套，因此嵌套结构体可以嵌套地初始化，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> <span class="title">s</span> =</span> &#123;&#123; <span class="number">1.0</span>, <span class="number">2.0</span> &#125;, &#123; <span class="number">4.0</span>, <span class="number">6.0</span> &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以平坦（Flat）地初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> <span class="title">s</span> =</span> &#123; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>甚至可以把两种方式混合使用（这样可读性很差，应该避免）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> <span class="title">s</span> =</span> &#123;&#123; <span class="number">1.0</span>, <span class="number">2.0</span> &#125;, <span class="number">4.0</span>, <span class="number">6.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>利用C99的新特性也可以做Memberwise Initialization，例如[15]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> <span class="title">s</span> =</span> &#123; .start.x = <span class="number">1.0</span>, .end.x = <span class="number">2.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>访问嵌套结构体的成员要用到多个.运算符，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.start.t = RECTANGULAR;</span><br><span class="line">s.start.a = <span class="number">1.0</span>;</span><br><span class="line">s.start.b = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Cadence%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Cadence%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Cadence</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-10 18:51:05" itemprop="dateModified" datetime="2025-12-10T18:51:05+08:00">2025-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%A8%A1%E6%8B%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">模拟设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%A8%A1%E6%8B%9F%E8%AE%BE%E8%AE%A1/Cadence/" itemprop="url" rel="index"><span itemprop="name">Cadence</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="vmware基本操作">VMware基本操作</h2>
<p>打开VMware Workstation
Pro,点击左侧”我的计算机”一栏中的”IC618”,然后点击最上面一栏的绿色小三角,就可以运行虚拟机了.</p>
<p>注意, 可以利用共享文件夹来添加工艺库文件, 步骤如下:</p>
<p>虚拟机设置-共享文件夹-点击”总是启用”,
主机路径直接设置成工艺库解压之后的文件夹.
然后打开虚拟机桌面的computer-filesystem-mnt,
这里就可以我们添加的工艺库了.</p>
<p>在桌面上面新建一个文件夹, 找到刚才导入的工艺库文件, ctrl+C
ctrl+V把它复制进来</p>
<h2 id="cadence简介">Cadence简介</h2>
<h3 id="软件介绍">软件介绍</h3>
<p>Cadence软件是CADENCE公司开发的集成电路设计产品的总称.Cadence可以完成电子设计的方方面面,包括ASIC设计,FPGA设计和PCB设计.与众所周知的EDA软件Synopsys相比,Cadence软件的综合工具略为逊色,但是Cadence在仿真,电路图设计,自动布局布线,版图设计以及验证等方面却有着绝对的优势.</p>
<p>在实际设计中,经常用到Cadence软件的工具包括:Verilog
HDL仿真工具Verilog-XL,电路设计工具Composer,电路模拟工具Analog
Artist,版图设计工具Virtuoso Layout
Editor,版图验证工具Dracula和Diva,自动布局布线工具Preview和Silicon
Ensemble. 几乎可以完成电子设计的方方面面, 包括ASIC设计,
FPGA设计和PCB板设计. 具体来说, 可以完成如下功能:</p>
<ul>
<li>板级电路设计系统</li>
<li>Alta系统级无线设计</li>
<li>逻辑设计与验证(LDV)</li>
<li>时序驱动的深亚微米设计</li>
<li>全定制IC设计工具</li>
</ul>
<p>我们这里主要学习如下工具:</p>
<ul>
<li>设计环境交互窗口: Virtuoso Design Environment</li>
<li>电路图设计工具: Virtuoso Schematic Editor</li>
<li>电路模拟工具: Virtuoso Analog Design Environment</li>
<li>版图设计工具: Virtuoso Layout Suite</li>
<li>版图验证工具: Virtuoso Layout Calibre</li>
</ul>
<h3 id="cadence的文件组织">Cadence的文件组织</h3>
<p><img src="/source/images/Cadence/Introduction/file.png" /></p>
<p>Cadence软件是按照库(Library),单元(Cell)和视图(View)的层次实现对文件的管理.</p>
<h4 id="库">库</h4>
<p>库文件是一组单元的集合, 包含各个单元的不同视图. 以文件夹的形式存在.
包含如下内容:</p>
<ul>
<li>基准库: 是Cadence软件自带的:
<ul>
<li>Sample库存储普通符号</li>
<li>US_8th存储各种尺寸和模板</li>
<li>Basic库包含特殊管脚信息</li>
<li>Analog库包含基本模拟器件</li>
</ul></li>
<li>设计库: 针对用户而言,
是用户自己创建的库(用户的设计库必须与某个工艺库相关联)</li>
<li>工艺库: 针对集成电路制造工艺而言</li>
</ul>
<p>单元是构造芯片和逻辑结构的最低层次的结构单元,例如反相器,运放,正弦波发生器等.视图位于单元层次下,包括电路图(Schematic),版图(Layout),符号(Symbol)等.</p>
<p>在Cadence软件中,库文件又包含设计库和工艺库(又称技术库).设计库是对于用户而言的,不同的用户可以有不同的设计库;工艺库是对集成电路制造工艺而言的,不同的特征尺寸工艺,不同的芯片制造厂商的工艺库是不同的.为了能够完成集成电路的制造,用户的设计库必须和某个工艺库相关联.</p>
<h4 id="library-manager">Library Manager</h4>
<p>通过Library Manager(库文件管理器)对库文件进行管理,
主要有以下操作:</p>
<ul>
<li>导入和访问设计数据</li>
<li>定义Cadence库的访问路径cds.lib文件</li>
<li>创建新的库</li>
<li>将数据复制到库中</li>
<li>删除库</li>
<li>重命名库, 单元, 视图, 文件或参考库</li>
<li>编辑库, 单元格和查看属性</li>
</ul>
<p>进入Library Manager的两种方式</p>
<ol type="1">
<li>在Command窗口输入libManager &amp;</li>
<li>在VDE窗口选择Tools-Library Manager</li>
</ol>
<p>两种显示方式:</p>
<ol type="1">
<li>List</li>
<li>通过View-list选择Tree</li>
</ol>
<h5 id="library-manager-categories">Library Manager-Categories</h5>
<p>Library Manager-Categories将元件按照种类分别展示,
可以帮助更快寻找所需的元件, 选中Show Categories选项即可.</p>
<h5 id="library-manager-library-path-editor">Library Manager-Library
Path Editor</h5>
<p>Library Path Editor管理库文件的所有路径. 可以通过Library Path
Editor添加工艺库文件.</p>
<p>打开方式: Library Manager-Edit-Library Path</p>
<p>通过Library Path Editor链接工艺库:</p>
<ol type="1">
<li>VDE窗口</li>
<li>Tools-Library Path Editor</li>
<li>Edit-Add new library</li>
<li>在Directory处选择工艺文件所在路径并在Library选择库文件</li>
</ol>
<p>链接设计库和工艺库:</p>
<ol type="1">
<li>在VDE Tools菜单下打开Technology File Manager-Attach</li>
<li>在Design Library选择设计库, 在Technology Library选择工艺库,
点击OK绑定.</li>
</ol>
<h3 id="vde界面">VDE界面</h3>
<p>VDE就是Virtuoso Design Environment, 启动过程如下:</p>
<ol type="1">
<li>在Linux的Open Terminal界面输入virtuoso &amp;</li>
<li>按下回车</li>
<li>出现命令解释器窗口CIW, 可以从命令解释器窗口CIW与设计环境交互</li>
</ol>
<h4 id="vde-file">VDE-File</h4>
<ol type="1">
<li>File-New-Library创建一个新的库,
注意不允许在现有的库中创建新的或者临时库,
因为在一个库中找到的任何目录都会被视为单元格</li>
<li>File-New-Cellview创建一个新的单元</li>
<li>File-Open-open file打开一个cell单元的视图</li>
<li>File-Import选择一个翻译器将另一种格式的设计导入到Cadence设计数据库格式中</li>
<li>File-Export选择一个翻译器将Cadence设计数据库格式转换成另一种格式的设计</li>
</ol>
<h4 id="vde-tools">VDE-Tools</h4>
<ol type="1">
<li>Tools-Library Manager 创建, 添加, 复制, 删除和组织库和视图</li>
<li>Tools-Library Path Editor 定义在设计中使用的库.
设置cds.lib文件指向要在设计中使用的引用和设计库. 注意从IC614开始,
Virtuoso不再支持lib.defs库定义文件, 目前唯一支持的格式为cds.lib.</li>
</ol>
<h3 id="vse界面">VSE界面</h3>
<p>VSE就是Virtuoso Schematic Editor, 是一个原理图绘制工具,
版本有Virtuoso Schematic Editor L和Virtuoso Schematic Editor XL.</p>
<p>原理图设计是电子电路设计的图示. 连接性信息来自于引脚,
线路和实例的放置.</p>
<p>VSE窗口界面主要包括如下要素:</p>
<ul>
<li>Assistant Panes</li>
<li>Cellview Tabs</li>
<li>Title Bar</li>
<li>Close Tab</li>
<li>Undock/Dock Assistant</li>
<li>Design Canvas</li>
<li>Resource Indictors</li>
</ul>
<p>注意:</p>
<ol type="1">
<li>可以使用多工作表原理图将大型设计划分到多个工作表(页面)中,
从而提高可读性并产生更好的绘图输出.</li>
<li>如果以只读模式打开原理图或符号, 则可以更改模式使其可以编辑,
具体做法是点击File-Make Editable</li>
</ol>
<h4 id="vse-symbol-editor">VSE-Symbol Editor</h4>
<p>Symbol Editor-Creating Symbols: 在Schematic Editor界面选择Creat-cell
view from cellview, View name选择symbol, 确定Pin方向</p>
<h3 id="ade界面">ADE界面</h3>
<p>ADE就是Analog Design Environment,
模拟设计环境使用不同的模拟器设置和运行模拟. 运行仿真后,
可以查看和分析仿真结果.</p>
<p>ADE界面主要包含如下要素:</p>
<ul>
<li>Setup toolbar</li>
<li>Analysis</li>
<li>Design informance</li>
<li>Design variable</li>
<li>Output</li>
<li>ADE toolbar</li>
</ul>
<p>当ADE L从VSE启动时, ADE L工具栏将显示在Virtuoso
Schematic工具栏区域.</p>
<h3 id="vls界面">VLS界面</h3>
<p>VLS就是Virtuoso Layout Suite, 是一个版图编辑工具,
支持创建自定义布局或编辑任何现有版图.</p>
<p>VLS XL版本的界面包含如下要素:</p>
<ul>
<li>Schematic View</li>
<li>Layout View</li>
<li>LSW</li>
<li>CIW</li>
</ul>
<h3 id="calibre界面">Calibre界面</h3>
<p>Mentor
Graphics公司的Calibre物理验证和提取工具已经被完整地集成到Cadence Design
Systems公司的Virtuoso设计环境, 用于设计规则检验(DRC),
布局对原理图(layout-versus-schematic, LVS)和寄生提取.</p>
<h3 id="pdk">PDK</h3>
<h4 id="pdk简介">PDK简介</h4>
<p>为了方便用户利用Cadence进行不同代工厂(Foundry)的版图设计,
代工厂提供了工艺设计工具包(Process Design Kit, PDK),
,PDK是为模拟/混合信号IC电路设计而提供的完整工艺文件集合,
PDK是连接代工厂(IC工艺制造)和用户设计(IC设计)的重要桥梁.
PDK主要包含以下部件:</p>
<ol type="1">
<li>器件模型(Device Model):由Foundry提供的仿真模型器件.</li>
<li>符号(Symbol)和视图(View):用于原理图设计的符号,通过了SPICE仿真验证参数化的设计单元.</li>
<li>CDF(Component Description
Format,组件描述格式)和Callback(器件的属性描述文件):定义了各种器件类型,器件名称,器件参数及参数调用关系函数集Callback,器件模型,器件的各种视图格式等.</li>
<li>参数化单元(Parameterized
Cell,Pcell):由Cadence语言的SKILL语言编写,其对应的版图通过了DRC和LVS验证,方便设计人员进行Schematic
Driven
Layout(原理图驱动的版图)设计流程,利用Pcell可以加速版图设计过程.</li>
<li>技术文件(Technology
File):用于版图设计和验证的工艺文件,包含GDSII的数据层和工艺层的映射关系定义,设计数据层的属性定义,在线设计规则,电气规则,显示彩色定义和图形格式定义等.</li>
<li>PV
Rule(物理验证规则)文件:包含版图验证文件DRC/LVS/RC的提取,支持Cadence软件的Diva,Dracula,Assura等.</li>
</ol>
<p>简而言之, 就是包含了反映制造工艺基本的元素: 晶体管, 接触孔,
互连线等.</p>
<ul>
<li>设计规则文件DRC</li>
<li>电学规则文件LVS</li>
<li>版图层次定义文件</li>
<li>SPICE仿真模型</li>
<li>器件版图</li>
<li>器件定制参数</li>
</ul>
<h4 id="pdk的安装">PDK的安装</h4>
<p>对于版图设计用户,熟悉并掌握PDK的安装尤为重要.PDK的格式通常为压缩文件(.tar.gz).如某代工厂提供的40nm工艺PDK文件为PDK40LL_1125_1TM_OA_CDS.tar.gz.下面是安装步骤:</p>
<ol type="1">
<li>将该PDK压缩文件复制到某一路径下用于后续安装</li>
<li>进入终端并更改工作路径为刚才PDK复制的路径;也可直接在刚才PDK复制的路径右键,在弹出的快捷菜单中选择Open
in Terminal命令,打开终端.</li>
<li>在终端输入解压缩命令: gtar zxvf
PDK40LL_1125_1TM_OA_CDS.tar.gz,并按Enter键.如果解压失败,也可以双击该文件,然后执行Extract命令.</li>
<li>解压完毕后会出现名为PDK40LL_1125_1TM_OA_CDS的文件夹,进入该文件夹,可以看到该文件夹里面还有压缩文件,可以用相同的方法进行解压.PDK40LL_1125_1TM_OA_CDS中有六个压缩文件,每个文件名中的1PXM(X代表数字4~9),表示该工艺可以制作一层多晶硅X层金属.这里选择1P4M压缩文件进行解压.</li>
<li>进入解压完成的文件4011_1125_1tm_oa_cds_1P4M,其主要内容如下:
<ol type="1">
<li>PDK_ReleaseNote_RevisionHistory_40LL_1125.pdf:PDF文件,包含PDK的发行说明和修订历史记录.</li>
<li>cds.lib:Cadence库定义文件</li>
<li>display.drf:Cadence显示资源文件</li>
<li>icc.rules_4lm_1tm:Virtuoso自定义布线规则文件</li>
<li>40ll:PDK库</li>
<li>techfile.tf:ASCII版本工艺文件</li>
<li>models:存储PDK模型的路径(文件夹)</li>
<li>stream:包含Cadence数据流输入和输出映射的目录</li>
<li>doc:包含PDK文档的目录</li>
<li>Calibre:包含Calibre验证文件的目录</li>
</ol></li>
<li>在终端输入Virtuoso &amp;,启动Cadence软件.</li>
<li>我们下面添加40nm工艺库.点击”Tool-&gt;Library
Manager”,然后在弹出的Library Manager窗口点击”Edit-&gt;Library
Path”,在弹出的Library Path Editor窗口点击”Edit-&gt;Add
Library”,在弹出的Add
Library窗口中找到刚才解压的工艺库文件(即40ll),点击OK,就可以看到在Library
Path
Editor窗口的最后一行出现”40ll”,然后在该窗口中点击”File-&gt;Save”.</li>
</ol>
<h2 id="virtuoso环境的配置">virtuoso环境的配置</h2>
<h3 id="库的创建">库的创建</h3>
<p>我们在桌面右键,点击”Open in Terminal”,在弹出的窗口中输入”virtuoso
&amp;“并按下回车键.就可以打开”Virtuoso 6.1.8-64b -
Log:/home/IC/CDS.log”界面.</p>
<p>我们点击最上面一栏的”File-&gt;New-&gt;Library”,就会弹出”New
Library”窗口,在”Name”一栏中,输入我们建立的设计库的名字”test1”.在”Technology
File”中选择”Attach to an existing technology
library”,路径默认为”/home/IC”,设置完成后,我们点击”OK”,在弹出的”Attach
Library to Technology Library”中选择”tsmcN65”,然后点击”OK”.</p>
<p>此时,在”Virtuoso 6.1.8-64b - Log:/home/IC/CDS.log”界面就会显示</p>
<p>“INFO (TECH-180011): Design library ‘test1’ successfully attached to
technology library ‘tsmcN65’.”</p>
<p>接下来,我们点击最上面一栏的”Tools-&gt;Library Manager”,打开”Library
Manager”窗口,在”Library”子窗口就可以看到我们新创建的”test1”了.</p>
<p>我们在”Library
Manager”窗口最上面一栏点击”File-&gt;New-&gt;Library”创建一个仿真文件,路径默认为”/home/IC”,在弹出的窗口中输入建立的仿真文件夹的名字”test1_sim”,然后点击”OK”,在弹出的”Technology
File for New Library”中选择”Attach to an existing technology
library”,我们点击”OK”,在弹出的”Attach Library to Technology
Library”中选择”tsmcN65”,然后点击”OK”.我们就可以看到在在”Library”子窗口出现了我们新创建的”test1_sim”了</p>
<p>下面我们建立设计单元,在”Library
Manager”窗口最上面一栏点击”File-&gt;New-&gt;Cell View”,这时会弹出”New
File”窗口,在”Library”中选择我们刚刚创建的”test1”,在”Cell”一栏中我们命名为”display”,注意”Library
path
file”是”/home/IC/cds.lib”,然后选择”Type”为”layout”,其他保持默认,然后点击”OK”,就会弹出”Virtuoso
Schematic Editor: test1 newtry
schematic”窗口,下面就可以在其中摆放器件了.</p>
<h3 id="工艺库相关">工艺库相关</h3>
<h4 id="工艺库的位置">工艺库的位置</h4>
<p>我们点击桌面上的”Files”图标,就会弹出所有文件.我们打开”Tech”文件夹,里面就包含了所有可用的工艺库.我们打开”TSMC-65nm(OA)“文件夹.其中:</p>
<p>“Calibre”就是验证文件存放的地方</p>
<p>“models”就是电路仿真所需要的文件</p>
<p>“skill”就是在调用PCell的时候所需要的文件</p>
<p>“tsmcN65”就是工艺库</p>
<p>“display.drf”就是图层颜色所显示的文件</p>
<h4 id="pdk工艺库的导入">PDK工艺库的导入</h4>
<p>假设我们在主机界面上有一个”tsmc18rf.tar”的压缩文件</p>
<p>方法一: 直接将这个压缩包拖入虚拟机的主界面,不多谈</p>
<p>方法二:
在主机界面创建一个名为”share”的文件夹,将”tsmc18rf.tar”放入其中,我们点击右上角的关机按钮,将IC618关闭.在IC618界面中点击”硬盘(SCSI)“,然后在”选项”界面中启用共享文件夹,将刚刚创建的”share”文件夹添加进去,点击”确定”,然后再运行虚拟机.打开”Files”,在左边一栏中点击”Other
Locations”,点击”Computer-&gt;mnt-&gt;hgfs”就可以看到共享文件夹”share”了.在虚拟机中使用共享文件夹中的文件,需要将文件复制到虚拟机的目录下.</p>
<h3 id="反相器">反相器</h3>
<p>在”Library Manager”窗口最上面一栏点击”File-&gt;New-&gt;Cell
View”,这时会弹出”New
File”窗口,在”Library”中选择我们刚刚创建的”test1”,在”Cell”一栏中我们命名为”inv”,注意”Library
path
file”是”/home/IC/cds.lib”,然后选择”Type”为”schematic”,其他保持默认,然后点击”OK”,就会弹出”Virtuoso
Schematic Editor: test1 newtry
schematic”窗口,下面就可以在其中摆放器件了.</p>
<p>在原理图窗口中,按下”i”键就可以打开”Add
Instance”窗口,在”Library”一栏中选择”tsmcN65”,“Cell”一栏中选择”nch_33”,按下回车键,将该N管放置好,然后再按下”i”键,在”Cell”一栏中选择”pch_33”,将其摆放好.然后按下”esc”键退出放置.然后长按鼠标左键进行连线.按下”p”键,打开”Create
Pin”窗口,在”Direction”一栏中选择”input/output”接口.电路图连接完成后点击左上角的”save
and check”选项.保存好后,点击”Create-&gt;Cellview-&gt;From
Cellview…“,在”Library
Name”一栏选择”text1”,其他保持默认点击”OK”,然后在弹出的”Symbol Generation
Options”窗口中保持默认,点击”OK”,就会弹出”Virtuoso Symbol Editor: test1
inv symbol”窗口,然后保存.</p>
<p>我们退出原理图窗口,在”Library
Manager”下的”test1”库中,“Cell”中有我们刚刚创建的”inv”,“view”中对应的有”schematic”和”symbol”.</p>
<p>接下来我们进行仿真.点击”File-&gt;New-&gt;Cell View”,弹出”New
File”窗口,在”Library”一栏中选择”test1_sim”,“Cell”一栏中命名为”inv_sim”,其他默认,点击”Ok”,弹出”Virtuoso
Schematic Editor L Editing: test1_sim inv_sim
schematic”,按下”i”键弹出”Add
Instance”窗口,在”Library”一栏中选择”test1”,然后在”Cell”一栏中选择”inv”(就是把我们刚刚创建的symbol调出来),摆放好即可.</p>
<p>下面我们设置偏置电压,按下”i”键,在”Library”一栏中选择”analogLib”,然后在”Cell”一栏中选择”vdc”,放置好电源后,点击电源图标,在左下角”Property
Editor”下的”DC
voltage”一栏设置参数,分别为”0,2”,再按下”i”键,在”Library”一栏中选择”basic”,然后在”Cell”一栏中选择”gnd”.</p>
<p>之后我们添加输入信号,按下”i”键,在”Library”一栏中选择”analogLib”,然后在”Cell”一栏中选择”vpulse”,放置好后,设置参数”Voltage
1=0”,“Voltage 2=2”,“Period=1/fin”,“Raise time=1n”,“Fall time=1n”,“Pulse
width=0.5/fin”.这里”fin”是变量,为输入频率.</p>
<p>设置完成后,点击”Check and Save”.然后点击”Launch-&gt;ADE L”,弹出”ADE L
- test1_sim inv_sim schematic”界面,在”Design
Variables”一栏中右键,点击”Copy from
Cellview”,就可以将变量”fin”添加进去,然后在”Value”中设置其为50M(也就是20ns),然后在右边一栏点击”Choose
Analyses”,在弹出的窗口中的”Analysis”下”tran”,“Stop
Time”设置为100n(也就是5个周期),并且勾选”conservative”,然后点击”OK”.</p>
<p>接下来在”ADE L - test1_sim inv_sim schematic”界面点击”Model
Library”图标,将其他选项取消勾选,点击”&lt; Click here to add model file
&gt;“,添加路径”/home/IC/Tech/TSMC-65nm(OA)/models/spectre”下面的”crn65lp_3d3_lk_v1d5.scs”,并且在”section”中选择”tt_33”和”stat_noise”,然后点击”Ok”.</p>
<p>上面的设置完成后,再次在原理图界面点击”Check and Save”,然后在ADE
L界面点击”Netlist and Run”开始仿真,等待一会之后就会弹出窗口.</p>
<p>我们接下来回到原理图窗口,点击第三行图标”Direct Plot-&gt;Main
Form”,然后点击第二行图标的”Defualt Selection
Filter”,然后我们就可以单击电路图中的连线,就会弹出”Virtuoso (R)
Visualization &amp; Analysis
Xl”的波形图窗口,我们再点击其他连线,也会把其他连线上的波形加入到波形图中.</p>
<h3 id="ic617-反相器">IC617 反相器</h3>
<p>在桌面新建一个文件夹,
把需要的工艺库文件夹复制粘贴到这个文件夹里面.</p>
<p>在终端输入<code>virtuoso &amp;</code>打开Cadence, 打开Library
Manager, 新建一个库, 随便命名, 路径就是刚刚在桌面创建的文件夹,
然后Attach到AnalogLib库即可. 这时, 我们就可以在Library Path
Editor里面把我们导入的工艺库(路径就是桌面上那个文件夹)添加进去.
这时我们就可以开始做自己的项目了.</p>
<p>再次新建一个库, 随便命名, 路径还是选择桌面上新建的那个文件夹,
然后Attach到我们导入的那个工艺库上. 库建好后, 点击File-New-CellView,
命名为INV, 然后就会弹出VSE界面. 点击Add Instance,
Library一般就是选择AnalogLib和我们导入的工艺库. 然后就可以摆放器件了,
摆放好之后要给它封装起来, 变成一个symbol, 我们需要pin脚, 比如input,
output, VDD, GND之类的. 做完之后记得保存.</p>
<p>然后在最上面一栏, 点击Create-Cellview-From Cellview…点击ok,
然后在left/right/top/bottom
pins分别输入我们给pin脚的命名(要和上一段一致). 保存之后,
这一部分工作就完成了!</p>
<p>这时我们再返回Library Manager里面, 点击Cell里面的INV,
就可以在右边的View里面看到schematic和symbol了.</p>
<p>接下来我们新建一个Testbench, 点击File-New-Cellview, 命名为INV_tb,
然后我们直接在Add Instance里面调用新建的库,
这个库里面就有我们刚刚设计好的INV,
选择好之后可以看到它以symbol的形式出现, 我们把四个pin脚用线引出来.
然后在Add Instance中的AnalogLib库里面选择vdc和gnd, 然后给线打上label,
相同label的线代表是同一根线. 弄好之后记得保存.</p>
<p>接下来进行仿真, 最上面一栏选择Launch-ADE L, 在Analog窗口右键选择Edit,
我们选择tran(瞬态). Stop time输入10u, 选择moderate, 点击ok.
在Output窗口右键点击Edit, 点击From Design,
然后就可以点击我们想要观察的线的信号, 选完之后点击ok.
弄完之后点击右边的绿色的按钮就可以跑仿真了, 这时就会出现波形图.</p>
<h2 id="实验-功耗仿真">实验: 功耗仿真</h2>
<p>work用户密码是111111</p>
<p>IC1用户密码是123456</p>
<p>home-work-project里面有cds.lib</p>
<p>在终端输入Virtuoso &amp;打开Cadence.</p>
<p>点击Tool-Library Manager操作界面</p>
<p>几个重要的Library: AnalogLib, tsmc65.
新建的用户设计库要和工艺库连接起来.</p>
<p>File-New-Library 命名为PowerSim, 可以看到cell里面是空的.
然后把设计库和tsmc连接起来. View选择Schematic. 点击ok就打开了</p>
<ol type="1">
<li>新建lib, 命名为PowerSim, 在库中新建cell命名为nand2,
在tsmc18rf工艺库里面选择nmod2v和pmos2v等单元, 将参数修改如下:
<ol type="1">
<li>pl:180n; pw: 1u; fingers of pmos: 1</li>
<li>nl:180n; nw: 1u; fingers of nmos: 1</li>
</ol></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:程序的基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 16:53:18" itemprop="dateModified" datetime="2025-08-06T16:53:18+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="程序的基本概念">程序的基本概念</h2>
<p>程序（Program）告诉计算机应如何完成一个计算任务，这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词。从根本上说，计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的。此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。</p>
<p>程序由一系列指令（Instruction）组成，指令是指示计算机做某种运算的命令，通常包括以下几类：</p>
<ol type="1">
<li>输入（Input）:从键盘、文件或者其它设备获取数据。</li>
<li>输出（Output）:把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。</li>
<li>基本运算:执行最基本的数学运算（加减乘除）和数据存取。</li>
<li>测试和分支:测试某个条件，然后根据不同的测试结果执行不同的后续指令。</li>
<li>循环:重复执行一系列操作。</li>
</ol>
<p>对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了，所以编写程序理应是一件相当复杂的工作。编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。</p>
<p>编程语言（Programming Language）分为低级语言（Low-level
Language）和高级语言（High-level Language）。机器语言（Machine
Language）和汇编语言（Assembly
Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>编程语言</th>
<th>表示形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>C语言</td>
<td><code>a=b+1</code></td>
</tr>
<tr>
<td>汇编语言</td>
<td><code>mov 0x804a01c, %eax</code><br><code>add $0x1, %eax</code><br><code>mov %eax, 0x804a018</code></td>
</tr>
<tr>
<td>机器语言</td>
<td><code>a1 1c a0 04 08</code><br><code>83 c0 01</code><br><code>a3 18 a0 04 08</code></td>
</tr>
</tbody>
</table>
<p>计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。从上面的例子可以看出，汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作，例如在第一条指令中，把<code>movl ?,%eax</code>这种格式的指令替换成机器码<code>a1 ?</code>，<code>?</code>表示一个地址，在汇编指令中是<code>0x804a01c</code>，转换成机器码之后是<code>1c a0 04 08</code>（这是指令中的十六进制数的小端表示）。</p>
<p>从上面的例子还可以看出，C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条<code>a=b+1</code>;语句要翻译成三条汇编或机器指令，这个过程称为编译（Compile），由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用C语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用C语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。其次，C语言是可移植的（Portable）或者称为平台无关的（Platform
Independent）。</p>
<p>平台这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating
System），也可以指开发平台（编译器、链接器等）。不同的计算机体系结构有不同的指令集（Instruction
Set），可以识别的机器指令格式是不同的，直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行，然而各种体系结构的计算机都有各自的C编译器，可以把C程序编译成各种不同体系结构的机器指令，这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行。各种高级语言都具有C语言的这些优点，所以绝大部分程序是用高级语言编写的，只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言。还要注意一点，即使在相同的体系结构和操作系统下，用不同的C编译器（或者同一个C编译器的不同版本）编译同一个程序得到的结果也有可能不同，C语言有些语法特性在C标准中并没有明确规定，各编译器有不同的实现，编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。</p>
<p>总结一下编译执行的过程，首先你用文本编辑器写一个C程序，然后保存成一个文件，例如program.c（通常C程序的文件名后缀是.c），这称为源代码（Source
Code）或源文件，然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如a.out，这称为可执行文件，可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令.</p>
<p>有些高级语言以解释（Interpret）的方式执行，解释执行过程和C语言的编译执行过程很不一样。例如编写一个Shell脚本<code>script.sh</code>，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">VAR=1</span><br><span class="line">VAR=$(($VAR+1))</span><br><span class="line">echo $VAR</span><br></pre></td></tr></table></figure>
<p>定义Shell变量VAR的初始值是1，然后自增1，然后打印VAR的值。用Shell程序<code>/bin/sh</code>解释执行这个脚本，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/sh script.sh</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>这里的<code>/bin/sh</code>称为解释器（Interpreter），它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。如果把脚本中的这三行当作三条命令直接敲到Shell提示符下，也能得到同样的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">VAR=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">VAR=$((<span class="variable">$VAR</span>+<span class="number">1</span>))</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$VAR</span></span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>编程语言仍在发展演化。以上介绍的机器语言称为第一代语言（1GL，1st
Generation Programming Language），汇编语言称为第二代语言（2GL，2nd
Generation Programming
Language），C、C++、Java、Python等可以称为第三代语言（3GL，3rd
Generation Programming Language）。目前已经有了4GL（4th Generation
Programming Language）和5GL（5th Generation Programming
Language）的概念。3GL的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。而4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定，例如SQL语言（SQL，Structured
Query Language，结构化查询语言）就是这样的例子。</p>
<h2 id="自然语言和形式语言">自然语言和形式语言</h2>
<p>自然语言（Natural
Language）就是人类讲的语言，比如汉语、英语和法语。这类语言不是人为设计（虽然有人试图强加一些规则）而是自然进化的。形式语言（Formal
Language）是为了特定应用而人为设计的语言。例如数学家用的数字和运算符号、化学家用的分子式等。编程语言也是一种形式语言，是专门设计用来表达计算过程的形式语言。</p>
<p>形式语言有严格的语法（Syntax）规则，例如，3+3=6是一个语法正确的数学等式，而3=+6<span
class="math inline">\(则不是，H2O是一个正确的分子式，而2Zz则不是。语法规则是由符号（Token）和结构（Structure）的规则所组成的。Token的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字，例如3=+6\)</span>的问题之一在于<span
class="math inline">\(不是一个合法的数也不是一个事先定义好的运算符，而2Zz的问题之一在于没有一种元素的缩写是Zz。结构是指Token的排列方式，3=+6\)</span>还有一个结构上的错误，虽然加号和等号都是合法的运算符，但是不能在等号之后紧跟加号，而2Zz的另一个问题在于分子式中必须把下标写在化学元素名称之后而不是前面。关于Token的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则[1]。</p>
<p>当阅读一个自然语言的句子或者一种形式语言的语句时，你不仅要搞清楚每个词（Token）是什么意思，而且必须搞清楚整个句子的结构是什么样的（在自然语言中你只是没有意识到，但确实这样做了，尤其是在读外语时你肯定也意识到了）。这个分析句子结构的过程称为解析（Parse）。例如，当你听到“The
other shoe fell.”这个句子时，你理解the other
shoe是主语而fell是谓语动词，一旦解析完成，你就搞懂了句子的意思，如果知道shoe是什么东西，fall意味着什么，这句话是在什么上下文（Context）中说的，你还能理解这个句子主要暗示的内容，这些都属于语义（Semantic）的范畴。</p>
<p>虽然形式语言和自然语言有很多共同之处，包括Token、结构和语义，但是也有很多不一样的地方。</p>
<p>歧义性（Ambiguity）
自然语言充满歧义，人们通过上下文的线索和自己的常识来解决这个问题。形式语言的设计要求是清晰的、毫无歧义的，这意味着每个语句都必须有确切的含义而不管上下文如何。</p>
<p>冗余性（Redundancy）
为了消除歧义减少误解，自然语言引入了相当多的冗余。结果是自然语言经常说得啰里啰嗦，而形式语言则更加紧凑，极少有冗余。</p>
<p>与字面意思的一致性
自然语言充斥着成语和隐喻（Metaphor），我在某种场合下说“The other shoe
fell”，可能并不是说谁的鞋掉了。而形式语言中字面（Literal）意思基本上就是真实意思，也会有一些例外，例如下一章要讲的C语言转义序列，但即使有例外也会明确规定哪些字面意思不是真实意思，它们所表示的真实意思又是什么。</p>
<p>说自然语言长大的人（实际上没有人例外），往往有一个适应形式语言的困难过程。某种意义上，形式语言和自然语言之间的不同正像诗歌和说明文的区别，当然，前者之间的区别比后者更明显：</p>
<p>诗歌
词语的发音和意思一样重要，全诗作为一个整体创造出一种效果或者表达一种感情。歧义和非字面意思不仅是常见的而且是刻意使用的。</p>
<p>说明文
词语的字面意思显得更重要，并且结构能传达更多的信息。诗歌只能看一个整体，而说明文更适合逐字句分析，但仍然充满歧义。</p>
<p>程序
计算机程序是毫无歧义的，字面和本意高度一致，能够完全通过对Token和结构的分析加以理解。</p>
<p>现在给出一些关于阅读程序（包括其它形式语言）的建议。首先请记住形式语言远比自然语言紧凑，所以要多花点时间来读。其次，结构很重要，从上到下从左到右读往往不是一个好办法，而应该学会在大脑里解析：识别Token，分解结构。最后，请记住细节的影响，诸如拼写错误和标点错误这些在自然语言中可以忽略的小毛病会把形式语言搞得面目全非。</p>
<h2 id="程序的调试">程序的调试</h2>
<p>编程是一件复杂的工作，因为是人做的事情，所以难免经常出错。据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的。从此以后，程序中的错误被叫做臭虫（Bug），而找到这些Bug并加以纠正的过程就叫做调试（Debug）。有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气。调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的Bug分为哪几类。</p>
<p>编译时错误
编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。</p>
<p>运行时错误
编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻注意区分编译时和运行时（Run-time）这两个概念，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。</p>
<p>逻辑错误和语义错误
第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。</p>
<p>通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个Bug，一步一步逼近正确的程序；如果假设错误，只好另外再找思路再做假设。“当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。”（即使你没看过福尔摩斯也该看过柯南吧）。</p>
<p>也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。例如，Linux操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，一开始它仅仅是Linus
Torvalds用来琢磨Intel 80386芯片而写的小程序。据Larry Greenfield
说，“Linus的早期工程之一是编写一个交替打印AAAA和BBBB的程序，这玩意儿后来进化成了Linux。”（引自The
Linux User’s Guide
Beta1版）在后面的章节中会给出更多关于调试和编程实践的建议。</p>
<h2 id="第一个程序">第一个程序</h2>
<p>通常一本教编程的书中第一个例子都是打印“Hello,
World.”，这个传统源自K&amp;R，用C语言写这个程序可以这样写：</p>
<p>例 Hello World</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* main: generate some simple output */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个程序保存成<code>main.c</code>，然后编译执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p>gcc是Linux平台的C编译器，编译后在当前目录下生成可执行文件a.out，直接在命令行输入这个可执行文件的路径就可以执行它。如果不想把文件名叫a.out，可以用gcc的-o参数自己指定文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure>
<p>虽然这只是一个很小的程序，但我们目前暂时还不具备相关的知识来完全理解这个程序，比如程序的第一行，还有程序主体的<code>int main(void)&#123;...return 0;&#125;</code>结构，这些部分我们暂时不详细解释，读者现在只需要把它们看成是每个程序按惯例必须要写的部分（Boilerplate）。但要注意<code>main</code>是一个特殊的名字，C程序总是从<code>main</code>里面的第一条语句开始执行的，在这个程序中是指<code>printf</code>这条语句。</p>
<p>第3行的<code>/* ... */</code>结构是一个注释（Comment），其中可以写一些描述性的话，解释这段程序在做什么。注释只是写给程序员看的，编译器会忽略从<code>/*</code>到<code>*/</code>的所有字符，所以写注释没有语法规则，爱怎么写就怎么写，并且不管写多少都不会被编译进可执行文件中。</p>
<p><code>printf</code>语句的作用是把消息打印到屏幕。注意语句的末尾以<code>;</code>号（Semicolon）结束，下一条语句<code>return 0;</code>也是如此。</p>
<p>C语言用<code>&#123;&#125;</code>括号（Brace或Curly
Brace）把语法结构分成组，在上面的程序中<code>printf</code>和<code>return</code>语句套在<code>main的&#123;&#125;</code>括号中，表示它们属于<code>main</code>的定义之中。我们看到这两句相比<code>main</code>那一行都缩进（Indent）了一些，在代码中可以用若干个空格（Blank）和<code>Tab</code>字符来缩进，缩进不是必须的，但这样使我们更容易看出这两行是属于<code>main</code>的定义之中的，要写出漂亮的程序必须有整齐的缩进，第
1 节 “缩进和空白”将介绍推荐的缩进写法。</p>
<p>正如前面所说，编译器对于语法错误是毫不留情的，如果你的程序有一点拼写错误，例如第一行写成了<code>stdoi.h</code>，在编译时会得到错误提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line">main.c:1:19: error: stdoi.h: No such file or directory</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个错误提示非常紧凑，初学者往往不容易看明白出了什么错误，即使知道这个错误提示说的是第1行有错误，很多初学者对照着书看好几遍也看不出自己这一行哪里有错误，因为他们对符号和拼写不敏感（尤其是英文较差的初学者），他们还不知道这些符号是什么意思又如何能记住正确的拼写？对于初学者来说，最想看到的错误提示其实是这样的：“在<code>main.c</code>程序第1行的第19列，您试图包含一个叫做<code>stdoi.h</code>的文件，可惜我没有找到这个文件，但我却找到了一个叫做<code>stdio.h</code>的文件，我猜这个才是您想要的，对吗？”可惜没有任何编译器会友善到这个程度，大多数时候你所得到的错误提示并不能直接指出谁是犯人，而只是一个线索，你需要根据这个线索做一些侦探和推理。</p>
<p>有些时候编译器的提示信息不是<code>error</code>而是<code>warning</code>，例如把上例中的<code>printf("Hello, world.\n");</code>改成<code>printf(1);</code>然后编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line">main.c: In function ‘main’:</span><br><span class="line">main.c:7: warning: passing argument 1 of ‘printf’ makes pointer from integer without a cast</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>这个警告信息是说类型不匹配，但勉强还能配得上。警告信息不是致命错误，编译仍然可以继续，如果整个编译过程只有警告信息而没有错误信息，仍然可以生成可执行文件。但是，警告信息也是不容忽视的。出警告信息说明你的程序写得不够规范，可能有Bug，虽然能编译生成可执行文件，但程序的运行结果往往是不正确的，例如上面的程序运行时出了一个段错误，这属于运行时错误。各种警告信息的严重程度不同，像上面这种警告几乎一定表明程序中有Bug，而另外一些警告只表明程序写得不够规范，一般还是能正确运行的，有些不重要的警告信息gcc默认是不提示的，但这些警告信息也有可能表明程序中有Bug。一个好的习惯是打开gcc的<code>-Wall</code>选项，也就是让gcc提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭。比如把上例中的<code>printf("Hello, world.\n");</code>改成<code>printf(0);</code>然后编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br></pre></td></tr></table></figure>
<p>编译既不报错也不报警告，一切正常，但是运行程序什么也不打印。如果打开<code>-Wall</code>选项编译就会报警告了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wall main.c</span></span><br><span class="line">main.c: In function ‘main’:</span><br><span class="line">main.c:7: warning: null argument where non-null required (argument 1)</span><br></pre></td></tr></table></figure>
<p>如果<code>printf</code>中的0是你不小心写上去的（例如错误地使用了编辑器的查找替换功能），这个警告就能帮助你发现错误。虽然本书的命令行为了突出重点通常省略<code>-Wall</code>选项，但是强烈建议你写每一个编译命令时都加上<code>-Wall</code>选项。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:简单函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 18:07:47" itemprop="dateModified" datetime="2025-08-06T18:07:47+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数学函数">数学函数</h2>
<p>在数学中我们用过<span class="math inline">\(sin\)</span>和<span
class="math inline">\(ln\)</span>这样的函数，例如<span
class="math inline">\(sin(π/2)=1\)</span>，<span
class="math inline">\(ln1=0\)</span>等等，在C语言中也可以使用这些函数（ln函数在C标准库中叫做log）：</p>
<p>例 在C语言中使用数学函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.1416</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sin(pi/2)=%f\nln1=%f\n&quot;</span>, <span class="built_in">sin</span>(pi/<span class="number">2</span>), <span class="built_in">log</span>(<span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行这个程序，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -lm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">sin(pi/2)=1.000000</span><br><span class="line">ln1=0.000000</span><br></pre></td></tr></table></figure>
<p>在数学中写一个函数有时候可以省略括号，而C语言要求一定要加上括号，例如<code>log(1.0)</code>。在C语言的术语中，<code>1.0</code>是参数（Argument），<code>log</code>是函数（Function），<code>log(1.0)</code>是函数调用（Function
Call）。<code>sin(pi/2)</code>和<code>log(1.0)</code>这两个函数调用在我们的<code>printf</code>语句中处于什么位置呢？在上一章讲过，这应该是写表达式的位置。因此函数调用也是一种表达式，这个表达式由函数调用运算符（<code>()</code>括号）和两个操作数组成，操作数<code>log</code>是一个函数名（Function
Designator），它的类型是一种函数类型（Function
Type），操作数<code>1.0</code>是double型的。<code>log(1.0)</code>这个表达式的值就是对数运算的结果，也是<code>double</code>型的，在C语言中函数调用表达式的值称为函数的返回值（Return
Value）。总结一下我们新学的语法规则：</p>
<p>表达式 → 函数名 表达式 → 表达式(参数列表) 参数列表 → 表达式, 表达式,
…</p>
<p>现在我们可以完全理解<code>printf</code>语句了：原来<code>printf</code>也是一个函数，上例中的<code>printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0))</code>是带三个参数的函数调用，而函数调用也是一种表达式，因此<code>printf</code>语句也是表达式语句的一种。但是<code>printf</code>感觉不像一个数学函数，为什么呢？因为像<code>log</code>这种函数，我们传进去一个参数会得到一个返回值，我们调用<code>log</code>函数就是为了得到它的返回值，至于<code>printf</code>，我们并不关心它的返回值（事实上它也有返回值，表示实际打印的字符数），我们调用<code>printf</code>不是为了得到它的返回值，而是为了利用它所产生的副作用（Side
Effect）－－打印。C语言的函数可以有Side
Effect，这一点是它和数学函数在概念上的根本区别。</p>
<p>Side
Effect这个概念也适用于运算符组成的表达式。比如<code>a + b</code>这个表达式也可以看成一个函数调用，把运算符<code>+</code>看作函数，它的两个参数是<code>a</code>和<code>b</code>，返回值是两个参数的和，传入两个参数，得到一个返回值，并没有产生任何Side
Effect。而赋值运算符是有Side
Effect的，如果把<code>a = b</code>这个表达式看成函数调用，返回值就是所赋的值，既是<code>b</code>的值也是<code>a</code>的值，但除此之外还产生了Side
Effect，就是变量<code>a</code>被改变了，改变计算机存储单元里的数据或者做输入输出操作都算Side
Effect。</p>
<p>回想一下我们的学习过程，一开始我们说赋值是一种语句，后来学了表达式，我们说赋值语句是表达式语句的一种；一开始我们说<code>printf</code>是一种语句，现在学了函数，我们又说<code>printf</code>也是表达式语句的一种。随着我们一步步的学习，把原来看似不同类型的语句统一成一种语句了。学习的过程总是这样，初学者一开始接触的很多概念从严格意义上说是错的，但是很容易理解，随着一步步学习，在理解原有概念的基础上不断纠正，不断泛化（Generalize）。比如一年级老师说小数不能减大数，其实这个概念是错的，后来引入了负数就可以减了，后来引入了分数，原来的正数和负数的概念就泛化为整数，上初中学了无理数，原来的整数和分数的概念就泛化为有理数，再上高中学了复数，有理数和无理数的概念就泛化为实数。坦白说，到目前为止本书的很多说法都是不完全正确的，但这是学习理解的必经阶段，到后面的章节都会逐步纠正的。</p>
<p>程序第一行的<code>#</code>号（Pound Sign，Number Sign或Hash
Sign）和<code>include</code>表示包含一个头文件（Header
File），后面尖括号（Angel
Bracket）中就是文件名（这些头文件通常位于/usr/include目录下）。头文件中声明了我们程序中使用的库函数，根据先声明后使用的原则，要使用<code>printf</code>函数必须包含<code>stdio.h</code>，要使用数学函数必须包含<code>math.h</code>，如果什么库函数都不使用就不必包含任何头文件，例如写一个程序<code>int main(void)&#123;int a;a=2;return 0;&#125;</code>，不需要包含头文件就可以编译通过，当然这个程序什么也做不了。</p>
<p>使用<code>math.h</code>中声明的库函数还有一点特殊之处，gcc命令行必须加<code>-lm</code>选项，因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），<code>-lm</code>选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如<code>printf</code>）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加<code>-lc</code>选项，当然加了也不算错，因为这个选项是gcc的默认选项。关于头文件和库函数目前理解这么多就可以了，到第
20 章 链接详解再详细解释。</p>
<p>C标准库和glibc:</p>
<p>C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单片机的C语言开发工具中只有C编译器而没有完整的C标准库。</p>
<p>在Linux平台上最广泛使用的C函数库是glibc，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有C程序都要调用glibc的库函数，所以glibc是Linux平台C程序运行的基础。glibc提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在libc.so库文件中，几乎所有C程序的运行都依赖于libc.so，有些做数学计算的C程序依赖于libm.so，以后我们还会看到多线程的C程序依赖于libpthread.so。以后我说libc时专指libc.so这个库文件，而说glibc时指的是glibc提供的所有库文件。</p>
<p>glibc并不是Linux平台唯一的基础C函数库，也有人在开发别的C函数库，比如适用于嵌入式系统的uClibc。</p>
<h2 id="自定义函数">自定义函数</h2>
<p>我们不仅可以调用C标准库提供的函数，也可以定义自己的函数，事实上我们已经这么做了：我们定义了<code>main</code>函数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hour = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> minute = <span class="number">59</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d and %d hours\n&quot;</span>, hour, minute / <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数的特殊之处在于执行程序时它自动被操作系统调用，操作系统就认准了<code>main</code>这个名字，除了名字特殊之外，<code>main</code>函数和别的函数没有区别。我们对照着<code>main</code>函数的定义来看语法规则：</p>
<p>函数定义 → 返回值类型 函数名(参数列表) 函数体 函数体 → { 语句列表 }
语句列表 → 语句列表项 语句列表项 … 语句列表项 → 语句 语句列表项 →
变量声明、类型声明或非定义的函数声明 非定义的函数声明 → 返回值类型
函数名(参数列表);</p>
<p>我们稍后再详细解释“函数定义”和“非定义的函数声明”的区别。从第 7 章
结构体开始我们才会看到类型声明，所以现在暂不讨论。</p>
<p>给函数命名也要遵循上一章讲过的标识符命名规则。由于我们定义的<code>main</code>函数不带任何参数，参数列表应写成<code>void</code>。函数体可以由若干条语句和声明组成，C89要求所有声明写在所有语句之前（本书的示例代码都遵循这一规定），而C99的新特性允许语句和声明按任意顺序排列，只要每个标识符都遵循先声明后使用的原则就行。<code>main</code>函数的返回值是<code>int</code>型的，<code>return 0</code>;这个语句表示返回值是<code>0</code>，<code>main</code>函数的返回值是返回给操作系统看的，因为<code>main</code>函数是被操作系统调用的，通常程序执行成功就返回<code>0</code>，在执行过程中出错就返回一个非零值。比如我们将<code>main</code>函数中的<code>return</code>语句改为<code>return 4</code>;再执行它，执行结束后可以在Shell中看到它的退出状态（Exit
Status）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">11 and 0 hours</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $?</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><code>$?</code>是Shell中的一个特殊变量，表示上一条命令的退出状态。关于<code>main</code>函数需要注意两点：</p>
<p>[K&amp;R]书上的<code>main</code>函数定义写成<code>main()&#123;...&#125;</code>的形式，不写返回值类型也不写参数列表，这是Old
Style C的风格。Old Style
C规定不写返回值类型就表示返回<code>int</code>型，不写参数列表就表示参数类型和个数没有明确指出。这种宽松的规定使编译器无法检查程序中可能存在的Bug，增加了调试难度，不幸的是现在的C标准为了兼容旧的代码仍然保留了这种语法，但读者绝不应该继续使用这种语法。</p>
<p>其实操作系统在调用<code>main</code>函数时是传参数的，<code>main</code>函数最标准的形式应该是<code>int main(int argc, char *argv[])</code>，在第
6 节
“指向指针的指针与指针数组”详细介绍。C标准也允许<code>int main(void)</code>这种写法，如果不使用系统传进来的两个参数也可以写成这种形式。但除了这两种形式之外，定义<code>main</code>函数的其它写法都是错误的或不可移植的。</p>
<p>关于返回值和<code>return</code>语句我们将在第 1 节
“return语句”详细讨论，我们先从不带参数也没有返回值的函数开始学习定义和使用函数：</p>
<p>例 最简单的自定义函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">newline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First Line.\n&quot;</span>);</span><br><span class="line">    newline();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second Line.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First Line.</span><br><span class="line"></span><br><span class="line">Second Line.</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<code>newline</code>函数给<code>main</code>函数调用，它的作用是打印一个换行，所以执行结果中间多了一个空行。<code>newline</code>函数不仅不带参数，也没有返回值，返回值类型为<code>void</code>表示没有返回值，这说明我们调用这个函数完全是为了利用它的Side
Effect。如果我们想要多次插入空行就可以多次调用<code>newline</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First Line.\n&quot;</span>);</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second Line.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们总需要三个三个地插入空行，我们可以再定义一个<code>threeline</code>函数每次插入三个空行：</p>
<p>例 较简单的自定义函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">newline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threeline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Three lines:\n&quot;</span>);</span><br><span class="line">    threeline();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Another three lines.\n&quot;</span>);</span><br><span class="line">    threeline();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个简单的例子可以体会到：</p>
<p>同一个函数可以被多次调用。</p>
<p>可以用一个函数调用另一个函数，后者再去调第三个函数。</p>
<p>通过自定义函数可以给一组复杂的操作起一个简单的名字，例如<code>threeline</code>。对于<code>main</code>函数来说，只需要通过<code>threeline</code>这个简单的名字来调用就行了，不必知道打印三个空行具体怎么做，所有的复杂操作都被隐藏在<code>threeline</code>这个名字后面。</p>
<p>使用自定义函数可以使代码更简洁，<code>main</code>函数在任何地方想打印三个空行只需调用一个简单的<code>threeline()</code>，而不必每次都写三个<code>printf("\n")</code>。</p>
<p>读代码和读文章不一样，按从上到下从左到右的顺序读代码未必是最好的。比如上面的例子，按源文件的顺序应该是先看<code>newline</code>再看<code>threeline</code>再看<code>main</code>。如果你换一个角度，按代码的执行顺序来读也许会更好：首先执行的是<code>main</code>函数中的语句，在一条<code>printf</code>之后调用了<code>threeline</code>，这时再去看<code>threeline</code>的定义，其中又调用了<code>newline</code>，这时再去看<code>newline</code>的定义，<code>newline</code>里面有一条<code>printf</code>，执行完成后返回<code>threeline</code>，这里还剩下两次<code>newline</code>调用，效果也都一样，执行完之后返回<code>main</code>，接下来又是一条<code>printf</code>和一条<code>threeline</code>。</p>
<p>读代码的过程就是模仿计算机执行程序的过程，我们不仅要记住当前读到了哪一行代码，还要记住现在读的代码是被哪个函数调用的，这段代码返回后应该从上一个函数的什么地方接着往下读。</p>
<p>现在澄清一下函数声明、函数定义、函数原型（Prototype）这几个概念。比如<code>void threeline(void)</code>这一行，声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。在代码中可以单独写一个函数原型，后面加<code>;</code>号结束，而不写函数体，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">threeline</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义。上一章讲过，只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也要占存储空间。那么没有函数体的函数声明有什么用呢？它为编译器提供了有用的信息，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令，所以函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。</p>
<p>在上面的例子中，<code>main</code>调用<code>threeline</code>，<code>threeline</code>再调用<code>newline</code>，要保证每个函数的原型出现在调用之前，就只能按先<code>newline</code>再<code>threeline</code>再<code>main</code>的顺序定义了。如果使用不带函数体的声明，则可以改变函数的定义顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">newline</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">threeline</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">newline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threeline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仍然遵循了先声明后使用的原则。</p>
<p>由于有Old Style
C语法的存在，并非所有函数声明都包含完整的函数原型，例如<code>void threeline();</code>这个声明并没有明确指出参数类型和个数，所以不算函数原型，这个声明提供给编译器的信息只有函数名和返回值类型。如果在这样的声明之后调用函数，编译器不知道参数的类型和个数，就不会做语法检查，所以很容易引入Bug。读者需要了解这个知识点以便维护别人用Old
Style C风格写的代码，但绝不应该按这种风格写新的代码。</p>
<p>如果在调用函数之前没有声明会怎么样呢？有的读者也许碰到过这种情况，我可以解释一下，但绝不推荐这种写法。比如按上面的顺序定义这三个函数，但是把开头的两行声明去掉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Three lines:\n&quot;</span>);</span><br><span class="line">    threeline();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Another three lines.\n&quot;</span>);</span><br><span class="line">    threeline();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">newline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threeline</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">    newline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时会报警告：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line">main.c:17: warning: conflicting types for ‘threeline’</span><br><span class="line">main.c:6: warning: previous implicit declaration of ‘threeline’ was here</span><br></pre></td></tr></table></figure>
<p>但仍然能编译通过，运行结果也对。这里涉及到的规则称为函数的隐式声明（Implicit
Declaration），在<code>main</code>函数中调用<code>threeline</code>时并没有声明它，编译器认为此处隐式声明了<code>int threeline(void);</code>，隐式声明的函数返回值类型都是<code>int</code>，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是<code>void</code>，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到<code>threeline</code>函数的原型是<code>void threeline(void)</code>，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确。</p>
<h2 id="形参和实参">形参和实参</h2>
<p>下面我们定义一个带参数的函数，我们需要在函数定义中指明参数的个数和每个参数的类型，定义参数就像定义变量一样，需要为每个参数指明类型，参数的命名也要遵循标识符命名规则。例如：</p>
<p>例 带参数的自定义函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_time(<span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，定义变量时可以把相同类型的变量列在一起，而定义参数却不可以，例如下面这样的定义是错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">int</span> hour, minute)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学习C语言的人肯定都乐意看到这句话：“变量是这样定义的，参数也是这样定义的，一模一样”，这意味着不用专门去记住参数应该怎么定义了。谁也不愿意看到这句话：“定义变量可以这样写，而定义参数却不可以”。C语言的设计者也不希望自己设计的语法规则里到处都是例外，一个容易被用户接受的设计应该遵循最少例外原则（Rule
of Least
Surprise）。其实关于参数的这条规定也不算十分例外，也是可以理解的，请读者想想为什么要这么规定。学习编程语言不应该死记各种语法规定，如果能够想清楚设计者这么规定的原因（Rationale），不仅有助于记忆，而且会有更多收获。本书在必要的地方会解释一些Rationale，或者启发读者自己去思考，例如上一节在脚注中解释了<code>void</code>关键字的Rationale。[C99
Rationale]是随C99标准一起发布的，值得参考。</p>
<p>总的来说，C语言的设计是非常优美的，只要理解了少数基本概念和基本原则就可以根据组合规则写出任意复杂的程序，很少有例外的规定说这样组合是不允许的，或者那样类推是错误的。相反，C++的设计就非常复杂，充满了例外，全世界没几个人能把C++的所有规则都牢记于心，因而C++的设计一直饱受争议，这个观点在[UNIX编程艺术]中有详细阐述。</p>
<p>在本书中，凡是提醒读者注意的地方都是多少有些Surprise的地方，初学者如果按常理来想很可能要想错，所以需要特别提醒一下。而初学者容易犯的另外一些错误，完全是因为没有掌握好基本概念和基本原理，或者根本无视组合规则而全凭自己主观臆断所致，对这一类问题本书不会做特别的提醒，例如有的初学者看完第
2 章 常量、变量和表达式之后会这样打印π的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi=<span class="number">3.1416</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之所以会犯这种错误，一是不理解Literal的含义，二是自己想当然地把变量名组合到字符串里去，而事实上根本没有这条语法规则。如果连这样的错误都需要在书上专门提醒，就好比提醒小孩吃饭一定要吃到嘴里，不要吃到鼻子里，更不要吃到耳朵里一样。</p>
<p>回到正题。我们调用<code>print_time(23, 59)</code>时，函数中的参数<code>hour</code>就代表<code>23</code>，参数<code>minute</code>就代表<code>59</code>。确切地说，当我们讨论函数中的<code>hour</code>这个参数时，我们所说的“参数”是指形参（Parameter），当我们讨论传一个参数<code>23</code>给函数时，我们所说的“参数”是指实参（Argument），但我习惯都叫参数而不习惯总把形参、实参这两个文绉绉的词挂在嘴边（事实上大多数人都不习惯），读者可以根据上下文判断我说的到底是形参还是实参。记住这条基本原理：形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化。例如这样调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">23</span>, m = <span class="number">59</span>;</span><br><span class="line">    print_time(h, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于在函数<code>print_time</code>中执行了这样一些语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hour = h;</span><br><span class="line"><span class="type">int</span> minute = m;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, hour, minute);</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数的变量<code>h</code>和<code>print_time</code>函数的参数<code>hour</code>是两个不同的变量，只不过它们的存储空间中都保存了相同的值<code>23</code>，因为变量<code>h</code>的值赋给了参数<code>hour</code>。同理，变量<code>m</code>的值赋给了参数<code>minute</code>。C语言的这种传递参数的方式称为Call
by
Value。在调用函数时，每个参数都需要得到一个值，函数定义中有几个形参，在调用时就要传几个实参，不能多也不能少，每个参数的类型也必须对应上。</p>
<p>肯定有读者注意到了，为什么我们每次调用<code>printf</code>传的实参个数都不一样呢？因为C语言规定了一种特殊的参数列表格式，用命令<code>man 3 printf</code>可以查看到<code>printf</code>函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是<code>const char *</code>类型的，后面的<code>...</code>可以代表<code>0</code>个或任意多个参数，这些参数的类型也是不确定的，这称为可变参数（Variable
Argument），第 6 节
“可变参数”将会详细讨论这种格式。总之，每个函数的原型都明确规定了返回值类型以及参数的类型和个数，即使像printf这样规定为“不确定”也是一种明确的规定，调用函数时要严格遵守这些规定，有时候我们把函数叫做接口（Interface），调用函数就是使用这个接口，使用接口的前提是必须和接口保持一致。</p>
<p>Man Page:</p>
<p>Man
Page是Linux开发最常用的参考手册，由很多页面组成，每个页面描述一个主题，这些页面被组织成若干个Section。FHS（Filesystem
Hierarchy Standard）标准规定了Man Page各Section的含义如下：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>用户命令，例如ls(1)</td>
</tr>
<tr>
<td>2</td>
<td>系统调用，例如_exit(2)</td>
</tr>
<tr>
<td>3</td>
<td>库函数，例如printf(3)</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件，例如null(4)描述了设备文件/dev/null、/dev/zero的作用</td>
</tr>
<tr>
<td>5</td>
<td>系统配置文件的格式，例如passwd(5)描述了系统配置文件/etc/passwd的格式</td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>其它杂项，例如bash-builtins(7)描述了bash的各种内建命令</td>
</tr>
<tr>
<td>8</td>
<td>系统管理命令，例如ifconfig(8)</td>
</tr>
</tbody>
</table>
<p>注意区分用户命令和系统管理命令，用户命令通常位于/bin和/usr/bin目录，系统管理命令通常位于/sbin和/usr/sbin目录，一般用户可以执行用户命令，而执行系统管理命令经常需要root权限。系统调用和库函数的区别将在第
2 节 “main函数和启动例程”说明。</p>
<p>Man
Page中有些页面有重名，比如敲<code>man printf</code>命令看到的并不是C函数<code>printf</code>，而是位于第1个Section的系统命令<code>printf</code>，要查看位于第3个Section的<code>printf</code>函数应该敲<code>man 3 printf</code>，也可以敲<code>man -k printf</code>命令搜索哪些页面的主题包含<code>printf</code>关键字。本书会经常出现类似<code>printf(3)</code>这样的写法，括号中的<code>3</code>表示Man
Page的第3个Section，或者表示“我这里想说的是<code>printf</code>库函数而不是<code>printf</code>命令”。</p>
<h2 id="全局变量局部变量和作用域">全局变量,局部变量和作用域</h2>
<p>我们把函数中定义的变量称为局部变量（Local
Variable），由于形参相当于函数中定义的变量，所以形参也是一种局部变量。在这里“局部”有两层含义：</p>
<p>1、一个函数中定义的变量不能被另一个函数使用。例如<code>print_time</code>中的<code>hour</code>和<code>minute</code>在<code>main</code>函数中没有定义，不能使用，同样<code>main</code>函数中的局部变量也不能被<code>print_time</code>函数使用。如果这样定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hour = <span class="number">23</span>, minute = <span class="number">59</span>;</span><br><span class="line">    print_time(hour, minute);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>函数中定义了局部变量<code>hour</code>，<code>print_time</code>函数中也有参数<code>hour</code>，虽然它们名称相同，但仍然是两个不同的变量，代表不同的存储单元。<code>main</code>函数的局部变量<code>minute</code>和<code>print_time</code>函数的参数<code>minute</code>也是如此。</p>
<p>2、每次调用函数时局部变量都表示不同的存储空间。局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间，例如调用<code>print_time(23, 59)</code>时分配<code>hour</code>和<code>minute</code>两个变量的存储空间，在里面分别存上<code>23</code>和<code>59</code>，函数返回时释放它们的存储空间，下次再调用<code>print_time(12, 20)</code>时又分配<code>hour</code>和<code>minute</code>的存储空间，在里面分别存上<code>12</code>和<code>20</code>。</p>
<p>与局部变量的概念相对的是全局变量（Global
Variable），全局变量定义在所有的函数体之外，它们在程序开始运行时分配存储空间，在程序结束时释放存储空间，在任何函数中都可以访问全局变量，例如：</p>
<p>例 全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hour = <span class="number">23</span>, minute = <span class="number">59</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d in print_time\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d in main\n&quot;</span>, hour, minute);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正因为全局变量在任何函数中都可以访问，所以在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。程序出现了Bug往往就是因为在某个不起眼的地方对全局变量的读写顺序不正确，如果代码规模很大，这种错误是很难找到的。而对局部变量的访问不仅局限在一个函数内部，而且局限在一次函数调用之中，从函数的源代码很容易看出访问的先后顺序是怎样的，所以比较容易找到Bug。因此，虽然全局变量用起来很方便，但一定要慎用，能用函数传参代替的就不要用全局变量。</p>
<p>如果全局变量和局部变量重名了会怎么样呢？我们把代码改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hour = <span class="number">23</span>, minute = <span class="number">59</span>;</span><br><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d in print_time\n&quot;</span>, hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> hour = <span class="number">0</span>, minute = <span class="number">30</span>;</span><br><span class="line">    print_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d in main\n&quot;</span>, hour, minute);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则第一次调用<code>print_time</code>打印的是全局变量的值，第二次直接调用<code>printf</code>打印的则是<code>main</code>函数局部变量的值。在C语言中每个标识符都有特定的作用域，全局变量是定义在所有函数体之外的标识符，它的作用域从定义的位置开始直到源文件结束，而<code>main</code>函数局部变量的作用域仅限于<code>main</code>函数之中。如上图所示，设想整个源文件是一张大纸，也就是全局变量的作用域，而<code>main</code>函数是盖在这张大纸上的一张小纸，也就是<code>main</code>函数局部变量的作用域。在小纸上用到标识符<code>hour</code>和<code>minute</code>时应该参考小纸上的定义，因为大纸（全局变量的作用域）被盖住了，如果在小纸上用到某个标识符却没有找到它的定义，那么再去翻看下面的大纸上有没有定义，例如上图中的变量<code>x</code>。</p>
<p>到目前为止我们在初始化一个变量时都是用常量做Initializer，其实也可以用表达式做Initializer，但要注意一点：局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant
Expression）初始化。例如，全局变量<code>pi</code>这样初始化是合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14</span> + <span class="number">0.0016</span>;</span><br></pre></td></tr></table></figure>
<p>但这样初始化是不合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br></pre></td></tr></table></figure>
<p>然而局部变量这样初始化却是可以的。程序开始运行时要用适当的值来初始化全局变量，所以初始值必须保存在编译生成的可执行文件中，因此初始值在编译时就要计算出来，然而上面第二种Initializer的值必须在程序运行时调用acos函数才能得到，所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念。为了简化编译器的实现，C语言从语法上规定全局变量只能用常量表达式来初始化，因此下面这种全局变量初始化是不合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minute = <span class="number">360</span>;</span><br><span class="line"><span class="type">int</span> hour = minute / <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>虽然在编译时计算出<code>hour</code>的初始值是可能的，但是<code>minute / 60</code>不是常量表达式，不符合语法规定，所以编译器不必想办法去算这个初始值。</p>
<p>如果全局变量在定义时不初始化则初始值是<code>0</code>，如果局部变量在定义时不初始化则初始值是不确定的。所以，局部变量在使用之前一定要先赋值，如果基于一个不确定的值做后续计算肯定会引入Bug。</p>
<p>如何证明“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”？当我们想要确认某些语法规则时，可以查教材，也可以查C99，但最快捷的办法就是编个小程序验证一下：</p>
<p>例 验证局部变量存储空间的分配和释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    i = <span class="number">777</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用<code>foo</code>函数，分配变量<code>i</code>的存储空间，然后打印<code>i</code>的值，由于<code>i</code>未初始化，打印的应该是一个不确定的值，然后把<code>i</code>赋值为<code>777</code>，函数返回，释放<code>i</code>的存储空间。第二次调用<code>foo</code>函数，分配变量<code>i</code>的存储空间，然后打印<code>i</code>的值，由于<code>i</code>未初始化，如果打印的又是一个不确定的值，就证明了“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”。分析完了，我们运行程序看看是不是像我们分析的这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">134518128</span><br><span class="line">777</span><br></pre></td></tr></table></figure>
<p>结果出乎意料，第二次调用打印的<code>i</code>值正是第一次调用末尾赋给<code>i</code>的值777。有一种初学者是这样，原本就没有把这条语法规则记牢，或者对自己的记忆力没信心，看到这个结果就会想：哦那肯定是我记错了，改过来记吧，应该是“函数中的局部变量具有一直存在的固定的存储空间，每次函数调用时使用它，返回时也不释放，再次调用函数时它应该还能保持上次的值”。还有一种初学者是怀疑论者或不可知论者，看到这个结果就会想：教材上明明说“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”，那一定是教材写错了，教材也是人写的，是人写的就难免出错，哦，连C99也这么写的啊，C99也是人写的，也难免出错，或者C99也许没错，但是反正运行结果就是错了，计算机这东西真靠不住，太容易受电磁干扰和宇宙射线影响了，我的程序写得再正确也有可能被干扰得不能正确运行。</p>
<p>这是初学者最常见的两种心态。不从客观事实和逻辑推理出发分析问题的真正原因，而仅凭主观臆断胡乱给问题定性，“说你有罪你就有罪”。先不要胡乱怀疑，我们再做一次实验，在两次<code>foo</code>函数调用之间插一个别的函数调用，结果就大不相同了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">134518200</span><br><span class="line">hello</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这一回，第二次调用<code>foo</code>打印的<code>i</code>值又不是<code>777</code>了而是<code>0</code>，“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”这个结论似乎对了，但另一个结论又不对了：全局变量不初始化才是<code>0</code>啊，不是说“局部变量不初始化则初值不确定”吗？</p>
<p>关键的一点是，我说“初值不确定”，有没有说这个不确定值不能是<code>0</code>？有没有说这个不确定值不能是上次调用赋的值？在这里“不确定”的准确含义是：每次调用这个函数时局部变量的初值可能不一样，运行环境不同，函数的调用次序不同，都会影响到局部变量的初值。在运用逻辑推理时一定要注意，不要把必要条件（Necessary
Condition）当充分条件（Sufficient
Condition），这一点在Debug时尤其重要，看到错误现象不要轻易断定原因是什么，一定要考虑再三，找出它的真正原因。例如，不要看到第二次调用打印777就下结论“函数中的局部变量具有一直存在的固定的存储空间，每次函数调用时使用它，返回时也不释放，再次调用函数时它应该还能保持上次的值”，这个结论倒是能推出777这个结果，但反过来由777这个结果却不能推出这样的结论。所以说777这个结果是该结论的必要条件，但不是充分条件。也不要看到第二次调用打印0就断定“局部变量未初始化则初值为0”，0这个结果是该结论的必要条件，但也不是充分条件。至于为什么会有这些现象，为什么这个不确定的值刚好是777，或者刚好是0，等学到例
19.1 “研究函数的调用过程”就能解释这些现象了。</p>
<p>从第 2 节
“自定义函数”介绍的语法规则可以看出，非定义的函数声明也可以写在局部作用域中，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print_time</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    print_time(<span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样声明的标识符<code>print_time</code>具有局部作域，只在<code>main</code>函数中是有效的函数名，出了<code>main</code>函数就不存在<code>print_time</code>这个标识符了。</p>
<p>写非定义的函数声明时参数可以只写类型而不起名，例如上面代码中的<code>void print_time(int, int);</code>，只要告诉编译器参数类型是什么，编译器就能为<code>print_time(23, 59)</code>函数调用生成正确的指令。另外注意，虽然在一个函数体中可以声明另一个函数，但不能定义另一个函数，C语言不允许嵌套定义函数[5]。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B9%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B9%9D%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:编码风格</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 20:02:07" itemprop="dateModified" datetime="2025-08-07T20:02:07+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>代码风格好不好就像字写得好不好看一样，如果一个公司招聘秘书，肯定不要字写得难看的，同理，代码风格糟糕的程序员肯定也是不称职的。虽然编译器不会挑剔难看的代码，照样能编译通过，但是和你一个Team的其他程序员肯定受不了，你自己也受不了，写完代码几天之后再来看，自己都不知道自己写的是什么。[SICP]里有句话说得好：“Thus,
programs must be written for people to read, and only incidentally for
machines to
execute.”代码主要是为了写给人看的，而不是写给机器看的，只是顺便也能用机器执行而已，如果是为了写给机器看那直接写机器指令就好了，没必要用高级语言了。代码和语言文字一样是为了表达思想、记载信息，所以一定要写得清楚整洁才能有效地表达。正因为如此，在一个软件项目中，代码风格一般都用文档规定死了，所有参与项目的人不管他自己原来是什么风格，都要遵守统一的风格，例如Linux内核的[CodingStyle]就是这样一个文档。本章我们以内核的代码风格为基础来讲解好的编码风格都有哪些规定，这些规定的Rationale是什么。我只是以Linux内核为例来讲解编码风格的概念，并没有说内核编码风格就一定是最好的编码风格，但Linux内核项目如此成功，就足以说明它的编码风格是最好的C语言编码风格之一了。</p>
<h2 id="缩进和空白">缩进和空白</h2>
<p>我们知道C语言的语法对缩进和空白没有要求，空格、<code>Tab</code>、换行都可以随意写，实现同样功能的代码可以写得很好看，也可以写得很难看。例如上一章例
8.5 “剪刀石头布”的代码如果写成这样就很难看了：</p>
<p>例 缺少缩进和空白的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> gesture[<span class="number">3</span>][<span class="number">10</span>]=&#123;<span class="string">&quot;scissor&quot;</span>,<span class="string">&quot;stone&quot;</span>,<span class="string">&quot;cloth&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> man,computer,result, ret;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">computer=rand()%<span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nInput your gesture (0-scissor 1-stone 2-cloth):\n&quot;</span>);</span><br><span class="line">ret=<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;man);</span><br><span class="line"><span class="keyword">if</span>(ret!=<span class="number">1</span>||man&lt;<span class="number">0</span>||man&gt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Your gesture: %s\tComputer&#x27;s gesture: %s\n&quot;</span>,gesture[man],gesture[computer]);</span><br><span class="line">result=(man-computer+<span class="number">4</span>)%<span class="number">3</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(result&gt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;You win!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;Draw!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;You lose!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一是缺少空白字符，代码密度太大，看着很费劲。二是没有缩进，看不出来哪个<code>&#123;</code>和哪个<code>&#125;</code>配对，像这么短的代码还能凑合着看，如果代码超过一屏就完全没法看了。[CodingStyle]中关于空白字符并没有特别规定，因为基本上所有的C代码风格对于空白字符的规定都差不多，主要有以下几条。</p>
<p>1、关键字<code>if</code>、<code>while</code>、<code>for</code>与其后的控制表达式的<code>(</code>括号之间插入一个空格分隔，但括号内的表达式应紧贴括号。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>␣(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>2、双目运算符的两侧各插入一个空格分隔，单目运算符和操作数之间不加空格，例如<code>i␣=␣i␣+␣1</code>、<code>++i</code>、<code>!(i␣&lt;␣1)</code>、<code>-x</code>、<code>&amp;a[1]</code>等。</p>
<p>3、后缀运算符和操作数之间也不加空格，例如取结构体成员<code>s.a</code>、函数调用<code>foo(arg1)</code>、取数组成员<code>a[i]</code>。</p>
<p>4、<code>,</code>号和<code>;</code>号之后要加空格，这是英文的书写习惯，例如<code>for␣(i␣=␣1;␣i␣&lt;␣10;␣i++)</code>、<code>foo(arg1,␣arg2)</code>。</p>
<p>5、以上关于双目运算符和后缀运算符的规则并没有严格要求，有时候为了突出优先级也可以写得更紧凑一些，例如<code>for␣(i=1;␣i&lt;10;␣i++)</code>、<code>distance␣=␣sqrt(x*x␣+␣y*y)</code>等。但是省略的空格一定不要误导了读代码的人，例如<code>a||b␣&amp;&amp;␣c</code>很容易让人理解成错误的优先级。</p>
<p>6、由于UNIX系统标准的字符终端是24行80列的，接近或大于80个字符的较长语句要折行写，折行后用空格和上面的表达式或参数对齐，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>␣(<span class="built_in">sqrt</span>(x*x␣+␣y*y)␣&gt;␣<span class="number">5.0</span></span><br><span class="line">    &amp;&amp;␣x␣&lt;␣<span class="number">0.0</span></span><br><span class="line">    &amp;&amp;␣y␣&gt;␣<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<p>再比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="built_in">sqrt</span>(x*x␣+␣y*y),</span><br><span class="line">    a[i<span class="number">-1</span>]␣+␣b[i<span class="number">-1</span>]␣+␣c[i<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>7、较长的字符串可以断成多个字符串然后分行书写，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is such a long sentence that &quot;</span></span><br><span class="line">       <span class="string">&quot;it cannot be held within a line\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>C编译器会自动把相邻的多个字符串接在一起，以上两个字符串相当于一个字符串<code>"This is such a long sentence that it cannot be held within a line\n"</code>。</p>
<p>8、有的人喜欢在变量定义语句中用<code>Tab</code>字符，使变量名对齐，这样看起来很美观。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">→<span class="type">int</span>    →a, b;</span><br><span class="line">→<span class="type">double</span> →c;</span><br></pre></td></tr></table></figure>
<p>内核代码风格关于缩进的规则有以下几条。</p>
<p>1、要用缩进体现出语句块的层次关系，使用<code>Tab</code>字符缩进，不能用空格代替<code>Tab</code>。在标准的字符终端上一个<code>Tab</code>看起来是8个空格的宽度，如果你的文本编辑器可以设置<code>Tab</code>的显示宽度是几个空格，建议也设成8，这样大的缩进使代码看起来非常清晰。如果有的行用空格做缩进，有的行用<code>Tab</code>做缩进，甚至空格和<code>Tab</code>混用，那么一旦改变了文本编辑器的<code>Tab</code>显示宽度就会看起来非常混乱，所以内核代码风格规定只能用<code>Tab</code>做缩进，不能用空格代替<code>Tab</code>。</p>
<p>2、<code>if/else</code>、<code>while</code>、<code>do/while</code>、<code>for</code>、<code>switch</code>这些可以带语句块的语句，语句块的<code>&#123;</code>或<code>&#125;</code>应该和关键字写在同一行，用空格隔开，而不是单独占一行。例如应该这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>␣(...)␣&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;␣<span class="keyword">else</span>␣<span class="keyword">if</span>␣(...)␣&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但很多人习惯这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>␣(...)</span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>␣<span class="keyword">if</span>␣(...)</span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核的写法和[K&amp;R]一致，好处是不必占太多行，使得一屏能显示更多代码。这两种写法用得都很广泛，只要在同一个项目中能保持统一就可以了。</p>
<p>3、函数定义的<code>&#123;</code>和<code>&#125;</code>单独占一行，这一点和语句块的规定不同，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>␣foo(<span class="type">int</span>␣a,␣<span class="type">int</span>␣b)</span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、<code>switch</code>和语句块里的<code>case</code>、<code>default</code>对齐写，也就是说语句块里的<code>case</code>、<code>default</code>标号相对于<code>switch</code>不往里缩进，但标号下的语句要往里缩进。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">→<span class="keyword">switch</span>␣(c)␣&#123;</span><br><span class="line">→<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">→       →语句列表</span><br><span class="line">→<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">→       →语句列表</span><br><span class="line">→<span class="keyword">default</span>:</span><br><span class="line">→       →语句列表</span><br><span class="line">→&#125;</span><br></pre></td></tr></table></figure>
<p>用于<code>goto</code>语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层。</p>
<p>5、代码中每个逻辑段落之间应该用一个空行分隔开。例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"><span class="type">double</span> h;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       →语句列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔。这条规定不是严格要求，通常把变量定义组成一组，后面加空行，<code>return</code>语句之前加空行，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">       →<span class="type">int</span>    →a, b;</span><br><span class="line">       →<span class="type">double</span> →c;</span><br><span class="line"></span><br><span class="line">       →语句组<span class="number">1</span></span><br><span class="line"></span><br><span class="line">       →语句组<span class="number">2</span></span><br><span class="line"></span><br><span class="line">       →<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注释">注释</h2>
<p>单行注释应采用<code>/*␣comment␣*/</code>的形式，用空格把界定符和文字分开。多行注释最常见的是这种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">␣*␣Multi-line</span></span><br><span class="line"><span class="comment">␣*␣comment</span></span><br><span class="line"><span class="comment">␣*/</span></span><br></pre></td></tr></table></figure>
<p>也有更花哨的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************\</span></span><br><span class="line"><span class="comment">* Multi-line  *</span></span><br><span class="line"><span class="comment">* comment     *</span></span><br><span class="line"><span class="comment">\*************/</span></span><br></pre></td></tr></table></figure>
<p>使用注释的场合主要有以下几种。</p>
<p>1、整个源文件的顶部注释。说明此模块的相关信息，例如文件名、作者和版本历史等，顶头写不缩进。例如内核源代码目录下的kernel/sched.c文件的开头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  kernel/sched.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Kernel scheduler and related syscalls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Copyright (C) 1991-2002  Linus Torvalds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and</span></span><br><span class="line"><span class="comment"> *              make semaphores SMP safe</span></span><br><span class="line"><span class="comment"> *  1998-11-19  Implemented schedule_timeout() and related stuff</span></span><br><span class="line"><span class="comment"> *              by Andrea Arcangeli</span></span><br><span class="line"><span class="comment"> *  2002-01-04  New ultra-scalable O(1) scheduler by Ingo Molnar:</span></span><br><span class="line"><span class="comment"> *              hybrid priority-list and round-robin design with</span></span><br><span class="line"><span class="comment"> *              an array-switch method of distributing timeslices</span></span><br><span class="line"><span class="comment"> *              and per-CPU runqueues.  Cleanups and useful suggestions</span></span><br><span class="line"><span class="comment"> *              by Davide Libenzi, preemptible kernel bits by Robert Love.</span></span><br><span class="line"><span class="comment"> *  2003-09-03  Interactivity tuning by Con Kolivas.</span></span><br><span class="line"><span class="comment"> *  2004-04-02  Scheduler domains code by Nick Piggin</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>2、函数注释。说明此函数的功能、参数、返回值、错误码等，写在函数定义上侧，和此函数定义之间不留空行，顶头写不缩进。</p>
<p>3、相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。</p>
<p>4、代码行右侧的简短注释。对当前代码行做特别说明，一般为单行注释，和代码之间至少用一个空格隔开，一个源文件中所有的右侧注释最好能上下对齐。尽管例
2.1 “带更多注释的Hello
World”讲过注释可以穿插在一行代码中间，但不建议这么写。内核源代码目录下的lib/radix-tree.c文件中的一个函数包含了上述三种注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      radix_tree_insert    -    insert into a radix tree</span></span><br><span class="line"><span class="comment"> *      @root:          radix tree root</span></span><br><span class="line"><span class="comment"> *      @index:         index key</span></span><br><span class="line"><span class="comment"> *      @item:          item to insert</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Insert an item into the radix tree at position @index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">radix_tree_insert</span><span class="params">(<span class="keyword">struct</span> radix_tree_root *root,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *item)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>, *slot;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> height, shift;</span><br><span class="line">        <span class="type">int</span> offset;</span><br><span class="line">        <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure the tree is high enough.  */</span></span><br><span class="line">        <span class="keyword">if</span> ((!index &amp;&amp; !root-&gt;rnode) ||</span><br><span class="line">                        index &gt; radix_tree_maxindex(root-&gt;height)) &#123;</span><br><span class="line">                error = radix_tree_extend(root, index);</span><br><span class="line">                <span class="keyword">if</span> (error)</span><br><span class="line">                        <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slot = root-&gt;rnode;</span><br><span class="line">        height = root-&gt;height;</span><br><span class="line">        shift = (height<span class="number">-1</span>) * RADIX_TREE_MAP_SHIFT;</span><br><span class="line"></span><br><span class="line">        offset = <span class="number">0</span>;                     <span class="comment">/* uninitialised var warning */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (slot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="comment">/* Have to add a child node.  */</span></span><br><span class="line">                        <span class="keyword">if</span> (!(slot = radix_tree_node_alloc(root)))</span><br><span class="line">                                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">                                node-&gt;slots[offset] = slot;</span><br><span class="line">                                node-&gt;count++;</span><br><span class="line">                        &#125; <span class="keyword">else</span></span><br><span class="line">                                root-&gt;rnode = slot;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Go a level down */</span></span><br><span class="line">                offset = (index &gt;&gt; shift) &amp; RADIX_TREE_MAP_MASK;</span><br><span class="line">                node = slot;</span><br><span class="line">                slot = node-&gt;slots[offset];</span><br><span class="line">                shift -= RADIX_TREE_MAP_SHIFT;</span><br><span class="line">                height--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (height &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slot != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -EEXIST;</span><br><span class="line"></span><br><span class="line">        BUG_ON(!node);</span><br><span class="line">        node-&gt;count++;</span><br><span class="line">        node-&gt;slots[offset] = item;</span><br><span class="line">        BUG_ON(tag_get(node, <span class="number">0</span>, offset));</span><br><span class="line">        BUG_ON(tag_get(node, <span class="number">1</span>, offset));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[CodingStyle]中特别指出，函数内的注释要尽可能少用。写注释主要是为了说明你的代码“能做什么”（比如函数接口定义），而不是为了说明“怎样做”，只要代码写得足够清晰，“怎样做”是一目了然的，如果你需要用注释才能解释清楚，那就表示你的代码可读性很差，除非是特别需要提醒注意的地方才使用函数内注释。</p>
<p>5、复杂的结构体定义比函数更需要注释。例如内核源代码目录下的kernel/sched.c文件中定义了这样一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the main, per-CPU runqueue data structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rule: those places that want to lock multiple runqueues</span></span><br><span class="line"><span class="comment"> * (such as the load balancing or the thread migration code), lock</span></span><br><span class="line"><span class="comment"> * acquire operations must be ordered by ascending &amp;runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">runqueue</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">         * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cpu_load[<span class="number">3</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> nr_switches;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment">         * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment">         * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment">         * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_uninterruptible;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> expired_timestamp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> timestamp_last_tick;</span><br><span class="line">        <span class="type">task_t</span> *curr, *idle;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">prev_mm</span>;</span></span><br><span class="line">        <span class="type">prio_array_t</span> *active, *expired, arrays[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> best_expired_prio;</span><br><span class="line">        <span class="type">atomic_t</span> nr_iowait;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_domain</span> *<span class="title">sd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For active balancing */</span></span><br><span class="line">        <span class="type">int</span> active_balance;</span><br><span class="line">        <span class="type">int</span> push_cpu;</span><br><span class="line"></span><br><span class="line">        <span class="type">task_t</span> *migration_thread;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">migration_queue</span>;</span></span><br><span class="line">        <span class="type">int</span> cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SCHEDSTATS</span></span><br><span class="line">        <span class="comment">/* latency stats */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span> <span class="title">rq_sched_info</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sys_sched_yield() stats */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> yld_exp_empty;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> yld_act_empty;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> yld_both_empty;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> yld_cnt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* schedule() stats */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> sched_switch;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> sched_cnt;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> sched_goidle;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* try_to_wake_up() stats */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> ttwu_cnt;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> ttwu_local;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6、复杂的宏定义和变量声明也需要注释。例如内核源代码目录下的include/linux/jiffies.h文件中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and  */</span></span><br><span class="line"><span class="comment">/* a value TUSEC for TICK_USEC (can be set bij adjtimex)                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* some arch&#x27;s have a small-data section that can be accessed register-relative</span></span><br><span class="line"><span class="comment"> * but that can only take up to, say, 4-byte variables. jiffies being part of</span></span><br><span class="line"><span class="comment"> * an 8-byte variable may not be correctly accessed unless we force the issue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __jiffy_data  __attribute__((section(<span class="string">&quot;.data&quot;</span>)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit value is not volatile - you MUST NOT read it</span></span><br><span class="line"><span class="comment"> * without sampling the sequence number in xtime_lock.</span></span><br><span class="line"><span class="comment"> * get_jiffies_64() will do this for you as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> u64 __jiffy_data jiffies_64;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __jiffy_data jiffies;</span><br></pre></td></tr></table></figure>
<h2 id="标识符命名">标识符命名</h2>
<p>标识符命名应遵循以下原则：</p>
<p>标识符命名要清晰明了，可以使用完整的单词和易于理解的缩写。短的单词可以通过去元音形成缩写，较长的单词可以取单词的头几个字母形成缩写。看别人的代码看多了就可以总结出一些缩写惯例，例如<code>count</code>写成<code>cnt</code>，<code>block</code>写成<code>blk</code>，<code>length</code>写成<code>len</code>，<code>window</code>写成<code>win</code>，<code>message</code>写成<code>msg</code>，<code>number</code>写成<code>nr</code>，<code>temporary</code>可以写成<code>temp</code>，也可以进一步写成<code>tmp</code>，最有意思的是<code>internationalization</code>写成<code>i18n</code>，词根<code>trans</code>经常缩写成<code>x</code>，例如<code>transmit</code>写成<code>xmt</code>。我就不多举例了，请读者在看代码时自己注意总结和积累。</p>
<p>内核编码风格规定变量、函数和类型采用全小写加下划线的方式命名，常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名，比如上一节举例的函数名<code>radix_tree_insert</code>、类型名<code>struct radix_tree_root</code>、常量名<code>RADIX_TREE_MAP_SHIFT</code>等。</p>
<p>微软发明了一种变量命名法叫匈牙利命名法（Hungarian
notation），在变量名中用前缀表示类型，例如iCnt（i表示int）、pMsg（p表示pointer）、lpszText（lpsz表示long
pointer to a zero-ended
string）等。Linus在[CodingStyle]中毫不客气地讽刺了这种写法：“Encoding
the type of a function into the name (so-called Hungarian notation) is
brain damaged - the compiler knows the types anyway and can check those,
and it only confuses the programmer. No wonder MicroSoft makes buggy
programs.”代码风格本来就是一个很有争议的问题，如果你接受本章介绍的内核编码风格（也是本书所有范例代码的风格），就不要使用大小写混合的变量命名方式[19]，更不要使用匈牙利命名法。</p>
<p>全局变量和全局函数的命名一定要详细，不惜多用几个单词多写几个下划线，例如函数名<code>radix_tree_insert</code>，因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以简略一些，但不能太短。尽量不要使用单个字母做变量名，只有一个例外：用<code>i</code>、<code>j</code>、<code>k</code>做循环变量是可以的。</p>
<p>针对中国程序员的一条特别规定：禁止用汉语拼音做标识符，可读性极差。</p>
<h2 id="函数">函数</h2>
<p>每个函数都应该设计得尽可能简单，简单的函数才容易维护。应遵循以下原则：</p>
<p>实现一个函数只是为了做好一件事情，不要把函数设计成用途广泛、面面俱到的，这样的函数肯定会超长，而且往往不可重用，维护困难。</p>
<p>函数内部的缩进层次不宜过多，一般以少于4层为宜。如果缩进层次太多就说明设计得太复杂了，应考虑分割成更小的函数（Helper
Function）来调用。</p>
<p>函数不要写得太长，建议在24行的标准终端上不超过两屏，太长会造成阅读困难，如果一个函数超过两屏就应该考虑分割函数了。[CodingStyle]中特别说明，如果一个函数在概念上是简单的，只是长度很长，这倒没关系。例如函数由一个大的<code>switch</code>组成，其中有非常多的<code>case</code>，这是可以的，因为各<code>case</code>分支互不影响，整个函数的复杂度只等于其中一个<code>case</code>的复杂度，这种情况很常见，例如TCP协议的状态机实现。</p>
<p>执行函数就是执行一个动作，函数名通常应包含动词，例如<code>get_current</code>、<code>radix_tree_insert</code>。</p>
<p>比较重要的函数定义上侧必须加注释，说明此函数的功能、参数、返回值、错误码等。</p>
<p>另一种度量函数复杂度的办法是看有多少个局部变量，5到10个局部变量已经很多了，再多就很难维护了，应该考虑分割成多个函数。每个函数都应该设计得尽可能简单，简单的函数才容易维护。应遵循以下原则：</p>
<p>实现一个函数只是为了做好一件事情，不要把函数设计成用途广泛、面面俱到的，这样的函数肯定会超长，而且往往不可重用，维护困难。</p>
<p>函数内部的缩进层次不宜过多，一般以少于4层为宜。如果缩进层次太多就说明设计得太复杂了，应考虑分割成更小的函数（Helper
Function）来调用。</p>
<p>函数不要写得太长，建议在24行的标准终端上不超过两屏，太长会造成阅读困难，如果一个函数超过两屏就应该考虑分割函数了。[CodingStyle]中特别说明，如果一个函数在概念上是简单的，只是长度很长，这倒没关系。例如函数由一个大的<code>switch</code>组成，其中有非常多的<code>case</code>，这是可以的，因为各<code>case</code>分支互不影响，整个函数的复杂度只等于其中一个case的复杂度，这种情况很常见，例如TCP协议的状态机实现。</p>
<p>执行函数就是执行一个动作，函数名通常应包含动词，例如<code>get_current</code>、<code>radix_tree_insert</code>。</p>
<p>比较重要的函数定义上侧必须加注释，说明此函数的功能、参数、返回值、错误码等。</p>
<p>另一种度量函数复杂度的办法是看有多少个局部变量，5到10个局部变量已经很多了，再多就很难维护了，应该考虑分割成多个函数。</p>
<h2 id="indent工具">indent工具</h2>
<p><code>indent</code>工具可以把代码格式化成某种风格，例如把例 9.1
“缺少缩进和空白的代码”格式化成内核编码风格：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ indent -kr -i8 main.c </span><br><span class="line">$ cat main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> gesture[<span class="number">3</span>][<span class="number">10</span>] = &#123; <span class="string">&quot;scissor&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;cloth&quot;</span> &#125;;</span><br><span class="line">    <span class="type">int</span> man, computer, result, ret;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        computer = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">            (<span class="string">&quot;\nInput your gesture (0-scissor 1-stone 2-cloth):\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your gesture: %s\tComputer&#x27;s gesture: %s\n&quot;</span>,</span><br><span class="line">               gesture[man], gesture[computer]);</span><br><span class="line">        result = (man - computer + <span class="number">4</span>) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You win!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Draw!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You lose!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-kr选项表示K&amp;R风格，-i8表示缩进8个空格的长度。如果没有指定-nut选项，则每8个缩进空格会自动用一个Tab代替。注意indent命令会直接修改原文件，而不是打印到屏幕上或者输出到另一个文件，这一点和很多UNIX命令不同。可以看出，-kr
-i8两个选项格式化出来的代码已经很符合本章介绍的代码风格了，添加了必要的缩进和空白，较长的代码行也会自动折行。美中不足的是没有添加适当的空行，因为indent工具也不知道哪几行代码在逻辑上是一组的，空行还是要自己动手添，当然原有的空行肯定不会被indent删去的。</p>
<p>如果你采纳本章介绍的内核编码风格，基本上-kr
-i8这两个参数就够用了。indent工具也有支持其它编码风格的选项，具体请参考Man
Page。有时候indent工具的确非常有用，比如某个项目中途决定改变编码风格（这很少见），或者往某个项目中添加的几个代码文件来自另一个编码风格不同的项目，但绝不能因为有了indent工具就肆无忌惮，一开始把代码写得乱七八糟，最后再依靠indent去清理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:预处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 17:47:39" itemprop="dateModified" datetime="2025-08-08T17:47:39+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="预处理的步骤">预处理的步骤</h2>
<p>现在我们全面了解一下C编译器做语法解析之前的预处理步骤：</p>
<p>1、把第 2 节 “常量”提到过的三连符替换成相应的单字符。</p>
<p>2、把用<code>\</code>字符续行的多行代码接成一行。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;hello, &quot;</span>\</span></span><br><span class="line"><span class="meta">        <span class="string">&quot;world&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>经过这个预处理步骤之后接成一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR <span class="string">&quot;hello, &quot;</span>       <span class="string">&quot;world&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这种续行的写法要求<code>\</code>后面紧跟换行，中间不能有其它空白字符。</p>
<p>3、把注释（不管是单行注释还是多行注释）都替换成一个空格。</p>
<p>4、经过以上两步之后去掉了一些换行，有的换行在续行过程中去掉了，有的换行在多行注释之中，也随着注释一起去掉了，剩下的代码行称为逻辑代码行。然后预处理器把逻辑代码行划分成Token和空白字符，这时的Token称为预处理Token，包括标识符、整数常量、浮点数常量、字符常量、字符串、运算符和其它符号。继续上面的例子，两个源代码行被接成一个逻辑代码行，然后这个逻辑代码行被划分成Token和空白字符：<code>#</code>，<code>define</code>，空格，<code>STR</code>，空格，<code>"hello, "</code>，<code>Tab</code>，<code>Tab</code>，<code>"world"</code>。</p>
<p>5、在Token中识别出预处理指示，做相应的预处理动作，如果遇到<code>#include</code>预处理指示，则把相应的源文件包含进来，并对源文件做以上1-4步预处理。如果遇到宏定义则做宏展开。</p>
<p>我们早在第 2 节
“数组应用实例：统计随机数”就认识了预处理指示这个概念，现在给出它的严格定义。一条预处理指示由一个逻辑代码行组成，以<code>#</code>开头，后面跟若干个预处理Token，在预处理指示中允许使用的空白字符只有空格和<code>Tab</code>。</p>
<p>6、找出字符常量或字符串中的转义序列，用相应的字节来替换它，比如把<code>\n</code>替换成字节<code>0x0a</code>。</p>
<p>7、把相邻的字符串连接起来。继续上面的例子，如果代码中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">    STR);</span><br></pre></td></tr></table></figure>
<p>经过第4步处理划分成以下Token：<code>printf</code>，<code>(</code>，换行，<code>Tab</code>，<code>STR</code>，<code>)</code>，<code>;</code>，换行。经过第5步宏展开后变成以下Token：<code>printf</code>，<code>(</code>，换行，<code>Tab</code>，<code>"hello, "</code>，<code>Tab</code>，<code>Tab</code>，<code>"world"</code>，<code>)</code>，<code>;</code>，换行。然后把相邻的字符串连接起来，变成以下Token：<code>printf</code>，<code>(</code>，换行，<code>Tab</code>，<code>"hello, world"，)，;</code>，换行。</p>
<p>8、经过以上处理之后，把空白字符丢掉，把Token交给C编译器做语法解析，这时就不再是预处理Token，而称为C
Token了。这里丢掉的空白字符包括空格、换行、水平<code>Tab</code>、垂直<code>Tab</code>、分页符。继续上面的例子，最后交给C编译器做语法解析的Token是：<code>printf</code>，<code>(</code>，<code>"hello, world"</code>，<code>)</code>
，<code>;</code>。注意，把一个预处理指示写成多行要用<code>\</code>续行，因为根据定义，一条预处理指示只能由一个逻辑代码行组成，而把C代码写成多行则不需要用<code>\</code>续行，因为换行在C代码中只不过是一种空白字符，在做语法解析时所有空白字符都已经丢掉了。</p>
<h2 id="宏定义">宏定义</h2>
<p>较大的项目都会用大量的宏定义来组织代码，你可以看看/usr/include下面的头文件中用了多少个宏定义。看起来宏展开就是做个替换而已，其实里面有比较复杂的规则，C语言有很多复杂但不常用的语法规则本书并不涉及，但有关宏展开的语法规则本节却力图做全面讲解，因为它很重要也很常用。</p>
<h3 id="函数式宏定义">函数式宏定义</h3>
<p>以前我们用过的<code>#define N 20</code>或<code>#define STR "hello, world"</code>这种宏定义可以称为变量式宏定义（Object-like
Macro），宏定义名可以像变量一样在代码中使用。另外一种宏定义可以像函数调用一样在代码中使用，称为函数式宏定义（Function-like
Macro）。例如编辑一个文件<code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line">k = MAX(i&amp;<span class="number">0x0f</span>, j&amp;<span class="number">0x0f</span>)</span><br></pre></td></tr></table></figure>
<p>我们想看第二行的表达式展开成什么样，可以用gcc的<code>-E</code>选项或<code>cpp</code>命令，尽管这个C程序不合语法，但没关系，我们只做预处理而不编译，不会检查程序是否符合C语法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cpp main.c</span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;main.c&quot;</span></span><br><span class="line"></span><br><span class="line">k = ((i&amp;<span class="number">0x0f</span>)&gt;(j&amp;<span class="number">0x0f</span>)?(i&amp;<span class="number">0x0f</span>):(j&amp;<span class="number">0x0f</span>))</span><br></pre></td></tr></table></figure>
<p>就像函数调用一样，把两个实参分别替换到宏定义中形参<code>a</code>和<code>b</code>的位置。注意这种函数式宏定义和真正的函数调用有什么不同：</p>
<p>1、函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心。</p>
<p>2、调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果<code>MAX</code>是个真正的函数，那么它的函数体<code>return a &gt; b ? a : b;</code>要编译生成指令，代码中出现的每次调用也要编译生成传参指令和<code>call</code>指令。而如果<code>MAX</code>是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和<code>call</code>指令。所以，使用函数式宏定义编译生成的目标文件会比较大。</p>
<p>3、定义这种宏要格外小心，如果上面的定义写成<code>#define MAX(a, b) (a&gt;b?a:b)</code>，省去内层括号，则宏展开就成了<code>k = (i&amp;0x0f&gt;j&amp;0x0f?i&amp;0x0f:j&amp;0x0f)</code>，运算的优先级就错了。同样道理，这个宏定义的外层括号也是不能省的，想一想为什么。</p>
<p>4、调用函数时先求实参表达式的值再传给形参，如果实参表达式有Side
Effect，那么这些Side
Effect只发生一次。例如<code>MAX(++a, ++b)</code>，如果<code>MAX</code>是个真正的函数，<code>a</code>和<code>b</code>只增加一次。但如果<code>MAX</code>是上面那样的宏定义，则要展开成<code>k = ((++a)&gt;(++b)?(++a):(++b))</code>，<code>a</code>和<code>b</code>就不一定是增加一次还是两次了。</p>
<p>5、即使实参没有Side
Effect，使用函数式宏定义也往往会导致较低的代码执行效率。下面举一个极端的例子，也是个很有意思的例子。</p>
<p>例 函数式宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? a[<span class="number">0</span>] : MAX(a[n], max(n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    max(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码从一个数组中找出最大的数，如果<code>MAX</code>是个真正的函数，这个算法就是从前到后遍历一遍数组，时间复杂度是Θ(n)，而现在<code>MAX</code>是这样一个函数式宏定义，思考一下这个算法的时间复杂度是多少？</p>
<p>尽管函数式宏定义和真正的函数相比有很多缺点，但只要小心使用还是会显著提高代码的执行效率，毕竟省去了分配和释放栈帧、传参、传返回值等一系列工作，因此那些简短并且被频繁调用的函数经常用函数式宏定义来代替实现。例如C标准库的很多函数都提供两种实现，一种是真正的函数实现，一种是宏定义实现，这一点以后还要详细解释。</p>
<p>函数式宏定义经常写成这样的形式（取自内核代码include/linux/pm.h）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> device_init_wakeup(dev,val) \</span></span><br><span class="line"><span class="meta">        do &#123; \</span></span><br><span class="line"><span class="meta">                device_can_wakeup(dev) = !!(val); \</span></span><br><span class="line"><span class="meta">                device_set_wakeup_enable(dev,val); \</span></span><br><span class="line"><span class="meta">        &#125; while(0)</span></span><br></pre></td></tr></table></figure>
<p>为什么要用<code>do &#123; ... &#125; while(0)</code>括起来呢？不括起来会有什么问题呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> device_init_wakeup(dev,val) \</span></span><br><span class="line"><span class="meta">                device_can_wakeup(dev) = !!(val); \</span></span><br><span class="line"><span class="meta">                device_set_wakeup_enable(dev,val);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">	device_init_wakeup(d, v);</span><br></pre></td></tr></table></figure>
<p>这样宏展开之后，函数体的第二条语句不在<code>if</code>条件中。那么简单地用<code>&#123; ... &#125;</code>括起来组成一个语句块不行吗？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> device_init_wakeup(dev,val) \</span></span><br><span class="line"><span class="meta">                &#123; device_can_wakeup(dev) = !!(val); \</span></span><br><span class="line"><span class="meta">                device_set_wakeup_enable(dev,val); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    device_init_wakeup(d, v);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<p>问题出在<code>device_init_wakeup(d, v);</code>末尾的<code>;</code>号，如果不允许写这个<code>;</code>号，看起来不像个函数调用，可如果写了这个<code>;</code>号，宏展开之后就有语法错误，<code>if</code>语句被这个<code>;</code>号结束掉了，没法跟<code>else</code>配对。因此，<code>do &#123; ... &#125; while(0)</code>是一种比较好的解决办法。</p>
<p>如果在一个程序文件中重复定义一个宏，C语言规定这些重复的宏定义必须一模一样。例如这样的重复定义是允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIKE (1 - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIKE <span class="comment">/* comment */</span> (1<span class="comment">/* comment */</span>-<span class="comment">/* comment */</span>  1)<span class="comment">/* comment */</span></span></span><br></pre></td></tr></table></figure>
<p>在定义的前后多些空白（空格、<code>Tab</code>、注释）没有关系，在定义之中多些空白或少些空白也没有关系，但在定义之中有空白和没有空白被认为是不同的，所以这样的重复定义是不允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIKE (1 - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIKE (1-1)</span></span><br></pre></td></tr></table></figure>
<p>如果需要重新定义一个宏，和原来的定义不同，可以先用<code>#undef</code>取消原来的定义，再重新定义，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> X 3</span></span><br><span class="line">... <span class="comment">/* X is 3 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> X</span></span><br><span class="line">... <span class="comment">/* X has no definition */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 2</span></span><br><span class="line">... <span class="comment">/* X is 2 */</span></span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3>
<p>C99引入一个新关键字<code>inline</code>，用于定义内联函数（inline
function）。这种用法在内核代码中很常见，例如include/linux/rwsem.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">down_read</span><span class="params">(<span class="keyword">struct</span> rw_semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">        might_sleep();</span><br><span class="line">        rwsemtrace(sem,<span class="string">&quot;Entering down_read&quot;</span>);</span><br><span class="line">        __down_read(sem);</span><br><span class="line">        rwsemtrace(sem,<span class="string">&quot;Leaving down_read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inline</code>关键字告诉编译器，这个函数的调用要尽可能快，可以当普通的函数调用实现，也可以用宏展开的办法实现。我们做个实验，把上一节的例子改一下：</p>
<p>例 内联函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">MAX</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? a[<span class="number">0</span>] : MAX(a[n], max(n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    max(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按往常的步骤编译然后反汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -dS a.out</span></span><br><span class="line">...</span><br><span class="line">int max(int n)</span><br><span class="line">&#123;</span><br><span class="line"> 8048369:       55                      push   %ebp</span><br><span class="line"> 804836a:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 804836c:       83 ec 0c                sub    $0xc,%esp</span><br><span class="line">        return n == 0 ? a[0] : MAX(a[n], max(n-1));</span><br><span class="line"> 804836f:       83 7d 08 00             cmpl   $0x0,0x8(%ebp)</span><br><span class="line"> 8048373:       75 0a                   jne    804837f &lt;max+0x16&gt;</span><br><span class="line"> 8048375:       a1 c0 95 04 08          mov    0x80495c0,%eax</span><br><span class="line"> 804837a:       89 45 fc                mov    %eax,-0x4(%ebp)</span><br><span class="line"> 804837d:       eb 29                   jmp    80483a8 &lt;max+0x3f&gt;</span><br><span class="line"> 804837f:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048382:       83 e8 01                sub    $0x1,%eax</span><br><span class="line"> 8048385:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048388:       e8 dc ff ff ff          call   8048369 &lt;max&gt;</span><br><span class="line"> 804838d:       89 c2                   mov    %eax,%edx</span><br><span class="line"> 804838f:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048392:       8b 04 85 c0 95 04 08    mov    0x80495c0(,%eax,4),%eax</span><br><span class="line"> 8048399:       89 54 24 04             mov    %edx,0x4(%esp)</span><br><span class="line"> 804839d:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80483a0:       e8 9f ff ff ff          call   8048344 &lt;MAX&gt;</span><br><span class="line"> 80483a5:       89 45 fc                mov    %eax,-0x4(%ebp)</span><br><span class="line"> 80483a8:       8b 45 fc                mov    -0x4(%ebp),%eax</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到<code>MAX</code>是作为普通函数调用的。如果指定优化选项编译，然后反汇编：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g -O</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -dS a.out</span></span><br><span class="line">...</span><br><span class="line">int max(int n)</span><br><span class="line">&#123;</span><br><span class="line"> 8048355:       55                      push   %ebp</span><br><span class="line"> 8048356:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048358:       53                      push   %ebx</span><br><span class="line"> 8048359:       83 ec 04                sub    $0x4,%esp</span><br><span class="line"> 804835c:       8b 5d 08                mov    0x8(%ebp),%ebx</span><br><span class="line">        return n == 0 ? a[0] : MAX(a[n], max(n-1));</span><br><span class="line"> 804835f:       85 db                   test   %ebx,%ebx</span><br><span class="line"> 8048361:       75 07                   jne    804836a &lt;max+0x15&gt;</span><br><span class="line"> 8048363:       a1 a0 95 04 08          mov    0x80495a0,%eax</span><br><span class="line"> 8048368:       eb 18                   jmp    8048382 &lt;max+0x2d&gt;</span><br><span class="line"> 804836a:       8d 43 ff                lea    -0x1(%ebx),%eax</span><br><span class="line"> 804836d:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048370:       e8 e0 ff ff ff          call   8048355 &lt;max&gt;</span><br><span class="line">inline int MAX(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line"> 8048375:       8b 14 9d a0 95 04 08    mov    0x80495a0(,%ebx,4),%edx</span><br><span class="line"> 804837c:       39 d0                   cmp    %edx,%eax</span><br><span class="line"> 804837e:       7d 02                   jge    8048382 &lt;max+0x2d&gt;</span><br><span class="line"> 8048380:       89 d0                   mov    %edx,%eax</span><br><span class="line">int a[] = &#123; 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 &#125;;</span><br><span class="line"></span><br><span class="line">int max(int n)</span><br><span class="line">&#123;</span><br><span class="line">        return n == 0 ? a[0] : MAX(a[n], max(n-1));</span><br><span class="line">&#125;</span><br><span class="line"> 8048382:       83 c4 04                add    $0x4,%esp</span><br><span class="line"> 8048385:       5b                      pop    %ebx</span><br><span class="line"> 8048386:       5d                      pop    %ebp</span><br><span class="line"> 8048387:       c3                      ret    </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，并没有<code>call</code>指令调用<code>MAX</code>函数，<code>MAX</code>函数的指令是内联在<code>max</code>函数中的，由于源代码和指令的次序无法对应，<code>max</code>和<code>MAX</code>函数的源代码也交错在一起显示。</p>
<h3 id="运算符和可变参数">#,##运算符和可变参数</h3>
<p>在函数式宏定义中，<code>#</code>运算符用于创建字符串，<code>#</code>运算符后面应该跟一个形参（中间可以有空格或<code>Tab</code>），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) # s</span></span><br><span class="line">STR(hello 	world)</span><br></pre></td></tr></table></figure>
<p>用<code>cpp</code>命令预处理之后是<code>"hello␣world"</code>，自动用<code>"</code>号把实参括起来成为一个字符串，并且实参中的连续多个空白字符被替换成一个空格。</p>
<p>再比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) #s</span></span><br><span class="line"><span class="built_in">fputs</span>(STR(<span class="built_in">strncmp</span>(<span class="string">&quot;ab\&quot;c\0d&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&#x27;\4&quot;&#x27;</span>)</span><br><span class="line">    == <span class="number">0</span>) STR(: @\n), s);</span><br></pre></td></tr></table></figure>
<p>预处理之后是<code>fputs("strncmp(\"ab\\\"c\\0d\", \"abc\", '\\4\"') == 0" ": @\n", s);</code>，注意如果实参中包含字符常量或字符串，则宏展开之后字符串的界定符<code>"</code>要替换成<code>\"</code>，字符常量或字符串中的<code>\</code>和<code>"</code>字符要替换成<code>\\</code>和<code>\"</code>。</p>
<p>在宏定义中可以用<code>##</code>运算符把前后两个预处理Token连接成一个预处理Token，和<code>#</code>运算符不同，<code>##</code>运算符不仅限于函数式宏定义，变量式宏定义也可以用。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(a, b) a##b</span></span><br><span class="line">CONCAT(con, cat)</span><br></pre></td></tr></table></figure>
<p>预处理之后是<code>concat</code>。再比如，要定义一个宏展开成两个<code>#</code>号，可以这样定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_HASH # ## #</span></span><br></pre></td></tr></table></figure>
<p>中间的<code>##</code>是运算符，宏展开时前后两个<code>#</code>号被这个运算符连接在一起。注意中间的两个空格是不可少的，如果写成<code>####</code>，会被划分成<code>##</code>和<code>##</code>两个Token，而根据定义<code>##</code>运算符用于连接前后两个预处理Token，不能出现在宏定义的开头或末尾，所以会报错。</p>
<p>我们知道<code>printf</code>函数带有可变参数，函数式宏定义也可以带可变参数，同样是在参数列表中用<code>...</code>表示可变参数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> showlist(...) printf(#__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> report(test, ...) ((test)?printf(#test):\</span></span><br><span class="line"><span class="meta">    printf(__VA_ARGS__))</span></span><br><span class="line">showlist(The first, second, and third items.);</span><br><span class="line">report(x&gt;y, <span class="string">&quot;x is %d but y is %d&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<p>预处理之后变成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The first, second, and third items.&quot;</span>);</span><br><span class="line">((x&gt;y)?<span class="built_in">printf</span>(<span class="string">&quot;x&gt;y&quot;</span>): <span class="built_in">printf</span>(<span class="string">&quot;x is %d but y is %d&quot;</span>, x, y));</span><br></pre></td></tr></table></figure>
<p>在宏定义中，可变参数的部分用<code>__VA_ARGS__</code>表示，实参中对应<code>...</code>的几个参数可以看成一个参数替换到宏定义中<code>__VA_ARGS__</code>所在的地方。</p>
<p>调用函数式宏定义允许传空参数，这一点和函数调用不同，通过下面几个例子理解空参数的用法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO() foo</span></span><br><span class="line">FOO()</span><br></pre></td></tr></table></figure>
<p>预处理之后变成<code>foo</code>。<code>FOO</code>在定义时不带参数，在调用时也不允许传参数给它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(a) foo##a</span></span><br><span class="line">FOO(bar)</span><br><span class="line">FOO()</span><br></pre></td></tr></table></figure>
<p>预处理之后变成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<p><code>FOO</code>在定义时带一个参数，在调用时必须传一个参数给它，如果不传参数则表示传了一个空参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(a, b, c) a##b##c</span></span><br><span class="line">FOO(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">FOO(<span class="number">1</span>,<span class="number">2</span>,)</span><br><span class="line">FOO(<span class="number">1</span>,,<span class="number">3</span>)</span><br><span class="line">FOO(,,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>预处理之后变成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><code>FOO</code>在定义时带三个参数，在调用时也必须传三个参数给它，空参数的位置可以空着，但必须给够三个参数，<code>FOO(1,2)</code>这样的调用是错误的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOO(a, ...) a##__VA_ARGS__</span></span><br><span class="line">FOO(<span class="number">1</span>)</span><br><span class="line">FOO(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,)</span><br></pre></td></tr></table></figure>
<p>预处理之后变成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12,3,</span><br></pre></td></tr></table></figure>
<p><code>FOO(1)</code>这个调用相当于可变参数部分传了一个空参数，<code>FOO(1,2,3,)</code>这个调用相当于可变参数部分传了三个参数，第三个是空参数。</p>
<p>gcc有一种扩展语法，如果<code>##</code>运算符用在<code>__VA_ARGS__</code>前面，除了起连接作用之外还有特殊的含义，例如内核代码net/netfilter/nf_conntrack_proto_sctp.c中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUGP(format, ...) printk(format, ## __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p><code>printk</code>这个内核函数相当于<code>printf</code>，也带有格式化字符串和可变参数，由于内核不能调用<code>libc</code>的函数，所以另外实现了一个打印函数。这个函数式宏定义可以这样调用：<code>DEBUGP("info no. %d", 1)</code>。也可以这样调用：<code>DEBUGP("info")</code>。后者相当于可变参数部分传了一个空参数，但展开后并不是<code>printk("info",)</code>，而是<code>printk("info")</code>，当<code>__VA_ARGS</code>是空参数时，<code>##</code>运算符把它前面的<code>,</code>号“吃”掉了。</p>
<h3 id="宏展开的步骤">宏展开的步骤</h3>
<p>以上举的宏展开的例子都是最简单的，有些宏展开的过程要做多次替换，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sh(x) printf(<span class="string">&quot;n&quot;</span> #x <span class="string">&quot;=%d, or %d\n&quot;</span>,n##x,alt[x])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sub_z  26</span></span><br><span class="line">sh(sub_z)</span><br></pre></td></tr></table></figure>
<p><code>sh(sub_z)</code>要用<code>sh(x)</code>这个宏定义来展开，形参<code>x</code>对应的实参是<code>sub_z</code>，替换过程如下：</p>
<p><code>#x</code>要替换成<code>"sub_z"</code>。</p>
<p><code>n##x</code>要替换成<code>nsub_z</code>。</p>
<p>除了带<code>#</code>和<code>##</code>运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该先把<code>sub_z</code>展开成26再替换到<code>alt[x]</code>中<code>x</code>的位置。</p>
<p>现在展开成了<code>printf("n" "sub_z" "=%d, or %d\n",nsub_z,alt[26])</code>，所有参数都替换完了，这时编译器会再扫描一遍，再找出可以展开的宏定义来展开，假设<code>nsub_z</code>或<code>alt</code>是变量式宏定义，这时会进一步展开。</p>
<p>再举一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> x 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f(a) f(x * (a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> g f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t(a) a</span></span><br><span class="line"></span><br><span class="line">t(t(g)(<span class="number">0</span>) + t)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>展开的步骤是：</p>
<p>先把<code>g</code>展开成<code>f</code>再替换到<code>#define t(a) a</code>中，得到<code>t(f(0) + t)(1);</code>。</p>
<p>根据<code>#define f(a) f(x * (a))</code>，得到<code>t(f(x * (0)) + t)(1);</code>。</p>
<p>把<code>x</code>替换成2，得到<code>t(f(2 * (0)) + t)(1);</code>。注意，一开始定义<code>x</code>为3，但是后来用<code>#undef x</code>取消了<code>x</code>的定义，又重新定义<code>x</code>为2。当处理到<code>t(t(g)(0) + t)(1);</code>这一行代码时<code>x</code>已经定义成2了，所以用2来替换。还要注意一点，现在得到的<code>t(f(2 * (0)) + t)(1);</code>中仍然有<code>f</code>，但不能再次根据<code>#define f(a) f(x * (a))</code>展开了，<code>f(2 * (0))</code>就是由展开<code>f(0)</code>得到的，这里面再遇到<code>f</code>就不展开了，这样规定可以避免无穷展开（类似于无穷递归），因此我们可以放心地使用递归定义，例如<code>#define a a[0]</code>，<code>#define a a.member</code>等。</p>
<p>根据<code>#define t(a) a</code>，最终展开成<code>f(2 * (0)) + t(1);</code>。这时不能再展开<code>t(1)</code>了，因为这里的<code>t</code>就是由展开<code>t(f(2 * (0)) + t)</code>得到的，所以不能再展开了。</p>
<h2 id="条件预处理指示">条件预处理指示</h2>
<p>我们在第 2.2 节 “头文件”中见过Header Guard的用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILENAME</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILENAME</span></span><br><span class="line"><span class="comment">/* body of header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>条件预处理指示也常用于源代码的配置管理，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> MACHINE == 68000</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> MACHINE == 8086</span></span><br><span class="line">    <span class="type">long</span> x;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>    <span class="comment">/* all others */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> UNKNOWN TARGET MACHINE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>假设这段程序是为多种平台编写的，在68000平台上需要定义<code>x</code>为<code>int</code>型，在8086平台上需要定义<code>x</code>为<code>long</code>型，对其它平台暂不提供支持，就可以用条件预处理指示来写。如果在预处理这段代码之前，<code>MACHINE</code>被定义为68000，则包含<code>intx;</code>这段代码；否则如果<code>MACHINE</code>被定义为8086，则包含<code>long x;</code>这段代码；否则（<code>MACHINE</code>没有定义，或者定义为其它值），包含<code>#error UNKNOWN TARGET MACHINE</code>这段代码，编译器遇到这个预处理指示就报错退出，错误信息就是UNKNOWN
TARGET MACHINE。</p>
<p>如果要为8086平台编译这段代码，有几种可选的办法：</p>
<p>1、手动编辑代码，在前面添一行<code>#define MACHINE 8086</code>。这样做的缺点是难以管理，如果这个项目中有很多源文件都需要定义<code>MACHINE</code>，每次要为8086平台编译就得把这些定义全部改成8086，每次要为68000平台编译就得把这些定义全部改成68000。</p>
<p>2、在所有需要配置的源文件开头包含一个头文件，在头文件中定义<code>#define MACHINE 8086</code>，这样只需要改一个头文件就可以影响所有包含它的源文件。通常这个头文件由配置工具生成，比如在Linux内核源代码的目录下运行make
menuconfig命令可以出来一个配置菜单，在其中配置的选项会自动转换成头文件include/linux/autoconf.h中的宏定义。</p>
<p>举一个具体的例子，在内核配置菜单中用回车键和方向键进入Device Drivers
—&gt; Network device support，然后用空格键选中Network device
support（菜单项左边的[
]括号内会出现一个*号），然后保存退出，会生成一个名为.config的隐藏文件，其内容类似于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Network device support</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">CONFIG_NETDEVICES=y</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_DUMMY is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_BONDING is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_EQUALIZER is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_TUN is not <span class="built_in">set</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后运行<code>make</code>命令编译内核，这时根据<code>.config</code>文件生成头文件<code>include/linux/autoconf.h</code>，其内容类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Network device support</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_NETDEVICES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CONFIG_DUMMY</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CONFIG_BONDING</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CONFIG_EQUALIZER</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CONFIG_TUN</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的代码用<code>#undef</code>确保取消一些宏的定义，如果先前没有定义过<code>CONFIG_DUMMY</code>，用<code>#undef CONFIG_DUMMY</code>取消它的定义没有任何作用，也不算错。</p>
<p>include/linux/autoconf.h被另一个头文件include/linux/config.h所包含，通常内核代码包含后一个头文件，例如net/core/sock.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/config.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">sock_setsockopt</span><span class="params">(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">                    <span class="type">char</span> __user *optval, <span class="type">int</span> optlen)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETDEVICES</span></span><br><span class="line">                <span class="keyword">case</span> SO_BINDTODEVICE:</span><br><span class="line">                &#123;</span><br><span class="line">			...</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再比如drivers/isdn/i4l/isdn_common.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/config.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">isdn_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file, uint cmd, ulong arg)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETDEVICES</span></span><br><span class="line">                        <span class="keyword">case</span> IIOCNETGPN:</span><br><span class="line">                                <span class="comment">/* Get peer phone number of a connected</span></span><br><span class="line"><span class="comment">                                 * isdn network interface */</span></span><br><span class="line">                                <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (copy_from_user(&amp;phone, argp, <span class="keyword">sizeof</span>(phone)))</span><br><span class="line">                                                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                                        <span class="keyword">return</span> isdn_net_getpeer(&amp;phone, argp);</span><br><span class="line">                                &#125; <span class="keyword">else</span></span><br><span class="line">                                        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETDEVICES</span></span><br><span class="line">                        <span class="keyword">case</span> IIOCNETAIF:</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>                          <span class="comment">/* CONFIG_NETDEVICES */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样，在配置菜单中所做的配置通过条件预处理最终决定了哪些代码被编译到内核中。<code>#ifdef</code>或<code>#if</code>可以嵌套使用，但预处理指示通常都顶头写不缩进，为了区分嵌套的层次，可以像上面的代码中最后一行那样，在<code>#endif</code>处用注释写清楚它结束的是哪个<code>#if</code>或<code>#ifdef</code>。</p>
<p>3、要定义一个宏不一定非得在代码中用<code>#define</code>定义，早在第 6
节
“折半查找”我们就见过用gcc的<code>-D</code>选项定义一个宏<code>NDEBUG</code>。对于上面的例子，我们需要给<code>MACHINE</code>定义一个值，可以写成类似这样的命令：<code>gcc -c -DMACHINE=8086 main.c</code>。这种办法需要给每个编译命令都加上适当的选项，和第2种方法相比似乎也很麻烦，第2种方法在头文件中只写一次宏定义就可以在很多源文件中生效，第3种方法能不能做到“只写一次到处生效”呢？等以后学习了Makefile就有办法了。</p>
<p>最后通过下面的例子说一下<code>#if</code>后面的表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined x || y || VERSION &lt; 3</span></span><br></pre></td></tr></table></figure>
<p>首先处理<code>defined</code>运算符，<code>defined</code>运算符一般用作表达式中的一部分，如果单独使用，<code>#if defined x</code>相当于<code>#ifdef x</code>，而<code>#if !defined x</code>相当于<code>#ifndef x</code>。在这个例子中，如果<code>x</code>这个宏有定义，则把<code>defined x</code>替换为1，否则替换为0，因此变成<code>#if 0 || y || VERSION &lt; 3</code>。</p>
<p>然后把有定义的宏展开，变成<code>#if 0 || y || 2 &lt; 3</code>。</p>
<p>把没有定义的宏替换成0，变成<code>#if 0 || 0 || 2 &lt; 3</code>，注意，即使前面定义了一个变量名是<code>y</code>，在这一步也还是替换成0，因为<code>#if</code>的表达式必须在编译时求值，其中包含的名字只能是宏定义。</p>
<p>把得到的表达式<code>0 || 0 || 2 &lt; 3</code>像C表达式一样求值，求值的结果是<code>#if 1</code>，因此条件成立。</p>
<h2 id="其他预处理特性">其他预处理特性</h2>
<p><code>#pragma</code>预处理指示供编译器实现一些非标准的特性，C标准没有规定<code>#pragma</code>后面应该写什么以及起什么作用，由编译器自己规定。有的编译器用<code>#pragma</code>定义一些特殊功能寄存器名，有的编译器用<code>#pragma</code>定位链接地址，本书不做深入讨论。如果编译器在代码中碰到不认识的<code>#pragma</code>指示则忽略它，例如gcc的<code>#pragma</code>指示都是<code>#pragma GCC ...</code>这种形式，用别的编译器编译则忽略这些指示。</p>
<p>C标准规定了几个特殊的宏，在不同的地方使用可以自动展开成不同的值，常用的有<code>__FILE__</code>和<code>__LINE__</code>，<code>__FILE__</code>展开为当前源文件的文件名，是一个字符串，<code>__LINE__</code>展开为当前代码行的行号，是一个整数。这两个宏在源代码中不同的位置使用会自动取不同的值，显然不是用<code>#define</code>能定义得出来的，它们是编译器内建的特殊的宏。在打印调试信息时打印这两个宏可以给开发者非常有用的提示，例如在第
6 节
“折半查找”我们看到<code>assert</code>函数打印的错误信息就有<code>__FILE__</code>和<code>__LINE__</code>的值。现在我们自己实现这个<code>assert</code>函数，以理解它的原理。这个实现出自[Standard
C Library]：</p>
<p>例 assert.h的一种实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* assert.h standard header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> assert   <span class="comment">/* remove existing definition */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(test)    ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>       <span class="comment">/* NDEBUG not defined */</span></span></span><br><span class="line">    <span class="type">void</span> _Assert(<span class="type">char</span> *);</span><br><span class="line">    <span class="comment">/* macros */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _STR(x) _VAL(x)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _VAL(x) #x</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> assert(test)    ((test) ? (void)0 \</span></span><br><span class="line"><span class="meta">        : _Assert(__FILE__ <span class="string">&quot;:&quot;</span> _STR(__LINE__) <span class="string">&quot; &quot;</span> #test))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>通过这个例子可以全面复习本章所讲的知识。C标准规定<code>assert</code>应该实现为宏定义而不是一个真正的函数，并且<code>assert(test)</code>这个表达式的值应该是<code>void</code>类型的。首先用<code>#undef assert</code>确保取消前面对<code>assert</code>的定义，然后分两种情况：如果定义了<code>NDEBUG</code>，那么<code>assert(test)</code>直接定义成一个<code>void</code>类型的值，什么也不做；如果没有定义<code>NDEBUG</code>，则要判断测试条件<code>test</code>是否成立，如果条件成立就什么也不做，如果不成立则调用<code>_Assert</code>函数。假设在<code>main.c</code>文件的第33行调用<code>assert(is_sorted())</code>，那么<code>__FILE__</code>是字符串<code>"main.c"</code>，<code>__LINE__</code>是整数33，<code>#test</code>是字符串<code>"is_sorted()"</code>。注意<code>_STR(__LINE__)</code>的展开过程：首先展开成<code>_VAL(33)</code>，然后进一步展开成字符串<code>"33"</code>。这样，最后<code>_Assert</code>调用的形式是<code>_Assert("main.c" ":" "33" " " "is_sorted()")</code>，传给<code>_Assert</code>函数的字符串是<code>"main.c:33 is_sorted()"</code>。<code>_Assert</code>函数是我们自己定义的，在另一个源文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* xassert.c _Assert function */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Assert(<span class="type">char</span> *mesg)</span><br><span class="line">&#123;       <span class="comment">/* print assertion message and abort */</span></span><br><span class="line">    <span class="built_in">fputs</span>(mesg, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot; -- assertion failed\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在头文件<code>assert.h</code>中自己定义的内部使用的标识符都以<code>_</code>线开头，例如<code>_STR</code>，<code>_VAL</code>，<code>_Assert</code>，因为我们在模拟C标准库的实现，在第
3 节
“变量”讲过，以_线开头的标识符通常由编译器和C语言库使用，在/usr/include下的头文件中你可以看到大量_线开头的标识符。另外一个问题，为什么我们不直接在<code>assert</code>的宏定义中调用<code>fputs</code>和<code>abort</code>呢？因为调用这两个函数需要包含<code>stdio.h</code>和<code>stdlib.h</code>，C标准库的头文件应该是相互独立的，一个程序只要包含<code>assert.h</code>就应该能使用<code>assert</code>，而不应该再依赖于别的头文件。<code>_Assert</code>中的<code>fputs</code>向标准错误输出打印错误信息，<code>abort</code>异常终止当前进程，这些函数以后再详细讨论。</p>
<p>现在测试一下我们的<code>assert</code>实现，把<code>assert.h</code>和<code>xassert.c</code>和测试代码<code>main.c</code>放在同一个目录下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;assert.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(<span class="number">2</span>&gt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>#include "assert.h"</code>要用<code>"</code>引号而不要用<code>&lt;&gt;</code>括号，以保证包含的是我们自己写的<code>assert.h</code>而非C标准库的头文件。然后编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c xassert.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">main.c:6 2&gt;3 -- assertion failed</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>
<p>在打印调试信息时除了文件名和行号之外还可以打印出当前函数名，C99引入一个特殊的标识符<code>__func__</code>支持这一功能。这个标识符应该是一个变量名而不是宏定义，不属于预处理的范畴，但它的作用和<code>__FILE__</code>、<code>__LINE__</code>类似，所以放在一起讲。例如：</p>
<p>例 特殊标识符<code>__func__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    myfunc();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">myfunc</span><br><span class="line">main</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:Makefile基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:50" itemprop="dateModified" datetime="2025-08-08T19:53:50+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本规则">基本规则</h2>
<p>除了Hello
World这种极简单的程序之外，一般的程序都是由多个源文件编译链接而成的，这些源文件的处理步骤通常用Makefile来管理。Makefile起什么作用呢？我们先看一个例子，这个例子由例
12.3 “用深度优先搜索解迷宫问题”改写而成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">predecessor</span>[<span class="title">MAX_ROW</span>][<span class="title">MAX_COL</span>] =</span> &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="keyword">struct</span> point pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    predecessor[row][col] = pre;</span><br><span class="line">    push(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    push(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = pop();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col, p);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col, p);</span><br><span class="line">        print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (predecessor[p.row][p.col].row != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = predecessor[p.row][p.col];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把堆栈和迷宫的代码分别转移到模块<code>stack.c</code>和<code>maze.c</code>中，<code>main.c</code>包含它们提供的头文件<code>stack.h</code>和<code>maze.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col; &#125; <span class="type">item_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>main.h</code>中定义了一个类型和两个常量，<code>main.c</code>、<code>stack.c</code>和<code>maze.c</code>都要用到这些定义，都要包含这个头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stack.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">item_t</span> <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">item_t</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">item_t</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* stack.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span> <span class="comment">/* provides definition for item_t */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">item_t</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">item_t</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>例 12.3
“用深度优先搜索解迷宫问题”中的堆栈规定死了只能放<code>char</code>型数据，现在我们做进一步抽象，堆栈中放<code>item_t</code>类型的数据，<code>item_t</code>可以定义为任意类型，只要它能够通过函数的参数和返回值传递并且支持赋值操作就行。这也是一种避免硬编码的策略，<code>stack.c</code>中多次使用<code>item_t</code>类型，要改变它的定义只需改变<code>main.h</code>中的一行代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maze.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* maze.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAZE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAZE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span> <span class="comment">/* provides defintion for MAX_ROW and MAX_COL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> maze[MAX_ROW][MAX_COL];</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>maze.c</code>中定义了一个<code>maze</code>数组和一个<code>print_maze</code>函数，需要在头文件<code>maze.h</code>中声明，以便提供给<code>main.c</code>使用，注意<code>print_maze</code>的声明可以不加<code>extern</code>，而<code>maze</code>的声明必须加<code>extern</code>。</p>
<p>这些源文件可以这样编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.c stack.c maze.c -o main</span></span><br></pre></td></tr></table></figure>
<p>但这不是个好办法，如果编译之后又对<code>maze.c</code>做了修改，又要把所有源文件编译一遍，即使<code>main.c</code>、<code>stack.c</code>和那些头文件都没有修改也要跟着重新编译。一个大型的软件项目往往由上千个源文件组成，全部编译一遍需要几个小时，只改一个源文件就要求全部重新编译肯定是不合理的。</p>
<p>这样编译也许更好一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c main.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c stack.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c maze.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.o stack.o maze.o -o main</span></span><br></pre></td></tr></table></figure>
<p>如果编译之后又对<code>maze.c</code>做了修改，要重新编译只需要做两步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c maze.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.o stack.o maze.o -o main</span></span><br></pre></td></tr></table></figure>
<p>这样又有一个问题，每次编译敲的命令都不一样，很容易出错，比如我修改了三个源文件，可能有一个忘了重新编译，结果编译完了修改没生效，运行时出了Bug还满世界找原因呢。更复杂的问题是，假如我改了<code>main.h</code>怎么办？所有包含<code>main.h</code>的源文件都需要重新编译，我得挨个找哪些源文件包含了<code>main.h</code>，有的还很不明显，例如<code>stack.c</code>包含了<code>stack.h</code>，而后者包含了<code>main.h</code>。可见手动处理这些问题非常容易出错，那有没有自动的解决办法呢？有，就是写一个Makefile文件和源代码放在同一个目录下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">stack.o: stack.c stack.h main.h</span><br><span class="line">    gcc -c stack.c</span><br><span class="line"></span><br><span class="line">maze.o: maze.c maze.h main.h</span><br><span class="line">    gcc -c maze.c</span><br></pre></td></tr></table></figure>
<p>然后在这个目录下运行<code>make</code>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c stack.c</span><br><span class="line">gcc -c maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>make</code>命令会自动读取当前目录下的Makefile文件[33]，完成相应的编译步骤。Makefile由一组规则（Rule）组成，每条规则的格式是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ... </span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>main</code>是这条规则的目标（Target），<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>是这条规则的条件（Prerequisite）。目标和条件之间的关系是：欲更新目标，必须首先更新它的所有条件；所有条件中只要有一个条件被更新了，目标也必须随之被更新。所谓“更新”就是执行一遍规则中的命令列表，命令列表中的每条命令必须以一个<code>Tab</code>开头，注意不能是空格，Makefile的格式不像C语言的缩进那么随意，对于Makefile中的每个以<code>Tab</code>开头的命令，<code>make</code>会创建一个Shell进程去执行它。</p>
<p>对于上面这个例子，<code>make</code>执行如下步骤：</p>
<p>尝试更新Makefile中第一条规则的目标<code>main</code>，第一条规则的目标称为缺省目标，只要缺省目标更新了就算完成任务了，其它工作都是为这个目的而做的。由于我们是第一次编译，<code>main</code>文件还没生成，显然需要更新，但规则说必须先更新了<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个条件，然后才能更新<code>main</code>。</p>
<p>所以<code>make</code>会进一步查找以这三个条件为目标的规则，这些目标文件也没有生成，也需要更新，所以执行相应的命令（<code>gcc -c main.c</code>、<code>gcc -c stack.c</code>和<code>gcc -c maze.c</code>）更新它们。</p>
<p>最后执行<code>gcc main.o stack.o maze.o -o main</code>更新<code>main</code>。</p>
<p>如果没有做任何改动，再次运行<code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: `main&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示缺省目标已经是最新的了，不需要执行任何命令更新它。再做个实验，如果修改了<code>maze.h</code>（比如加个无关痛痒的空格）再运行<code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>make</code>会自动选择那些受影响的源文件重新编译，不受影响的源文件则不重新编译，这是怎么做到的呢？</p>
<p><code>make</code>仍然尝试更新缺省目标，首先检查目标<code>main</code>是否需要更新，这就要检查三个条件<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>是否需要更新。</p>
<p><code>make</code>会进一步查找以这三个条件为目标的规则，然后发现<code>main.o</code>和<code>maze.o</code>需要更新，因为它们都有一个条件是<code>maze.h</code>，而这个文件的修改时间比<code>main.o</code>和<code>maze.o</code>晚，所以执行相应的命令更新<code>main.o</code>和<code>maze.o</code>。</p>
<p>既然<code>main</code>的三个条件中有两个被更新过了，那么<code>main</code>也需要更新，所以执行命令<code>gcc main.o stack.o maze.o -o main</code>更新<code>main</code>。</p>
<p>现在总结一下Makefile的规则，请读者结合上面的例子理解。如果一条规则的目标属于以下情况之一，就称为需要更新：</p>
<p>目标没有生成。</p>
<p>某个条件需要更新。</p>
<p>某个条件的修改时间比目标晚。</p>
<p>在一条规则被执行之前，规则的条件可能处于以下三种状态之一：</p>
<p>需要更新。能够找到以该条件为目标的规则，并且该规则中目标需要更新。</p>
<p>不需要更新。能够找到以该条件为目标的规则，但是该规则中目标不需要更新；或者不能找到以该条件为目标的规则，并且该条件已经生成。</p>
<p>错误。不能找到以该条件为目标的规则，并且该条件没有生成。</p>
<p>执行一条规则A的步骤如下：</p>
<p>检查它的每个条件P：</p>
<p>如果P需要更新，就执行以P为目标的规则B。之后，无论是否生成文件P，都认为P已被更新。</p>
<p>如果找不到规则B，并且文件P已存在，表示P不需要更新。</p>
<p>如果找不到规则B，并且文件P不存在，则报错退出。</p>
<p>在检查完规则A的所有条件后，检查它的目标T，如果属于以下情况之一，就执行它的命令列表：</p>
<p>文件T不存在。</p>
<p>文件T存在，但是某个条件的修改时间比它晚。</p>
<p>某个条件P已被更新（并不一定生成文件P）。</p>
<p>通常Makefile都会有一个<code>clean</code>规则，用于清除编译过程中产生的二进制文件，保留源文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    @echo &quot;cleanning project&quot;</span><br><span class="line">    -rm main *.o</span><br><span class="line">    @echo &quot;clean completed&quot;</span><br></pre></td></tr></table></figure>
<p>把这条规则添加到我们的Makefile末尾，然后执行这条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span> </span><br><span class="line">cleanning project</span><br><span class="line">rm main *.o</span><br><span class="line">clean completed</span><br></pre></td></tr></table></figure>
<p>如果在<code>make</code>的命令行中指定一个目标（例如<code>clean</code>），则更新这个目标，如果不指定目标则更新Makefile中第一条规则的目标（缺省目标）。</p>
<p>和前面介绍的规则不同，<code>clean</code>目标不依赖于任何条件，并且执行它的命令列表不会生成<code>clean</code>这个文件，刚才说过，只要执行了命令列表就算更新了目标，即使目标并没有生成也算。在这个例子还演示了命令前面加<code>@</code>和<code>-</code>字符的效果：如果<code>make</code>执行的命令前面加了<code>@</code>字符，则不显示命令本身而只显示它的结果；通常<code>make</code>执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了<code>-</code>号，即使这条命令出错，<code>make</code>也会继续执行后续命令。通常<code>rm</code>命令和<code>mkdir</code>命令前面要加<code>-</code>号，因为<code>rm</code>要删除的文件可能不存在，<code>mkdir</code>要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。例如上面已经执行过一遍<code>make clean</code>，再执行一遍就没有文件可删了，这时<code>rm</code>会报错，但<code>make</code>忽略这一错误，继续执行后面的<code>echo</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span> </span><br><span class="line">cleanning project</span><br><span class="line">rm main *.o</span><br><span class="line">rm: cannot remove `main&#x27;: No such file or directory</span><br><span class="line">rm: cannot remove `*.o&#x27;: No such file or directory</span><br><span class="line">make: [clean] Error 1 (ignored)</span><br><span class="line">clean completed</span><br></pre></td></tr></table></figure>
<p>读者可以把命令前面的<code>@</code>和<code>-</code>去掉再试试，对比一下结果有何不同。这里还有一个问题，如果当前目录下存在一个文件叫<code>clean</code>会怎么样呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br><span class="line">make: `clean&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p>如果存在<code>clean</code>这个文件，<code>clean</code>目标又不依赖于任何条件，<code>make</code>就认为它不需要更新了。而我们希望把<code>clean</code>当作一个特殊的名字使用，不管它存在不存在都要更新，可以添一条特殊规则，把<code>clean</code>声明为一个伪目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这条规则没有命令列表。类似<code>.PHONY</code>这种<code>make</code>内建的特殊目标还有很多，各有不同的用途，详见[GNUmake]。在C语言中要求变量和函数先声明后使用，而Makefile不太一样，这条规则写在<code>clean</code>:规则的后面也行，也能起到声明<code>clean</code>是伪目标的作用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    @echo &quot;cleanning project&quot;</span><br><span class="line">    -rm main *.o</span><br><span class="line">    @echo &quot;clean completed&quot;</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>当然写在前面也行。gcc处理一个C程序分为预处理和编译两个阶段，类似地，<code>make</code>处理Makefile的过程也分为两个阶段：</p>
<p>首先从前到后读取所有规则，建立起一个完整的依赖关系图，例如：</p>
<figure>
<img src="C:\blog\Blog\images\C\make.graph.png"
alt="Makefile的依赖关系图" />
<figcaption aria-hidden="true">Makefile的依赖关系图</figcaption>
</figure>
<p>然后从缺省目标或者命令行指定的目标开始，根据依赖关系图选择适当的规则执行，执行Makefile中的规则和执行C代码不一样，并不是从前到后按顺序执行，也不是所有规则都要执行一遍，例如<code>make</code>缺省目标时不会更新<code>clean</code>目标，因为从上图可以看出，它跟缺省目标没有任何依赖关系。</p>
<p><code>clean</code>目标是一个约定俗成的名字，在所有软件项目的Makefile中都表示清除编译生成的文件，类似这样的约定俗成的目标名字有：</p>
<p><code>all</code>，执行主要的编译工作，通常用作缺省目标。</p>
<p><code>install</code>，执行编译后的安装工作，把可执行文件、配置文件、文档等分别拷到不同的安装目录。</p>
<p><code>clean</code>，删除编译生成的二进制文件。</p>
<p><code>distclean</code>，不仅删除编译生成的二进制文件，也删除其它生成的文件，例如配置文件和格式转换后的文档，执行<code>make distclean</code>之后应该清除所有这些文件，只留下源文件。</p>
<h2 id="隐含规则和模式规则">隐含规则和模式规则</h2>
<p>上一节的Makefile写得中规中矩，比较繁琐，是为了讲清楚基本概念，其实Makefile有很多灵活的写法，可以写得更简洁，同时减少出错的可能。本节我们来看看这样一个例子还有哪些改进的余地。</p>
<p>一个目标依赖的所有条件不一定非得写在一条规则中，也可以拆开写，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure>
<p>就相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure>
<p>如果一个目标拆开写多条规则，其中只有一条规则允许有命令列表，其它规则应该没有命令列表，否则<code>make</code>会报警告并且采用最后一条规则的命令列表。</p>
<p>这样我们的例子可以改写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">stack.o: stack.c</span><br><span class="line">    gcc -c stack.c</span><br><span class="line"></span><br><span class="line">maze.o: maze.c</span><br><span class="line">    gcc -c maze.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这不是比原来更繁琐了吗？现在可以把提出来的三条规则删去，写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这就比原来简单多了。可是现在<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个目标连编译命令都没有了，怎么编译的呢？试试看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>现在解释一下前三条编译命令是怎么来。如果一个目标在Makefile中的所有规则都没有命令列表，<code>make</code>会尝试在内建的隐含规则（Implicit
Rule）数据库中查找适用的规则。<code>make</code>的隐含规则数据库可以用<code>make -p</code>命令打印，打印出来的格式也是Makefile的格式，包括很多变量和规则，其中和我们这个例子有关的隐含规则有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">OUTPUT_OPTION = -o $@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">CC = cc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> commands to execute (built-in):</span></span><br><span class="line">        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</span><br></pre></td></tr></table></figure>
<p><code>#</code>号在Makefile中表示单行注释，就像C语言的<code>//</code>注释一样。<code>CC</code>是一个Makefile变量，用<code>CC = cc</code>定义和赋值，用<code>$(CC)</code>取它的值，其值应该是<code>cc</code>。Makefile变量像C的宏定义一样，代表一串字符，在取值的地方展开。<code>cc</code>是一个符号链接，通常指向gcc，在有些UNIX系统上可能指向另外一种C编译器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> cc</span></span><br><span class="line">/usr/bin/cc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /usr/bin/cc</span></span><br><span class="line">lrwxrwxrwx 1 root root 20 2008-07-04 05:59 /usr/bin/cc -&gt; /etc/alternatives/cc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /etc/alternatives/cc</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 2008-11-01 09:10 /etc/alternatives/cc -&gt; /usr/bin/gcc</span><br></pre></td></tr></table></figure>
<p><code>CFLAGS</code>这个变量没有定义，<code>$(CFLAGS)</code>展开是空，<code>CPPFLAGS</code>和<code>TARGET_ARCH</code>也是如此。这样<code>$(COMPILE.c)</code>展开应该是<code>cc␣空␣空␣空␣-c</code>，去掉所有的“<code>空</code>”得到<code>cc␣␣␣␣-c</code>，注意中间留下4个空格，所以<code>%.o: %.c</code>规则的命令<code>$(COMPILE.c)␣$(OUTPUT_OPTION)␣$&lt;</code>展开之后是<code>cc␣␣␣␣-c␣-o␣$@␣$&lt;</code>，和上面的编译命令已经很接近了。</p>
<p><code>$@</code>和<code>$&lt;</code>是两个特殊的变量，<code>$@</code>的取值为规则中的目标，<code>$&lt;</code>的取值为规则中的第一个条件。<code>%.o: %.c</code>是一种特殊的规则，称为模式规则（Pattern
Rule）。现在回顾一下整个过程，在我们的Makefile中以<code>main.o</code>为目标的规则都没有命令列表，所以<code>make</code>会查找隐含规则，发现隐含规则中有这样一条模式规则适用，<code>main.o</code>符合<code>%.o</code>的模式，现在<code>%</code>就代表<code>main</code>（称为<code>main.o</code>这个名字的Stem），再替换到<code>%.c</code>中就是<code>main.c</code>。所以这条模式规则相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">    cc    -c -o main.o main.c</span><br></pre></td></tr></table></figure>
<p>随后，在处理<code>stack.o</code>目标时又用到这条模式规则，这时又相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.o: stack.c</span><br><span class="line">    cc    -c -o stack.o stack.c</span><br></pre></td></tr></table></figure>
<p><code>maze.o</code>也同样处理。这三条规则可以由<code>make</code>的隐含规则推导出来，所以不必写在Makefile中。</p>
<p>先前我们写Makefile都是以目标为中心，一个目标依赖于若干条件，现在换个角度，以条件为中心，Makefile还可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o stack.o maze.o: main.h</span><br><span class="line">main.o maze.o: maze.h</span><br><span class="line">main.o stack.o: stack.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>我们知道，写规则的目的是让<code>make</code>建立依赖关系图，不管怎么写，只要把所有的依赖关系都描述清楚了就行。对于多目标的规则，<code>make</code>会拆成几条单目标的规则来处理，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target1 target2: prerequisite1 prerequisite2</span><br><span class="line">    command $&lt; -o $@</span><br></pre></td></tr></table></figure>
<p>这样一条规则相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target1: prerequisite1 prerequisite2</span><br><span class="line">    command prerequisite1 -o target1</span><br><span class="line"></span><br><span class="line">target2: prerequisite1 prerequisite2</span><br><span class="line">    command prerequisite1 -o target2</span><br></pre></td></tr></table></figure>
<p>注意两条规则的命令列表是一样的，但<code>$@</code>的取值不同。</p>
<h2 id="变量">变量</h2>
<p>这一节我们详细看看Makefile中关于变量的语法规则。先看一个简单的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = $(bar) </span><br><span class="line">bar = Huh? </span><br><span class="line"></span><br><span class="line">all: </span><br><span class="line">    @echo $(foo)</span><br></pre></td></tr></table></figure>
<p>我们执行<code>make</code>将会打出<code>Huh?</code>。当<code>make</code>读到<code>foo = $(bar)</code>时，确定<code>foo</code>的值是<code>$(bar)</code>，但并不立即展开<code>$(bar)</code>，然后读到<code>bar = Huh?</code>，确定<code>bar</code>的值是<code>Huh?</code>，然后在执行规则<code>all:</code>的命令列表时才需要展开<code>$(foo)</code>，得到<code>$(bar)</code>，再展开<code>$(bar)</code>，得到<code>Huh?</code>。因此，虽然<code>bar</code>的定义写在<code>foo</code>之后，<code>$(foo)</code>展开还是能够取到<code>$(bar)</code>的值。</p>
<p>这种特性有好处也有坏处。好处是我们可以把变量的值推迟到后面定义，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt;</span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -O -g</span><br><span class="line">CPPFLAGS = -Iinclude</span><br></pre></td></tr></table></figure>
<p>编译命令可以展开成<code>gcc -O -g -Iinclude -c main.c</code>。通常把<code>CFLAGS</code>定义成一些编译选项，例如<code>-O</code>、<code>-g</code>等，而把<code>CPPFLAGS</code>定义成一些预处理选项，例如<code>-D</code>、<code>-I</code>等。用<code>=</code>号定义变量的延迟展开特性也有坏处，就是有可能写出无穷递归的定义，例如<code>CFLAGS = $(CFLAGS) -O</code>，或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = $(B)</span><br><span class="line">B = $(A)</span><br></pre></td></tr></table></figure>
<p>当然，<code>make</code>有能力检测出这样的错误而不会陷入死循环。有时候我们希望<code>make</code>在遇到变量定义时立即展开，可以用<code>:=</code>运算符，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line"></span><br><span class="line">all: </span><br><span class="line">    @echo &quot;-$(y)-&quot;</span><br></pre></td></tr></table></figure>
<p>当<code>make</code>读到<code>y := $(x) bar</code>定义时，立即把<code>$(x)</code>展开，使变量<code>y</code>的取值是<code>foo bar</code>，如果把这两行颠倒过来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := $(x) bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>那么当<code>make</code>读到<code>y := $(x) bar</code>时，<code>x</code>还没有定义，展开为空值，所以<code>y</code>的取值是<code>␣bar</code>，注意<code>bar</code>前面有个空格。一个变量的定义从<code>=</code>后面的第一个非空白字符开始（从<code>$(x)</code>的<code>$</code>开始），包括后面的所有字符，直到注释或换行之前结束。如果要定义一个变量的值是一个空格，可以这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring := </span><br><span class="line">space := $(nullstring) # end of the line</span><br></pre></td></tr></table></figure>
<p><code>nullstring</code>的值为空，<code>space</code>的值是一个空格，后面写个注释是为了增加可读性，如果不写注释就换行，则很难看出<code>$(nullstring)</code>后面有个空格。</p>
<p>还有一个比较有用的赋值运算符是<code>?=</code>，例如<code>foo ?= $(bar)</code>的意思是：如果<code>foo</code>没有定义过，那么<code>?=</code>相当于<code>=</code>，定义<code>foo</code>的值是<code>$(bar)</code>，但不立即展开；如果先前已经定义了<code>foo</code>，则什么也不做，不会给<code>foo</code>重新赋值。</p>
<p><code>+=</code>运算符可以给变量追加值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o</span><br><span class="line">objects += $(foo)</span><br><span class="line">foo = foo.o bar.o</span><br></pre></td></tr></table></figure>
<p><code>object</code>是用<code>=</code>定义的，<code>+=</code>仍然保持<code>=</code>的特性，<code>objects</code>的值是<code>main.o $(foo)</code>（注意<code>$(foo)</code>前面自动添一个空格），但不立即展开，等到后面需要展开<code>$(objects)</code>时会展开成<code>main.o foo.o bar.o</code>。</p>
<p>再比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects := main.o</span><br><span class="line">objects += $(foo)</span><br><span class="line">foo = foo.o bar.o</span><br></pre></td></tr></table></figure>
<p><code>object</code>是用<code>:=</code>定义的，<code>+=</code>保持<code>:=</code>的特性，<code>objects</code>的值是<code>main.o $(foo)</code>，立即展开得到<code>main.o</code>
（这时<code>foo</code>还没定义），注意<code>main.o</code>后面的空格仍保留。</p>
<p>如果变量还没有定义过就直接用<code>+=</code>赋值，那么<code>+=</code>相当于<code>=</code>。</p>
<p>上一节我们用到了特殊变量<code>$@</code>和<code>$&lt;</code>，这两个变量的特点是不需要给它们赋值，在不同的上下文中它们自动取不同的值。常用的特殊变量有：</p>
<p><code>$@</code>，表示规则中的目标。</p>
<p><code>$&lt;</code>，表示规则中的第一个条件。</p>
<p><code>$?</code>，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。</p>
<p><code>$^</code>，表示规则中的所有条件，组成一个列表，以空格分隔。</p>
<p>例如前面写过的这条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>可以改写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br></pre></td></tr></table></figure>
<p>这样即使以后又往条件里添加了新的目标文件，编译命令也不需要修改，减少了出错的可能。</p>
<p><code>$?</code>变量也很有用，有时候希望只对更新过的条件进行操作，例如有一个库文件<code>libsome.a</code>依赖于几个目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libsome.a: foo.o bar.o lose.o win.o </span><br><span class="line">    ar r libsome.a $?</span><br><span class="line">    ranlib libsome.a</span><br></pre></td></tr></table></figure>
<p>这样，只有更新过的目标文件才需要重新打包到<code>libsome.a</code>中，没更新过的目标文件原本已经在<code>libsome.a</code>中了，不必重新打包。</p>
<p>在上一节我们看到<code>make</code>的隐含规则数据库中用到了很多变量，有些变量没有定义（例如<code>CFLAGS</code>），有些变量定义了缺省值（例如<code>CC</code>），我们写Makefile时可以重新定义这些变量的值，也可以在缺省值的基础上追加。以下列举一些常用的变量，请读者体会其中的规律。</p>
<p><code>AR</code> 静态库打包命令的名字，缺省值是<code>ar</code>。</p>
<p><code>ARFLAGS</code>
静态库打包命令的选项，缺省值是<code>rv</code>。</p>
<p><code>AS</code> 汇编器的名字，缺省值是<code>as</code>。</p>
<p><code>ASFLAGS</code> 汇编器的选项，没有定义。</p>
<p><code>CC</code> C编译器的名字，缺省值是<code>cc</code>。</p>
<p><code>CFLAGS</code> C编译器的选项，没有定义。</p>
<p><code>CXX</code> C++编译器的名字，缺省值是<code>g++</code>。</p>
<p><code>CXXFLAGS</code> C++编译器的选项，没有定义。</p>
<p><code>CPP</code> C预处理器的名字，缺省值是<code>$(CC) -E</code>。</p>
<p><code>CPPFLAGS</code> C预处理器的选项，没有定义。</p>
<p><code>LD</code> 链接器的名字，缺省值是<code>ld</code>。</p>
<p><code>LDFLAGS</code> 链接器的选项，没有定义。</p>
<p><code>TARGET_ARCH</code> 和目标平台相关的命令行选项，没有定义。</p>
<p><code>OUTPUT_OPTION</code>
输出的命令行选项，缺省值是<code>-o $@</code>。</p>
<p><code>LINK.o</code>
把.o文件链接在一起的命令行，缺省值是<code>$(CC) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>LINK.c</code>
把.c文件链接在一起的命令行，缺省值是<code>$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>LINK.cc</code>
把.cc文件（C++源文件）链接在一起的命令行，缺省值是<code>$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>COMPILE.c</code>
编译.c文件的命令行，缺省值是<code>$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p>
<p><code>COMPILE.cc</code>
编译.cc文件的命令行，缺省值是<code>$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p>
<p><code>RM</code> 删除命令的名字，缺省值是<code>rm -f</code>。</p>
<h2 id="自动处理头文件的依赖关系">自动处理头文件的依赖关系</h2>
<p>现在我们的Makefile写成这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">all: main</span><br><span class="line"></span><br><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>按照惯例，用<code>all</code>做缺省目标。现在还有一点比较麻烦，在写<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个目标的规则时要查看源代码，找出它们依赖于哪些头文件，这很容易出错，一是因为有的头文件包含在另一个头文件中，在写规则时很容易遗漏，二是如果以后修改源代码改变了依赖关系，很可能忘记修改Makefile的规则。为了解决这个问题，可以用gcc的<code>-M</code>选项自动生成目标文件和源文件的依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -M main.c</span></span><br><span class="line">main.o: main.c /usr/include/stdio.h /usr/include/features.h \</span><br><span class="line">  /usr/include/sys/cdefs.h /usr/include/bits/wordsize.h \</span><br><span class="line">  /usr/include/gnu/stubs.h /usr/include/gnu/stubs-32.h \</span><br><span class="line">  /usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h \</span><br><span class="line">  /usr/include/bits/types.h /usr/include/bits/typesizes.h \</span><br><span class="line">  /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line">  /usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h \</span><br><span class="line">  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h main.h \</span><br><span class="line">  stack.h maze.h</span><br></pre></td></tr></table></figure>
<p><code>-M</code>选项把<code>stdio.h</code>以及它所包含的系统头文件也找出来了，如果我们不需要输出系统头文件的依赖关系，可以用<code>-MM</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -MM *.c</span></span><br><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">maze.o: maze.c maze.h main.h</span><br><span class="line">stack.o: stack.c stack.h main.h</span><br></pre></td></tr></table></figure>
<p>接下来的问题是怎么把这些规则包含到Makefile中，GNU
make的官方手册建议这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all: main</span><br><span class="line"></span><br><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">sources = main.c stack.c maze.c</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.d: %.c</span></span><br><span class="line">    set -e; rm -f $@; \</span><br><span class="line">    $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">    sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">    rm -f $@.$$$$</span><br></pre></td></tr></table></figure>
<p><code>sources</code>变量包含我们要编译的所有.c文件，<code>$(sources:.c=.d)</code>是一个变量替换语法，把<code>sources</code>变量中每一项的.c替换成.d，所以<code>include</code>这一句相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include main.d stack.d maze.d</span><br></pre></td></tr></table></figure>
<p>类似于C语言的<code>#include</code>指示，这里的<code>include</code>表示包含三个文件<code>main.d</code>、<code>stack.d</code>和<code>maze.d</code>，这三个文件也应该符合Makefile的语法。如果现在你的工作目录是干净的，只有.c文件、.h文件和Makefile，运行<code>make</code>的结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">Makefile:13: main.d: No such file or directory</span><br><span class="line">Makefile:13: stack.d: No such file or directory</span><br><span class="line">Makefile:13: maze.d: No such file or directory</span><br><span class="line">set -e; rm -f maze.d; \</span><br><span class="line">    cc -MM  maze.c &gt; maze.d.$$; \</span><br><span class="line">    sed &#x27;s,\(maze\)\.o[ :]*,\1.o maze.d : ,g&#x27; &lt; maze.d.$$ &gt; maze.d; \</span><br><span class="line">    rm -f maze.d.$$</span><br><span class="line">set -e; rm -f stack.d; \</span><br><span class="line">    cc -MM  stack.c &gt; stack.d.$$; \</span><br><span class="line">    sed &#x27;s,\(stack\)\.o[ :]*,\1.o stack.d : ,g&#x27; &lt; stack.d.$$ &gt; stack.d; \</span><br><span class="line">    rm -f stack.d.$$</span><br><span class="line">set -e; rm -f main.d; \</span><br><span class="line">    cc -MM  main.c &gt; main.d.$$; \</span><br><span class="line">    sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.$$ &gt; main.d; \</span><br><span class="line">    rm -f main.d.$$</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>一开始找不到.d文件，所以<code>make</code>会报警告。但是<code>make</code>会把<code>include</code>的文件名也当作目标来尝试更新，而这些目标适用模式规则<code>%.d: %c</code>，所以执行它的命令列表，比如生成<code>maze.d</code>的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set -e; rm -f maze.d; \</span><br><span class="line">    cc -MM  maze.c &gt; maze.d.$$; \</span><br><span class="line">    sed &#x27;s,\(maze\)\.o[ :]*,\1.o maze.d : ,g&#x27; &lt; maze.d.$$ &gt; maze.d; \</span><br><span class="line">    rm -f maze.d.$$</span><br></pre></td></tr></table></figure>
<p>注意，虽然在Makefile中这个命令写了四行，但其实是一条命令，<code>make</code>只创建一个Shell进程执行这条命令，这条命令分为5个子命令，用<code>;</code>号隔开，并且为了美观，用续行符<code>\</code>拆成四行来写。执行步骤为：</p>
<p><code>set -e</code>命令设置当前Shell进程为这样的状态：如果它执行的任何一条命令的退出状态非零则立刻终止，不再执行后续命令。</p>
<p>把原来的<code>maze.d</code>删掉。</p>
<p>重新生成<code>maze.c</code>的依赖关系，保存成文件<code>maze.d.1234</code>（假设当前Shell进程的id是1234）。注意，在Makefile中<code>$</code>有特殊含义，如果要表示它的字面意思则需要写两个<code>$</code>，所以Makefile中的四个<code>$</code>传给Shell变成两个<code>$</code>，两个<code>$</code>在Shell中表示当前进程的id，一般用它给临时文件起名，以保证文件名唯一。</p>
<p>这个<code>sed</code>命令比较复杂，就不细讲了，主要作用是查找替换。<code>maze.d.1234</code>的内容应该是<code>maze.o: maze.c maze.h main.h</code>，经过<code>sed</code>处理之后存为<code>maze.d</code>，其内容是<code>maze.o maze.d: maze.c maze.h main.h</code>。</p>
<p>最后把临时文件<code>maze.d.1234</code>删掉。</p>
<p>不管是Makefile本身还是被它包含的文件，只要有一个文件在<code>make</code>过程中被更新了，<code>make</code>就会重新读取整个Makefile以及被它包含的所有文件，现在<code>main.d</code>、<code>stack.d</code>和<code>maze.d</code>都生成了，就可以正常包含进来了（假如这时还没有生成，<code>make</code>就要报错而不是报警告了），相当于在Makefile中添了三条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d: main.c main.h stack.h maze.h</span><br><span class="line">maze.o maze.d: maze.c maze.h main.h</span><br><span class="line">stack.o stack.d: stack.c stack.h main.h</span><br></pre></td></tr></table></figure>
<p>如果我在<code>main.c</code>中加了一行<code>#include "foo.h"</code>，那么：</p>
<p>1、<code>main.c</code>的修改日期变了，根据规则<code>main.o main.d: main.c main.h stack.h maze.h</code>要重新生成<code>main.o</code>和<code>main.d</code>。生成<code>main.o</code>的规则有两条：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> commands to execute (built-in):</span></span><br><span class="line">        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</span><br></pre></td></tr></table></figure>
<p>第一条是把规则<code>main.o main.d: main.c main.h stack.h maze.h</code>拆开写得到的，第二条是隐含规则，因此执行<code>cc</code>命令重新编译<code>main.o</code>。生成<code>main.d</code>的规则也有两条：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.d: main.c main.h stack.h maze.h</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.d: %.c</span></span><br><span class="line">    set -e; rm -f $@; \</span><br><span class="line">    $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">    sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">    rm -f $@.$$$$</span><br></pre></td></tr></table></figure>
<p>因此<code>main.d</code>的内容被更新为<code>main.o main.d: main.c main.h stack.h maze.h foo.h</code>。</p>
<p>2、由于<code>main.d</code>被Makefile包含，<code>main.d</code>被更新又导致<code>make</code>重新读取整个Makefile，把新的<code>main.d</code>包含进来，于是新的依赖关系生效了。</p>
<h2 id="常用的make命令行选项">常用的make命令行选项</h2>
<p><code>-n</code>选项只打印要执行的命令，而不会真的执行命令，这个选项有助于我们检查Makefile写得是否正确，由于Makefile不是顺序执行的，用这个选项可以先看看命令的执行顺序，确认无误了再真正执行命令。</p>
<p><code>-C</code>选项可以切换到另一个目录执行那个目录下的Makefile，比如先退到上一级目录再执行我们的Makefile（假设我们的源代码都放在testmake目录下）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -C testmake</span></span><br><span class="line">make: Entering directory `/home/akaedu/testmake&#x27;</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br><span class="line">make: Leaving directory `/home/akaedu/testmake&#x27;</span><br></pre></td></tr></table></figure>
<p>一些规模较大的项目会把不同的模块或子系统的源代码放在不同的子目录中，然后在每个子目录下都写一个该目录的Makefile，然后在一个总的Makefile中用<code>make -C</code>命令执行每个子目录下的Makefile。例如Linux内核源代码根目录下有Makefile，子目录fs、net等也有各自的Makefile，二级子目录fs/ramfs、net/ipv4等也有各自的Makefile。</p>
<p>在<code>make</code>命令行也可以用<code>=</code>或<code>:=</code>定义变量，如果这次编译我想加调试选项<code>-g</code>，但我不想每次编译都加<code>-g</code>选项，可以在命令行定义<code>CFLAGS</code>变量，而不必修改Makefile编译完了再改回来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CFLAGS=-g</span></span><br><span class="line">cc -g   -c -o main.o main.c</span><br><span class="line">cc -g   -c -o stack.o stack.c</span><br><span class="line">cc -g   -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>如果在Makefile中也定义了<code>CFLAGS</code>变量，则命令行的值覆盖Makefile中的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
