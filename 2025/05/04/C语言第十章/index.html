<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入printf，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言:gdb">
<meta property="og:url" content="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:description" content="程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入printf，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-07T09:49:37.204Z">
<meta property="article:author" content="SiyuanLei">
<meta property="article:tag" content="C">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/","path":"2025/05/04/C语言第十章/","title":"C语言:gdb"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言:gdb | SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SiyuanLei's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">单步执行和跟踪函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">断点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">观察点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%94%99%E8%AF%AF"><span class="nav-number">4.</span> <span class="nav-text">段错误</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言:gdb | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言:gdb
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 17:49:37" itemprop="dateModified" datetime="2025-08-07T17:49:37+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入<code>printf</code>，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的代码行等。掌握了gdb的用法之后，调试手段就更加丰富了。但要注意，即使调试手段丰富了，调试的基本思想仍然是“分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设”这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用而忽略了分析过程，往往会治标不治本地修正Bug，导致一个错误现象消失了但Bug仍然存在，甚至是把程序越改越错。本章通过初学者易犯的几个错误实例来讲解如何使用gdb调试程序，在每个实例后面总结一部分常用的gdb命令。</p>
<h2 id="单步执行和跟踪函数调用">单步执行和跟踪函数调用</h2>
<p>看下面的程序：</p>
<p>例 函数调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">    result[<span class="number">0</span>] = add_range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    result[<span class="number">1</span>] = add_range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>, result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_range</code>函数从<code>low</code>加到<code>high</code>，在<code>main</code>函数中首先从<code>1</code>加到<code>10</code>，把结果保存下来，然后从<code>1</code>加到<code>100</code>，再把结果保存下来，最后打印的两个结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br></pre></td></tr></table></figure>
<p>第一个结果正确[20]，第二个结果显然不正确，在小学我们就听说过高斯小时候的故事，从1加到100应该是5050。一段代码，第一次运行结果是对的，第二次运行却不对，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。在动手调试之前，读者先试试只看代码能不能看出错误原因，只要前面几章学得扎实就应该能看出来。</p>
<p>在编译时要加上<code>-g</code>选项，生成的可执行文件才能用gdb进行源码级调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g main.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">GNU gdb 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入<code>help</code>可以查看命令的类别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure>
<p>也可以进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help files</span><br><span class="line">Specifying and examining files.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">add-shared-symbol-files -- Load the symbols from shared objects in the dynamic linker&#x27;s link map</span><br><span class="line">add-symbol-file -- Load symbols from FILE</span><br><span class="line">add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file</span><br><span class="line">cd -- Set working directory to DIR for debugger and program being debugged</span><br><span class="line">core-file -- Use FILE as core dump for examining memory and registers</span><br><span class="line">directory -- Add directory DIR to beginning of search path for source files</span><br><span class="line">edit -- Edit specified file or function</span><br><span class="line">exec-file -- Use FILE as program for getting contents of pure memory</span><br><span class="line">file -- Use FILE as program to be debugged</span><br><span class="line">forward-search -- Search for regular expression (see regex(3)) from last line listed</span><br><span class="line">generate-core-file -- Save a core file with the current state of the debugged process</span><br><span class="line">list -- List specified function or line</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在试试用<code>list</code>命令从第一行开始列出源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 1</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>一次只列10行，如果要从第11行开始继续列源代码可以输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure>
<p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) （直接回车）</span><br><span class="line">11  int main(void)</span><br><span class="line">12  &#123;</span><br><span class="line">13      int result[100];</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">17      return 0;</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>gdb的很多常用命令有简写形式，例如<code>list</code>命令可以写成<code>l</code>，要列一个函数的源代码也可以用函数名做参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l add_range</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>现在退出gdb的环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>我们做一个实验，把源代码改名或移到别处再用gdb调试，这样就列不出源代码了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> main.c mian.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) l</span><br><span class="line">5	main.c: No such file or directory.</span><br><span class="line">	in main.c</span><br></pre></td></tr></table></figure>
<p>可见gcc的<code>-g</code>选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用<code>start</code>命令开始执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14		result[0] = add_range(1, 10);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb停在<code>main</code>函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句。我们可以用<code>next</code>命令（简写为<code>n</code>）控制这些语句一条一条地执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">15		result[1] = add_range(1, 100);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">16		printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br><span class="line">17		return 0;</span><br></pre></td></tr></table></figure>
<p>用<code>n</code>命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在<code>return</code>语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在<code>main</code>函数中而在<code>add_range</code>函数中，现在用<code>start</code>命令重新来过，这次用<code>step</code>命令（简写为<code>s</code>）钻进<code>add_range</code>函数中去跟踪执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line"></span><br><span class="line">Breakpoint 2 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=10) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br></pre></td></tr></table></figure>
<p>这次停在了<code>add_range</code>函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，<code>backtrace</code>命令（简写为<code>bt</code>）可以查看函数调用的栈帧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=10) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br></pre></td></tr></table></figure>
<p>可见当前的<code>add_range</code>函数是被<code>main</code>函数调用的，<code>main</code>传进来的参数是<code>low=1</code>,
<code>high=10</code>。<code>main</code>函数的栈帧编号为<code>1</code>，<code>add_range</code>的栈帧编号为<code>0</code>。现在可以用<code>info</code>命令（简写为<code>i</code>）查看<code>add_range</code>函数局部变量的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i locals</span><br><span class="line">i = 0</span><br><span class="line">sum = 0</span><br></pre></td></tr></table></figure>
<p>如果想查看<code>main</code>函数当前局部变量的值也可以做到，先用<code>frame</code>命令（简写为<code>f</code>）选择<code>1</code>号栈帧然后再查看局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br><span class="line">14	    result[0] = add_range(1, 10);</span><br><span class="line">(gdb) i locals </span><br><span class="line">result = &#123;0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>result</code>数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用<code>s</code>或<code>n</code>往下走几步，然后用<code>print</code>命令（简写为<code>p</code>）打印出变量<code>sum</code>的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 3</span></span><br></pre></td></tr></table></figure>
<p>第一次循环<code>i</code>是<code>1</code>，第二次循环<code>i</code>是<code>2</code>，加起来是<code>3</code>，没错。这里的<code>$1</code>表示gdb保存着这些中间结果，<code>$</code>后面的编号会自动增长，在命令中可以用<code>$1</code>、<code>$2</code>、<code>$3</code>等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用<code>finish</code>命令让程序一直运行到从当前函数返回为止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=10) at main.c:6</span><br><span class="line">0x080483c1 in main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">Value returned is $2 = 55</span><br></pre></td></tr></table></figure>
<p>返回值是55，当前正准备执行赋值操作，用<code>s</code>命令赋值，然后查看<code>result</code>数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480,</span> </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值55确实赋给了<code>result</code>数组的第<code>0</code>个元素。下面用<code>s</code>命令进入第二次<code>add_range</code>调用，进入之后首先查看参数和局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=100) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=100) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483db <span class="keyword">in</span> main () at main.c:15</span></span><br><span class="line">(gdb) i locals </span><br><span class="line">i = 11</span><br><span class="line">sum = 55</span><br></pre></td></tr></table></figure>
<p>由于局部变量<code>i</code>和<code>sum</code>没初始化，所以具有不确定的值，又由于两次调用是挨着的，<code>i</code>和<code>sum</code>正好取了上次调用时的值，原来这跟例
3.7
“验证局部变量存储空间的分配和释放”是一样的道理，只不过我这次举的例子设法让局部变量<code>sum</code>在第一次调用时初值为<code>0</code>了。<code>i</code>的初值不是<code>0</code>倒没关系，在<code>for</code>循环中会赋值为<code>0</code>的，但<code>sum</code>如果初值不是<code>0</code>，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出gdb修改源代码了。如果我们不想浪费这次调试机会，可以在gdb中马上把<code>sum</code>的初值改为<code>0</code>继续运行，看看这一处改了之后还有没有别的Bug：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var sum=0</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=100) at main.c:6</span><br><span class="line">0x080483db in main () at main.c:15</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">Value returned is $4 = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5050</span><br><span class="line">17      return 0;</span><br></pre></td></tr></table></figure>
<p>这样结果就对了。修改变量的值除了用<code>set</code>命令之外也可以用<code>print</code>命令，因为<code>print</code>命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用<code>print</code>命令修改变量的值或者调用函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 33</span></span><br><span class="line">(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])</span><br><span class="line">result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 13</span></span><br></pre></td></tr></table></figure>
<p>我们讲过，<code>printf</code>的返回值表示实际打印的字符数，所以<code>$6</code>的结果是<code>13</code>。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>backtrace（或bt）</td>
<td>查看各级函数调用及参数</td>
</tr>
<tr>
<td>finish</td>
<td>连续运行到当前函数返回为止，然后停下来等待命令</td>
</tr>
<tr>
<td>frame（或f） 帧编号</td>
<td>选择栈帧</td>
</tr>
<tr>
<td>info（或i） locals</td>
<td>查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td>list（或l）</td>
<td>列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td>list 行号</td>
<td>列出从第几行开始的源代码</td>
</tr>
<tr>
<td>list 函数名</td>
<td>列出某个函数的源代码</td>
</tr>
<tr>
<td>next（或n）</td>
<td>执行下一行语句</td>
</tr>
<tr>
<td>print（或p）</td>
<td>打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td>quit（或q）</td>
<td>退出gdb调试环境</td>
</tr>
<tr>
<td>set var</td>
<td>修改变量的值</td>
</tr>
<tr>
<td>start</td>
<td>开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td>step（或s）</td>
<td>执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
</tbody>
</table>
<h2 id="断点">断点</h2>
<p>看以下程序：</p>
<p>例 断点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用是：首先从键盘读入一串数字存到字符数组<code>input</code>中，然后转换成整型存到<code>sum</code>中，然后打印出来，一直这样循环下去。<code>scanf("%s", input);</code>这个调用的功能是等待用户输入一个字符串并回车，<code>scanf</code>把其中第一段非空白（非空格、<code>Tab</code>、换行）的字符串保存到<code>input</code>数组中，并自动在末尾添加<code>'\0'</code>。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是<code>"2345"</code>，则循环累加的过程是<code>(((0*10+2)*10+3)*10+4)*10+5=2345</code>。注意字符型的<code>'2'</code>要减去<code>'0'</code>的ASCII码才能转换成整数值<code>2</code>。下面编译运行程序看看有什么问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">234</span><br><span class="line">input=123234</span><br><span class="line">（Ctrl-C退出程序）</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅<code>sum</code>赋了初值，连不必赋初值的<code>i</code>都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br></pre></td></tr></table></figure>
<p>有了上一次的经验，<code>sum</code>被列为重点怀疑对象，我们可以用<code>display</code>命令使得每次停下来的时候都显示当前<code>sum</code>的值，然后继续往下走：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display sum</span><br><span class="line">1: sum = -1208103488</span><br><span class="line">(gdb) n</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 0</span><br><span class="line">(gdb) </span><br><span class="line">123</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 0</span><br></pre></td></tr></table></figure>
<p><code>undisplay</code>命令可以取消跟踪显示，变量<code>sum</code>的编号是<code>1</code>，可以用<code>undisplay 1</code>命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用<code>break</code>命令（简写为<code>b</code>）在第9行设一个断点（Breakpoint）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">5       int sum = 0, i;</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">11              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">12          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">13      &#125;</span><br><span class="line">14      return 0;</span><br><span class="line">(gdb) b 9</span><br><span class="line">Breakpoint 2 at 0x80483bc: file main.c, line 9.</span><br></pre></td></tr></table></figure>
<p><code>break</code>命令的参数也可以是函数名，表示在某个函数开头设断点。现在用<code>continue</code>命令（简写为<code>c</code>）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>然后输入新的字符串准备转换：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">234</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>问题暴露出来了，新的转换应该再次从<code>0</code>开始累加，而<code>sum</code>现在已经是<code>123</code>了，原因在于新的循环没有把<code>sum</code>归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，“断点加单步”是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用<code>printf</code>打印中间结果时也要分析应该在哪里插入<code>printf</code>，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用<code>info</code>命令可以查看已经设置的断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 3 at 0x8048411: file main.c, line 12.</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>每个断点都有一个编号，可以用编号指定删除某个断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints 2</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoints 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep n   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) enable 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>
<p>gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当<code>sum</code>不等于<code>0</code>时才中断，然后用<code>run</code>命令（简写为<code>r</code>）重新从程序开头连续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 9 if sum != 0</span><br><span class="line">Breakpoint 5 at 0x80483c3: file main.c, line 9.</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">5       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    stop only if sum != 0</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 5, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>结果是第一次执行<code>scanf</code>之前没有中断，第二次却中断了。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break（或b） 行号</td>
<td>在某一行设置断点</td>
</tr>
<tr>
<td>break 函数名</td>
<td>在某个函数开头设置断点</td>
</tr>
<tr>
<td>break … if …</td>
<td>设置条件断点</td>
</tr>
<tr>
<td>continue（或c）</td>
<td>从当前位置开始连续运行程序</td>
</tr>
<tr>
<td>delete breakpoints 断点号</td>
<td>删除断点</td>
</tr>
<tr>
<td>display 变量名</td>
<td>跟踪查看某个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td>disable breakpoints 断点号</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable 断点号</td>
<td>启用断点</td>
</tr>
<tr>
<td>info（或i） breakpoints</td>
<td>查看当前设置了哪些断点</td>
</tr>
<tr>
<td>run（或r）</td>
<td>从头开始连续运行程序</td>
</tr>
<tr>
<td>undisplay 跟踪显示号</td>
<td>取消跟踪显示</td>
</tr>
</tbody>
</table>
<h2 id="观察点">观察点</h2>
<p>接着上一节的步骤，经过调试我们知道，虽然<code>sum</code>已经赋了初值<code>0</code>，但仍需要在<code>while (1)</code>循环的开头加上<code>sum = 0;</code>：</p>
<p>例 观察点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>scanf</code>函数是非常凶险的，即使修正了这个Bug也还存在很多问题。如果输入的字符串超长了会怎么样？我们知道数组访问越界是不会检查的，所以<code>scanf</code>会写出界。现象是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">67</span><br><span class="line">input=67</span><br><span class="line">12345</span><br><span class="line">input=123407</span><br></pre></td></tr></table></figure>
<p>下面用调试器看看最后这个诡异的结果是怎么出来的[21]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p input</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;12345&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>input</code>数组只有<code>5</code>个元素，写出界的是<code>scanf</code>自动添的<code>'\0'</code>，用<code>x</code>命令看会更清楚一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x00    0x00</span><br></pre></td></tr></table></figure>
<p><code>x</code>命令打印指定存储单元的内容。<code>7b</code>是打印格式，<code>b</code>表示每个字节一组，<code>7</code>表示打印<code>7</code>组[22]，从<code>input</code>数组的第一个字节开始连续打印<code>7</code>个字节。前<code>5</code>个字节是<code>input</code>数组的存储单元，打印的正是十六进制ASCII码的<code>'1'</code>到<code>'5'</code>，第<code>6</code>个字节是写出界的<code>'\0'</code>。根据运行结果，前4个字符转成数字都没错，第5个错了，也就是<code>i</code>从0到3的循环都没错，我们设一个条件断点从<code>i</code>等于4开始单步调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           sum = 0;</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">13          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">14      &#125;</span><br><span class="line">15      return 0;</span><br><span class="line">(gdb) b 12 if i == 4</span><br><span class="line">Breakpoint 2 at 0x80483e6: file main.c, line 12.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:12</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1234</span></span><br></pre></td></tr></table></figure>
<p>现在<code>sum</code>是<code>1234</code>没错，根据运行结果是<code>123407</code>我们知道即将进行的这步计算肯定要出错，算出来应该是<code>12340</code>，那就是说<code>input[4]</code>肯定不是<code>'5'</code>了，事实证明这个推理是不严谨的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x04    0x00</span><br></pre></td></tr></table></figure>
<p><code>input[4]</code>的确是<code>0x35</code>，产生<code>123407</code>还有另外一种可能，就是在下一次循环中<code>123450</code>不是加上而是减去一个数得到<code>123407</code>。可现在不是到字符串末尾了吗？怎么会有下一次循环呢？注意到循环控制条件是<code>input[i] != '\0'</code>，而本来应该是<code>0x00</code>的位置现在莫名其妙地变成了<code>0x04</code>，因此循环不会结束。继续单步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 12345</span></span><br><span class="line">(gdb) n</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x05    0x00</span><br></pre></td></tr></table></figure>
<p>进入下一次循环，原来的<code>0x04</code>又莫名其妙地变成了<code>0x05</code>，这是怎么回事？这个暂时解释不了，但<code>123407</code>这个结果可以解释了，是<code>12345*10 + 0x05 - 0x30</code>得到的，虽然多循环了一次，但下次一定会退出循环了，因为<code>0x05</code>的后面是<code>'\0'</code>。</p>
<p><code>input[4]</code>后面那个字节到底是什么时候变的？可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。下面删除原来设的断点，从头执行程序，重复上次的输入，用<code>watch</code>命令设置观察点，跟踪<code>input[4]</code>后面那个字节（可以用<code>input[5]</code>表示，虽然这是访问越界）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) watch input[5]</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line">(gdb) i watchpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       hw watchpoint  keep y              input[5]</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 0 &#x27;\0&#x27;</span><br><span class="line">New value = 1 &#x27;\001&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 1 &#x27;\001&#x27;</span><br><span class="line">New value = 2 &#x27;\002&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 2 &#x27;\002&#x27;</span><br><span class="line">New value = 3 &#x27;\003&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br></pre></td></tr></table></figure>
<p>已经很明显了，每次都是回到<code>for</code>循环开头的时候改变了<code>input[5]</code>的值，而且是每次加<code>1</code>，而循环变量<code>i</code>正是在每次回到循环开头之前加<code>1</code>，原来<code>input[5]</code>就是变量<code>i</code>的存储单元，换句话说，<code>i</code>的存储单元是紧跟在<code>input</code>数组后面的。</p>
<p>修正这个Bug对初学者来说有一定难度。如果你发现了这个Bug却没想到数组访问越界这一点，也许一时想不出原因，就会先去处理另外一个更容易修正的Bug：如果输入的不是数字而是字母或别的符号也能算出结果来，这显然是不对的，可以在循环中加上判断条件检查非法字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123a</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">dead</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234578</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">23</span><br><span class="line">input=23</span><br></pre></td></tr></table></figure>
<p>似乎是两个Bug一起解决掉了，但这是治标不治本的解决方法。看起来输入超长的错误是不出现了，但只要没有找到根本原因就不可能真的解决掉，等到条件一变，它可能又冒出来了，在下一节你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入超长也会报错。最后总结一下本节用到的gdb命令：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch</td>
<td>设置观察点</td>
</tr>
<tr>
<td>info（或i） watchpoints</td>
<td>查看当前设置了哪些观察点</td>
</tr>
<tr>
<td>x</td>
<td>从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量</td>
</tr>
</tbody>
</table>
<h2 id="段错误">段错误</h2>
<p>如果程序运行时出现段错误，用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程序：</p>
<p>例 段错误调试实例一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> man = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, man);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0xb7e1404b <span class="keyword">in</span> _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0xb7e1dd2b <span class="keyword">in</span> scanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0804839f <span class="keyword">in</span> main () at main.c:6</span></span><br></pre></td></tr></table></figure>
<p>在gdb中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。gdb显示段错误出现在<code>_IO_vfscanf</code>函数中，用<code>bt</code>命令可以看到这个函数是被我们的<code>scanf</code>函数调用的，所以是<code>scanf</code>这一行代码引发的段错误。仔细观察程序发现是<code>man</code>前面少了个<code>&amp;</code>。</p>
<p>继续调试上一节的程序，上一节最后提出修正Bug的方法是在循环中加上判断条件，如果不是数字就报错退出，不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无论怎么运行都不出错了，但假如我们把<code>while (1)</code>循环去掉，每次执行程序只转换一个数：</p>
<p>例 段错误调试实例二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输入一个超长的字符串，看看会发生什么：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br></pre></td></tr></table></figure>
<p>看起来正常。再来一次，这次输个更长的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>又出段错误了。我们按同样的方法用gdb调试看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0804848e in main () at main.c:19</span><br><span class="line">19  &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">14          &#125;</span><br><span class="line">15          sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">16      &#125;</span><br><span class="line">17      printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">18      return 0;</span><br><span class="line">19  &#125;</span><br></pre></td></tr></table></figure>
<p>gdb指出，段错误发生在第<code>19</code>行。可是这一行什么都没有啊，只有表示<code>main</code>函数结束的<code>&#125;</code>括号。这可以算是一条规律，如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误。</p>
<p>想要写出Bug-free的程序是非常不容易的，即使<code>scanf</code>读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误，有些错误现象是我们暂时没法解释的：为什么变量<code>i</code>的存储单元紧跟在<code>input</code>数组后面？为什么同样是访问越界，有时出段错误有时不出段错误？为什么访问越界的段错误在函数返回时才出现？还有最基本的问题，为什么<code>scanf</code>输入整型变量就必须要加<code>&amp;</code>，否则就出段错误，而输入字符串就不要加<code>&amp;</code>？这些问题在后续章节中都会解释清楚。其实现在讲<code>scanf</code>这个函数为时过早，读者还不具备充足的基础知识。但还是有必要讲的，学完这一阶段之后读者应该能写出有用的程序了，然而一个只有输出而没有输入的程序算不上是有用的程序，另一方面也让读者认识到，学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个<code>scanf</code>函数都没办法用好，更没有办法保证写出正确的程序。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" rel="prev" title="C语言:计算机中数的表示">
                  <i class="fa fa-angle-left"></i> C语言:计算机中数的表示
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" rel="next" title="C语言:数据类型">
                  C语言:数据类型 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
