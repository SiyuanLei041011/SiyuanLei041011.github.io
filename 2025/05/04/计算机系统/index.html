<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="第一部分:基本概念 计算机系统概述 从问题描述到电子运转的转换层次如下 问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件  用自然语言提出一个问题 将问题转化成具体的算法, 算法有三大特点  确定性: 每个操作的步骤是清晰的, 可定义的 可计算性: 每一步都可以被计算机执行 有限性: 过程是会终止的  将算法用程序语言">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统概论笔记">
<meta property="og:url" content="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:description" content="第一部分:基本概念 计算机系统概述 从问题描述到电子运转的转换层次如下 问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件  用自然语言提出一个问题 将问题转化成具体的算法, 算法有三大特点  确定性: 每个操作的步骤是清晰的, 可定义的 可计算性: 每一步都可以被计算机执行 有限性: 过程是会终止的  将算法用程序语言">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-31T02:50:02.828Z">
<meta property="article:author" content="SiyuanLei">
<meta property="article:tag" content="LC-3">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","path":"2025/05/04/计算机系统/","title":"计算机系统概论笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机系统概论笔记 | SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SiyuanLei's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">第一部分:基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">计算机系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bit-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">bit, 数据类型及其运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86lc-3%E5%8F%8A%E5%85%B6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">第二部分:LC-3及其汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">冯诺依曼模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">组成部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98-1"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">处理单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">输入和输出单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">控制单元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">指令处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">指令周期</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">取指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%91%E7%A0%81"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">译码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">地址计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%96%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">2.1.2.2.4.</span> <span class="nav-text">取操作数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.2.2.5.</span> <span class="nav-text">执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E6%94%BE%E7%BB%93%E6%9E%9C"><span class="nav-number">2.1.2.2.6.</span> <span class="nav-text">存放结果</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">改变执行顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%81%9C%E6%9C%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">停机操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">LC-3结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lc-3-isa%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">LC-3 ISA概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">内存组织</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">指令集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">操作码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">寻址模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">条件码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">运算指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%90%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.3.</span> <span class="nav-text">数据搬移指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pc%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">PC相对寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">间接寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E5%9D%80%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">基址偏移寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">立即数寻址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.4.</span> <span class="nav-text">控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E5%92%8C%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">条件跳转和无条件跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmp"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">JMP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trap"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">TRAP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">2.3.</span> <span class="nav-text">LC-3 汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">操作码和操作数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%8F%B7"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">标号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.</span> <span class="nav-text">伪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.</span> <span class="nav-text">汇编过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">两遍扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.1.</span> <span class="nav-text">第一遍扫描</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.2.</span> <span class="nav-text">第二遍扫描</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.3.4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%98%A0%E5%83%8F"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">可执行映像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">多目标文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">2.4.</span> <span class="nav-text">输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A6%82%E8%BF%B0"><span class="nav-number">2.4.1.</span> <span class="nav-text">输入&#x2F;输出概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">设备寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84io%E4%B8%8E%E4%B8%93%E7%94%A8io%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">内存映射I&#x2F;O与专用I&#x2F;O指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5io%E4%B8%8E%E5%90%8C%E6%AD%A5io"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">异步I&#x2F;O与同步I&#x2F;O</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%BD%AE%E8%AF%A2"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">中断驱动和轮询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="nav-number">2.4.2.</span> <span class="nav-text">键盘输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E8%BE%93%E5%87%BA"><span class="nav-number">2.4.3.</span> <span class="nav-text">显示器输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8io"><span class="nav-number">2.4.4.</span> <span class="nav-text">中断驱动I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">中断信号的产生</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A5%E8%87%AA%E8%AE%BE%E5%A4%87%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">来自设备的中断信号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">中断优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%A3%80%E6%B5%8B"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">中断检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">TRAP程序及其子程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#trap%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.1.</span> <span class="nav-text">TRAP机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trap%E6%8C%87%E4%BB%A4"><span class="nav-number">2.5.2.</span> <span class="nav-text">TRAP指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.3.</span> <span class="nav-text">完整机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#halt%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.5.4.</span> <span class="nav-text">HALT中断程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9%E7%9A%84%E4%BF%9D%E6%8C%81%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">2.5.5.</span> <span class="nav-text">寄存器内容的保持和恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.5.6.</span> <span class="nav-text">子程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E6%9C%BA%E5%88%B6"><span class="nav-number">2.5.6.1.</span> <span class="nav-text">调用&#x2F;返回机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jsrjsrr%E6%8C%87%E4%BB%A4"><span class="nav-number">2.5.6.2.</span> <span class="nav-text">JSR&#x2F;JSRR指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">2.6.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">2.6.1.</span> <span class="nav-text">栈的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%8B%E5%85%A5"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">压入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%B9%E5%87%BA"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">弹出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E6%BA%A2%E5%87%BA"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">下溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E6%BA%A2%E5%87%BA"><span class="nav-number">2.6.1.4.</span> <span class="nav-text">上溢出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8io-1"><span class="nav-number">2.6.2.</span> <span class="nav-text">中断驱动I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">启动和执行</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81"><span class="nav-number">2.6.2.1.1.</span> <span class="nav-text">程序状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98"><span class="nav-number">2.6.2.1.2.</span> <span class="nav-text">被中断程序的状态保存</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81%E8%A3%85%E5%85%A5"><span class="nav-number">2.6.2.1.3.</span> <span class="nav-text">中断服务程序的状态装入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.6.2.1.4.</span> <span class="nav-text">中断服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E"><span class="nav-number">2.6.2.1.5.</span> <span class="nav-text">中断返回</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-%E5%B5%8C%E5%A5%97%E4%B8%AD%E6%96%AD"><span class="nav-number">2.6.2.1.6.</span> <span class="nav-text">例子: 嵌套中断</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86c%E8%AF%AD%E8%A8%80"><span class="nav-number">3.</span> <span class="nav-text">第三部分:C语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91"><span class="nav-number">3.1.</span> <span class="nav-text">高级语言翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.1.</span> <span class="nav-text">解释执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.2.</span> <span class="nav-text">编译执行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">3.2.</span> <span class="nav-text">C编程语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.2.1.</span> <span class="nav-text">C编译器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.</span> <span class="nav-text">变量和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bintchardouble"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">三种基本数据类型:int,char,double</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">局部变量和全局变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">递增&#x2F;递减运算符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86"><span class="nav-number">3.3.3.</span> <span class="nav-text">编译器处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">符号表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">变量的空间分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.</span> <span class="nav-text">条件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.2.</span> <span class="nav-text">循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">while语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">for语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#do-while%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">do-while循环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.3.</span> <span class="nav-text">其他控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">break和continue语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.1.</span> <span class="nav-text">C语言中的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">返回</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.2.</span> <span class="nav-text">C语言函数的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86cache"><span class="nav-number">4.</span> <span class="nav-text">第四部分:Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">计算机存储系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%AD%98%E5%82%A8%E5%99%A8%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">Cache存储器原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cache%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">Cache的读操作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.3.</span> <span class="nav-text">Cache结构的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cache%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.1.</span> <span class="nav-text">Cache的映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">直接映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">全相联映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E7%9B%B8%E8%BF%9E%E6%98%A0%E5%B0%84"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">组相连映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">替换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.3.</span> <span class="nav-text">Cache的写策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E7%9B%B4%E8%BE%BE%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">写直达策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">写回策略</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95-lc-3%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">附录 LC-3指令集结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AF%A6%E8%A7%A3"><span class="nav-number">5.2.</span> <span class="nav-text">LC-3指令集详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#add"><span class="nav-number">5.2.1.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#and"><span class="nav-number">5.2.2.</span> <span class="nav-text">AND</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#br"><span class="nav-number">5.2.3.</span> <span class="nav-text">BR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jmp%E5%92%8Cret"><span class="nav-number">5.2.4.</span> <span class="nav-text">JMP和RET</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jsr%E5%92%8Cjsrr"><span class="nav-number">5.2.5.</span> <span class="nav-text">JSR和JSRR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load%E7%B3%BB%E5%88%97%E6%8C%87%E4%BB%A4"><span class="nav-number">5.3.</span> <span class="nav-text">Load系列指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ld"><span class="nav-number">5.3.1.</span> <span class="nav-text">LD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldi"><span class="nav-number">5.3.2.</span> <span class="nav-text">LDI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldr"><span class="nav-number">5.3.3.</span> <span class="nav-text">LDR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lea"><span class="nav-number">5.3.4.</span> <span class="nav-text">LEA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#not"><span class="nav-number">5.4.</span> <span class="nav-text">NOT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rti"><span class="nav-number">5.5.</span> <span class="nav-text">RTI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store%E7%B3%BB%E5%88%97%E6%8C%87%E4%BB%A4"><span class="nav-number">5.6.</span> <span class="nav-text">Store系列指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#st"><span class="nav-number">5.6.1.</span> <span class="nav-text">ST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sti"><span class="nav-number">5.6.2.</span> <span class="nav-text">STI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#str"><span class="nav-number">5.6.3.</span> <span class="nav-text">STR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-1"><span class="nav-number">5.7.</span> <span class="nav-text">TRAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BE%A8%E6%9E%90"><span class="nav-number">5.8.</span> <span class="nav-text">一些指令的使用辨析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ld-1"><span class="nav-number">5.8.1.</span> <span class="nav-text">LD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldi-1"><span class="nav-number">5.8.2.</span> <span class="nav-text">LDI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldr-1"><span class="nav-number">5.8.3.</span> <span class="nav-text">LDR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lea-1"><span class="nav-number">5.8.4.</span> <span class="nav-text">LEA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#st-1"><span class="nav-number">5.8.5.</span> <span class="nav-text">ST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sti-1"><span class="nav-number">5.8.6.</span> <span class="nav-text">STI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#str-1"><span class="nav-number">5.8.7.</span> <span class="nav-text">STR</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C"><span class="nav-number">6.</span> <span class="nav-text">实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%981"><span class="nav-number">6.1.</span> <span class="nav-text">习题1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">6.1.1.</span> <span class="nav-text">实验步骤与实验思路:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">6.1.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%982"><span class="nav-number">6.2.</span> <span class="nav-text">习题2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">实验步骤与实验思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-1"><span class="nav-number">6.2.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%983"><span class="nav-number">6.3.</span> <span class="nav-text">习题3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-2"><span class="nav-number">6.3.1.</span> <span class="nav-text">实验步骤与实验思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-2"><span class="nav-number">6.3.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%984"><span class="nav-number">6.4.</span> <span class="nav-text">习题4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-3"><span class="nav-number">6.4.1.</span> <span class="nav-text">实验步骤与实验思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-3"><span class="nav-number">6.4.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%985"><span class="nav-number">6.5.</span> <span class="nav-text">习题5</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-4"><span class="nav-number">6.5.1.</span> <span class="nav-text">实验步骤与实验思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%981%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">问题1的解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%982%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.5.1.2.</span> <span class="nav-text">问题2的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5"><span class="nav-number">6.5.1.2.1.</span> <span class="nav-text">十进制输入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BE%93%E5%85%A5"><span class="nav-number">6.5.1.2.2.</span> <span class="nav-text">十六进制输入</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%983%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.5.1.3.</span> <span class="nav-text">问题3的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.5.1.3.1.</span> <span class="nav-text">十进制转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.5.1.3.2.</span> <span class="nav-text">十六进制转换</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%AE%E9%A2%984%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.5.1.4.</span> <span class="nav-text">问题4的解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-4"><span class="nav-number">6.5.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%986"><span class="nav-number">6.6.</span> <span class="nav-text">习题6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4%E4%B8%8E%E5%AE%9E%E9%AA%8C%E6%80%9D%E8%B7%AF-5"><span class="nav-number">6.6.1.</span> <span class="nav-text">实验步骤与实验思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-5"><span class="nav-number">6.6.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机系统概论笔记 | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机系统概论笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-31 10:50:02" itemprop="dateModified" datetime="2025-12-31T10:50:02+08:00">2025-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="第一部分基本概念">第一部分:基本概念</h2>
<h3 id="计算机系统概述">计算机系统概述</h3>
<p>从问题描述到电子运转的转换层次如下</p>
<p>问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件</p>
<ol type="1">
<li>用自然语言提出一个问题</li>
<li>将问题转化成具体的算法, 算法有三大特点
<ol type="1">
<li><strong>确定性</strong>: 每个操作的步骤是清晰的, 可定义的</li>
<li><strong>可计算性</strong>: 每一步都可以被计算机执行</li>
<li><strong>有限性</strong>: 过程是会终止的</li>
</ol></li>
<li>将算法用程序语言实现, 而程序语言就是机器语言,
它又分成高级语言和低级语言
<ol type="1">
<li>高级语言和计算机底层相关性弱, 比如Python,Matlab</li>
<li>低级语言和计算机底层相关性强, 通常一种低级语言对应一种计算机,
称为某某机器的汇编语言</li>
</ol></li>
<li>将编程语言转换成特定计算机的指令集. 指令集架构(Instruction Set
Architecture,ISA)是程序和计算机硬件之间接口的一个完整定义.
将高级语言翻译成ISA指令的过程由<strong>编译器</strong>完成,
而将计算机特定汇编语言翻译成其ISA的过程由<strong>汇编器</strong>完成.
ISA的定义包括:
<ol type="1">
<li>计算机可以执行的<strong>指令集合</strong>,
即计算机所能执行的操作</li>
<li>每个操作所需数据是什么, 即<strong>操作数</strong></li>
<li>可接受的操作数表达方式, 即<strong>数据类型</strong></li>
<li>获取操作数的机制, 即定位各种操作数的不同方法,
称为<strong>寻址模式</strong></li>
</ol></li>
<li>将ISA转换成对应的实现, 实现的具体组织称为<strong>微结构</strong>.
例如很多处理器都实现了X86这种ISA结构,但是每个处理器的实现方法不同,即有自己的微结构.</li>
<li>微结构则是由一些简单的逻辑电路实现的</li>
<li>每个基本的逻辑电路,都是按照特定的器件技术实现的</li>
</ol>
<h3 id="bit-数据类型及其运算">bit, 数据类型及其运算</h3>
<p>表示负数的方法:</p>
<p>思路一: 以最高bit表示符号, 0为正数, 1为负数, 称为符号位表示法.</p>
<p>思路二: 将一个正数的所有bit位全部取反, 即得到该正数对应的复数的编码,
称为反码表示法.</p>
<p>思路三: 补码表示法, 这也是最适合硬件操作的编码方案.</p>
<p>有符号整数的三种表示方法如下:</p>
<table>
<thead>
<tr>
<th>表示</th>
<th>符号位表示法</th>
<th>反码表示法</th>
<th>补码表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>00001</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>00010</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>00011</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>00100</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>00101</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>00110</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>00111</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>01000</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>01001</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>01010</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>01011</td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>01100</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>01101</td>
<td>13</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>01110</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>01111</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>10000</td>
<td>-0</td>
<td>-15</td>
<td>-16</td>
</tr>
<tr>
<td>10001</td>
<td>-1</td>
<td>-14</td>
<td>-15</td>
</tr>
<tr>
<td>10010</td>
<td>-2</td>
<td>-13</td>
<td>-14</td>
</tr>
<tr>
<td>10011</td>
<td>-3</td>
<td>-12</td>
<td>-13</td>
</tr>
<tr>
<td>10100</td>
<td>-4</td>
<td>-11</td>
<td>-12</td>
</tr>
<tr>
<td>10101</td>
<td>-5</td>
<td>-10</td>
<td>-11</td>
</tr>
<tr>
<td>10110</td>
<td>-6</td>
<td>-9</td>
<td>-10</td>
</tr>
<tr>
<td>10111</td>
<td>-7</td>
<td>-8</td>
<td>-9</td>
</tr>
<tr>
<td>11000</td>
<td>-8</td>
<td>-7</td>
<td>-8</td>
</tr>
<tr>
<td>11001</td>
<td>-9</td>
<td>-6</td>
<td>-7</td>
</tr>
<tr>
<td>11010</td>
<td>-10</td>
<td>-5</td>
<td>-6</td>
</tr>
<tr>
<td>11011</td>
<td>-11</td>
<td>-4</td>
<td>-5</td>
</tr>
<tr>
<td>11100</td>
<td>-12</td>
<td>-3</td>
<td>-4</td>
</tr>
<tr>
<td>11101</td>
<td>-13</td>
<td>-2</td>
<td>-3</td>
</tr>
<tr>
<td>11110</td>
<td>-14</td>
<td>-1</td>
<td>-2</td>
</tr>
<tr>
<td>11111</td>
<td>-15</td>
<td>-0</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p><strong>原码</strong>第一位是符号位, 0代表正数,
1代表负数.后面的位数都是数值位.</p>
<p><strong>反码</strong>正数的反码和原码相同,
负数的反码保持符号位是1,数值位取反</p>
<p><strong>补码</strong>正数的补码和原码相同,
负数的补码是在其反码的基础上加1.</p>
<p><strong>注意事项</strong></p>
<ul>
<li>如果已知一个数的补码, 对其再求一次补码就可以得到原码</li>
<li>4位字长的原码和反码表示的数值范围都是<code>-7~+7</code>,
补码表示的范围是<code>-8~+7</code>. 规定<code>+0</code>的原码, 反码,
补码都是<code>0000</code>,
<code>-0</code>只有原码(<code>1000</code>)和反码(<code>1111</code>),
没有补码; <code>-8</code>只有补码(<code>1000</code>),
没有原码和反码</li>
</ul>
<p><strong>符号扩展</strong>在二进制补码正数前加上任意多个0不改变它的值,
在二进制补码负数前加上任意多个1不改变它的值.</p>
<p><strong>溢出</strong>两个数进行补码运算, 如果结果的正负号和预期相反,
那么就就称为溢出. 只有在两种同符号运算的情况下, 才会发生溢出.</p>
<p><strong>浮点数</strong>IEEE浮点数的定义如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号位</th>
<th style="text-align: center;">数值范围</th>
<th style="text-align: center;">数值精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">(S)</td>
<td style="text-align: center;">指数(exponent)</td>
<td style="text-align: center;">尾数(fraction)</td>
</tr>
<tr>
<td style="text-align: center;">1 bit</td>
<td style="text-align: center;">8 bit</td>
<td style="text-align: center;">23 bit</td>
</tr>
</tbody>
</table>
<p>浮点数的计算公式如下: <span class="math display">\[N=(-1)^s\times
1.\rm{fraction}\times 2^{\rm{exponent}-127},~1\leq \rm{exponent}\leq
254\]</span></p>
<p><strong>例1</strong> <span
class="math inline">\(-6\frac{5}{8}\)</span>的IEEE浮点数是多少?</p>
<p><strong>解</strong><span
class="math display">\[-6\frac{5}{8}=-(1\times 2^2+1\times 2^1+0\times
2^0+1\times 2^{-1}+0\times 2^{-1}+1\times 2^{-3})=-1.10101\times
2^2\]</span></p>
<p>符号位是<span class="math inline">\(1\)</span>,指数是<span
class="math inline">\(2+127=129=10000001\)</span>,尾数为<span
class="math inline">\(10101000000000000000000\)</span> 于是IEEE浮点数为
<span
class="math display">\[1(1~bit)~~10000001(8~bit)~~10101000000000000000000(23~bit)\]</span></p>
<p><strong>例2</strong> IEEE浮点数 <span
class="math display">\[0~01111011~00000000000000000000000\]</span>
表示的是什么数?</p>
<p><strong>解</strong> <span
class="math inline">\(01111011-127=123-127=-4\)</span>,位数部分全为<span
class="math inline">\(0\)</span>, 整个数为正数, 所以 <span
class="math display">\[+1.00000000000000000000000\times
2^{-4}=\frac{1}{16}\]</span></p>
<p><strong>例3</strong> 在IEEE浮点数的定义中, 我们看到指数的范围为<span
class="math inline">\(1\leq \rm{exponential}\leq 254\)</span>,
也就是说指数不能为<span class="math inline">\(00000000\)</span>或者<span
class="math inline">\(11111111\)</span>. 如果指数字段的内容为<span
class="math inline">\(00000000\)</span>, 那么规定此时指数为<span
class="math inline">\(-126\)</span>, 且尾数中小数点左边的数为<span
class="math inline">\(0\)</span>, 而不是<span
class="math inline">\(1\)</span>. 此时浮点数的值为</p>
<p><span class="math display">\[(-1)^s\times 0.\rm{fraction}\times
2^{-126}\]</span></p>
<p>比如IEEE浮点数</p>
<p><span
class="math display">\[0~00000000~00001000000000000000000\]</span></p>
<p>解释如下: 最高位<span class="math inline">\(0\)</span>表示为正数,
指数全为<span class="math inline">\(0\)</span>表示<span
class="math inline">\(2^{-126}\)</span>, 尾数部分为<span
class="math inline">\(00001000...\)</span>表示<span
class="math inline">\(2^{-5}\)</span>, 于是该浮点数等于<span
class="math inline">\(2^{-5}\times 2^{-126}=2^{-131}\)</span>.</p>
<h3 id="内存">内存</h3>
<p>内存是由一定数目的”位置”组成的,
其中每个”位置”可以被单独识别并且存放一个数据.
我们称用来<strong>识别位置的一组数</strong>为<strong>地址</strong>,
称存储在<strong>各个位置中的bit数目</strong>为<strong>寻址能力</strong>.
内存中可独立识别的位置总数为内存的<strong>寻址空间</strong>.</p>
<p>例如, <span class="math inline">\(2^3\times 16\)</span>大小的内存,
其寻址空间大小为<span class="math inline">\(2^3=8\)</span>,
寻址能力为<span class="math inline">\(16 bit\)</span>的宽度.</p>
<h2 id="第二部分lc-3及其汇编语言">第二部分:LC-3及其汇编语言</h2>
<h3 id="冯诺依曼模型">冯诺依曼模型</h3>
<h4 id="组成部分">组成部分</h4>
<p>冯诺依曼模型包括五个组成部分:</p>
<ol type="1">
<li>内存memory</li>
<li>处理单元processing unit</li>
<li>输入input</li>
<li>输出output</li>
<li>控制单元control unit</li>
</ol>
<p>下面我们一一介绍</p>
<h5 id="内存-1">内存</h5>
<p>今天的计算机都是<span class="math inline">\(2^{28}\times
8~\rm{bit}\)</span>模式, 也就是说有<span
class="math inline">\(2^{28}\)</span>个存储单元,
每个存储单元可以存储<span
class="math inline">\(8~\rm{bit}\)</span>的信息. 我们称寻址空间为<span
class="math inline">\(2^{28}\)</span>, 寻址能力为<span
class="math inline">\(8\)</span>位(<span
class="math inline">\(1~\rm{byte}=8~\rm{bit}\)</span>).</p>
<p>访问内存的第一步, 就是向内存提供被访问的内存单元的地址</p>
<ul>
<li>读操作: 首先将被访问内存单元的地址放入CPU的内存地址寄存器(Memory
Address Register, MAR), 然后发送读信号通知内存,
最后内存将该内存单元中存放的数据发送到内存数据寄存器(Memory Data
Register, MDR).</li>
<li>写操作: 首先将被访问内存单元的地址放入CPU的MAR,
然后将要写入的数据放入CPU的MDR, 再向内存发送写信号,
最后MDR的内容被写入MAR指向的内存单元.</li>
</ul>
<h5 id="处理单元">处理单元</h5>
<p>处理单元是信息被真正处理的地方,
其中最简单的功能单元是算数逻辑单元ALU.
ALU所能处理的量化大小称为该机器的”字长”, 而量化的基本单位称为一个”字”.
例如, LC-3所能处理的量化大小为<span
class="math inline">\(16\rm{bit}\)</span>, 所以称LC-3是一个<span
class="math inline">\(16\)</span>位的机器.</p>
<p>通常会在ALU周围配置少量存储器, 以便存放最近生成的中间计算结果,
这样可以减少内存访问浪费的时间.
临时存储器最常见的设计方式就是一组寄存器,
其中每个寄存器的宽度和ALU处理数据的宽度一致,
我们说每个寄存器存放了一个字. 在LC-3中, 有<span
class="math inline">\(8\)</span>个这样的寄存器<code>R0, R1, ..., R7</code>,
每个宽度为16 bit.</p>
<h5 id="输入和输出单元">输入和输出单元</h5>
<p>输入和输出设备的种类很多, 我们称它们为”外围设备”.
常见的输入设备是键盘, 输出设备是显示器.</p>
<h5 id="控制单元">控制单元</h5>
<p>控制单元控制其他所有单元之间的协同工作.
控制单元中有几个特殊的寄存器:</p>
<ol type="1">
<li>指令寄存器IR: 保存的是正在被执行的那条指令.</li>
<li>PC寄存器: 指向下一条待处理的指令,
这个寄存器又称为”程序计数器”或者”指令指针”,
这是因为该寄存器的内容实际上指向下一条待处理的指令的地址.</li>
</ol>
<h4 id="指令处理">指令处理</h4>
<p>冯诺依曼模型的核心思想是,
程序和数据都是以bit流的方式存放在计算机内存中, 程序在控制单元的控制下,
依次完成指令的读取和执行.</p>
<h5 id="指令">指令</h5>
<p>指令是计算机执行的最小单位.
指令本身又是由<strong>操作码</strong>和<strong>操作数</strong>两部分组成.
操作码表示该指令是做什么的, 操作数表示该操作的对象有哪些.</p>
<p>LC-3指令长度是16, 其中<span
class="math inline">\(\rm{bit}[15:12]\)</span>表示操作码, <span
class="math inline">\(\rm{bit}[11:0]\)</span>对应操作数的表示.</p>
<p><strong>例1</strong> <code>ADD</code>指令</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>1 1 0</td>
<td>0 1 0</td>
<td>0</td>
<td>0 0</td>
<td>1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=110\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010,\rm{bit}[2:0]=110\)</span>
表示源寄存器<span class="math inline">\(\rm{R2}\)</span>和<span
class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[5:3]\)</span> 的含义以后再进行解释</p>
<p>上述指令的解释为将寄存器<span
class="math inline">\(\rm{R2}\)</span>和寄存器<span
class="math inline">\(\rm{R6}\)</span>的内容相加,
然后将结果放入寄存器R6.</p>
<p><strong>例2</strong> <code>LDR</code>指令</p>
<p>LD表示load, 表示从内存的某个位置读取内容, 然后装入某个寄存器中.
R表示读取内存地址的机制(寻址模式),
这里表示的意思是”base+offset”模式.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 1 0</td>
<td>0 1 1</td>
<td>0 0 0 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示LDR操作 <span class="math inline">\(\rm{bit}[11:9]=010\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=011\)</span> 表示偏移寄存器<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=000110\)</span> 表示基址<span
class="math inline">\(6\)</span></p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{R3}\)</span>的内容和<span
class="math inline">\(\rm{bit}[5:0]\)</span>的补码数值相加得到内存地址,
然后将该地址指向的内存单元的内容放入<span
class="math inline">\(\rm{R2}\)</span>中.</p>
<h5 id="指令周期">指令周期</h5>
<p>指令的处理过程是在控制单元的控制下一步步地完成的.
我们称这个执行的步骤顺序为指令周期, 其中每一步称为节拍.
一个指令周期包括6个节拍:</p>
<ol type="1">
<li>取指令(FETCH)</li>
<li>译码(DECODE)</li>
<li>地址计算(EVALUATE ADDRESS)</li>
<li>取操作数(FETCH OPERAND)</li>
<li>执行(EXECUTE)</li>
<li>存放结果(STORE RESULT)</li>
</ol>
<h6 id="取指令">取指令</h6>
<p>该节拍负责从内存中(整个程序的所有指令都保存在内存里面)取出下一条待执行的指令,
将其放入控制单元的指令寄存器IR. 而取出下一条待执行的指令,
就需要知道它在内存中的地址, 而程序计数器PC就是负责这个任务.
FETCH节拍的具体过程如下:</p>
<ol type="1">
<li>将PC寄存器的内容装入MAR</li>
<li>将MAR对应的内存单元的内容装入MDR</li>
<li>控制单元将MDR的内容装入IR寄存器</li>
<li><strong>PC+1</strong></li>
</ol>
<p>上面的每一个动作就是一个机器周期, 或者叫时钟周期.</p>
<h6 id="译码">译码</h6>
<p>将<span class="math inline">\(\rm{IR}[15:12]\)</span>作为输入,
输出<span class="math inline">\(16\)</span>根使能线, 但是这<span
class="math inline">\(16\)</span>根使能线中有且仅有一条是有效的.</p>
<h6 id="地址计算">地址计算</h6>
<p>不是所有的指令都有这个环节.</p>
<h6 id="取操作数">取操作数</h6>
<p><strong>源操作数既可以来自寄存器,又可以来自内存.</strong></p>
<h6 id="执行">执行</h6>
<p>没什么好说的</p>
<h6 id="存放结果">存放结果</h6>
<p>之前节拍的执行结果被写入目的寄存器.</p>
<h5 id="改变执行顺序">改变执行顺序</h5>
<p>由于任意的指令周期都是从将PC的内容装入MAR中开始的,
如果我们想要改变指令执行的顺序,
就必须在PC+1与下一条指令的取指令节拍开始之前修改PC+1的值.
控制指令就是<strong>用新的地址覆盖PC+1的内容</strong>.</p>
<p><strong>例</strong> <code>JMP</code>指令</p>
<p>假设该指令存放在内存<span
class="math inline">\(\rm{x36A2}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11</th>
<th>10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>0 1 1</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示JMP操作 <span class="math inline">\(\rm{bit}[8:6]=011\)</span>
表示寄存器<span
class="math inline">\(\rm{R3}\)</span>中存储了下一条指令</p>
<p>上述指令的解释为将寄存器3的内容放入PC寄存器, 覆盖掉当前PC+1, 换言之,
下一条要执行的指令在内存中的地址来自<span
class="math inline">\(\rm{R3}\)</span>.</p>
<p>具体来说, 首先在指令执行之初, PC的内容为<code>x36A2</code>,
在取指令节拍, 整条JMP指令放入IR寄存器, 同时PC自增变成<code>x36A3</code>,
假设<span
class="math inline">\(\rm{R3}\)</span>的内容是<code>x5446</code>,
那么在执行节拍, PC的内容就被覆盖为<code>x5446</code>.
这就导致了下一条指令来自内存中地址为<code>x5446</code>,
而不是$<code>x36A3</code>.</p>
<h5 id="停机操作">停机操作</h5>
<p>用户程序是受控于操作系统而执行的, 即操作系统有终值用户程序的办法.
对于计算机来说, 用户程序和操作系统没有区别, 都是一堆指令的集合.</p>
<p>对于用户程序来说, 想要停止用户程序,
就要在用户程序的结尾处放置一个控制指令, 该指令的任务就是修改PC寄存器,
使之跳转到操作系统, 而操作系统也借这个时刻启动一个新的用户程序.</p>
<h3 id="lc-3结构">LC-3结构</h3>
<h4 id="lc-3-isa概述">LC-3 ISA概述</h4>
<p>ISA定义了软件编程所需要的必要而完整的描述, 换言之,
ISA向以机器语言编程的程序员提供有关控制机器所需要的全部信息.
ISA主要包含如下信息:</p>
<ol type="1">
<li>内存组织方式</li>
<li>寄存器组</li>
<li>指令集(包括操作码, 数据类型, 寻址模式)</li>
</ol>
<h5 id="内存组织">内存组织</h5>
<p>LC-3的可寻址空间大小为<span
class="math inline">\(2^{16}\)</span>(这些空间并不是全部用于内存),
寻址基本单位是<span class="math inline">\(16\)</span>位.
LC-3中数据处理的基本单位是<span class="math inline">\(16\)</span>位,
所以称<span class="math inline">\(16\)</span>位为一个字,
也称LC-3是一个<strong>字寻址机器</strong>.</p>
<h5 id="寄存器">寄存器</h5>
<p>由于从内存中获取数据的速度很慢(不止一个周期),
所以计算机会提供临时存储空间, 它们的访问速度是一个周期.
临时存储空间最常见的实现方式是寄存器, LC-3提供了一组通用寄存器,
其中每个寄存器都叫做通用寄存器.</p>
<p>寄存器有以下特性:</p>
<ol type="1">
<li>记忆特性: 存储的信息可以被再次读出. 对于LC-3,
每个寄存器的大小为一个字, 即<span
class="math inline">\(16\)</span>位</li>
<li>独立寻址: 每个寄存器有唯一的标识. LC-3, 提供了<span
class="math inline">\(8\)</span>个寄存器<code>R0, R1, ..., R7</code></li>
</ol>
<h5 id="指令集">指令集</h5>
<p>一条指令分为两个部分, 第一个部分是<strong>操作码</strong>(做什么),
第二个部分是<strong>操作数</strong>(对谁操作).
<strong>一个ISA的指令集定义包括: 操作码的集合, 数据类型, 寻址模式.
其中寻址模式决定了操作数的存放位置.</strong></p>
<h5 id="操作码">操作码</h5>
<p>LC-3的ISA结构定义了<span class="math inline">\(15\)</span>条指令,
注意到<span class="math inline">\(\rm{bit}[15:12]\)</span>这<span
class="math inline">\(4~\rm{bit}\)</span>的操作码本来可以定义<span
class="math inline">\(16\)</span>条指令, 但我们将<span
class="math inline">\(1101\)</span>先预留出来.</p>
<p>所有指令可以分成三类:</p>
<ol type="1">
<li><strong>运算指令:</strong> 算数运算或者逻辑运算, 负责处理信息</li>
<li><strong>数据搬移指令:</strong> 将数据从一个地方搬到另一个地方,
如内存和寄存器之间, 内存, 寄存器和输入输出之间</li>
<li><strong>控制指令:</strong> 改变程序的执行顺序</li>
</ol>
<h5 id="数据类型">数据类型</h5>
<p>数据类型是指信息的表达方式, 即ISA的操作码是怎样理解这些表达信息的.
如果ISA的操作码能识别/处理某种数据类型的信息,
那么我们称该ISA支持这种数据类型.
<strong>LC-3所支持的唯一的数据类型就是补码整数</strong>.</p>
<h5 id="寻址模式">寻址模式</h5>
<p>寻址模式是定义操作数位置的机制.操作数的来源有三个:</p>
<ol type="1">
<li>内存</li>
<li>寄存器</li>
<li>指令本身</li>
</ol>
<p>称存在于指令本身的操作数为”字面值”或”立即数”.</p>
<p>而LC-3总共支持<span class="math inline">\(5\)</span>种寻址模式:</p>
<ol type="1">
<li>立即数</li>
<li>寄存器</li>
<li>相对寻址</li>
<li>间接寻址</li>
<li>基址偏移</li>
</ol>
<h5 id="条件码">条件码</h5>
<p>LC-3具有三个位寄存器, 每当<span
class="math inline">\(8\)</span>个通用寄存器中的任意一个被修改或者写入时,
这三个<span class="math inline">\(\rm{bit}\)</span>位就会发生变化.
这三个位寄存器分别为<span class="math inline">\(N,Z,P\)</span>,
分别代表负数, 零, 正数. 即每当通用寄存器被写入时, 根据写入的结果是负数,
零, 正数, 分别设置这三个位. 例如, 写入负数, 置<span
class="math inline">\(N=1,Z=P=0\)</span>.
我们称这三个位寄存器为”条件码”.</p>
<h4 id="运算指令">运算指令</h4>
<p>LC-3只支持三种运算: <code>ADD</code>, <code>AND</code>,
<code>NOT</code></p>
<p><strong>例1</strong> <code>NOT</code>指令</p>
<p><code>NOT</code>指令是唯一的单操作数指令.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 0 1</td>
<td>0 1 1</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1001\)</span>
表示取反NOT操作 <span class="math inline">\(\rm{bit}[11:9]=011\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=101\)</span> 表示源寄存器<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5:0]\)</span> 全部为<span
class="math inline">\(1\)</span></p>
<p>上述指令的解释为将寄存器5的内容取反,然后放入寄存器3.</p>
<p><strong>例2</strong> <code>AND</code>指令</p>
<p><code>AND</code>(操作码为<code>0101</code>)和<code>ADD</code>(操作码为<code>0001</code>)都是双操作数指令,
它们都需要两个<span class="math inline">\(16\)</span>位源操作数.
<code>AND</code>和<code>ADD</code>的源操作数之一(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)以及目的寄存器(<span
class="math inline">\(\rm{bit}[11:9]\)</span>)都是寄存器寻址.
对于第二个操作数的寻址方式, 则是取决于<span
class="math inline">\(\rm{bit}[5]\)</span>的值, 若为<span
class="math inline">\(1\)</span>, 则是立即数寻址, 此时<span
class="math inline">\(\rm{bit}[4:0]\)</span>表示立即数; 若为<span
class="math inline">\(0\)</span>, 则是寄存器寻址, 此时源寄存器为<span
class="math inline">\(\rm{bit}[2:0]\)</span>, <span
class="math inline">\(\rm{bit}[4:3]=00\)</span>.</p>
<p>下面是<strong>寄存器寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100,\rm{bit}[2:0]=101\)</span>
表示源寄存器<span class="math inline">\(\rm{R4}\)</span>和<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5]=0\)</span> 表示寄存器寻址,此时<span
class="math inline">\(\rm{bit}[4:3]=00\)</span></p>
<p>上述指令的解释为将寄存器R4和寄存器R5的内容相加,
然后将结果放入寄存器R1.</p>
<p>下面是<strong>立即数寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>1</td>
<td>1 1 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100\)</span> 表示源寄存器<span
class="math inline">\(\rm{R4}\)</span> <span
class="math inline">\(\rm{bit}[5]=1\)</span> 表示立即数寻址,此时<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>为立即数</p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,
然后与寄存器R4的内容相加,然后将结果放入寄存器R1.</p>
<h4 id="数据搬移指令">数据搬移指令</h4>
<p>我们称将数据从内存移入寄存器为”装载(Load)“,
将数据从寄存器放入内存为”存储(Store)“. 注意, 在这种情况下,
数据源的内容不会随着数据的移动而改变, 但是目的操作数的内容会被刷新,
以前的内容会被覆盖.</p>
<p>LC-3有<span class="math inline">\(7\)</span>种数据搬移指令:
<code>LD</code>, <code>LDR</code>, <code>LDI</code>, <code>LEA</code>,
<code>ST</code>, <code>STR</code>, <code>STI</code></p>
<p>Load和Store的指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">操作码</td>
<td style="text-align: center;">DR或SR</td>
<td style="text-align: center;">地址生成位</td>
</tr>
</tbody>
</table>
<p>数据搬移指令需要有两个操作数: 源和目的, 且两个操作数之一必然是寄存器,
另一个则是内存或者输入输出设备.</p>
<p><span class="math inline">\(\rm{bit}[11:9]\)</span>标识了操作数之一,
即寄存器, 如果是Load类型的指令, 那么这代表目的寄存器(DR);
如果是Store类型的指令, 那么这代表源寄存器(SR).</p>
<p><span class="math inline">\(\rm{bit}[8:0]\)</span>是”地址生成位”,
这表示基于<span class="math inline">\(\rm{bit}[8:0]\)</span>的信息,
可以计算出第二个操作数的<span class="math inline">\(16\)</span>位地址.
LC-3中, 有<span
class="math inline">\(4\)</span>种生成地址(或者说阐释<span
class="math inline">\(\rm{bit}[8:0]\)</span>)的方法, 也就是<span
class="math inline">\(4\)</span>种寻址模式.</p>
<h5 id="pc相对寻址">PC相对寻址</h5>
<p><code>LD</code>(操作码为<code>0010</code>)和<code>ST</code>(操作码为<code>0011</code>)采用<strong>PC相对寻址</strong>.
此时<span
class="math inline">\(\rm{bit}[8:0]\)</span>代表的是<strong>对于当前PC值的偏移量</strong>.
地址计算方法是, 将<span
class="math inline">\(\rm{bit}[8:0]\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,
然后和PC当前值(已增量)相加得到内存单元的地址.</p>
<p><strong>例</strong> <code>LD</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 1 0</td>
<td>0 1 0</td>
<td>1 1 0 1 0 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示PC相对寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=010\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span>
表示偏移量,符号扩展之后为<span
class="math inline">\(\rm{xFFAF}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)+\rm{xFFAF}=\rm{x3FC8}\)</span>,
将<span class="math inline">\(\rm{x3FC8}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x3FC8}\)</span>的内容装入MDR中,
最后把MDR的内容加载到<span class="math inline">\(R2\)</span>中.</p>
<p>注意这种寻址方式计算出来的内存地址范围是受限的,
即该地址只能在当前LD或者ST指令所在地址的<span
class="math inline">\(+256\)</span>和<span
class="math inline">\(-255\)</span>范围内, 另外<span
class="math inline">\(\rm{bit}[8:0]\)</span>是有符号数值.</p>
<h5 id="间接寻址">间接寻址</h5>
<p><code>LDI</code>(操作码为<code>1010</code>)和<code>STI</code>(操作码为<code>1011</code>)采用<strong>间接寻址</strong>.
首先用和LD/ST相同的方法算出一个地址, 但是这个地址的内容又是另外一个地址,
这个新的地址的内容才是源操作数.
这种寻址方式的范围是<strong>整个内存空间</strong>.</p>
<p><strong>例</strong> <code>LDI</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4A1B}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 1 0</td>
<td>0 1 1</td>
<td>1 1 1 0 0 1 1 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示间接寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=011\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span> 表示偏移量,
符号扩展之后为<span class="math inline">\(\rm{xFFCC}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4A1B}+1)+\rm{xFFCC}=\rm{x49E8}\)</span>,
将<span class="math inline">\(\rm{x49E8}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x49E8}\)</span>的内容(假设为<span
class="math inline">\(\rm{x2110}\)</span>)装入MDR中, 而<span
class="math inline">\(\rm{x2110}\)</span>不是操作数, 而是地址, 所以<span
class="math inline">\(\rm{x2110}\)</span>又被装入MAR,
再次读取内存地址为<span
class="math inline">\(\rm{x2110}\)</span>的内容装入到MDR,
最后把MDR的内容加载到<span class="math inline">\(R3\)</span>中.</p>
<h5 id="基址偏移寻址">基址偏移寻址</h5>
<p><code>LDR</code>(操作码为<code>0110</code>)和<code>STR</code>(操作码为<code>0111</code>)采用<strong>基址+偏移寻址</strong>.
操作数的地址是由<span
class="math inline">\(\rm{bit}[5:0]\)</span>的<span
class="math inline">\(6~\rm{bit}\)</span>偏移量和<span
class="math inline">\(\rm{bit}[8:6]\)</span>的寄存器的内容(基址)相加得出.</p>
<p><strong>例</strong> <code>LD</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 0 1</td>
<td>0 1 0</td>
<td>0 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示基址+偏移寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=001\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010\)</span> 表示基址寄存器<span
class="math inline">\(\rm{R2}\)</span>, 其内容假设为<span
class="math inline">\(\rm{x2345}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=011101\)</span> 符号扩展为<span
class="math inline">\(\rm{x001D}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\(\rm{x2345}+\rm{x001D}=\rm{x2362}\)</span>, 将<span
class="math inline">\(\rm{x2362}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x2362}\)</span>的内容装入MDR中,
最后把MDR的内容加载到<span class="math inline">\(R1\)</span>中.</p>
<h5 id="立即数寻址">立即数寻址</h5>
<p>立即数寻址模式只用于有效地址装载指令, 用途是对寄存器初始化,
即向寄存器中装入一个地址, 注意该地址需要离当前PC比较近,
且LEA是唯一不需要访问内存的load类型指令.
LEA(操作码为1110)将增量PC直接和<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加, 并装入<span
class="math inline">\(\rm{bit}[11:9]\)</span>指定的寄存器.</p>
<p><strong>例</strong> <code>LEA</code>指令</p>
<p>设这条指令位于<span class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 1 0</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1110\)</span>
表示LEA操作 <span class="math inline">\(\rm{bit}[11:9]=101\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R5}\)</span>,
假设内容为<span class="math inline">\(\rm{x4018}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=111111101\)</span> 为<span
class="math inline">\(-3\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)-3=\rm{x4016}\)</span>, 将<span
class="math inline">\(\rm{x4016}\)</span>装入<span
class="math inline">\(\rm{R5}\)</span>.</p>
<h4 id="控制指令">控制指令</h4>
<p>控制指令是指可以改变指令执行顺序的指令. 如果没有控制指令,
那么当前指令完毕后的下一条指令一定是内存位置顺序的下一条,
这是因为取指令之后, PC会自动加一.</p>
<p>LC-3中有<span
class="math inline">\(5\)</span>种操作码可以打破这种顺序: 条件跳转,
无条件跳转, 子程序(又称为函数)调用, TRAP, 中断返回.</p>
<h5 id="条件跳转和无条件跳转">条件跳转和无条件跳转</h5>
<p>条件跳转指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">P</td>
<td style="text-align: center;">PC偏移</td>
</tr>
</tbody>
</table>
<p>其中:</p>
<p><span
class="math inline">\(\rm{bit}[11],[10],[9]\)</span>分别对应三个条件码.
<strong>任何一个对寄存器进行操作的指令都会设置这三个条件码,
这些指令包括ADD, AND, NOT, LD, LDI, LDR,
LEA.</strong>(注意Store类型的指令不改变条件码).</p>
<p>条件码的使用方法是:
条件跳转指令通过判断条件码来决定是否改变指令流.</p>
<p>控制指令的执行周期如下:</p>
<ol type="1">
<li>取指令和译码节拍正常, 取指令之后, PC自动增量</li>
<li>地址计算节拍, 将增量后的PC和指令中<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加求得地址</li>
<li>执行节拍, 处理器会检测某个(我们指定的)条件码,
如果该条件码的值为<span class="math inline">\(1\)</span>,
那么PC的内容将会被修改成上一个节拍计算出来的地址;
如果该条件码的值为<span class="math inline">\(0\)</span>,
那么PC的内容不变. 如果我们指定三个条件码都为<span
class="math inline">\(1\)</span>, 那么PC内容必然会更新,
这就是无条件跳转指令.</li>
</ol>
<h5 id="jmp">JMP</h5>
<p><code>JMP</code>指令格式如下</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0 0 0</td>
<td>0 1 0</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>JMP指令的任务就是<strong>将基址寄存器(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)的内容装入PC中</strong>.
JMP指令可以使指令跳转到内存空间的任意位置,
这是因为基址寄存器的内容是<span class="math inline">\(16\)</span>位,
它可以表达内存空间的所有地址.</p>
<h5 id="trap">TRAP</h5>
<p>TRAP指令的任务是改变PC的内容, 使其指向操作系统所在的空间内部. 换言之,
就是以当前程序身份跳转至操作系统的某个代码入口开始执行.
按照操作系统的术语来说, 我们称TRAP指令是激活了操作系统的服务调用.</p>
<p>TRAP指令格式如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 1 1</td>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">陷入矢量</td>
</tr>
</tbody>
</table>
<p>其中<span class="math inline">\(\rm{bit}[7:0]\)</span>表示陷入矢量,
陷入矢量表示的是程序希望操作系统执行的服务程序的编号.</p>
<p>操作系统在完成服务调用之后,
程序计数器PC将被设置成TRAP指令后的下一条指令地址.</p>
<h3 id="lc-3-汇编语言">LC-3 汇编语言</h3>
<p>汇编语言属于低级语言, 每一条汇编语言通常对应于一条ISA指令,
高级语言是ISA无关的, 而低级语言是ISA相关的.</p>
<p>在汇编语言中,
我们采用<strong>助记符</strong>方式来表示<code>AND</code>,<code>NOT</code>之类的<strong>操作码</strong>,
而<strong>内存地址</strong>则被SUM,PRODUCT之类的<strong>符号名</strong>所替代.
我们称这种命名方式为<strong>符号地址</strong>.</p>
<p>我们先看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Program to multiply an integer by the constant 6</span><br><span class="line">; Before execution, an integer must be stored in NUMBER</span><br><span class="line">         .ORIG    x3050</span><br><span class="line">         LD       R1,SIX</span><br><span class="line">         LD       R2,NUMBER</span><br><span class="line">         AND      R3,R3,#0</span><br><span class="line">; The inner loop</span><br><span class="line">   AGAIN ADD      R3,R3,R2</span><br><span class="line">         ADD      R1,R1,#-1</span><br><span class="line">         BRp      AGAIN</span><br><span class="line"></span><br><span class="line">         HALT</span><br><span class="line"></span><br><span class="line">   NUMBER .BLKW   1</span><br><span class="line">   SIX    .FILL   x0006</span><br><span class="line"></span><br><span class="line">          .END</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ol type="1">
<li>以<code>;</code>开头的内容是注释</li>
<li>以<code>AND</code>, <code>NOT</code>, <code>HALT</code>,
<code>AGAIN</code>开头的代码行是要翻译成LC-3机器指令的,
即真正要运行的</li>
<li><code>.ORIG</code>, <code>NUMBER</code>, <code>SIX</code>,
<code>.END</code>是伪操作,
是程序员传递给汇编器的信息,用于提示帮助翻译的过程.</li>
</ol>
<h4 id="指令-1">指令</h4>
<p>汇编语言的指令格式包含<span
class="math inline">\(4\)</span>个部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL OPCODE OPERANDS ; COMMENTS</span><br></pre></td></tr></table></figure>
<h5 id="操作码和操作数">操作码和操作数</h5>
<p>在一个汇编指令的所有字段中, 操作码(OPCODE,
做什么事情)和操作数(OPERAND, 被操作的对象)两部分是必须的,
操作数的数目取决于具体的操作.</p>
<p>操作数的获取有三种方式:</p>
<ol type="1">
<li>寄存器操作数:
直接用<code>R1</code>,<code>R2</code>等显式表示寄存器</li>
<li>内存操作数:
内存地址被表达为符号名,例如<code>NUMBER</code>和<code>SIX</code></li>
<li>立即数操作数:
数值被显式表达,“#”表示十进制,“x”表示十六进制,“b”表示二进制.</li>
</ol>
<h5 id="标号">标号</h5>
<p>标号是指向内存单元的符号名, 它可以在程序中直接引用. LC-3汇编语言中,
一个标号可以包含<span class="math inline">\(1\)</span>到<span
class="math inline">\(20\)</span>个字符(如大写或者小写的字母或者数字),
但是首个字符必须是字母. 显式访问内存单元的方式有两种:</p>
<ol type="1">
<li>该单元的内容是指令, 该单元地址是跳转指令的目标,
比如<code>AGAIN</code></li>
<li>该单元的内容是Load或者Store指令访问的数值, 比如<code>NUMBER</code>,
<code>SIX</code></li>
</ol>
<p>如果一个内存单元从来不被引用, 那么就没有必要为其标号.</p>
<h4 id="伪操作">伪操作</h4>
<p>伪操作又被称为<strong>汇编指令</strong>,
它们并不代表(被翻译的汇编)程序中的任何操作,
或者说程序执行时它们是不产生任何操作的.
它们可以理解为程序员传递给汇编器的信息, 用于指导汇编器的汇编操作.
LC-3汇编器只有<span class="math inline">\(5\)</span>种伪操作:</p>
<ol type="1">
<li><code>.ORIG</code>:
<code>.ORIG</code>告诉汇编器将LC-3程序放在内存的什么位置,例如<code>.ORIG x3050</code>表示”从”x3050”开始,
于是<code>LD R1,SIX</code>这一条指令就被放在”x3050”处.</li>
<li><code>.FILL</code>: <code>.FILL</code>告诉汇编器开始占用下一个地址,
并且填充初始值(如其操作数),
如<code>SIX .FILL x0006</code>,即该单元被初始化为<code>x0006</code>.</li>
<li><code>.BLKW</code>: <code>.BLKW</code>告诉汇编器在程序空间中,
开始占用一连串的地址空间,
具体的占用数目由<code>.BLKW</code>的伪操作数决定.</li>
<li><code>.STRINGZ</code>:
<code>.STRINGZ</code>告诉汇编器连续占用并初始化<span
class="math inline">\(n+1\)</span>个内存单元,
其参数(或操作数)是双括号括起来的<span
class="math inline">\(n\)</span>个字符. <span
class="math inline">\(n+1\)</span>个内存单元的前<span
class="math inline">\(n\)</span>个字的内容分别是字符串对应字符的ASCII码的零扩展,
内存的最后一个字则被初始化为<span class="math inline">\(0\)</span>.
最后的这个字符<code>x0000</code>通常为ASCII码的处理提供了”哨兵机制”.
例如下面的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      .ORIG x3010</span><br><span class="line">HELLO .STRINGZ &quot;Hello, World!&quot;      </span><br></pre></td></tr></table></figure>
<p>导致汇编器将内存x3010到x301D初始化为如下内容:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;">对应字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x3010</td>
<td style="text-align: center;">x0048</td>
<td style="text-align: center;">H</td>
</tr>
<tr>
<td style="text-align: center;">x3011</td>
<td style="text-align: center;">x0065</td>
<td style="text-align: center;">e</td>
</tr>
<tr>
<td style="text-align: center;">x3012</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3013</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3014</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3015</td>
<td style="text-align: center;">x002C</td>
<td style="text-align: center;">,</td>
</tr>
<tr>
<td style="text-align: center;">x3016</td>
<td style="text-align: center;">x0020</td>
<td style="text-align: center;">空格</td>
</tr>
<tr>
<td style="text-align: center;">x3017</td>
<td style="text-align: center;">x0057</td>
<td style="text-align: center;">W</td>
</tr>
<tr>
<td style="text-align: center;">x3018</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3019</td>
<td style="text-align: center;">x0072</td>
<td style="text-align: center;">r</td>
</tr>
<tr>
<td style="text-align: center;">x301A</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x301B</td>
<td style="text-align: center;">x0064</td>
<td style="text-align: center;">d</td>
</tr>
<tr>
<td style="text-align: center;">x301C</td>
<td style="text-align: center;">x0021</td>
<td style="text-align: center;">!</td>
</tr>
<tr>
<td style="text-align: center;">x301D</td>
<td style="text-align: center;">x0000</td>
<td style="text-align: center;">空字符</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li><code>.END</code>: <code>.END</code>告诉汇编器”程序结束了”.</li>
</ol>
<h4 id="汇编过程">汇编过程</h4>
<p>我们先看如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.ORIG    x3000                  ;这是伪操作, 不是第一条指令</span><br><span class="line">         AND      R2, R2, #0    ;x3000 这才是第一条指令</span><br><span class="line">         LD       R3, PTR       ;x3001</span><br><span class="line">         TRAP     x23           ;x3002</span><br><span class="line">         LDR      R1, R3, #0    ;x3003</span><br><span class="line"></span><br><span class="line">TEST     ADD     R4, R1, #-4    ;x3004 检测到TEXT</span><br><span class="line">         BRz     OUTPUT         ;x3005</span><br><span class="line"></span><br><span class="line">         NOT      R1, R1        ;x3006</span><br><span class="line">         ADD      R1, R1, R0    ;x3007</span><br><span class="line">         NOT      R1, R1        ;x3008</span><br><span class="line">         BRnp     GETCHAR       ;x3009</span><br><span class="line">         ADD      R2, R2, #1    ;x300A</span><br><span class="line"></span><br><span class="line">GETCHAR  ADD      R3, R3, #1    ;x300B 检测到GETCHAR</span><br><span class="line">         LDR      R1, R3, #0    ;x300C</span><br><span class="line">         BRnzp    TEST          ;x300D</span><br><span class="line"></span><br><span class="line">OUTPUT   LD       R0, ASCII     ;x300E 检测到OUTPUT</span><br><span class="line">         ADD      R0, R0, R2    ;x300F</span><br><span class="line">         TRAP     x21           ;x3010</span><br><span class="line">         TRAP     x25           ;x3011</span><br><span class="line"></span><br><span class="line">ASCII    .FILL    x0030         ;x3012 检测到ASCII, 这条指令的意思是, 在地址x3012处装入内容x0030</span><br><span class="line">PTR      .FILL    x4000         ;x3013 检测到PTR, 这条指令的意思是, 在地址x3013处装入内容x4000</span><br><span class="line">         .END</span><br></pre></td></tr></table></figure>
<h5 id="两遍扫描">两遍扫描</h5>
<p>汇编器在将汇编指令翻译成对应的机器指令前,
需要对整个汇编程序从头到尾(从开始到<code>.END</code>)扫描一遍,
为的是在第一遍扫描时先确定符号名对应的二进制地址,
即确定所有符号和地址之间的映射关系.
我们称这个映射集合为<strong>符号表</strong>. 在建立完符号表之后,
汇编器就可以一行一行进行翻译了.</p>
<p>总之, 第一遍扫描负责符号表的创建,
第二遍扫描负责将所有汇编指令翻译成对应的机器指令.</p>
<h6 id="第一遍扫描">第一遍扫描</h6>
<p>第一遍扫描的具体操作如下:</p>
<ol type="1">
<li>丢弃掉所有注释</li>
<li><code>.ORIG</code>后面的第一条有效指令所分配的地址就是<code>.ORIG</code>后的参数.
为了方便说明, 我们采用”地址跟踪计数器LC”,
LC的初始值由<code>.ORIG</code>指定, 也就是x3000.</li>
<li>每识别出一条有效指令, LC的值加<span
class="math inline">\(1\)</span>.
如果当前指令行的<strong>头部存在”标识”字段</strong>,
那么就为该标识创建符号表项, 其地址值就是当前LC的内容</li>
<li>继续识别下一条指令, 直至<code>.END</code></li>
</ol>
<p>按照上面的操作创建的符号表如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号名</th>
<th style="text-align: center;">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">TEST</td>
<td style="text-align: center;">x3004</td>
</tr>
<tr>
<td style="text-align: center;">GETCHAR</td>
<td style="text-align: center;">x300B</td>
</tr>
<tr>
<td style="text-align: center;">OUTPUT</td>
<td style="text-align: center;">x300E</td>
</tr>
<tr>
<td style="text-align: center;">ASCII</td>
<td style="text-align: center;">x3012</td>
</tr>
<tr>
<td style="text-align: center;">PTR</td>
<td style="text-align: center;">x3013</td>
</tr>
</tbody>
</table>
<h6 id="第二遍扫描">第二遍扫描</h6>
<p>没什么好说的, 就是把汇编语言翻译成二进制代码.</p>
<p>这里需要说明一下, 在编译到<code>LD R3, PTR ;x3001</code>这一条指令时,
<code>PTR</code>的地址为<code>x3013</code>,
而此时的PC+1为<code>x3002</code>, LC为<code>x3001</code>,
由于<code>PTR</code>的地址为PC+1和符号扩展之后的PCoffset值之和,
因而可以计算出PCoffset字段的内容是<code>x0011</code>. 注意,
<code>LD</code>指令中的源操作数的地址(即<code>PTR</code>)不能超出<code>LD</code>指令所在位置的+256或者-255,
也就是说,如果<code>PTR</code>的地址大于<code>LC+1+256</code>或者小于<code>LC+1-255</code>,
那么该偏移值就会超出了指令<code>bit[8:0]</code>字段所能表示的范围.</p>
<h4 id="其他">其他</h4>
<h5 id="可执行映像">可执行映像</h5>
<p>当计算机开始程序的执行时, 执行实体又称为”可执行映像”.
可执行映像通常是由多个相互独立的模块组装在一起形成的,
而这些模块通常又是由不同的程序员, 不同的语言(例如汇编语言, C语言,
Python等)分别编写的, 且有些模块是用户编写的, 有些则是操作系统的库程序.
所有这些模块在组装之前, 是一个个独立的目标文件,
最后通过<strong>连接</strong>操作将这些目标拼装成一个可执行映像.</p>
<h5 id="多目标文件">多目标文件</h5>
<p>待完成</p>
<h3 id="输入输出">输入/输出</h3>
<h4 id="输入输出概述">输入/输出概述</h4>
<p>我们需要找到一种方法, 将待处理的信息输入到计算机系统中,
并将计算机处理后的结果以人们可以理解的方式输出.</p>
<h5 id="设备寄存器">设备寄存器</h5>
<p>和一个I/O设备进行交互, 我们需要多个<strong>设备寄存器</strong>,
即使是最简单的I/O设备, 也至少需要两个寄存器:</p>
<ol type="1">
<li>用来保持和计算机之间传输的数据</li>
<li>指示当前设备的状态信息, 如”设备是否空闲”, “最近处理的I/O任务”等</li>
</ol>
<h5 id="内存映射io与专用io指令">内存映射I/O与专用I/O指令</h5>
<p>指令访问I/O设备寄存器时, 需要明确指明目标寄存器.
通常有两种方法实现:</p>
<ol type="1">
<li>一些计算机厂家采用专门的I/O指令来访问, 即”专用I/O指令”(不常见)</li>
<li>采用内存操作指令完成I/O操作, 即”内存映射I/O”(常用)</li>
</ol>
<p>程序员使用与内存访问相同的指令来操作I/O,
所以设备的每个输入输出寄存器都必须有一个和内存中位置相同的标识方式.
为此, 在ISA的内存地址空间中, 专门划分出一段地址,
用于设备寄存器的标识映射. 换句话说,
I/O设备的寄存器被”映射”到一组地址(这些地址是分配给I/O寄存器的,
而不是分配给内存位置的), 即所谓”内存映射I/O”方式.</p>
<p>LC-3采用内存映射I/O方式,
其中<code>0x0000~0xFDFF</code>的地址空间用于标识内存,
<code>0xFE00~0xFFFF</code>则保留给外部设备使用.</p>
<h5 id="异步io与同步io">异步I/O与同步I/O</h5>
<p>下面考虑程序员的输入字符操作, 每输入一个字符,
该字符的ASCII码就会被存入键盘输入寄存器中, 然后CPU执行load指令时,
如果目标地址指向键盘输入寄存器, 则将该ASCII码值读入计算机.</p>
<p>I/O设备和处理器的工作节奏是不一致的,
因此我们称I/O设备和CPU之间是异步的. 异步通信方式下,
需要通过一定的协议或者握手机制来控制发送和接收.</p>
<p>实现同步的最简单方式是采用标志.
键盘状态寄存器中的标志位提供了最简单的一种握手机制:
打字员每输入一个字符, 该标志位(Ready位)就被置位, 而每次处理器读取之后,
都自动将该标志位清零. 所以在每次读取输入字符之前,
处理器都会检查该Ready位, 如果Ready位为<span
class="math inline">\(0\)</span>, 表示没有新的字符输入,
处理器不再读取输入寄存器, 否则有新的字符输入, 则处理器执行Load指令,
读入输入寄存器的ASCII码值.</p>
<h5 id="中断驱动和轮询">中断驱动和轮询</h5>
<p>I/O设备和处理器交互的方式有两种: 中断驱动和轮询.
它们之间的根本区别在于谁控制这个交互.</p>
<p>以键盘和CPU之间的交互为例, 如果由键盘控制交互过程,
那么处理器只需要做自己的事情, 当键盘数据准备好时,
它会主动通知寄存器进行读取, 这种就是”中断驱动”.
而如果交互过程是由处理器控制, 那么处理器必须不断读取,
测试状态寄存器的内容, 直到Ready位被置位(说明有新的字符输入),
于是从寄存器中读取数据, 这种就是”轮询”.</p>
<h4 id="键盘输入">键盘输入</h4>
<p>将字符从键盘输入需要两个条件:</p>
<ol type="1">
<li>数据寄存器: 用来存放键盘输入字符的ASCII值,
这可以通过<strong>键盘数据寄存器(<code>KBDR</code>,地址是<code>0xFE02</code>)</strong>实现,<code>KBDR</code>的第0~7位用来储存输入字符的ASCII码.</li>
<li>同步机制: 用告诉处理器数据已经准备好的方法,
这可以通过<strong>键盘状态寄存器(<code>KBSR</code>,地址是<code>0xFE00</code>)</strong>实现,<code>KBSR</code>的第15位用以储存同步信息(Ready位).</li>
</ol>
<p><code>KBSR[15]</code>的作用是控制处理器(快速)和键盘(慢速)之间的同步.
当某个按键被按下, 该键对应的ASCII码被存入<code>KBDR[7:0]</code>的同时,
键盘硬件电路自动将<code>KBSR[15]</code>置为1;
当LC-3读取<code>KBDR</code>时, 键盘自动清除<code>KBSR[15]</code>.
<code>KBSR[15]=0</code>意味着键盘可以继续输入,
而<code>KBSR[15]=1</code>意味着上次输入的字符还没有被取走,
即键盘无法继续输入其他字符. 在轮询(处理器控制的I/O)方式下,
程序将反复读取并测试<code>KBSR[15]</code>位.</p>
<p>如下程序的功能是将键盘<code>KBDR</code>寄存器中的ASCII值读取到本地寄存器<code>R0</code>中,然后跳转至下一个任务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START    LDI   R1,A</span><br><span class="line">         BRzp  START</span><br><span class="line">         LDI   R0,B</span><br><span class="line">         BRnzp NEXT_TASK</span><br><span class="line">A        .FILL xFE00</span><br><span class="line">B        .FILL xFE02</span><br></pre></td></tr></table></figure>
<p>解释: 第一二行构成<code>KBSR[15]</code>的循环测试,
<code>LDI</code>指令将地址<code>0xFE00</code>(<code>0xFE00</code>是<code>KBSR</code>寄存器的内存映射地址)处的值载入<code>R1</code>,
如果<code>KBSR[15]=0</code>, 则程序跳回<code>START</code>处继续循环,
如果有键盘输入的话,
那么该键的ASCII码被装入<code>KBDR</code>,同时<code>KBSR[15]</code>被置位(这是最高位,
如果被置位, 那么<code>R1</code>中的值就是负数, 这一点很重要),
这意味着程序进入第三行代码,
<code>LDI</code>指令将地址<code>0xFE02</code>(<code>0xFE02</code>是<code>KBDR</code>寄存器的内存映射地址)处的值载入<code>R0</code>.于是读取键盘输入过程完毕,程序无条件跳转至<code>NEXT_TASK</code>.</p>
<h4 id="显示器输出">显示器输出</h4>
<p>在显示器工作时:</p>
<ol type="1">
<li>输出数据寄存器是<code>DDR</code>, 内存映射地址是<code>0xFE06</code>,
<code>DDR</code>的第7~0位用来存放数据</li>
<li>状态寄存器是<code>DSR</code>,内存映射地址是<code>0xFE04</code>,
<code>DSR</code>的第15位是Ready位</li>
</ol>
<p><code>DSR[15]</code>用来同步处理器(快速)和显示器(慢速).
在LC-3将单个字符的ASCII码输入到<code>DDR[7:0]</code>的同时,
显示器硬件电路自动把<code>DSR[15]</code>清零(表示显示器”忙”,当前正在处理字符),
然后开始<code>DDR[7:0]</code>的数据的处理;
当显示器完成字符到屏幕的输出后, 电路自动将<code>DSR[15]</code>置位,
这表示显示器已经完成工作, 处理器可以继续下一个字符的输出.</p>
<p>下面这段程序是将<code>R0</code>中的字符输出到显示器上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START LDI   R1, A</span><br><span class="line">      BRzp  START</span><br><span class="line">      STI   R0, B</span><br><span class="line">      BRnzp NEXT_START</span><br><span class="line">A .FILL xFE04</span><br><span class="line">B .FILL xFE06</span><br></pre></td></tr></table></figure>
<p>解释: 前两行反复测试<code>DSR[15]</code>,
如果其值为1(也就是<code>R1</code>是负数),
表示显示器已经完成前一个字符的显示, 那么程序跳到第三行,
把<code>R0</code>中的值放入<code>xFE06</code>,
也就是<code>DDR[7:0]</code>中,
同时硬件电路将自动清除<code>DSR[15]</code>.</p>
<h4 id="中断驱动io">中断驱动I/O</h4>
<p>中断驱动I/O的本质是, I/O设备可以实现下列功能:</p>
<ol type="1">
<li>强行中止当前程序的运行</li>
<li>使得处理器执行I/O设备的请求</li>
<li>最后恢复中断程序的执行, 并且让它感觉好像什么事情都没发生过一样</li>
</ol>
<p>中断驱动的一个优点就是, 如果I/O设备采用轮询方式,
处理器将会花费大量时间检测Ready位, 但是采用中断方式, 如果中断没有发生,
处理器可以执行其他程序, 当中断发生时, 处理器才暂停当前程序,
并自动调用相应的I/O处理程序.</p>
<h5 id="中断信号的产生">中断信号的产生</h5>
<p>中断驱动I/O包括两部分内容:</p>
<ol type="1">
<li>中断使能机制, 即I/O设备是如何通知处理器的(当设备有输入数据,
或者输出部件准备就绪时)</li>
<li>传输机制, 即I/O数据是如何在处理器和设备之间传输</li>
</ol>
<p>这两部分可以简单描述为:</p>
<ol type="1">
<li>产生中断信号, 中止当前执行程序</li>
<li>处理该中断请求</li>
</ol>
<p>我们这里先介绍第一部分的内容, 而第二部分的内容则需要用到堆栈.
设备是否必须, 且能否中断处理器(也即第一部分内容),
必须具备以下几个条件:</p>
<ol type="1">
<li>I/O设备自身确实需要服务</li>
<li>设备有请求服务的权限</li>
<li>设备中断请求的优先级高于当前处理器所运行程序的优先级</li>
</ol>
<p>如果以上三个要求都满足, 则处理器才会中止当前程序,
并相应设备的中断请求.</p>
<h5 id="来自设备的中断信号">来自设备的中断信号</h5>
<p>对于条件1(I/O设备自身确实需要服务),
就是<code>KBSR</code>和<code>DSR</code>的寄存器Ready位,
I/O设备通过设置Ready位来表示”请求服务”.</p>
<p>对于条件2(设备有请求服务的权限), 是指”中断使能标志”,
处理器通过设置该标志位, 控制I/O设备是否有上报中断的权限.
如果该标志位为1, 表示处理器允许设备发送中断信号, 否则,
表示处理器禁止接收来自该设备的中断信号.
通常状态寄存器中会包含”中断允许标志(IE)“.
<strong><code>KBSR</code>和<code>DSR</code>的第14位即为中断允许标志,
来自I/O设备的中断请求信号是IE和Ready位的逻辑与(AND)结果.</strong></p>
<h5 id="中断优先级">中断优先级</h5>
<p>对于条件3(设备中断请求的优先级高于当前处理器所运行程序的优先级),
LC-3定义了<span class="math inline">\(8\)</span>个优先级别(PL0~PL7),
数值越大, 对应的优先级越高.
一个程序的PL通常与请求运行该程序的PL(即紧迫度)相同.
如果程序当前正在运行一个特定的PL,
而此时来了一个更高级别的PL计算机访问请求,
那么当前这个优先级较低的程序将被挂起, 直到更高级的程序完成那个请求之后,
被挂起的程序才能恢复执行.
<strong>中断优先级是通过优先级编码器(一个组合逻辑电路)实现的,
它可以从中断信号中选出优先级最高的一个,
且如果被选出的优先级比当前程序优先级高, 那么则会成功生成INT中断信号,
并中止当前程序.</strong></p>
<p>详细来说, 假如我们有PL0设备, PL1设备, …, PL7设备,
它们的状态寄存器的第14, 15位AND之后, 同时输入一个优先级编码器,
从中选出一个优先级最高的一个, 产生一个3bit的输出A,
然后将这个3bit的输出A和当前程序的优先级PL B(也是3bit)进行比较,
如果A&gt;B, 那么就会成功生成INt信号.</p>
<h5 id="中断检测">中断检测</h5>
<p>指令的执行过程包括六个节拍:</p>
<p>取指令–&gt;译码–&gt;地址计算–&gt;取操作数–&gt;执行–&gt;存放结果</p>
<p>在增加了中断信号检测逻辑之后, 原先的最后一步操作,
即从存放结果到取指令的操作将出现变化:
<strong>在存放结果的同时还会进行中断信号INT的测试.</strong>
如果INT未被设置, 那么一切照旧, 控制单元将会直接返回取指令节拍;
如果INT信号有效, 则控制单元在返回取指令节拍之前, 必须完成两件事情,
一是保持足够的信息, 以备以后可以正常恢复被中断程序的执行环境,
二是将即将服务于该设备请求的程序入口地址装入PC寄存器.</p>
<h3 id="trap程序及其子程序">TRAP程序及其子程序</h3>
<p>我们需要知道, 一些资源是用户程序无法直接访问的,
它们只能被一些有合适权限的程序访问,
而”操作系统”就是有特权权限的程序.</p>
<p>以<code>TRAP</code>指令为例,
如果用户在<code>x4000</code>处要执行I/O任务,
它会请求操作系统以用户程序的身份完成这个任务. 操作系统接过控制权,
分析并处理<code>TRAP</code>指令传递的服务要求,
然后再将控制权交还给<code>x4001</code>地址的指令.
我们称这种用户程序的请求为服务调用或者系统调用.</p>
<h4 id="trap机制">TRAP机制</h4>
<p>TRAP机制包含以下要素:</p>
<ol type="1">
<li><strong>服务程序集合:</strong> 由操作系统提供, 但以用户身份执行.
这些服务程序是操作系统的组成部分, 起始于各自固定的内存地址.
LC-3最多可以支持256个服务程序.</li>
<li><strong>起始地址表:</strong> 包含256个服务程序的起始地址.
该表位于内存地址<code>x0000~x00FF</code>. 在不同的操作系统中,
该表的名称也不一样, 有的称为”系统控制块”, 有的称为”陷入矢量表”.</li>
<li><strong>TRAP指令:</strong>
用户程序如果希望操作系统以用户程序身份执行某个特定的服务程序,
并在执行结束后将控制权返回, 则可以使用TRAP指令</li>
<li><strong>链接:</strong> 通过链接返回用户程序.
它意味着操作系统所提供的从服务程序返回用户程序的机制</li>
</ol>
<h4 id="trap指令">TRAP指令</h4>
<p>在执行服务程序之前, TRAP指令需要先完成两件事:</p>
<ol type="1">
<li>根据陷入矢量表项的内容, 将PC值修改为对应于服务程序的起始地址</li>
<li>提供一种机制, 返回到调用TRAP指令的子程序.
我们称该返回机制为链接</li>
</ol>
<p>TRAP指令由两部分组成: 操作码<code>1111</code>和陷入矢量编号<span
class="math inline">\(\rm{bit}[7:0]\)</span>. 位<span
class="math inline">\([11:8]\)</span>全部为<span
class="math inline">\(0\)</span>.
陷入矢量标识了用户程序希望操作系统执行的服务程序,
例如下面的陷入矢量为<code>x23</code>.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 1 1</td>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">0 0 1 0 0 0 1 1</td>
</tr>
</tbody>
</table>
<p>TRAP指令在执行时,需要完成<span
class="math inline">\(4\)</span>项任务:</p>
<ol type="1">
<li>将8 bit的陷入矢量零扩展为16 bit地址, 并装入MAR,
例如<code>x23</code>扩展为<code>x0023</code>.</li>
<li>陷入矢量表位于内存<code>x0000~x00FF</code>,
表项<code>x0023</code>的内容(假设为<code>x04A0</code>)装入MDR</li>
<li>将当前PC值存入寄存器<code>R7</code>,
以实现返回用户程序的链接机制</li>
<li>将MDR的内容装入PC, 至此完成TRAP指令</li>
</ol>
<p>现在, PC的内容变成了<code>x04A0</code>,
因而程序从地址<code>x04A0</code>开始执行.
<code>x04A0</code>指向的是操作系统”键盘读入”程序的起始.
我们说该陷入矢量指向该TRAP程序的起始.
所以<code>TRAP x23</code>指令的作用是激活操作系统”键盘读入”的服务程序.</p>
<p>TRAP程序能够返回用户程序的下一条指令(服务程序结束之后)的前提是,
必须存在机制以保存下条指令的地址. 所以TRAP指令会在服务程序加载到PC之前,
先将原来的PC值存入<code>R7</code>. 换句话说,
TRAP指令为服务程序返回用户程序提供了所有必要的信息.
由于在TRAP指令的预取阶段, PC已经更新, 指向下一条指令,
所以在TRAP服务程序开始执行时,
<code>R7</code>中包含的是TRAP指令的下一条指令地址.</p>
<h4 id="完整机制">完整机制</h4>
<p>我们知道, 若要改变程序控制流程, 就要在当前指令的”执行”阶段修改PC值,
之后的下一个周期, CPU将会从新地址处读取指令.</p>
<p>因而, 如果要请求字符输入服务, 我们只需要在用户程序中,
调用TRAP指令的第<code>x23</code>号矢量即可.
TRAP指令将从内存地址<code>x0023</code>读取其内容<code>x04A0</code>,
并将其加载到PC中, 同时将下一条指令的地址装入<code>R7</code>.
在下一个指令周期的”取指令”节拍, 将从<code>x04A0</code>开始执行,
即请求键盘输入的操作系统服务程序.
该TRAP服务程序的结尾是<code>JMP R7</code>指令,
其作用是将<code>R7</code>的内容装入PC.
如果<code>R7</code>的内容在服务程序的执行过程中没有改变,
那么该值就是用户程序中TRAP指令的下一条指令的地址. 随后,
用户程序继续执行,
<code>R0</code>的内容就是刚才键盘输入的字符的ASCII码.</p>
<p>在TRAP服务程序中,<code>JMP R7</code>指令非常有用,
为此LC-3汇编语言中专门为这个操作定义了一个专用指令字<code>RET</code>,
如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 0 0</td>
<td style="text-align: center;">0 0 0</td>
<td style="text-align: center;">1 1 1</td>
<td style="text-align: center;">0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<h4 id="halt中断程序">HALT中断程序</h4>
<p>在现代计算机中,用TRAP指令方式来清除RUN门.在LC-3中,RUN门的内容对应机器控制寄存器(映射内存地址<code>xFFFE</code>)的第15位.</p>
<h4 id="寄存器内容的保持和恢复">寄存器内容的保持和恢复</h4>
<p>在下面的情况中, 我们需要显式地保持寄存器的内容:</p>
<ol type="1">
<li>如果该寄存器的内容会被后续操作修改</li>
<li>如果后续操作会使用该寄存器</li>
</ol>
<p>一个寄存器的原内容, 如果在修改成其他值之后还需要被使用,
那么在修改之前, 必须要将原值保存, 修改后再将其恢复. 保存的方法是,
将寄存器内容存入内存的某个位置, 恢复时, 再重新装入寄存器即可.</p>
<p>对于保存和恢复的问题, 既可以由调用程序在TRAP之前负责,
也可以由被调用程序(TRAP执行之后)来负责.
我们称<strong>由调用程序来负责该问题的方式为”调用者保存”</strong>,
称<strong>由被调用者来保存的方式为”被调用者保存”</strong>. 因此,
对于被调用者来说, 由于它知道自己的程序需要使用哪些寄存器,
所以它在执行之前会将这些程序依次放入内存, 执行结束时,
再将这些原值恢复到寄存器中. 对于调用者来说, 它知道在自己程序的操控下,
哪些寄存器的内容会被破坏, 因此在调用服务程序之前,
就把相关寄存器的内容保存到内存, 在服务程序结束之后,
恢复寄存器的原值.</p>
<h4 id="子程序">子程序</h4>
<p>我们称可以重复利用的代码为”子程序”或者”过程”,
而C语言的属于则称之为”函数”. 它们的使用机制则被称为”调用/返回机制”.</p>
<h5 id="调用返回机制">调用/返回机制</h5>
<p>调用机制的过程是, 首先计算子程序的开始地址, 然后装入PC,
然后保存调用返回地址(下一条指令地址). 在返回机制中,
将把返回地址再装入PC.</p>
<p>调用/返回机制和TRAP指令的执行过程非常相似, 两种情况下,
都是先保存返回调用程序的链接地址,
然后将程序流跳转至代码段(服务程序或者子程序). 其中,
PC装入的都是代码段的起始地址,
<code>R7</code>装入的都是返回调用者的链接地址; 代码段的最后一条语句,
无论是在中断服务程序还是子程序中, 都是<code>JMP R7</code>指令,
也就是将<code>R7</code>的内容装入PC,从而将控制权返回到调用者.</p>
<p>子程序和服务程序之间的主要区别在于TRAP指令, 在TRAP方式下,
服务程序调用了操作系统资源, 因而具备访问计算机底层硬件的特权.
它们通常由系统程序员编写, 相比之下,
子程序和调用程序可以由同一个程序员编写.</p>
<h5 id="jsrjsrr指令">JSR/JSRR指令</h5>
<p>在LC-3中, 子程序调用的指令的操作码是<code>0100</code>.
该指令的寻址模式(计算子程序的起始地址)有两种:
PC相对地址寻址和基地址寻址. 在LC-3汇编语言中, 两种模式的操作码相同,
但是助记符不同. 该指令完成两件事: 首先将返回地址存入<code>R7</code>,
然后将计算子程序起始地址并装入PC, 返回的地址就是跳转前已经增量的PC地址,
它指向调用程序中紧随JSR/JSRR指令之后的那一条指令.</p>
<p>JSR/JSRR指令由三部分组成</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">address evaluation bits</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0100\)</span>
为操作码 <span class="math inline">\(\rm{bit}[11]\)</span> 表示寻址模式,
<span class="math inline">\(1\)</span>代表PC相对寻址模式, <span
class="math inline">\(0\)</span>代表基地址寻址 <span
class="math inline">\(\rm{bit}[10:0]\)</span>
用于子程序的起始地址计算</p>
<p>JSR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PCoffet11</td>
</tr>
</tbody>
</table>
<p>地址计算方法是, 将递增后的PC值和符号位扩展后的<span
class="math inline">\(\rm{bit}[10:0]\)</span>相加.</p>
<p>例如, 有一条位于<code>x4200</code>处的JSR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">10000000100</td>
</tr>
</tbody>
</table>
<p>这条指令执行后, R7寄存器的内容为<code>x4201</code>(也就是PC+1).
PCoffset11符号扩展为<span
class="math inline">\(1111~1100~0000~0100\)</span>, 其取反加一为<span
class="math inline">\(0000~0011~1111~1100\)</span>, 用当前的PC+1(<span
class="math inline">\(0100~0010~0000~0001\)</span>)减去这个值得到<span
class="math inline">\(0011~1110~0000~0100\)</span>也就是<code>x3E05</code>,
即此时的PC值为<code>x3E05</code>.</p>
<p>JSRR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>地址计算方法是, 将递增后的PC值和基址寄存器的内容相加.</p>
<p>例如， 有一条位于<code>x420A</code>的JSRR指令如下,
R5的内容为<code>x3002</code>,</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>这条指令执行后, R7的内容为PC+1, 也就是<code>x420B</code>,
而当前PC的内容就是R5寄存器的内容， 也就是<code>x3002</code>.</p>
<h3 id="栈">栈</h3>
<h4 id="栈的基本结构">栈的基本结构</h4>
<p>“栈”的概念, 是指它的访问规则. <strong>“栈”的定义是, 最后存入的东西,
总是被第一个取走的, 我们称这种特点为”后入先出”或”LIFO,Last In First
Out”.</strong> 按照计算机的术语来说,
栈是一种<strong>抽象数据类型</strong>,
抽象数据类型指的是其存储机制的操作方式(而不是实现方法).</p>
<p>下面是栈在内存中的实现</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">&lt;-top</td>
</tr>
<tr>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x4000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">初始状态</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">压入一次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">压入三次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">弹出两次</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>栈是由一段连续内存空间和一个寄存器(栈指针)组成.
所谓”栈指针”就是一个寄存器, 里面的内容是一个地址值,
<strong>始终指向栈的顶部(即最近被压入的元素)</strong>.
上面的第一列代表最初的空栈, 第二列压入了值<span
class="math inline">\(18\)</span>, 第三列依次压入了<span
class="math inline">\(31\)</span>, <span
class="math inline">\(5\)</span>和<span
class="math inline">\(12\)</span>, 最后依次弹出值<span
class="math inline">\(12\)</span>和<span
class="math inline">\(5\)</span>,
其内容依旧存留在内存位置<code>x3FFD</code>和<code>x3FFC</code>处,
但是这两个值不能再被访问, 因为这一段内存只能通过栈机制来访问.</p>
<h5 id="压入">压入</h5>
<p>对于上面的栈的第一列, <code>R6</code>的内容是<code>x4000</code>,
即基地址(<code>x3FFF</code>)之前的一个位置, 这表明此时栈是空的.
当压入<span class="math inline">\(18\)</span>时,
栈指针指向了最后压入的值, 即<code>x3FFF</code>(储存<span
class="math inline">\(18\)</span>的位置). <strong>每压入一个值,
栈指针先递减, 然后将数值存入它所指向的地址位置</strong>,
对应的汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP      ADD   R6,R6,#-1</span><br><span class="line">         STR   R0,R6,#0</span><br></pre></td></tr></table></figure>
<h5 id="弹出">弹出</h5>
<p>如果想要从栈里面弹出一个元素,
<strong>要先通过指针提供的地址读取该数值, 然后递增指针</strong>,
对应的汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP      LDR   R0,R6,#0</span><br><span class="line">         ADD   R6,R6,#1</span><br></pre></td></tr></table></figure>
<p>其中栈顶的元素被弹出, 装入<code>R0</code>.</p>
<h5 id="下溢出">下溢出</h5>
<p>如果试图对一个空栈执行弹出操作, 将造成”下溢”问题.
为了检查是否发生”下溢”, 常用的做法是,
子程序将执行成功或者失败的信息记录在某个寄存器中. 在POP程序的流程中,
将成功或者失败的信息记录在<code>R5</code>中. 那么, POP程序返回后,
调用程序通过<code>R5</code>就可以获知执行是否成功(如果成功,
<code>R5=0</code>, 否则<code>R5=1</code>). 注意,
由于POP程序使用<code>R5</code>记录执行情况,
这就要求调用程序在<code>JSR</code>指令之前, 保持<code>R5</code>的内容.
对应的POP汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POP      LD    R1,EMPTY</span><br><span class="line">         ADD   R2,R6,R1</span><br><span class="line">         BRz   Failure</span><br><span class="line">         LDR   R0,R6,#0</span><br><span class="line">         ADD   R6,R6,#1</span><br><span class="line">         AND   R5,R5,#0</span><br><span class="line">         RET</span><br><span class="line">Failure  AND   R5,R5,#0</span><br><span class="line">         ADD   R5,R5,#1</span><br><span class="line">         RET</span><br><span class="line">EMPTY    .FILL xC000</span><br></pre></td></tr></table></figure>
<p>注意<code>RET</code>之前的那一条指令可以影响条件码,
所以调用程序也可以进行条件位<code>Z</code>的测试,
判断POP程序是否执行成功.</p>
<h5 id="上溢出">上溢出</h5>
<p>如果在栈空间全部被占用的情况下, 再往栈中压入元素,
那么就会发生”上溢”问题. 和”下溢”相似, 通过比较栈指针内容和栈底的地址,
可以判断是否发生”上溢”. 如果两个值相等, 则意味着栈空间已经满了.
要求PUSH程序在执行成功之时, 把数值<span
class="math inline">\(0\)</span>存入<code>R5</code>, 失败时将数值<span
class="math inline">\(1\)</span>存入<code>R5</code>. 于是,
PUSH程序返回后, 调用程序通过检查<code>R5</code>的内容,
即可判断PUSH的执行是否成功. PUSH汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUSH     LD    R1,MAX</span><br><span class="line">         ADD   R2,R6,R1</span><br><span class="line">         BRz   Failure</span><br><span class="line">         ADD   R6,R6,#-1</span><br><span class="line">         STR   R0,R6,#0</span><br><span class="line">         AND   R5,R5,#0</span><br><span class="line">         RET</span><br><span class="line">Failure  AND   R5,R5,#0</span><br><span class="line">         ADD   R5,R5,#1</span><br><span class="line">         RET</span><br><span class="line">MAX      .FILL xC005</span><br></pre></td></tr></table></figure>
<h4 id="中断驱动io-1">中断驱动I/O</h4>
<p>我们回忆中断驱动I/O包括两个部分:</p>
<ol type="1">
<li>中断使能机制: 在有输入数据需要传递或者准备好接收输出数据的情况下,
I/O设备具备向处理器发出中断的能力.</li>
<li>I/O数据传输的管理能力(即中断处理程序)</li>
</ol>
<p>所谓的中断使能机制, 就是发出INT信号的能力, 通过READY和IE的组合,
设备可以发出中断请求信号,
且只有在中断使能信号大于当前程序优先级的情况下, INT信号才能有效.</p>
<p>而中断处理程序包含以下三个阶段:</p>
<ol type="1">
<li>中断服务程序的启动</li>
<li>中断服务程序的执行</li>
<li>中断服务程序的返回</li>
</ol>
<h5 id="启动和执行">启动和执行</h5>
<p>当一个设备成功发出INT信号时, 就会启动中断. 从处理器角度来看,
它每执行完一条指令之后, 都会检查INT信号, 如果INT信号有效,
则暂停下一条指令的读取, 如果无效, 则继续下一条指令的执行.</p>
<p>此时开始中断执行的准备工作, 以启动中断服务程序,
准备工作包括如下内容:</p>
<ol type="1">
<li><strong>保存当前执行程序的状态</strong>, 使得从中断服务程序返回时,
可以从当前的程序继续运行</li>
<li><strong>装载中断服务程序的工作状态</strong>, 开始中断请求的服务</li>
</ol>
<h6 id="程序状态">程序状态</h6>
<p>所谓程序状态, 就是该程序运行所涉及的资源的快照.
<strong>它包括程序的内存空间和通用寄存器的内容,
以及两个重要的寄存器PC和PSR.</strong> PSR寄存器就是处理器状态寄存器,
它包含了与运行程序相关的重要信息, 具体字段含义如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15</th>
<th style="text-align: center;">14 13 12 11</th>
<th style="text-align: center;">10 9 8</th>
<th style="text-align: center;">7 6 5 4 3</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Pr</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PL</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">P</td>
</tr>
</tbody>
</table>
<p>其中</p>
<ol type="1">
<li><code>PSR[15]</code>表示该程序的运行模式,
特权模式/超级用户模式和非特权模式/用户模式. 所谓特权模式,
就是指在该模式下, 程序可以访问一般用户程序所不能访问的资源.</li>
<li><code>PSR[10:8]</code>表示正在执行程序的优先级别,
总共有8种优先级PL0~PL8</li>
<li><code>PSR[2:0]</code>表示条件码</li>
</ol>
<h6 id="被中断程序的状态保存">被中断程序的状态保存</h6>
<p>中断启动的第一个任务, 就是保存正在运行程序的状态,
使得I/O设备请求的服务完成后, 程序可以继续运行. 对于LC-3,
也就是保存PC和PSR.</p>
<ol type="1">
<li>保存<strong>PC</strong>,
是因为它保存了中断返回后的下一条指令的地址</li>
<li>保存<strong>条件码</strong>, 是因为后续程序可以用它完成条件跳转</li>
<li>保存<strong>被中断程序的优先级</strong>,
是因为它提供被中断程序与其他程序相比的迫切程度, 被中断程序的恢复执行时,
可能还会有其他级别的程序再次中断它</li>
<li>保存<strong>被中断程序的特权级别</strong>,
是因为它表明了被中断程序可以访问的资源范围</li>
</ol>
<p>注意第2, 3, 4条都包含在PSR中.</p>
<p>一般情况下, 我们认为通用寄存器的内容没有必要进行保存,
因为我们假定中断服务程序在动用它们之前已经自动保存了,
并且在中断返回前恢复原值.</p>
<p>LC-3将这些需要保持的信息存放在”超级用户栈”中,
该栈空间只供特权模式下的程序使用, 它们也是内存空间的一部分,
只是它与用户程序的用户栈空间是相互隔离的.</p>
<p>所有程序都通过<code>R6</code>栈指针来访问栈空间: 在用户模式下,
<code>R6</code>指向用户栈空间, 在超级用户模式下,
<code>R6</code>指向超级用户栈空间. 在未使用的情况下,
内部寄存器Saved.SSP(超级用户栈指针寄存器)和Saved.USP(用户栈指针寄存器)分别用于保存两个栈指针的内容,
例如, 当特权模式从用户模式切换到超级用户模式时,
原先的<code>R6</code>内容就会被放入Saved.USP内,
然后将Saved.SSP的内容放入<code>R6</code>.
这意味着在中断服务程序开始之前,
<code>R6</code>已经装入了超级用户栈指针的内容,
而PC和PSR寄存器的内容已经被压入超级用户栈.</p>
<h6 id="中断服务程序的状态装入">中断服务程序的状态装入</h6>
<p>被中断程序的状态信息被装入超级用户栈之后,
下一步的任务是装入中断服务程序的PC和PSR内容,
中断服务程序和TRAP指令很相似, 它们的代码都事先存放于特定的内存地址中,
它们服务的都是中断请求.</p>
<p>在中断情况下, I/O设备在发出中断时, 向处理器传递一个8
bit的矢量值(以及中断请求信号和设备优先级).
在多个设备同时请求中断处理的情况下, 优先级最高的请求被选中并交给处理器,
我们称之为INTV, 如果该中断被处理器接收, 它将该8
bit的中断矢量(INTV)扩展成一个16 bit的地址,
即中断矢量表中的某一个表项地址.
中断矢量表的内存地址为<code>x0100~x01FF</code>(TRAP矢量表的内存地址为<code>x0000~x00FF</code>),
每个表项包含了一个中断服务程序的起始地址,
处理器将扩展之后的中断矢量INTV地址的内容(即表项矢量的内容)装入PC.</p>
<p>PSR寄存器的装入过程如下: 由于在中断服务程序中, 还没有指令执行过,
所以<code>PSR[2:0]</code>的内容初始化为0,
而中断服务程序是在特权模式下运行的, 所以<code>PSR[15]=0</code>,
<code>PSR[10:8]</code>被设置为中断请求者(即设备)的优先级.</p>
<p>至此我们就完成了中断服务的启动阶段.</p>
<h6 id="中断服务">中断服务</h6>
<p>此时PC的内容就是中断服务程序的起始地址,
所以下一个开始执行的就是中断服务程序了, 即I/O设备的请求开始被服务了</p>
<h6 id="中断返回">中断返回</h6>
<p>中断服务程序的最后, 是中断返回指令RTI. 当处理器遇到RTI指令时,
表明I/O设备的请求已经完成.</p>
<p>RTI指令(操作码1000)的任务是, 将PC和PSR的内容弹出超级用户栈,
然后将它们填入处理器中的正确的位置. 现在,
条件码的值已经恢复成程序被中断之前的值,
同样特权级别<code>PSR[15]</code>和优先级别<code>PSR[10:8]</code>的内容也被恢复,
PC的内容恢复成中断前的下一条待执行指令.</p>
<h6 id="例子-嵌套中断">例子: 嵌套中断</h6>
<p>程序A位于内存地址<code>x3000~x3010</code>,
在执行<code>x3006</code>的<code>ADD</code>指令时, 设备B发出了中断请求,
导致矢量<code>xF1</code>的INT产生.</p>
<p>设备B的中断服务程序位于内存地址<code>x6200~x6210</code>中,
<code>x6210</code>处为RTI指令,
在执行<code>x6202</code>的<code>AND</code>指令时, 设备C又发出了中断请求,
导致矢量<code>xF2</code>的INT产生.</p>
<p>设备C的中断服务程序位于内存地址<code>x6300~x6315</code>中,
<code>x6315</code>处为RTI指令</p>
<p>下面是该例子在运行过程中, 超级用户栈和PC的内容快照:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;">&lt;-Saved.SSP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;">&lt;-Saved.SSP</td>
</tr>
<tr>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x3006</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6200</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6300</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>第一列是程序A在读取<code>x3006</code>指令前的超级用户栈和PC值.
注意图中标识的栈指针是Saved.SSP, 而不是<code>R6</code>.
由于此时中断尚未发生, 所以<code>R6</code>指向的是用户栈.
在<code>x3006</code>指令执行的最后, 检测到INT信号(来自设备B的中断).</p>
<p>第二列是程序A的状态被保存在超级用户栈, 为了可以使用超级用户栈,
先将当前<code>R6</code>的内容放入Saved.USP寄存器,
然后将Saved.SSP的内容放入<code>R6</code>,
随后PC的内容(也就是程序A的下一条指令的地址)<code>x3007</code>被压入超级用户栈,
同样, <code>ADD</code>指令产生的操作码和PSR信息也被压入超级用户栈;
再随后, 设备B的中断矢量扩展为<code>x01F1</code>,
<code>x01F1</code>的内容<code>x6200</code>被装入PC.
设备B的中断服务程序开始执行</p>
<p>第三列是在<code>x6202</code>指令执行周期结束时,
又检测到更高优先级的中断, 随后,
地址<code>x6203</code>被压入超级用户栈中,
同时被压入的还有B程序的PSR内容(包含<code>AND</code>指令产生的条件码信息),
设备C的中断矢量被扩展为<code>x01F2</code>,
<code>x01F2</code>的内容<code>x6300</code>被装入PC.
设备C的中断服务程序开始执行.</p>
<p>第四列是程序C在执行<code>x6315</code>的RTI指令之后,
超级用户栈被两次弹出,
一是恢复程序B的PSR内容(包含位于<code>x6202</code>的<code>AND</code>指令所产生的条件码),
二是恢复PC的内容为<code>x6203</code>.</p>
<p>第五列是程序B从<code>x6203</code>开始恢复执行,
直到<code>x6210</code>的RTI指令结束, 超级用户栈再次被弹出两次,
恢复程序A的PSR(包括位于<code>x3006</code>处的<code>ADD</code>指令所产生的条件码)和PC(<code>x3007</code>).
之后, 由于程序A运行在用户模式下,
所以<code>R6</code>的内容被存入Saved.SSP,
装入<code>R6</code>的是Saved.USP的内容. 最后,
程序A从<code>x3007</code>的指令开始继续执行.</p>
<h2 id="第三部分c语言">第三部分:C语言</h2>
<h3 id="高级语言翻译">高级语言翻译</h3>
<p>高级语言有两种翻译方法:</p>
<ol type="1">
<li>解释执行, 负责翻译的程序称为”解释器”, 它读入高级语言程序,
然后按照高级程序的语义执行相应的操作. 真正的执行者不是高级语言代码本身,
而是解释器程序</li>
<li>编译执行, 负责翻译的程序称为”编译器”, 它将高级语言程序读入,
然后翻译成机器代码, 又称为可执行映像,
该映像是可以直接在机器上执行的.</li>
</ol>
<p>无论是解释器还是编译器, 其本身也是一个程序.</p>
<h4 id="解释执行">解释执行</h4>
<p>解释器逐个读入每条命令, 然后按照语言规范的语义完成命令.
高级语言程序只是向解释器提供一组”数据”, 而不能直接被硬件执行. 换句话说,
解释器如同一个虚拟机, 高级语言只是在虚拟机上被执行的程序.</p>
<h4 id="编译执行">编译执行</h4>
<p>在编译执行方式中, 整个高级语言被全部翻译成机器码, 然后在机器上执行.
为了保证程序翻译的有效性, 在翻译之前,
编译器会在更大的范围内做分析(通常是整个源文件). 通常程序只需要编译一次,
然后就可以多次执行. 编译器是这样一个系统,
它能处理一个或者多个包含高级语言程序的文件, 生成一个”可执行映像”,
编译器本身不执行程序, 它只负责翻译任务, 即将高级语言翻译成机器语言.</p>
<h3 id="c编程语言">C编程语言</h3>
<p>这里采用的C语言遵循ANSI C标准, 只要编译器是ANSI C兼容的,
那么就可以编译这里的C语言代码.</p>
<h4 id="c编译器">C编译器</h4>
<p>C编译器能够将C源程序翻译为一个可执行映像.
可执行映像是一个用机器语言表示的, 具备内存装载信息的可执行程序.
整个编译过程将涉及预处理器, 编译器和链接器等组件.
通常我们把它们统称为”编译器”. 编译器在处理过程中,
将自动调用预处理器和链接器等组件.</p>
<ol type="1">
<li>预处理器: C预处理器扫描所有的C源文件,
寻找并执行其中的预处理指令.</li>
<li>编译器: 经过预处理之后的程序, 由编译器继续翻译成”目标模块”.
目标模块是程序的一个组成部分, 是机器语言代码形式. 编译过程包括两个阶段.
一是”分析”或”语法分析”, 即将源程序分解为更小的组成单元; 二是”合成”,
即生成机器语言代码. 分析阶段的任务是读入, 分析源代码,
并构建编译器内部格式的数据结构; 而合成阶段的任务则是生成机器码,
以及根据编译指令优化机器代码. 符号表是编译器中一个重要的内部数据结构,
它记录了程序中使用过的所有符号.</li>
<li>链接器: 所有的目标代码生成后, 将由链接器完成后续处理.
链接器的任务是将各个目标模块组装成一个可执行映像.
可执行映像是一种具有特定格式的机器语言程序,
具有可装载性和可直接执行这两个特性. C程序对于库函数的依赖非常强.
库函数中包含了最常用的一些操作函数, 它们以库函数的方式存在.
这些库函数通常由系统软件(如操作系统, 编译器)的开发者编写. 在用户程序中,
如果调用了库函数, 则链接器将负责查找该函数在库文件中的位置,
并拷贝对应目标代码, 然后”链接”入可执行映像.</li>
</ol>
<h3 id="变量和运算符">变量和运算符</h3>
<h4 id="变量">变量</h4>
<h5
id="三种基本数据类型intchardouble">三种基本数据类型:int,char,double</h5>
<ol type="1">
<li><code>int</code>: 标识符<code>int</code>声明的是一个有符号整数变量.
整数类型的内部表示及其数值大小的范围, 取决于不同的ISA以及所使用的编译器.
一般情况下, C语言的<code>int</code>和底层的ISA的字长相对应.</li>
<li><code>char</code>:
标识符<code>char</code>声明的是一个字符类型的数据.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> key=<span class="string">&#x27;Q&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里变量<code>key</code>的初始值是大写字母<code>Q</code>的ASCII码值.注意<code>Q</code>被单引号包围,表明这是一个ASCII字符值.</p>
<ol start="3" type="1">
<li><code>double</code>:
标识符<code>double</code>声明的是一个浮点类型变量.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">2.1E2</span>; <span class="comment">/*这是210.0*/</span></span><br><span class="line"><span class="type">double</span> b = <span class="number">-2E-1</span>; <span class="comment">/*这是-0.2*/</span></span><br></pre></td></tr></table></figure>
<h5 id="局部变量和全局变量">局部变量和全局变量</h5>
<p>在C语言中, 程序中的变量声明是向编译器传递以下三类信息: 变量的标识符,
类型, 作用域. 对于前两者, 编译器可以直接从变量声明语句中获取,
但是有关作用域, 编译器则要通过声明语句所在位置判断.</p>
<ol type="1">
<li>局部变量: 有些变量是在它们所在代码块的开始处声明, 我们称为局部变量.
这里所说的代码块指的是用一对大括号包括起来的代码.
局部变量只能在当前代码块中被访问.</li>
<li>全局变量: 全局变量在整个程序的生命周期内都占有独立的空间及其内容,
可以在程序的任意地方被访问.</li>
</ol>
<h4 id="运算符">运算符</h4>
<h5 id="赋值运算符">赋值运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">x = x + <span class="number">4</span>;</span><br><span class="line">x = x + <span class="number">4.0</span>;  </span><br></pre></td></tr></table></figure>
<h5 id="算数运算符">算数运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x + y;</span><br><span class="line">x - y;</span><br><span class="line">x * y;</span><br><span class="line">x / y;</span><br><span class="line">x % y; <span class="comment">/*取余数*/</span></span><br></pre></td></tr></table></figure>
<h5 id="位运算符">位运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1234</span> &amp; <span class="number">0x5678</span>;  <span class="comment">/*按位与，等于0x567C*/</span></span><br><span class="line"><span class="number">0x1234</span> | <span class="number">0x5678</span>;  <span class="comment">/*按位或，等于0x1230*/</span></span><br><span class="line"><span class="number">0x1234</span> ^ <span class="number">0x5678</span>;  <span class="comment">/*按位异或，等于0x444C*/</span></span><br><span class="line">~<span class="number">0x1234</span>;          <span class="comment">/*按位取反，等于0xEDCB*/</span></span><br><span class="line"><span class="number">1234</span> &amp; <span class="number">5678</span>;      <span class="comment">/*按位与，等于1026*/</span></span><br><span class="line"><span class="number">0x1234</span> &lt;&lt; <span class="number">3</span>;      <span class="comment">/*左移3位，右边补0，等于0x91A0*/</span></span><br><span class="line"><span class="number">0x1234</span> &gt;&gt; <span class="number">2</span>;      <span class="comment">/*右移2位，左边符号扩展，等于0x048D*/</span></span><br><span class="line"><span class="number">1234</span> &lt;&lt; <span class="number">3</span>;        <span class="comment">/*等于9872*/</span></span><br><span class="line"><span class="number">1234</span> &gt;&gt; <span class="number">2</span>;        <span class="comment">/*等于308*/</span></span><br></pre></td></tr></table></figure>
<h5 id="关系运算符">关系运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;,&lt;,&lt;=,&gt;=,==,!=;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑运算符">逻辑运算符</h5>
<p>在C语言中, 任何非零值都是逻辑真, 数值零被认为逻辑假.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!        <span class="comment">/*逻辑非*/</span></span><br><span class="line">&amp;&amp;       <span class="comment">/*逻辑与*/</span></span><br><span class="line">||       <span class="comment">/*逻辑或*/</span></span><br></pre></td></tr></table></figure>
<h5 id="递增递减运算符">递增/递减运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x++;    <span class="comment">/*先把x赋给y，然后自增*/</span></span><br><span class="line">y = ++x;    <span class="comment">/*x先自增，然后把新的值赋给y*/</span></span><br></pre></td></tr></table></figure>
<h4 id="编译器处理">编译器处理</h4>
<p>编译器在完成翻译工作的时候, 需要借助于两个机制:</p>
<ol type="1">
<li>符号表: 编译器在编译过程中, 将与变量相关的信息记录在”符号表”中.</li>
<li>内存的系统分配: 根据变量特性分配内存. 编译器将从整个系统层面,
为不同类别的对象划分不同的内存区域.</li>
</ol>
<p>我们看一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> amount;</span><br><span class="line">   <span class="type">int</span> rate;</span><br><span class="line">   <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> hours;</span><br><span class="line">   <span class="type">int</span> minutes;</span><br><span class="line">   <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;How many bytes of data to be transferred?&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;amount);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;What is the transfer rate?&quot;</span>)</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rate)</span><br><span class="line"></span><br><span class="line">   time = amount / rate;</span><br><span class="line"></span><br><span class="line">   hours = time / <span class="number">3600</span>;</span><br><span class="line">   minutes = (time % <span class="number">3600</span>) /<span class="number">60</span>;</span><br><span class="line">   seconds = ((time % <span class="number">3600</span>) % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time: %dh %dm %ds\n&quot;</span>, hours, minutes, seconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="符号表">符号表</h5>
<p>编译器在扫描程序代码时, 每遇到一个变量声明语句,
就在符号表中创造一个新的表项. 表项结构中包含很多字段信息,
这些字段信息与变量的存储空间管理以及变量操作代码生成等都有关.
这些字段包括: 名字, 类型, 已分配的内存地址,
变量声明域或作用域等信息.</p>
<p>下面的符号表对应上面的代码. 注意,
编译器采用偏移方式记录变量在内存中的位置.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">标识</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">位置(偏移量)</th>
<th style="text-align: center;">范围</th>
<th style="text-align: center;">其他信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">amount</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">hours</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">minutes</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-4</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">rate</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">seconds</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-5</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">time</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-2</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
<h5 id="变量的空间分配">变量的空间分配</h5>
<p>在C语言中, 存放变量内容的内存空间(变量的分配空间)有两种区段:
<strong>全局数据段</strong>和<strong>运行时栈</strong>.
全局数据段是内存中存放全局变量的区段, 运行时栈是局部变量所在的地方.
符号表中的偏移字段提供了有关变量在内存中的更精确的位置信息,
它代表的是变量存储地址距离内存段基地址的偏移(或距离).</p>
<p>在编译器生成的机器代码中, R4是一个专用寄存器,
它存放的是全局数据段的基地址(或起始地址), 所以R4可以被视为是全局指针.
而一个函数中所有的局部变量都存放在一个被称为<strong>活动记录</strong>或者<strong>堆栈帧</strong>的内存模板中.
所谓的活动记录, 就是一段连续的内存空间,
它包含了当前函数中所有的局部变量. 每个函数都有自己的活动记录.
当我们调用一个函数时, 该函数活动记录的最大地址将存放在寄存器R5中,
因此R5又被称为<strong>帧指针</strong>.</p>
<p>当我们调用一个函数时, 该函数的活动记录被压入当前栈.
同时R5的内容被调整, 指向当前栈顶(即记录的基地址).
这表明可以通过栈指针访问函数内的局部变量. 当该函数结束,
即将把控制权交还给调用者时, 活动记录将被弹出当前栈. 同样,
指针R5的内容也会被修改, 指向调用者活动记录所在位置. 整个过程中,
寄存器R6始终指向运行时栈顶, 我们称R6为<strong>栈指针</strong>.</p>
<h3 id="控制结构">控制结构</h3>
<p>一个大问题被分解成多个子任务, 然后对每个子任务独立编程.
各种子任务的基本编程结构可以分为顺序, 条件和循环.</p>
<h4 id="条件结构">条件结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">10</span>)</span><br><span class="line">   y= x^<span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">   y= x^<span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line">   z= <span class="number">2</span>*y - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x)&#123;</span><br><span class="line">   y++;</span><br><span class="line">   z--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   y--;</span><br><span class="line">   z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> month;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of the month:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(month==<span class="number">4</span> || month==<span class="number">6</span> || month==<span class="number">9</span> || month==<span class="number">11</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has 30 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(month==<span class="number">1</span> || month==<span class="number">3</span> || month==<span class="number">5</span> || month==<span class="number">7</span> || month==<span class="number">8</span> || month==<span class="number">10</span> || month==<span class="number">12</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has 31 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(month==<span class="number">2</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has either 29 days or 28 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t know that month.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环结构">循环结构</h4>
<h5 id="while语句">while语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="for语句">for语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> multiplicand;</span><br><span class="line">   <span class="type">int</span> multiplier;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(multiplicant=<span class="number">0</span>; multiplicant&lt;<span class="number">10</span>; multiplicant++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(multiplier=<span class="number">0</span>; multiplier&lt;<span class="number">10</span>; multiplier++)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, multiplier*multiplicant);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-while循环">do-while循环</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, x);</span><br><span class="line">   x = x + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="其他控制结构">其他控制结构</h4>
<h5 id="switch语句">switch语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> keypress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(keypress)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement A*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement B*/</span></span><br><span class="line">   <span class="keyword">break</span>;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement C*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement D*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="break和continue语句">break和continue语句</h5>
<p><code>break</code>的作用是立即结束其所在的循环体.<code>continue</code>的作用是,立即跳转至下一次循环.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;<span class="comment">/*output:0 1 2 3 4*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;<span class="comment">/*output:0 1 2 3 4 6 7 8 9*/</span></span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<h4 id="c语言中的函数">C语言中的函数</h4>
<h5 id="声明">声明</h5>
<p>函数声明告诉编译器函数的一些相关属性,我们又称之为”函数原型”.函数声明的内容包括:函数名,返回值类型以及输入参数列表.函数声明语句以分号结尾.</p>
<ol type="1">
<li>函数返回值类型是声明语句的第一个字段.该类型可以说int,char,double等,它描述了函数将产生的输出结果(唯一的).但是不是所有函数都有返回值,如果没有返回值,那么就称它的返回类型是void.</li>
<li>第二个字段是函数名.</li>
<li>第三个字段描述了函数所需的输入参数的类型和顺序,它们是该函数期望从调用者获取的参数类型和传入顺序.</li>
</ol>
<h5 id="调用">调用</h5>
<p>调用是只需提供函数名和对应的输入参数,注意输入参数的类型要与声明中的类型相匹配.</p>
<h5 id="定义">定义</h5>
<p>函数定义和函数声明几乎一样,除了前者后面不需要分号.函数名后面是函数的正则化参数列表,所谓正则化参数列表就是一组变量的声明,每个变量的内容都被初始化为调用者提供的对应数值.调用者传递的形式参数必须和正则化参数列表中定义的参数类型和顺序相匹配.</p>
<h5 id="返回">返回</h5>
<p>如果函数要返回一个值,那么关键词<code>return</code>必须跟随一个表达式,且该表达式的类型必须与函数声明的返回值类型相匹配.而没有返回值的函数(声明为<code>void</code>的函数),不需要<code>return</code>语句.</p>
<h4 id="c语言函数的实现">C语言函数的实现</h4>
<h2 id="第四部分cache">第四部分:Cache</h2>
<h3 id="计算机存储系统概述">计算机存储系统概述</h3>
<p>内部存储器有寄存器, 主存, Cache, 以字节或者字为单位表示;
外部存储器有光盘, 磁带, 磁盘等, 以字节表示.</p>
<p>存取时间: 从地址放到总线上到获得有效数据所需的时间,
是一次读/写操作的时间.</p>
<p>存储周期: 存取时间+下一次存取开始之前所需的时间</p>
<p>传送速率: 数据传入或传出存储单元的速率</p>
<p>物理类型: 半导体, 磁介质, 光介质; 物理特性: 易失性存储器,
非易失性存储器.</p>
<p>计算机的存储系统利用了局部性原理.</p>
<h3 id="cache存储器原理">Cache存储器原理</h3>
<p>Cache的作用: Cache位于CPU和主存之间, 当CPU试图访问主存内的某个字时,
首先检查这个字是否在Cache中, 如果是, 那么直接把这个字传送给CPU; 否则,
就将存储中<strong>包含这个字的固定大小的块</strong>读入Cache中,
然后再传送改字到CPU.</p>
<p>主存的结构: 由<span
class="math inline">\(2^n\)</span>个可寻址的字/字节组成(<span
class="math inline">\(n\)</span>为地址线长度),
主存分成定长的块(每块包含<span class="math inline">\(K\)</span>字节),
因此主存有<span class="math inline">\(M=2^n/K\)</span>个块.</p>
<p>Cache的结构: 包含<span class="math inline">\(m\)</span>行,
每一行包括: <span
class="math inline">\(K\)</span>个字节的块+标记Tag(标记当前存储的哪一行)+控制位.</p>
<p><strong>主存的每一个块对应于Cache的一行.</strong></p>
<h4 id="cache的读操作流程">Cache的读操作流程</h4>
<ol type="1">
<li>CPU请求内存位置的内容</li>
<li>检查此数据的Cache</li>
<li>如果存在, 则直接从Cache中获取</li>
<li>如果不存在, 则从主存中读取所需的块到Cache</li>
<li>然后Cache交付给CPU</li>
<li>Cache包括标签, 用于标识每个缓存行对应哪个主存块</li>
</ol>
<h3 id="cache结构的设计">Cache结构的设计</h3>
<h4 id="cache的映射">Cache的映射</h4>
<h5 id="直接映射">直接映射</h5>
<p>直接映射就是主存中的块会映射到一个固定的Cache行.</p>
<p>在直接映射关系中地址(<span
class="math inline">\(s+w\)</span>)可以分成两部分:</p>
<ul>
<li>高<span
class="math inline">\(s\)</span>位用于指定主存中唯一的块</li>
<li>低<span
class="math inline">\(w\)</span>位用于指定某个块中唯一的一个字或者字节</li>
</ul>
<p>高<span
class="math inline">\(s\)</span>位又被分成一个Cache行字段<span
class="math inline">\(r\)</span>(用于确定块属于哪一确定的行)和一个<span
class="math inline">\(s-r\)</span>位的标签Tag(用于区分属于同一行的不同块).</p>
<p>总结:</p>
<ul>
<li>地址长度<span class="math inline">\(=s+w\)</span>位</li>
<li>可寻址单位数<span
class="math inline">\(=2^{s+w}\)</span>字/字节</li>
<li>块大小<span class="math inline">\(=\)</span>行大小<span
class="math inline">\(=2^w\)</span>字/字节</li>
<li>主存中块数<span class="math inline">\(=2^{s+w}/2^w=2^s\)</span></li>
<li>Cache中的行数<span class="math inline">\(=m=2^r\)</span></li>
<li>标签的大小<span class="math inline">\(=s-r\)</span>位</li>
</ul>
<p>优点: 技术简单, 实现起来花费少. 缺点: 可能出现抖动现象.</p>
<h5 id="全相联映射">全相联映射</h5>
<p>存储器地址只有两部分:</p>
<ul>
<li>标签Tag: 可确定并标识唯一的一个主存的块</li>
<li>字Word: 可确定块中的唯一一个字节</li>
</ul>
<p>主存中的某个块可以被对应到任意的Cache的行.</p>
<p>优点: 替换旧的数据块很灵活.</p>
<p>缺点: 硬件复杂.</p>
<h5 id="组相连映射">组相连映射</h5>
<p>组相连映射是直接映射和全相联映射折中的方法.</p>
<p>Cache被划分为多个组, 每一组又被划分成多个行,
主存中的一个块可以被映射到一个固定组的任一行.</p>
<ul>
<li>地址长度为<span class="math inline">\(s+w\)</span>位</li>
<li>块大小<span class="math inline">\(=\)</span>行大小<span
class="math inline">\(=2^w\)</span>个字/字节</li>
<li>主存的块数<span class="math inline">\(2^s\)</span></li>
<li>Cache每个组的行数<span class="math inline">\(=k\)</span></li>
<li>Cache的组数<span class="math inline">\(v=2^d\)</span></li>
<li>Cache的存储容量<span class="math inline">\(=k\times
2^d\)</span></li>
</ul>
<p>Cache被分成<span class="math inline">\(v=2^d\)</span>组,
每一组里面有<span class="math inline">\(k\)</span>行, 内存中的头<span
class="math inline">\(v\)</span>个块, 每个块映射到对应的第<span
class="math inline">\(v\)</span>个组中的任一行.
地址的标记Tag字段只需要与组内的<span
class="math inline">\(k\)</span>行进行匹配即可,
Word字段选择行中的第<span class="math inline">\(2^w\)</span>个字节.</p>
<h4 id="替换算法">替换算法</h4>
<p>对于直接映射, 没有选择, 因为每个数据块必须被映射到Cache的固定行,
直接替换掉对应的行数据即可.</p>
<p>对于全相联和组相联映射, 有如下的替换方法:</p>
<ul>
<li>最近最少使用</li>
<li>先进先出</li>
<li>最不经常使用</li>
<li>随机</li>
</ul>
<h4 id="cache的写策略">Cache的写策略</h4>
<h5 id="写直达策略">写直达策略</h5>
<p>所有写操作同时写主存和缓存, 这样主存中的数据总是有效的.
CPU监控主存流量, 以保持和Cache一致. 缺点是大量的数据交换,
减慢写入速度.</p>
<h5 id="写回策略">写回策略</h5>
<p>最初仅在Cache内进行数据更新, Cache行中设有更新位, 当数据更新发生时,
更新位被设置. 如果块被替换或者被替换算法选中,
只有当更新位被设置才会写入主存, 其他的缓存不同步.
缺点是部分主存内容无效, 由于这部分主存内容无效, I/O不能直接访问主存,
必须通过缓存访问主存, 硬件复杂.</p>
<h2 id="附录-lc-3指令集结构">附录 LC-3指令集结构</h2>
<h3 id="概述">概述</h3>
<ul>
<li>内存地址空间: 16位地址, 对应<span
class="math inline">\(2^{16}\)</span>个内存单元, 每个单元包含一个字,
每个字宽度是<span class="math inline">\(16\)</span>位.
地址的编号从x0000到xFFFF,
地址是用来识别每个内存单元和内存映射的I/O设备寄存器.
内存中的部分区段有特殊用途, 划分如下:
<ol type="1">
<li>x0000~x00FF: 陷入矢量表</li>
<li>x0100~x01FF: 中断矢量表</li>
<li>x0200~x2FFF: 操作系统及其内核栈空间</li>
<li>x3000~xFDFF: 用户程序占用空间</li>
<li>xFE00~xFFFF: 设备寄存器地址空间</li>
</ol></li>
<li>位编号: 量化数的每个位也是有编号的. 通常, 最右边的位是<span
class="math inline">\(\rm{bit}[0]\)</span>, 最左边的位是<span
class="math inline">\(\rm{bit}[15]\)</span>.</li>
<li>指令: 每个指令的宽度是<span class="math inline">\(16\)</span>位,
前四位(<span
class="math inline">\(\rm{bit}[15:12]\)</span>)是操作码.</li>
<li>非法操作码异常: 操作码<span
class="math inline">\(\rm{bit}[15:12]=1101\)</span>是没有定义的.</li>
<li>程序计数器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的一个寄存器,
内容是下一条执行指令所在的地址.</li>
<li>通用寄存器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的八个寄存器, 编号从<span
class="math inline">\(000\)</span>到<span
class="math inline">\(111\)</span>.</li>
<li>条件码: <span
class="math inline">\(1~\rm{bit}\)</span>宽度的三个寄存器, 分别是N , Z,
P. Load类型的指令和运算指令在向任意一个通用寄存器中写入内容时,
都会改变条件码. 而其他的指令不会改变条件码.</li>
<li>内存映射: 设备的输入输出是通过Load和Store指令完成的,
所以需要为I/O设备寄存器分配内存地址(xFE00~xFFFF).</li>
<li>中断处理</li>
<li>优先级: LC-3定义了<span class="math inline">\(8\)</span>个优先级,
其中PL7最高, PL0最低.</li>
<li>处理器状态寄存器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的寄存器,
包含了当前执行进程的状态信息. 其中PSR的<span
class="math inline">\(8\)</span>个位已经做了定义,
PSR[15]定义了执行进程的权限模式, PSR[10:8]表示当前执行进程的优先级别,
PSR[2:0]包含的是条件码(PSR[2]=N, PSR[1]=Z, PSR[0]=P).</li>
<li>权限模式: LC-3定义了两种权限模式, 特权模式和用户模式.
PSR[15]=0表示特权模式, PSR[15]=1表示用户模式.</li>
<li>权限模式异常: 如果RTI指令执行在特权模式下,
但是你试图在用户模式下执行RTI指令, 那么会产生”权限模式异常”</li>
<li>特权模式栈空间: 又称为内核栈空间. 在特权模式下,
通过SSP指针访问该内存区域. 事实上, 特权模式PSR[15]=0下,
栈指针R6就是SSP</li>
<li>用户模式栈空间: 在用户模式下, 通过USP指针访问该内存区域. 事实上,
特权模式PSR[15]=1下, 栈指针R6就是USP</li>
</ul>
<h3 id="lc-3指令集详解">LC-3指令集详解</h3>
<h4 id="add">ADD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD DR, SR1, SR2</span><br><span class="line">ADD DR, SR1, imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1+SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1+SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R2, R3, R4      ;R2&lt;-R3+R4</span><br><span class="line">ADD R2, R3, #7      ;R2&lt;-R3+7</span><br></pre></td></tr></table></figure>
<h4 id="and">AND</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND DR, SR1, SR2</span><br><span class="line">AND DR, SR1, imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1 AND SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1 ANd SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND R2, R3, R4      ;R2&lt;-R3 AND R4</span><br><span class="line">AND R2, R3, #7      ;R2&lt;-R3 AND 7</span><br></pre></td></tr></table></figure>
<h4 id="br">BR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BR  LABEL   BRnzp LABEL</span><br><span class="line">BRn LABEL   BRzp  LABEL</span><br><span class="line">BRz LABEL   BRnp  LABEL</span><br><span class="line">BRp LABEL   BRnz  LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">z</td>
<td style="text-align: center;">p</td>
<td style="text-align: center;">PCoffset9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n AND N) OR (z AND Z) OR (p AND P))</span><br><span class="line">   PC=(PC+<span class="number">1</span>)+SEXT(PCoffset9)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BRzp LOOP      ;如果最后的结果是零或者正数,那么跳转至LOOP</span><br><span class="line">BR   NEXT      ;无条件跳转至NEXT</span><br></pre></td></tr></table></figure>
<h4 id="jmp和ret">JMP和RET</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   BaseR</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC=BaseR</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   R2    ;PC&lt;-R2</span><br><span class="line">RET         ;PC&lt;-R7</span><br></pre></td></tr></table></figure>
<p>注意:RET指令可以看作JMP指令的一个特例,PC被装入R7的内容,R7扮演的是链接的作用,其内容指向子程序调用指令之后的指令地址.</p>
<h4 id="jsr和jsrr">JSR和JSRR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   LABEL</span><br><span class="line">JSRR  BaseR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PCoffet11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (bit[<span class="number">11</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=BaseR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   PC=PC+SEXT(PCoffset11);</span><br></pre></td></tr></table></figure>
<p>解释:增量PC值先保存在R7中,这是返回调用代码的链接地址,然后PC装入被调用子程序的入口地址,即等价于无条件跳转至该地址.子程序的入口地址来自基址寄存器或者是PC增量和偏移量的符号扩展之和.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   QUEUE    ;将JSR指令之后的地址装入R7,然后跳转至QUEUE</span><br><span class="line">JSRR  R3       ;将JSRR指令之后的地址装入R7,然后跳转至R3内容所指定的地址</span><br></pre></td></tr></table></figure>
<h3 id="load系列指令">Load系列指令</h3>
<h4 id="ld">LD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem((PC+<span class="number">1</span>)+SEXT(PCoffset9));</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD  R4, VALUE      ;R4&lt;-mem[VALUE]</span><br></pre></td></tr></table></figure>
<h4 id="ldi">LDI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将其对应地址中的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI  R4, ONEMORE      ;R4&lt;-mem[mem[ONEMORE]]</span><br></pre></td></tr></table></figure>
<h4 id="ldr">LDR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR DR, BaseR, offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">PCoffet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[BaseR+SEXT(offset6)];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR  R4, R2, #-5    ;R4&lt;-mem[R2-5]</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=(PC+<span class="number">1</span>)+SEXT(PCoffset9);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址直接装入DR寄存器(无需访问内存,只是将计算出来的内存单元的地址放入DR中),同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA  R4, TERTGET    ;R4&lt;-address of TARTGET</span><br></pre></td></tr></table></figure>
<h3 id="not">NOT</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT DR, SR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11111</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=NOT(SR);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT R4, R2    ;R4&lt;-NOT(R2)</span><br></pre></td></tr></table></figure>
<h3 id="rti">RTI</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTI</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">000000000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PSR[<span class="number">15</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=mem[R6];    <span class="comment">//R6是SSP</span></span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   TEMP=mem[R6];</span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   PSR=TEMP;</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>解释:如果当前处理器运行在特权模式,则该指令是合法的,特权模式栈顶部两个单元的内容被弹出,并分别赋值给PC和PSR.如果当前处理器运行在用户模式,则该指令的执行将引发”特权模式冲突”异常.</p>
<h3 id="store系列指令">Store系列指令</h3>
<h4 id="st">ST</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST SR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offset6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[(PC+<span class="number">1</span>)+SEXT(PCoffset9)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入改地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST    R4, HERE     ;mem[HERE]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="sti">STI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI SR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1011</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将SR的内容装入这个地址中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI   R4, NOT_HERE      ;mem[mem[NOT_HERE]]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="str">STR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   SR, BaseR, offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[BaseR+SEXT(offset6)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入该地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   R4, R2, #5   ;mem[R2+5]&lt;-R4</span><br></pre></td></tr></table></figure>
<h3 id="trap-1">TRAP</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRAP  trapvector8</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1111</td>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">trapvect8</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line">PC=mem[ZEXT(trapvect8)];</span><br></pre></td></tr></table></figure>
<p>解释:首先将PC增量装入R7(为服务返回程序做准备).然后将由trapvector8指定的系统调用的入口地址装入PC(等价于跳转).注意,这个入口地址的计算是间接的,即先将trapvector8零扩展为一个<span
class="math inline">\(16~\rm{bit}\)</span>地址,然后读取该地址单元的内容,作为服务程序的入口地址.</p>
<h3 id="一些指令的使用辨析">一些指令的使用辨析</h3>
<p>在LC-3里, 我们应该了解load系列的指令(LD, LDI, LDR,
LEA)和store系列的指令(ST, STI, STR)应该在什么情况下使用, 我们先简要说明,
然后举一些例子.</p>
<h4 id="ld-1">LD</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：加载静态变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, VALUE     ; 将VALUE地址处的值加载到R1</span><br><span class="line">        ADD  R1, R1, #1    ; R1加1</span><br><span class="line">        ST   R1, VALUE     ; 存回VALUE</span><br><span class="line">        HALT</span><br><span class="line">VALUE   .FILL x000A        ; 静态变量，值为10</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：访问数组元素（已知索引）</span><br><span class="line">ARRAY   .FILL x0001</span><br><span class="line">        .FILL x0002</span><br><span class="line">        .FILL x0003</span><br><span class="line">        LD   R2, ARRAY     ; 加载ARRAY[0]到R2</span><br><span class="line">        LD   R3, ARRAY+1   ; 加载ARRAY[1]到R3（+1表示下一个内存位置）</span><br></pre></td></tr></table></figure>
<h4 id="ldi-1">LDI</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 示例：通过指针访问变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        ; 假设我们有一个指针指向某个数据</span><br><span class="line">        LD   R1, POINTER   ; R1 = 指针的值（地址）</span><br><span class="line">        LDI  R2, POINTER   ; R2 = MEM[POINTER]的值（间接加载）</span><br><span class="line">        </span><br><span class="line">        ; 修改指针指向的值</span><br><span class="line">        ADD  R2, R2, #1    ; R2加1</span><br><span class="line">        STI  R2, POINTER   ; 间接存储回原地址</span><br><span class="line">        </span><br><span class="line">        HALT</span><br><span class="line">POINTER .FILL x3100        ; 指针，指向地址x3100</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 在x3100处有数据：</span><br><span class="line">; x3100: .FILL x0005</span><br></pre></td></tr></table></figure>
<h4 id="ldr-1">LDR</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：遍历数组</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R2, ARRAY     ; R2 = 数组起始地址（基址）</span><br><span class="line">        AND  R3, R3, #0    ; R3 = 0（索引）</span><br><span class="line">        ADD  R4, R3, #5    ; R4 = 5（数组长度）</span><br><span class="line">LOOP    BRz  DONE</span><br><span class="line">        LDR  R1, R2, #0    ; 加载ARRAY[R3]到R1（偏移量为0）</span><br><span class="line">        ; 处理R1中的数据...</span><br><span class="line">        ADD  R2, R2, #1    ; 基址加1（下一个元素）</span><br><span class="line">        ADD  R4, R4, #-1   ; 计数器减1</span><br><span class="line">        BR   LOOP</span><br><span class="line">DONE    HALT</span><br><span class="line">ARRAY   .BLKW 5           ; 分配5个字的数组</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：结构体访问</span><br><span class="line">; 假设一个结构体：x坐标、y坐标、状态</span><br><span class="line">STRUCT  .FILL x000A       ; x坐标</span><br><span class="line">        .FILL x0005       ; y坐标</span><br><span class="line">        .FILL x0001       ; 状态</span><br><span class="line">        </span><br><span class="line">        LEA  R2, STRUCT   ; R2指向结构体起始地址</span><br><span class="line">        LDR  R3, R2, #0   ; R3 = x坐标（偏移0）</span><br><span class="line">        LDR  R4, R2, #1   ; R4 = y坐标（偏移1）</span><br><span class="line">        LDR  R5, R2, #2   ; R5 = 状态（偏移2）</span><br></pre></td></tr></table></figure>
<h4 id="lea-1">LEA</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：获取字符串地址并输出</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R0, MESSAGE   ; 将字符串地址加载到R0</span><br><span class="line">        PUTS               ; 输出字符串（PUTS使用R0作为地址）</span><br><span class="line">        HALT</span><br><span class="line">MESSAGE .STRINGZ &quot;Hello, LC-3!&quot;</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：设置数组迭代器</span><br><span class="line">        LEA  R2, ARRAY     ; R2指向数组起始地址</span><br><span class="line">        ADD  R3, R2, #5    ; R3指向数组第6个元素（偏移5）</span><br></pre></td></tr></table></figure>
<h4 id="st-1">ST</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 示例：保存计算结果</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, INPUT1</span><br><span class="line">        LD   R2, INPUT2</span><br><span class="line">        ADD  R3, R1, R2    ; R3 = R1 + R2</span><br><span class="line">        ST   R3, RESULT    ; 将结果保存到RESULT</span><br><span class="line">        HALT</span><br><span class="line">INPUT1  .FILL x0005</span><br><span class="line">INPUT2  .FILL x0003</span><br><span class="line">RESULT  .BLKW 1           ; 为结果预留空间</span><br><span class="line">        .END</span><br></pre></td></tr></table></figure>
<h4 id="sti-1">STI</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 示例：通过指针修改变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, NEW_VALUE</span><br><span class="line">        STI  R1, POINTER   ; 将R1的值存储到POINTER指向的地址</span><br><span class="line">        HALT</span><br><span class="line">POINTER .FILL x3100        ; 指向x3100</span><br><span class="line">NEW_VALUE .FILL x0007</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; x3100处原本可能有一个值，现在被修改为7</span><br></pre></td></tr></table></figure>
<h4 id="str-1">STR</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 示例：向数组写入数据</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R2, ARRAY     ; R2指向数组起始地址</span><br><span class="line">        AND  R3, R3, #0</span><br><span class="line">        ADD  R3, R3, #1    ; R3 = 1（要存储的值）</span><br><span class="line">        </span><br><span class="line">        ; 存储到数组的不同位置</span><br><span class="line">        STR  R3, R2, #0    ; ARRAY[0] = 1</span><br><span class="line">        ADD  R3, R3, #1</span><br><span class="line">        STR  R3, R2, #1    ; ARRAY[1] = 2</span><br><span class="line">        ADD  R3, R3, #1</span><br><span class="line">        STR  R3, R2, #2    ; ARRAY[2] = 3</span><br><span class="line">        </span><br><span class="line">        HALT</span><br><span class="line">ARRAY   .BLKW 5           ; 分配5个字的数组</span><br><span class="line">        .END</span><br></pre></td></tr></table></figure>
<h2 id="实验">实验</h2>
<h3 id="习题1">习题1</h3>
<p>比较R2和R3的内容, 并将最大值放入R1寄存器, 如果两个数相同,
则要求R1等于0. 要求程序起始地址为<code>x3000</code>,
程序完成后正常结束.</p>
<h4 id="实验步骤与实验思路">实验步骤与实验思路:</h4>
<p>首先写好起始地址<code>.ORIG x3000</code>和结束语句<code>.END</code>.</p>
<p>比较两个寄存器的内容的大小可以用减法, 但是LC-3指令集没有提供减法运算,
所以具体做法是, 先对<code>R3</code>取反再加一,
放到<code>R0</code>寄存器里面, 然后和<code>R2</code>相加,
结果放在<code>R0</code>寄存器里面.</p>
<p>根据减法的结果(正数, 负数,
零)跳转(也就是使用<code>BR</code>指令)到对应的后续操作. 如果是正数,
说明<code>R2</code>大, 把<code>R2</code>放到<code>R1</code>里面;
如果是零, 说明两个数相等, 把<code>R1</code>清零即可; 如果是负数,
就把<code>R3</code>的值放入<code>R1</code>里面.</p>
<h4 id="实现代码">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    NOT R0, R3</span><br><span class="line">    ADD R0, R0, #1  ;取R3的补码, 放到R0里面</span><br><span class="line">    ADD R0, R2, R0  ;计算R2-R0, 结果放到R0里面</span><br><span class="line">    </span><br><span class="line">    BRz ZERO        ;如果结果为0, 则跳转到ZERO, 把R0的内容放到R1里面</span><br><span class="line">    BRp POSITIVE    ;如果结果为正, 则跳转到POSITIVE, 把R2放到R1里面</span><br><span class="line">    BRn NEGATIVE    ;如果结果为负, 则跳转到NEGATIVE, 把R3放到R1里面</span><br><span class="line"></span><br><span class="line">ZERO:</span><br><span class="line">    AND R1, R0, #0  ;把R1清零</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">POSITIVE:</span><br><span class="line">    ADD R1, R2, #0  ;把R2放到R1里面</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">NEGATIVE:</span><br><span class="line">    ADD R1, R3, #0  ;把R3放到R1里面</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题2">习题2</h3>
<p>实现两个正整数的除法, 要求程序从<code>x3000</code>开始执行,
被除数位于<code>x4000</code>, 除数位于<code>x4001</code>,
商放在<code>x5000</code>, 余数放在<code>x5001</code>.</p>
<h4 id="实验步骤与实验思路-1">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>根据题目要求, 先给指定的地址标签(<code>NUM1 .FILL x4000</code>,
<code>NUM2 .FILL x4001</code>, <code>QUOTIENT .FILL x5000</code>,
<code>REMAINDER .FILL x5001</code>), 方便以后使用.
我们把被除数放在<code>R1</code>里面, 除数放在<code>R2</code>里面.
两个正整数的除法就是, 用被除数减去除数, 看看可以减多少次,
所以选用<code>R3</code>作为计数器, 也就是存放商的寄存器.</p>
<p>我们用<code>R1</code>减去<code>R2</code>,
减法的结果放到<code>R1</code>里面, 如果减完为正,
说明还可以继续除以<code>R2</code>, 所以应该继续减法; 如果减完为零,
说明<code>R2</code>整除<code>R1</code>; 如果减完为负, 说明存在余数,
这时直接用这个负数加上被减数就得到余数.</p>
<h4 id="实现代码-1">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    LDI R1, NUM1  ;加载被除数到R1中</span><br><span class="line">    LDI R2, NUM2  ;加载除数到R2中</span><br><span class="line">    </span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用来计数R1可以被R2减多少次</span><br><span class="line">    NOT R2, R2</span><br><span class="line">    ADD R2, R2, #1   ;对R2取反加一</span><br><span class="line"></span><br><span class="line">DIV:</span><br><span class="line">    ADD R3, R3, #1   ;计数器先加上1</span><br><span class="line">    ADD R1, R1, R2   ;用R1减去R2, 结果存放在R1里面</span><br><span class="line">    BRp DIV          ;如果结果为正, 则重复循环</span><br><span class="line">    BRz FINISH       ;如果结果为零, 则跳转到FINISH, 说明R2整除R1, 余数为0</span><br><span class="line"></span><br><span class="line">    ADD R3 R3 -1     ;如果结果为负, 说明减过头了, 把计数器减去1</span><br><span class="line">    NOT R2 R2</span><br><span class="line">    ADD R2 R2 1</span><br><span class="line">    ADD R2 R1 R2     ;这里是计算余数, 把余数放到R2里面</span><br><span class="line">    STI R2 REMAINDER ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3 QUOTIENT  ;把商R3放到地址x5000处</span><br><span class="line">    BRp EOP</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    AND R2, R2, #0      ;把余数设为0</span><br><span class="line">    STI R2, REMAINDER   ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3, QUOTIENT    ;把商放到地址x5000处</span><br><span class="line">EOP: </span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">NUM1      .FILL x4000</span><br><span class="line">NUM2      .FILL x4001</span><br><span class="line">QUOTIENT  .FILL x5000</span><br><span class="line">REMAINDER .FILL x5001</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题3">习题3</h3>
<p>从键盘输入一个值, 范围是数字<code>0~9</code>,
字母<code>a~z</code>以及<code>A~Z</code>.
检查从<code>x3100</code>开始的十个内存单元中是否有该数值, 如果有,
则设置<code>R0=1</code>, 如果没有, 则设置<code>R0=0</code>.
程序存放于<code>x3000</code>地址.</p>
<h4 id="实验步骤与实验思路-2">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.
根据题目要求,
可以使用<code>TRAP x20</code>和<code>TRAP x21</code>进行键盘字符的读取和回显,
读取的字符的ASCII码存放到<code>R0</code>里.
我们把<code>R0</code>的值先装到<code>R1</code>里面便于后续比较,
而<code>R0</code>本身用于存放比较的结果.
我们设置<code>R2</code>作为指针指向搜索的起始地址<code>x3100</code>,
<code>R3</code>作为计数器, 计数十次.</p>
<p>做好上述的准备工作后, 下面我们编写主要的循环.</p>
<p>记循环开始处为<code>LOOP</code>, 在开始处,
首先把<code>R2</code>指向的地址的值给<code>R4</code>,
为了比较<code>R4</code>里面的值是否和<code>R1</code>中的相等,
我们采用减法, 也就是先对<code>R4</code>取反加一,
放到<code>R5</code>里面, 然后用<code>R1</code>加上<code>R5</code>,
如果结果为零, 则跳转到<code>YES</code>处,
这里的<code>YES</code>就是把<code>R0</code>置为<code>1</code>的语句;
如果结果非零, 就更新指针<code>R2</code>和计数器<code>R3</code>,
然后跳回到循环开始的位置进行下一个地址处的比较.
如果<code>R3</code>为零时仍然未找到, 就无条件跳转至<code>NO</code>处,
这里的<code>NO</code>就是把<code>R0</code>置为<code>0</code>,
最后结束程序.</p>
<h4 id="实现代码-2">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    TRAP x20   ;从键盘读取字符存放到R0</span><br><span class="line">    TRAP x21   ;回显用户输入的字符</span><br><span class="line">    </span><br><span class="line">    ADD R1, R0, #0   ;把R0的内容放入R1便于后续的比较</span><br><span class="line">    AND R3, R3, #0   ;把计数器R3清零</span><br><span class="line">    ADD R3, R3, #10  ;计数10次</span><br><span class="line">    </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向起始地址x3100</span><br><span class="line"></span><br><span class="line">    AND R0, R0, #0   ;把R0清零, 用于存放比较的结果</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    LDR R4, R2, #0   ;把指针R2指向的地址内容放到R4里面进行后续比较</span><br><span class="line">    NOT R5, R4</span><br><span class="line">    ADD R5, R5, #1   ;对R4取补码, 放入R5中</span><br><span class="line">    ADD R5, R1, R5   ;用R1减去R5, 结果放入R5中</span><br><span class="line">    BRz YES          ;如果结果为0, 则说明该内存单元的内容和输入字符是一样的, 程序跳转到YES</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1   ;如果结果不为零, 则继续循环, 把指针加一</span><br><span class="line">    ADD R3, R3, #-1  ;计数器减一</span><br><span class="line">    BRp LOOP         ;如果计数器R3的值仍然大于零, 则重复循环, 直到等于零</span><br><span class="line">    </span><br><span class="line">    AND R0, R0, #0   ;如果循环了10次, 仍然没有找到内存中有相同的字符, 则把R0清零</span><br><span class="line">    BRnzp FINISH     ;跳转到程序结束</span><br><span class="line"></span><br><span class="line">YES:</span><br><span class="line">    ADD R0, R0, #1   ;把R0加1, 说明找到了</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS .FILL x3100</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题4">习题4</h3>
<p>从键盘读取一个字符, 并且统计一个文件中该字符出现的次数,
最后在显示器上显示该数值. 假设一个文件中任意字符的出现次数很小,
即最多只有9次. 文件存放于内存<code>x4000</code>地址起始的内存位置,
内容仅包含<code>1~9, a~z, A~Z</code>.</p>
<h4 id="实验步骤与实验思路-3">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
<code>R0</code>用于读取和输出结果, <code>R1</code>存储键盘输入的结果,
用于和文件的内容比较, <code>R2</code>用作指针,
<code>R3</code>用作计数器. 首先进行初始化:
从键盘读取一个字符放入<code>R0</code>并回显,
把从键盘读取的内容放到<code>R1</code>里面, 供后续的比较,
指针<code>R2</code>指向文件的起始地址<code>x4000</code>,
把<code>R3</code>清零.</p>
<p>做好上述准备工作后, 我们开始编写主要的循环.</p>
<p>循环的开始记为<code>LOOP</code>,
首先把<code>R2</code>指针指向的地址的内容放到<code>R0</code>里面,
如果此时<code>R2</code>指向的地址的内容为空,
则直接跳转到<code>FINISH</code>显示结果; 如果内容不为空,
那么开始进行比较, 首先对<code>R1</code>取补码放到<code>R4</code>里面,
用<code>R0</code>加上<code>R4</code>, 如果结果不为零,
则跳转到<code>NO</code>,
这里<code>NO</code>就是将指针<code>R2</code>加一, 并且返回循环的开头;
如果结果为零, 则将计数器<code>R3</code>加一, 指针<code>R2</code>加一,
然后继续循环.</p>
<p>由于文件的结尾处为<code>0</code>,
所以当<code>R2</code>指向文件的结尾时, 循环结束,
程序跳转到<code>FINISH</code>,
此时计数器<code>R3</code>的内容就是文件中特定字符出现的次数,
但是如果想要把具体的数字打印到屏幕上,
则需要将<code>R3</code>内的数字转换成对应的ASCII码,
一个简单的方式就是加上<code>0</code>的ASCII码,
然后放入<code>R0</code>进行输出即可.</p>
<h4 id="实现代码-3">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20         ;从键盘读取字符放到R0里面</span><br><span class="line">    TRAP x21         ;回显</span><br><span class="line">    ADD R1, R0, #0   ;把读取的字符放到R1里面, 便于后续的比较  </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向文件起始位置x4000</span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用作计数器 </span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    LDR R0, R2, #0   ;把指针R2指向的地址内容放入R0</span><br><span class="line">    BRz FINISH       ;如果读到0, 说明文件结束, 跳转到FINISH</span><br><span class="line">    </span><br><span class="line">    NOT R4, R1</span><br><span class="line">    ADD R4, R4, #1   ;把输入的内容R1取补码后放入R4</span><br><span class="line">    ADD R4, R0, R4   ;用R0-R4, 用于比较文件内容是否和输入内容相等</span><br><span class="line">    BRnp NO          ;如果结果非零, 说明不相等, 跳转到NO</span><br><span class="line"></span><br><span class="line">    ADD R3, R3, #1   ;如果结果为零, 说明相等, 计数器R3加一</span><br><span class="line">    </span><br><span class="line">NO:</span><br><span class="line">    ADD R2, R2, #1     ;指针R2加一</span><br><span class="line">    BRnzp LOOP         ;重复循环</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    LD R0, ZERO_ASCII  ;把&#x27;0&#x27;的ASCII码放入R0</span><br><span class="line">    ADD R0, R0, R3     ;R0=&#x27;0&#x27;+R3</span><br><span class="line">    TRAP x21           ;显示R0的内容到屏幕上</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS    .FILL x4000</span><br><span class="line">ZERO_ASCII .FILL x30    ;&#x27;0&#x27;的ASCII</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题5">习题5</h3>
<p>将键盘编写的十进制或者十六进制常数(前缀<code>#</code>代表十进制,
前缀<code>x</code>代表十六进制)转换为二进制表达方式,
并且打印出来(假设常数表示时, 十进制或十六进制的数字不超过两个).
例如键盘输入<code>x2A</code>时, 程序输出<code>00101010</code>,
键盘输入<code>#12</code>时, 程序输出<code>00001100</code>.</p>
<h4 id="实验步骤与实验思路-4">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>我们需要解决如下的几个问题:</p>
<ol type="1">
<li>如何根据输入的前缀是<code>#</code>或<code>x</code>来判断后续输入的是十进制还是十六进制?</li>
<li>如何判断输入的是单个字符还是两个字符?</li>
<li>如何把输入字符的ASCII码转化成对应的数值?</li>
<li>如何把对应的数值转化成二进制数?</li>
</ol>
<h5 id="问题1的解决方案">问题1的解决方案</h5>
<p>首先把<code>#</code>读取到<code>R1</code>寄存器中,
输入内容放到<code>R0</code>寄存器中, 计算<code>R0-R1</code>,
结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>#</code>, 如果是,
那么程序跳转到<code>DEC_MODE</code>处理十进制输入; 如果不是,
那么程序继续往下执行, 把<code>x</code>读取到<code>R1</code>寄存器中,
计算<code>R0-R1</code>, 结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>x</code>, 如果是,
那么程序跳转到<code>HEX_MODE</code>处理十六进制输入; 如果不是,
那么为无效输入, 程序直接结束, 跳转到<code>END</code>.</p>
<p>代码实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">TRAP x21           ;回显</span><br><span class="line"></span><br><span class="line">;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line"></span><br><span class="line">;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line"></span><br><span class="line">BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br></pre></td></tr></table></figure>
<h5 id="问题2的解决方案">问题2的解决方案</h5>
<h6 id="十进制输入">十进制输入</h6>
<p>先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
现在判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>DEC_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5, 因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;调用子程序, 将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0       ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line"></span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0       ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R4, R0, #0       ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0       ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3       ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ; 计算 10 × 十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br></pre></td></tr></table></figure>
<p>这里我们顺便把处理单个字符的子程序<code>DEC_SINGLE</code>和把ASCII码转换成对应数值的子程序<code>ASCII _TO_DECIMAL</code>写好:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEC_SINGLE:</span><br><span class="line">    ; 使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R2, R0, #0       ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY  ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<h6 id="十六进制输入">十六进制输入</h6>
<p>和十进制类似,先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>HEX_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ; 计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br></pre></td></tr></table></figure>
<h5 id="问题3的解决方案">问题3的解决方案</h5>
<p>在上面的问题2中,
我们已经用到了子程序<code>ASCII_TO_DECIMAL</code>和<code>ASCII_TO_HEX</code>,
其作用是把我们输入字符的ASCII码分别转换成对应的数值.</p>
<p>这里我们先来看一下ASCII的编码系统, 从而确定字符转换的程序.</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>示例</th>
<th>ASCII码(十进制)</th>
<th>ASCII码(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字字符</td>
<td>‘0’</td>
<td>48</td>
<td>x30</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘1’</td>
<td>49</td>
<td>x31</td>
</tr>
<tr>
<td>数字字符</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘9’</td>
<td>57</td>
<td>x39</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘A’</td>
<td>65</td>
<td>x41</td>
</tr>
<tr>
<td>大写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘Z’</td>
<td>90</td>
<td>x5A</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘a’</td>
<td>97</td>
<td>x61</td>
</tr>
<tr>
<td>小写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘z’</td>
<td>122</td>
<td>x7A</td>
</tr>
</tbody>
</table>
<p>当我们从键盘输入时, 存储到<code>R0</code>寄存器的是ASCII码,
而不是数值本身, 所以我们应该进行数值的转换, 对于数字,
根据上表可知只需要用数字字符对应的ASCII码直接减去<code>0</code>对应的ASCII码就可以得到该数字字符对应的数值了.
同样地, 对于十六进制大写字母,
只需要用大写字母对应的ASCII码直接减去’A’对应的ASCII码就可以得到该大写字母对应的数值了.</p>
<h6 id="十进制转换">十进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h6 id="十六进制转换">十六进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">; 处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h5 id="问题4的解决方案">问题4的解决方案</h5>
<p>接下来我们考虑如何将数值转换成对应的二进制码.
这里我们采用位检测和移位算法, 首先输入数值,
设置计数器的值为8(因为输出的是8位二进制数), 检查当前最高位,
如果最高位是1, 那么输出1, 然后左移一位; 如果最高位是0, 那么输出0,
然后左移一位. 此时把计数器减一, 如果计数器的值大于零, 那么继续循环,
直到完整循环了8次, 也就是输出8位二进制数了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    AND R1, R1, #0     ;初始化循环计数器R1</span><br><span class="line">    ADD R1, R1, #8     ;设置R1=8, 循环8次</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0     ;设置条件码, 检查R2的符号位</span><br><span class="line">    BRn OUTPUT_ONE     ;如果最高位为1(负数)，跳转到输出&#x27;1&#x27;</span><br><span class="line">    </span><br><span class="line">    ;如果最高位为0, 输出&#x27;0&#x27;</span><br><span class="line">    LD R0, ZERO_ASCII  ;R0=&#x27;0&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;0&#x27;</span><br><span class="line">    BRnzp SHIFT_NEXT   ;跳转到移位处理</span><br><span class="line"></span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII   ;R0=&#x27;1&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2     ;R2左移一位</span><br><span class="line">    ADD R1, R1, #-1    ;计数器减1</span><br><span class="line">    BRp LOOP           ;如果计数器大于0, 继续循环</span><br><span class="line">    </span><br><span class="line">    ;输出换行, 使结果更清晰</span><br><span class="line">    LD R0, NEWLINE     ;R0=换行符</span><br><span class="line">    TRAP x21           ;输出换行</span><br></pre></td></tr></table></figure>
<p>后来我在debug的时候发现有个问题, LC-3是16位机器,
假如我输入<code>#12</code>(也就是十进制数<code>12</code>,
其二进制数为<code>0000_0000_0000_1100</code>), 循环8次后输出全是0,
永远也不可能输出1, 而我们仅仅关心低8位.
所以应该先把<code>R2</code>左移8位, 把低8位变成高8位,
改正后的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">    LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">    BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">    LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">    BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line">    </span><br><span class="line">    BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br><span class="line"></span><br><span class="line">;*************************************************</span><br><span class="line">;****************下面是十进制模式******************</span><br><span class="line">;*************************************************</span><br><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5，因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;调用子程序，将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0          ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0          ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R4, R0, #0          ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0     ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3     ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ;计算10×十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是处理单个十进制数字的子程序</span><br><span class="line">DEC_SINGLE:</span><br><span class="line">    ;使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R2, R0, #0          ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY     ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;***************************************************</span><br><span class="line">;****************下面是十六进制模式******************</span><br><span class="line">;***************************************************</span><br><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ; 读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ; 保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ; 检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ;计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是单个十六进制数字的处理</span><br><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br><span class="line"></span><br><span class="line">;*****************************************************</span><br><span class="line">;****************下面是二进制输出程序******************</span><br><span class="line">;*****************************************************</span><br><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移, 使得低8位变成高8位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    HALT               ;程序结束</span><br><span class="line"></span><br><span class="line">;********************************************************</span><br><span class="line">;***************子程序: ASCII转十进制数值*****************</span><br><span class="line">;********************************************************</span><br><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;*********************************************************</span><br><span class="line">;**************子程序: ASCII转十六进制数值*****************</span><br><span class="line">;*********************************************************</span><br><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">;处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;数据定义</span><br><span class="line">DEC           .FILL x23   ;&#x27;#&#x27;的ASCII码</span><br><span class="line">HEX           .FILL x78   ;&#x27;x&#x27;的ASCII码</span><br><span class="line">ZERO_ASCII    .FILL x30   ;&#x27;0&#x27;的ASCII码</span><br><span class="line">ONE_ASCII     .FILL x31   ;&#x27;1&#x27;的ASCII码</span><br><span class="line">A_ASCII       .FILL x41   ;&#x27;A&#x27;的ASCII码</span><br><span class="line">ENTER_KEY     .FILL x0A   ;回车键的ASCII码</span><br><span class="line"></span><br><span class="line">SAVE_R1       .BLKW 1     ;用于保存R1</span><br><span class="line">SAVE_R2       .BLKW 1     ;用于保存R2</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题6">习题6</h3>
<p>采用轮询方式的控制外设,
通过键盘进行输入并在控制台屏幕显示大写的字母<code>A~I</code>,
要求利用LC-3处理器提供的如下表所示的设备端口,
使用设备端口寄存器来实现键盘输入与显示终端显示的功能.
设备端口寄存器的内存映射如下:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Location</th>
<th>I/O Register</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xFE00</code></td>
<td>键盘状态寄存器(KBSR)</td>
<td>当键盘接收到一个新字符时, 位[15]为1.</td>
</tr>
<tr>
<td><code>xFE02</code></td>
<td>键盘数据寄存器(KBDR)</td>
<td>位[7:0]包含键盘上键入的最后一个字符.</td>
</tr>
<tr>
<td><code>xFE04</code></td>
<td>显示状态寄存器(DSR)</td>
<td>当设备准备在屏幕上显示另一个字符时, 位[15]是1.</td>
</tr>
<tr>
<td><code>xFE06</code></td>
<td>显示数据寄存器(DDR)</td>
<td>写入位[7:0]的字符将显示在屏幕上.</td>
</tr>
</tbody>
</table>
<h4 id="实验步骤与实验思路-5">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
由于我们使用轮询的方式控制外设,
所以先考虑如何实现键盘输入和显示器输出的轮询,
思路就是<code>R0</code>读取键盘状态寄存器<code>KBSR</code>(<code>LDI R0 KBSR_ADDRESS</code>,
<code>KBSR_ADDRESS .FILL xFE00</code>), 如果最高位是0, 表示没有新的字符,
继续轮询; 如果最高位是1(也就是说<code>KBSR</code>寄存器的内容是负数),
表示有新字符,
这时<code>R0</code>读取键盘数据寄存器<code>KBDR</code>进行后续的操作(<code>LDI R0 KBDR_ADDRESS</code>,
<code>KBDR_ADDRESS .FILL xFE02</code>). 类似地, 对于输出轮询,
<code>R1</code>读取显示状态寄存器<code>DSR</code>(<code>LDI R1 DSR_ADDRESS</code>,
<code>DSR_ADDRESS .FILL xFE04</code>), 如果最高位是0, 表示显示器忙,
继续轮询; 如果最高位是1(也就是说<code>DSR</code>寄存器的内容是负数),
表示显示器准备就绪,
这时<code>R1</code>读取显示数据寄存器<code>DDR</code>进行显示(<code>LDI R1 DDR_ADDRESS</code>,
<code>DDR_ADDRESS .FILL xFE06</code>).</p>
<p>我们期望在键盘上依次输入<code>A~I</code>,
期望在显示器上依次回显<code>A~I</code>,
所以我们可以先把一个寄存器依次初始化为<code>A, B, ..., I</code>,
然后依次和我们的输入相比, 如果一致, 则输出该字符; 如果不一致,
则要求重新输入.</p>
<h4 id="实现代码-5">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">MAIN:</span><br><span class="line">    LD R2, A_ASCII  ;把&#x27;A&#x27;的ASCII码放到R2里面, 和输入进行比较</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    TRAP x20        ;读取输入到R0</span><br><span class="line">    NOT R1, R2</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R0, R1  ;计算R0-R2判断输入和期望是否一致, 结果放入R1</span><br><span class="line">    BRnp LOOP       ;如果结果不为零, 说明不一致, 重新输入</span><br><span class="line">    </span><br><span class="line">    ADD R3, R0, #0  ;如果一致, 把R0放入R3输出</span><br><span class="line">    TRAP x21        ;输出</span><br><span class="line">    </span><br><span class="line">    LD R1, I_ASCII  ;把&#x27;I&#x27;的ASCII码放到R1里面, 和输入进行比较</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R2, R1  ;计算R2-R1, 判断当前输入字符是否为&#x27;I&#x27;</span><br><span class="line">    BRz FINISH      ;如果是, 那么程序结束</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1  ;如果不是, 那么R2＋1, 即R2初始化为下一个期望得到的字符</span><br><span class="line">    BRnzp LOOP      ;输入</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">A_ASCII .FILL x41           ; &#x27;A&#x27;的ASCII码</span><br><span class="line">I_ASCII .FILL x49           ; &#x27;I&#x27;的ASCII码</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LC-3/" rel="tag"># LC-3</a>
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/04/hello-world/" rel="next" title="Hello World">
                  Hello World <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
