<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="第一部分:基本概念 计算机系统概述 从问题描述到电子运转的转换层次如下 问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件  用自然语言提出一个问题 将问题转化成具体的算法,算法有三大特点  确定性:每个操作的步骤是清晰的,可定义的 可计算性:每一步都可以被计算机执行 有限性:过程是会终止的  将算法用程序语言实现,而程">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机系统概论笔记">
<meta property="og:url" content="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:description" content="第一部分:基本概念 计算机系统概述 从问题描述到电子运转的转换层次如下 问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件  用自然语言提出一个问题 将问题转化成具体的算法,算法有三大特点  确定性:每个操作的步骤是清晰的,可定义的 可计算性:每一步都可以被计算机执行 有限性:过程是会终止的  将算法用程序语言实现,而程">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-21T09:13:53.270Z">
<meta property="article:author" content="SiyuanLei">
<meta property="article:tag" content="LC-3">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","path":"2025/05/04/计算机系统/","title":"计算机系统概论笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机系统概论笔记 | SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SiyuanLei's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">第一部分:基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">计算机系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bit%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">bit,数据类型及其运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86lc-3%E5%8F%8A%E5%85%B6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">第二部分:LC-3及其汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">冯诺依曼模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">组成部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98-1"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">处理单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">输入和输出单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">控制单元</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86"><span class="nav-number">2.1.2.</span> <span class="nav-text">指令处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">指令周期</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">取指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AF%91%E7%A0%81"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">译码</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">地址计算</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%96%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">2.1.2.2.4.</span> <span class="nav-text">取操作数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.2.2.5.</span> <span class="nav-text">执行</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E6%94%BE%E7%BB%93%E6%9E%9C"><span class="nav-number">2.1.2.2.6.</span> <span class="nav-text">存放结果</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">改变执行顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%81%9C%E6%9C%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">停机操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">LC-3结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lc-3-isa%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">LC-3 ISA概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">内存组织</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">指令集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">操作码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">寻址模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">2.2.1.7.</span> <span class="nav-text">条件码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">运算指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%90%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.3.</span> <span class="nav-text">数据搬移指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pc%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">PC相对寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">间接寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E5%9D%80%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">基址偏移寻址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">立即数寻址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.4.</span> <span class="nav-text">控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E5%92%8C%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">条件跳转和无条件跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmp"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">JMP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trap"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">TRAP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">2.3.</span> <span class="nav-text">LC-3 汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">操作码和操作数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%8F%B7"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">标号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.</span> <span class="nav-text">伪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.3.</span> <span class="nav-text">汇编过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">两遍扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.1.</span> <span class="nav-text">第一遍扫描</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%8D%E6%89%AB%E6%8F%8F"><span class="nav-number">2.3.3.1.2.</span> <span class="nav-text">第二遍扫描</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.3.4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%98%A0%E5%83%8F"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">可执行映像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">多目标文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">2.4.</span> <span class="nav-text">输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A6%82%E8%BF%B0"><span class="nav-number">2.4.1.</span> <span class="nav-text">输入&#x2F;输出概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">设备寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84io%E4%B8%8E%E4%B8%93%E7%94%A8io%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">内存映射I&#x2F;O与专用I&#x2F;O指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5io%E4%B8%8E%E5%90%8C%E6%AD%A5io"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">异步I&#x2F;O与同步I&#x2F;O</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%BD%AE%E8%AF%A2"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">中断驱动和轮询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="nav-number">2.4.2.</span> <span class="nav-text">键盘输入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86c%E8%AF%AD%E8%A8%80"><span class="nav-number">3.</span> <span class="nav-text">第三部分:C语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95-lc-3%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">附录 LC-3指令集结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lc-3%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.2.</span> <span class="nav-text">LC-3指令集详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#add"><span class="nav-number">4.2.1.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#and"><span class="nav-number">4.2.2.</span> <span class="nav-text">AND</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#br"><span class="nav-number">4.2.3.</span> <span class="nav-text">BR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jmp%E5%92%8Cret"><span class="nav-number">4.2.4.</span> <span class="nav-text">JMP和RET</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsr%E5%92%8Cjsrr"><span class="nav-number">4.3.</span> <span class="nav-text">JSR和JSRR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load%E7%B3%BB%E5%88%97%E6%8C%87%E4%BB%A4"><span class="nav-number">4.4.</span> <span class="nav-text">Load系列指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ld"><span class="nav-number">4.4.1.</span> <span class="nav-text">LD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldi"><span class="nav-number">4.4.2.</span> <span class="nav-text">LDI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ldr"><span class="nav-number">4.4.3.</span> <span class="nav-text">LDR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lea"><span class="nav-number">4.4.4.</span> <span class="nav-text">LEA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#not"><span class="nav-number">4.5.</span> <span class="nav-text">NOT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rti"><span class="nav-number">4.6.</span> <span class="nav-text">RTI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store%E7%B3%BB%E5%88%97%E6%8C%87%E4%BB%A4"><span class="nav-number">4.7.</span> <span class="nav-text">Store系列指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#st"><span class="nav-number">4.7.1.</span> <span class="nav-text">ST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sti"><span class="nav-number">4.7.2.</span> <span class="nav-text">STI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#str"><span class="nav-number">4.7.3.</span> <span class="nav-text">STR</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trap-1"><span class="nav-number">4.8.</span> <span class="nav-text">TRAP</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机系统概论笔记 | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机系统概论笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-21 17:13:53" itemprop="dateModified" datetime="2025-05-21T17:13:53+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="第一部分基本概念">第一部分:基本概念</h2>
<h3 id="计算机系统概述">计算机系统概述</h3>
<p>从问题描述到电子运转的转换层次如下</p>
<p>问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件</p>
<ol type="1">
<li>用自然语言提出一个问题</li>
<li>将问题转化成具体的算法,算法有三大特点
<ol type="1">
<li>确定性:每个操作的步骤是清晰的,可定义的</li>
<li>可计算性:每一步都可以被计算机执行</li>
<li>有限性:过程是会终止的</li>
</ol></li>
<li>将算法用程序语言实现,而程序语言就是机器语言,它又分成高级语言和低级语言
<ol type="1">
<li>高级语言和计算机底层相关性弱,比如Python,Matlab</li>
<li>低级语言和计算机底层相关性强,通常一种低级语言对应一种计算机,称为某某机器的汇编语言</li>
</ol></li>
<li>将编程语言转换成特定计算机的指令集.指令集架构(Instruction Set
Architecture,ISA)是程序和计算机硬件之间接口的一个完整定义.将高级语言翻译成ISA指令的过程由<strong>编译器</strong>完成,而将计算机特定汇编语言翻译成其ISA的过程由<strong>汇编器</strong>完成.ISA的定义包括:
<ol type="1">
<li>计算机可以执行的指令集合,即计算机所能执行的操作</li>
<li>每个操作所需数据是什么,即操作数</li>
<li>可接受的操作数表达方式,即数据类型</li>
<li>获取操作数的机制,即定位各种操作数的不同方法,称为寻址模式</li>
</ol></li>
<li>将ISA转换成对应的实现,实现的具体组织称为微结构.例如很多处理器都实现了X86这种ISA结构,但是每个处理器的实现方法不同,即有自己的微结构.</li>
<li>微结构则是由一些简单的逻辑电路实现的</li>
<li>每个基本的逻辑电路,都是按照特定的器件技术实现的</li>
</ol>
<h3 id="bit数据类型及其运算">bit,数据类型及其运算</h3>
<p><strong>原码</strong>第一位是符号位,0代表正数,1代表负数.后面的位数都是数值位.</p>
<p><strong>反码</strong>正数的反码和原码相同,负数的反码保持符号位是1,数值位取反</p>
<p><strong>补码</strong>正数的补码和原码相同,负数的补码是在其反码的基础上加1.</p>
<p><strong>注意事项</strong></p>
<ul>
<li>如果已知一个数的补码,对其再求一次补码就可以得到原码</li>
<li>4位字长的原码和反码表示的数值范围都是-7<sub>+7,补码表示的范围是-8</sub>+7.规定+0的原码,反码,补码都是0000,-0只有原码(1000)和补码(1111),没有补码;-8只有补码(1000),没有原码和反码</li>
</ul>
<p><strong>符号扩展</strong>在二进制补码正数前加上任意多个0不改变它的值,在二进制补码负数前加上任意多个1不改变它的值.</p>
<p><strong>溢出</strong>两个数进行补码运算,如果结果的正负号和预期相反,那么就就称为溢出.只有在两种同符号运算的情况下,才会发生溢出.</p>
<p><strong>浮点数</strong>IEEE浮点数的定义如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号位</th>
<th style="text-align: center;">数值范围</th>
<th style="text-align: center;">数值精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">(S)</td>
<td style="text-align: center;">指数(exponent)</td>
<td style="text-align: center;">尾数(fraction)</td>
</tr>
<tr>
<td style="text-align: center;">1 bit</td>
<td style="text-align: center;">8 bit</td>
<td style="text-align: center;">23 bit</td>
</tr>
</tbody>
</table>
<p>浮点数的计算公式如下: <span class="math display">\[N=(-1)^s\times
1.\rm{fraction}\times 2^{\rm{exponent}-127},~1\leq \rm{exponent}\leq
254\]</span></p>
<p><strong>例1</strong><span
class="math inline">\(-6\frac{5}{8}\)</span>的IEEE浮点数是多少?</p>
<p><strong>解</strong><span
class="math display">\[-6\frac{5}{8}=-(1\times 2^2+1\times 2^1+0\times
2^0+1\times 2^{-1}+0\times 2^{-1}+1\times 2^{-3})=-1.10101\times
2^2\]</span></p>
<p>符号位是<span class="math inline">\(1\)</span>,指数是<span
class="math inline">\(2+127=129=10000001\)</span>,尾数为<span
class="math inline">\(10101000000000000000000\)</span> 于是IEEE浮点数为
<span
class="math display">\[1(1~bit)~~10000001(8~bit)~~10101000000000000000000(23~bit)\]</span></p>
<p><strong>例2</strong>IEEE浮点数 <span
class="math display">\[0~01111011~00000000000000000000000\]</span>
表示的是什么数?</p>
<p><strong>解</strong><span
class="math inline">\(01111011-127=123-127=-4\)</span>,位数部分全为<span
class="math inline">\(0\)</span>,整个数为正数,所以 <span
class="math display">\[+1.00000000000000000000000\times
2^{-4}=\frac{1}{16}\]</span></p>
<h3 id="内存">内存</h3>
<p>内存是由一定数目的”位置”组成的,其中每个”位置”可以被单独识别并且存放一个数据.我们称用来<strong>识别位置的一组数</strong>为<strong>地址</strong>,称存储在<strong>各个位置中的bit数目</strong>为<strong>寻址能力</strong>.内存中可独立识别的位置总数为内存的<strong>寻址空间</strong>.</p>
<p>例如,<span class="math inline">\(2^3\times
16\)</span>大小的内存,其寻址空间大小为<span
class="math inline">\(2^3=8\)</span>,寻址能力为<span
class="math inline">\(16 bit\)</span>的宽度.</p>
<h2 id="第二部分lc-3及其汇编语言">第二部分:LC-3及其汇编语言</h2>
<h3 id="冯诺依曼模型">冯诺依曼模型</h3>
<h4 id="组成部分">组成部分</h4>
<p>冯诺依曼模型包括五个组成部分:</p>
<ol type="1">
<li>内存memory</li>
<li>处理单元processing unit</li>
<li>输入input</li>
<li>输出output</li>
<li>控制单元control unit</li>
</ol>
<p>下面我们一一介绍</p>
<h5 id="内存-1">内存</h5>
<p>今天的计算机都是<span class="math inline">\(2^{28}\times
8~\rm{bit}\)</span>模式,也就是说有<span
class="math inline">\(2^{28}\)</span>个存储单元,每个存储单元可以存储<span
class="math inline">\(8~\rm{bit}\)</span>的信息.我们称寻址空间为<span
class="math inline">\(2^{28}\)</span>,寻址能力为<span
class="math inline">\(8\)</span>位(<span
class="math inline">\(1~\rm{byte}=8~\rm{bit}\)</span>).</p>
<p>访问内存的第一步,就是向内存提供被访问的内存单元的地址</p>
<ul>
<li>读操作:首先将被访问内存单元的地址放入CPU的内存地址寄存器(Memory
Address Register,
MAR),然后发送读信号通知内存,最后内存将该单元中存放的数据发送到内存数据寄存器(Memory
Data Register, MDR).</li>
<li>写操作:首先将被访问内存单元的地址放入CPU的MAR,然后将要写入的数据放入CPU的MDR,再向内存发送写信号,最后MDR的内容被写入MAR指向的内存单元.</li>
</ul>
<h5 id="处理单元">处理单元</h5>
<p>处理单元是信息被真正处理的地方,其中最简单的功能单元是算数逻辑单元ALU.ALU所能处理的量化大小称为该机器的”字长”,而量化的基本单位称为一个”字”.例如,LC-3所能处理的量化大小为<span
class="math inline">\(16-\rm{bit}\)</span>,所以称LC-3是一个<span
class="math inline">\(16\)</span>位的机器.</p>
<p>通常会在ALU周围配置少量存储器,以便存放最近生成的中间计算结果,这样可以减少内存访问浪费的时间.临时存储器最常见的设计方式就是一组寄存器,其中每个寄存器的宽度和ALU处理数据的宽度一致,我们说每个寄存器存放了一个字.在LC-3中,有<span
class="math inline">\(8\)</span>个这样的寄存器(<span
class="math inline">\(\rm{R0,R1,\cdots,R7}\)</span>),每个宽度为<span
class="math inline">\(16-\rm{bit}\)</span>.</p>
<h5 id="输入和输出单元">输入和输出单元</h5>
<p>输入和输出设备的种类很多,我们称它们为”外围设备”.常见的输入设备是键盘,输出设备是显示器.</p>
<h5 id="控制单元">控制单元</h5>
<p>控制单元控制其他所有单元之间的协同工作.控制单元中有几个特殊的寄存器:</p>
<ol type="1">
<li>指令寄存器:保存的是正在被执行的那条指令.</li>
<li>PC寄存器:指向下一条待处理的指令,这个寄存器又称为”程序计数器”或者”指令指针”,这是因为该寄存器的内容实际上指向下一条待处理的指令的地址.</li>
</ol>
<h4 id="指令处理">指令处理</h4>
<p>冯诺依曼模型的核心思想是,程序和数据都是以<span
class="math inline">\(\rm{bit}\)</span>流的方式存放在计算机内存中,程序在控制单元的控制下,依次完成指令的读取和执行.</p>
<h5 id="指令">指令</h5>
<p>指令是计算机执行的最小单位.指令本身又是由操作码和操作数两部分组成.操作码表示该指令是做什么的,操作数表示该操作的对象有哪些.LC-3指令长度是<span
class="math inline">\(16-\rm{bit}\)</span>,其中<span
class="math inline">\(\rm{bit}[15:12]\)</span>表示操作码,<span
class="math inline">\(\rm{bit}[11:0]\)</span>对应操作数的表示.</p>
<p><strong>例1</strong>ADD指令</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>1 1 0</td>
<td>0 1 0</td>
<td>0</td>
<td>0 0</td>
<td>1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=110\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010,\rm{bit}[2:0]=110\)</span>
表示源寄存器<span class="math inline">\(\rm{R2}\)</span>和<span
class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[5:3]\)</span> 的含义以后再进行解释</p>
<p>上述指令的解释为将寄存器2和寄存器6的内容相加,然后将结果放入寄存器6.</p>
<p><strong>例2</strong>LDR指令</p>
<p>LD表示load,表示从内存的某个位置读取内容,然后装入某个寄存器中.R表示读取内存地址的机制(寻址模式),这里表示的意思是”base+offset”模式.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 1 0</td>
<td>0 1 1</td>
<td>0 0 0 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示LDR操作 <span class="math inline">\(\rm{bit}[11:9]=010\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=011\)</span> 表示偏移寄存器<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=000110\)</span> 表示基址<span
class="math inline">\(6\)</span></p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{R3}\)</span>的内容和<span
class="math inline">\(\rm{bit}[5:0]\)</span>的补码数值相加得到内存地址,然后将该地址指向的内存单元的内容放入<span
class="math inline">\(\rm{R2}\)</span>中.</p>
<h5 id="指令周期">指令周期</h5>
<p>指令的处理过程是在控制单元的控制下一步步地完成的.我们称这个执行的步骤顺序为指令周期,其中每一步称为节拍.一个指令周期包括6个节拍:</p>
<ol type="1">
<li>取指令(FETCH)</li>
<li>译码(DECODE)</li>
<li>地址计算(EVALUATE ADDRESS)</li>
<li>取操作数(FETCH OPERAND)</li>
<li>执行(EXECUTE)</li>
<li>存放结果(STORE RESULT)</li>
</ol>
<h6 id="取指令">取指令</h6>
<p>该节拍负责从内存中(整个程序的所有指令都保存在内存里面)取出下一条待执行的指令,将其放入控制单元的指令寄存器IR.而取出下一条待执行的指令,就需要知道它在内存中的地址,而程序计数器PC就是负责这个任务.FETCH节拍的具体过程如下:</p>
<ol type="1">
<li>将PC寄存器的内容装入MAR</li>
<li>将MAR对应的内存单元的内容(即下一条指令)装入MDR</li>
<li>控制单元将MDR的内容装入IR寄存器</li>
<li>PC+1</li>
</ol>
<p>上面的每一个动作就是一个机器周期,或者叫时钟周期.</p>
<h6 id="译码">译码</h6>
<p>将<span
class="math inline">\(\rm{IR}[15:12]\)</span>作为输入,输出<span
class="math inline">\(16\)</span>根使能线,但是这<span
class="math inline">\(16\)</span>根使能线中有且仅有一条是有效的.</p>
<h6 id="地址计算">地址计算</h6>
<p>不是所有的指令都有这个环节.</p>
<h6 id="取操作数">取操作数</h6>
<p>源操作数既可以来自寄存器,又可以来自内存.</p>
<h6 id="执行">执行</h6>
<p>没什么好说的</p>
<h6 id="存放结果">存放结果</h6>
<p>之前节拍的执行结果被写入目的寄存器.</p>
<h5 id="改变执行顺序">改变执行顺序</h5>
<p>由于任意的指令周期都是从将PC的内容装入MAR中开始的,如果我们想要改变指令执行的顺序,就必须在PC+1与下一条指令的取指令节拍开始之前修改PC+1的值.控制指令就是用新的地址覆盖PC+1的内容.</p>
<p><strong>例</strong>JMP指令</p>
<p>假设该指令存放在内存<span
class="math inline">\(\rm{x36A2}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11</th>
<th>10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>0 1 1</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示JMP操作 <span class="math inline">\(\rm{bit}[8:6]=011\)</span>
表示寄存器<span
class="math inline">\(\rm{R3}\)</span>中存储了下一条指令</p>
<p>上述指令的解释为将寄存器3的内容放入PC寄存器,覆盖掉当前PC+1,换言之,下一条要执行的指令在内存中的地址来自<span
class="math inline">\(\rm{R3}\)</span>.</p>
<p>具体来说,首先在指令执行之初,PC的内容为<span
class="math inline">\(\rm{x36A2}\)</span>,在取指令节拍,整条JMP指令放入IR寄存器,同时PC自增变成<span
class="math inline">\(\rm{x36A3}\)</span>,假设<span
class="math inline">\(\rm{R3}\)</span>的内容是<span
class="math inline">\(\rm{x5446}\)</span>,那么在执行节拍,PC的内容就被覆盖为<span
class="math inline">\(\rm{x5446}\)</span>.这就导致了下一条指令来自内存中地址为<span
class="math inline">\(\rm{x5446}\)</span>,而不是<span
class="math inline">\(\rm{x36A3}\)</span>.</p>
<h5 id="停机操作">停机操作</h5>
<p>用户程序是受控于操作系统而执行的,即操作系统有终值用户程序的办法.对于计算机来说,用户程序和操作系统没有区别,都是一堆指令的集合.</p>
<p>对于用户程序来说,想要停止用户程序,就要在用户程序的结尾处放置一个控制指令,该指令的任务就是修改Pc寄存器,使之跳转到操作系统,而操作系统也借这个时刻启动一个新的用户程序.</p>
<h3 id="lc-3结构">LC-3结构</h3>
<h4 id="lc-3-isa概述">LC-3 ISA概述</h4>
<p>ISA定义了软件编程所需要的必要而完整的描述,换言之,ISA向以机器语言编程的程序员提供有关控制机器所需要的全部信息.ISA主要包含如下信息:</p>
<ol type="1">
<li>内存组织方式</li>
<li>寄存器组</li>
<li>指令集(包括操作码,数据类型,寻址模式)</li>
</ol>
<h5 id="内存组织">内存组织</h5>
<p>LC-3的可寻址空间大小为<span
class="math inline">\(2^{16}\)</span>(这些空间并不是全部用于内存),寻址基本单位是<span
class="math inline">\(16\)</span>位.LC-3中数据处理的基本单位是<span
class="math inline">\(16\)</span>位,所以称<span
class="math inline">\(16\)</span>位为一个字,也称LC-3是一个字寻址机器.</p>
<h5 id="寄存器">寄存器</h5>
<p>由于从内存中获取数据的速度很慢(不止一个周期),所以计算机会提供临时存储空间,它们的访问速度是一个周期.临时存储空间最常见的实现方式是寄存器,LC-3提供了一组通用寄存器,其中每个寄存器都叫做通用寄存器.</p>
<p>寄存器有以下特性:</p>
<ol type="1">
<li>记忆特性:存储的信息可以被再次读出.对于LC-3,每个寄存器的大小为一个字,即<span
class="math inline">\(16\)</span>位</li>
<li>独立寻址:每个寄存器有唯一的标识.LC-3,提供了<span
class="math inline">\(8\)</span>个寄存器<span
class="math inline">\(\rm{R0,R1,\cdots,R7}\)</span></li>
</ol>
<h5 id="指令集">指令集</h5>
<p>一条指令分为两个部分,第一个部分是操作码(做什么),第二个部分是操作数(对谁操作).一个ISA的指令集定义包括:操作码的集合,数据类型,寻址模式.其中寻址模式决定了操作数的存放位置.</p>
<h5 id="操作码">操作码</h5>
<p>LC-3的ISA结构定义了<span
class="math inline">\(15\)</span>条指令,注意到<span
class="math inline">\(\rm{bit}[15:12]\)</span>这<span
class="math inline">\(4~\rm{bit}\)</span>的操作码本来可以定义<span
class="math inline">\(16\)</span>条指令,但我们将<span
class="math inline">\(1101\)</span>先预留出来.</p>
<p>所有指令可以分成三类:</p>
<ol type="1">
<li>运算指令:算数运算或者逻辑运算,负责处理信息</li>
<li>数据搬移指令:将数据从一个地方搬到另一个地方,如内存和寄存器之间,内存,寄存器和输入输出之间</li>
<li>控制指令:改变程序的执行顺序</li>
</ol>
<h5 id="数据类型">数据类型</h5>
<p>数据类型是指信息的表达方式,即ISA的操作码是怎样理解这些表达信息的.如果ISA的操作码能识别/处理某种数据类型的信息,那么我们称该ISA支持这种数据类型.LC-3所支持的唯一的数据类型就是补码整数.</p>
<h5 id="寻址模式">寻址模式</h5>
<p>寻址模式是定义操作数位置的机制.操作数的来源有三个:</p>
<ol type="1">
<li>内存</li>
<li>寄存器</li>
<li>指令本身</li>
</ol>
<p>称存在于指令本身的操作数为”字面值”或”立即数”.</p>
<p>而LC-3总共支持<span class="math inline">\(5\)</span>种寻址模式:</p>
<ol type="1">
<li>立即数</li>
<li>寄存器</li>
<li>相对寻址</li>
<li>间接寻址</li>
<li>基址偏移</li>
</ol>
<h5 id="条件码">条件码</h5>
<p>LC-3具有三个位寄存器,每当<span
class="math inline">\(8\)</span>个通用寄存器中的任意一个被修改或者写入时,这三个<span
class="math inline">\(\rm{bit}\)</span>位就会发生变化.这三个位寄存器分别为<span
class="math inline">\(N,Z,P\)</span>,分别代表负数,零,正数.即每当通用寄存器被写入时,根据写入的结果是负数,零,正数,分别设置这三个位.例如,写入负数,置<span
class="math inline">\(N=1,N=P=0\)</span>.我们称这三个位寄存器为”条件码”.</p>
<h4 id="运算指令">运算指令</h4>
<p>LC-3只支持三种运算:ADD,AND,NOT</p>
<p><strong>例1</strong>NOT指令</p>
<p>NOT指令是唯一的单操作数指令.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 0 1</td>
<td>0 1 1</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1001\)</span>
表示取反NOT操作 <span class="math inline">\(\rm{bit}[11:9]=011\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=101\)</span> 表示源寄存器<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5:0]\)</span> 全部为<span
class="math inline">\(1\)</span></p>
<p>上述指令的解释为将寄存器5的内容取反,然后放入寄存器3.</p>
<p><strong>例2</strong>AND指令</p>
<p>AND(操作码为0101)和ADD(操作码为0001)都是双操作数指令,它们都需要两个<span
class="math inline">\(16\)</span>位源操作数.AND和ADD的源操作数之一(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)以及目的寄存器(<span
class="math inline">\(\rm{bit}[11:9]\)</span>)都是寄存器寻址.对于第二个操作数的寻址方式,则是取决于<span
class="math inline">\(\rm{bit}[5]\)</span>的值,若为<span
class="math inline">\(1\)</span>,则是立即数寻址,此时<span
class="math inline">\(\rm{bit}[4:0]\)</span>表示立即数;若为<span
class="math inline">\(0\)</span>,则是寄存器寻址,此时源寄存器为<span
class="math inline">\(\rm{bit}[2:0]\)</span>,<span
class="math inline">\(\rm{bit}[4:3]=00\)</span>.</p>
<p>下面是<strong>寄存器寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100,\rm{bit}[2:0]=101\)</span>
表示源寄存器<span class="math inline">\(\rm{R4}\)</span>和<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5]=0\)</span> 表示寄存器寻址,此时<span
class="math inline">\(\rm{bit}[4:3]=00\)</span></p>
<p>上述指令的解释为将寄存器4和寄存器5的内容相加,然后将结果放入寄存器1.</p>
<p>下面是<strong>立即数寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>1</td>
<td>1 1 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100\)</span> 表示源寄存器<span
class="math inline">\(\rm{R4}\)</span> <span
class="math inline">\(\rm{bit}[5]=1\)</span> 表示立即数寻址,此时<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>为立即数</p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,然后与寄存器4的内容相加,然后将结果放入寄存器1.</p>
<h4 id="数据搬移指令">数据搬移指令</h4>
<p>我们称将数据从内存移入寄存器为”装载(Load)“,将数据从寄存器放入内存为”存储(Store)“.注意,在这种情况下,数据源的内容不会随着数据的移动而改变,但是目的操作数的内容会被刷新,以前的内容会被覆盖.</p>
<p>LC-3有<span
class="math inline">\(7\)</span>种数据搬移指令:LD,LDR,LDI,LEA,ST,STR,STI</p>
<p>Load和Store的指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">操作码</td>
<td style="text-align: center;">DR或SR</td>
<td style="text-align: center;">地址生成位</td>
</tr>
</tbody>
</table>
<p>数据搬移指令需要有两个操作数:源和目的,且两个操作数之一必然是寄存器,另一个则是内存或者输入输出设备.</p>
<p><span
class="math inline">\(\rm{bit}[11:9]\)</span>标识了操作数之一,即寄存器,如果是Load类型的指令,那么这代表目的寄存器(DR);如果是Store类型的指令,那么这代表源寄存器(SR).</p>
<p><span
class="math inline">\(\rm{bit}[8:0]\)</span>是”地址生成位”,这表示基于<span
class="math inline">\(\rm{bit}[8:0]\)</span>的信息,可以计算出第二个操作数的<span
class="math inline">\(16\)</span>位地址.LC-3中,有<span
class="math inline">\(4\)</span>种生成地址(或者说阐释<span
class="math inline">\(\rm{bit}[8:0]\)</span>)的方法,也就是<span
class="math inline">\(4\)</span>种寻址模式.</p>
<h5 id="pc相对寻址">PC相对寻址</h5>
<p>LD(操作码为0010)和ST(操作码为0011)采用PC相对寻址.此时<span
class="math inline">\(\rm{bit}[8:0]\)</span>代表的是对于当前PC值的偏移量.地址计算方法是,将<span
class="math inline">\(\rm{bit}[8:0]\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,然后和PC当前值(已增量)相加得到内存单元的地址.</p>
<p><strong>例</strong>LD指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 1 0</td>
<td>0 1 0</td>
<td>1 1 0 1 0 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示PC相对寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=010\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span>
表示偏移量,符号扩展之后为<span
class="math inline">\(\rm{xFFAF}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)+\rm{xFFAF}=\rm{x3FC8}\)</span>,将<span
class="math inline">\(\rm{x3FC8}\)</span>装入MAR,然后读取内存地址为<span
class="math inline">\(\rm{x3FC8}\)</span>的内容装入MDR中,最后把MDR的内容加载到<span
class="math inline">\(R2\)</span>中.</p>
<p>注意这种寻址方式计算出来的内存地址范围是受限的,即该地址只能在当前LD或者ST指令所在地址的<span
class="math inline">\(+256\)</span>和<span
class="math inline">\(-255\)</span>范围内,另外<span
class="math inline">\(\rm{bit}[8:0]\)</span>是有符号数值.</p>
<h5 id="间接寻址">间接寻址</h5>
<p>LDI(操作码为1010)和STI(操作码为1011)采用间接寻址.首先用和LD/ST相同的方法算出一个地址,但是这个地址的内容又是另外一个地址,这个新的地址的内容才是源操作数.这种寻址方式的范围是整个内存空间.</p>
<p><strong>例</strong>LDI指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4A1B}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 1 0</td>
<td>0 1 1</td>
<td>1 1 1 0 0 1 1 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示间接寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=011\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span>
表示偏移量,符号扩展之后为<span
class="math inline">\(\rm{xFFCC}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4A1B}+1)+\rm{xFFCC}=\rm{x49E8}\)</span>,将<span
class="math inline">\(\rm{x49E8}\)</span>装入MAR,然后读取内存地址为<span
class="math inline">\(\rm{x49E8}\)</span>的内容(假设为<span
class="math inline">\(\rm{x2110}\)</span>)装入MDR中,而<span
class="math inline">\(\rm{x2110}\)</span>不是操作数,而是地址,所以<span
class="math inline">\(\rm{x2110}\)</span>又被装入MAR,再次读取内存地址为<span
class="math inline">\(\rm{x2110}\)</span>的内容装入到MDR,最后把MDR的内容加载到<span
class="math inline">\(R3\)</span>中.</p>
<h5 id="基址偏移寻址">基址偏移寻址</h5>
<p>LDR(操作码为0110)和STR(操作码为0111)采用基址+偏移寻址.操作数的地址是由<span
class="math inline">\(\rm{bit}[5:0]\)</span>的<span
class="math inline">\(6~\rm{bit}\)</span>偏移量和<span
class="math inline">\(\rm{bit}[8:6]\)</span>的寄存器的内容(基址)相加得出.</p>
<p><strong>例</strong>LD指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 0 1</td>
<td>0 1 0</td>
<td>0 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示基址+偏移寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=001\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010\)</span> 表示基址寄存器<span
class="math inline">\(\rm{R2}\)</span>,其内容假设为<span
class="math inline">\(\rm{x2345}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=011101\)</span> 符号扩展为<span
class="math inline">\(\rm{x001D}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\(\rm{x2345}+\rm{x001D}=\rm{x2362}\)</span>,将<span
class="math inline">\(\rm{x2362}\)</span>装入MAR,然后读取内存地址为<span
class="math inline">\(\rm{x2362}\)</span>的内容装入MDR中,最后把MDR的内容加载到<span
class="math inline">\(R1\)</span>中.</p>
<h5 id="立即数寻址">立即数寻址</h5>
<p>立即数寻址模式只用于有效地址装载指令,用途是对寄存器初始化,即向寄存器中装入一个地址.LEA(操作码为1110)将增量PC直接和<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加,并装入<span
class="math inline">\(\rm{bit}[11:9]\)</span>指定的寄存器.</p>
<p><strong>例</strong>LEA指令</p>
<p>设这条指令位于<span class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 1 0</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1110\)</span>
表示LEA操作 <span class="math inline">\(\rm{bit}[11:9]=101\)</span>
表示目的寄存器是<span
class="math inline">\(\rm{R5}\)</span>,假设内容为<span
class="math inline">\(\rm{x4018}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=111111101\)</span> 为<span
class="math inline">\(-3\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)-3=\rm{x4016}\)</span>,将<span
class="math inline">\(\rm{x4016}\)</span>装入<span
class="math inline">\(\rm{R5}\)</span>.</p>
<h4 id="控制指令">控制指令</h4>
<p>控制指令是指可以改变指令执行顺序的指令.如果没有控制指令,那么当前指令完毕后的下一条指令一定是内存位置顺序的下一条,这是因为取指令之后,PC会自动加一.</p>
<p>LC-3中有<span
class="math inline">\(5\)</span>种操作码可以打破这种顺序:条件跳转,无条件跳转,子程序(又称为函数)调用,TRAP,中断返回.</p>
<h5 id="条件跳转和无条件跳转">条件跳转和无条件跳转</h5>
<p>条件跳转指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">P</td>
<td style="text-align: center;">PC偏移</td>
</tr>
</tbody>
</table>
<p>其中:</p>
<p><span
class="math inline">\(\rm{bit}[11],[10],[9]\)</span>分别对应三个条件码.任何一个对寄存器进行操作的指令都会设置这三个条件码,这些指令包括ADD,AND,NOT,LD,LDI,LDR,LEA.</p>
<p>条件码的使用方法是:条件跳转指令通过判断条件码来决定是否改变指令流.</p>
<p>控制指令的执行周期如下:</p>
<ol type="1">
<li>取指令和译码节拍正常,取指令之后,PC自动增量</li>
<li>地址计算节拍,将增量后的PC和指令中<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加求得地址</li>
<li>执行节拍,处理器会检测某个(我们指定的)条件码,如果该条件码的值为<span
class="math inline">\(1\)</span>,那么PC的内容将会被修改成上一个节拍计算出来的地址;如果该条件码的值为<span
class="math inline">\(0\)</span>,那么PC的内容不变.如果我们指定三个条件码都为<span
class="math inline">\(1\)</span>,那么PC内容必然会更新,这就是无条件跳转指令.</li>
</ol>
<h5 id="jmp">JMP</h5>
<p>JMP指令格式如下</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0 0 0</td>
<td>0 1 0</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>JMP指令的任务就是将基址寄存器(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)的内容装入PC中.JMP指令可以使指令跳转到内存空间的任意位置,这是因为基址寄存器的内容是<span
class="math inline">\(16\)</span>位,它可以表达内存空间的所有地址.</p>
<h5 id="trap">TRAP</h5>
<p>TRAP指令的任务是改变PC的内容,使其指向操作系统所在的空间内部.换言之,就是以当前程序身份跳转至操作系统的某个代码入口开始执行.按照操作系统的术语来说,我们称TRAP指令是激活了操作系统的服务调用.</p>
<p>TRAP指令格式如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 1 1</td>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">陷入矢量</td>
</tr>
</tbody>
</table>
<p>其中<span
class="math inline">\(\rm{bit}[7:0]\)</span>表示陷入矢量,陷入矢量表示的是程序希望操作系统执行的服务程序的编号.</p>
<p>操作系统在完成服务调用之后,程序计数器PC将被设置成TRAP指令后的下一条指令地址.</p>
<h3 id="lc-3-汇编语言">LC-3 汇编语言</h3>
<p>汇编语言属于低级语言,每一条汇编语言通常对应于一条ISA指令,高级语言是ISA无关的,而低级语言是ISA相关的.</p>
<p>在汇编语言中,我们采用<strong>助记符</strong>方式来表示AND,NOT之类的<strong>操作码</strong>,而<strong>内存地址</strong>则被SUM,PRODUCT之类的<strong>符号名</strong>所替代.我们称这种命名方式为<strong>符号地址</strong>.</p>
<p>我们先看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Program to multiply an integer by the constant 6</span><br><span class="line">; Before execution, an integer must be stored in NUMBER</span><br><span class="line">         .ORIG    x3050</span><br><span class="line">         LD       R1,SIX</span><br><span class="line">         LD       R2,NUMBER</span><br><span class="line">         AND      R3,R3,#0</span><br><span class="line">; The inner loop</span><br><span class="line">   AGAIN ADD      R3,R3,R2</span><br><span class="line">         ADD      R1,R1,#-1</span><br><span class="line">         BRp      AGAIN</span><br><span class="line"></span><br><span class="line">         HALT</span><br><span class="line"></span><br><span class="line">   NUMBER .BLKW   1</span><br><span class="line">   SIX    .FILL   x0006</span><br><span class="line"></span><br><span class="line">          .END</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ol type="1">
<li>以”;“后面的内容是注释</li>
<li>以AND,NOT,HALT,AGAIN的代码行是要翻译成LC-3机器指令的,即真正要运行的</li>
<li>.ORIG,NUMBER,SIX,.END是伪操作,是程序员传递给汇编器的信息,用于提示帮助翻译的过程.</li>
</ol>
<h4 id="指令-1">指令</h4>
<p>汇编语言的指令格式包含<span
class="math inline">\(4\)</span>个部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL OPCODE OPERANDS ; COMMENTS</span><br></pre></td></tr></table></figure>
<h5 id="操作码和操作数">操作码和操作数</h5>
<p>在一个汇编指令的所有字段中,操作码(OPCODE,做什么事情)和操作数(OPERAND,被操作的对象)两部分是必须的,操作数的数目取决于具体的操作.</p>
<p>操作数的获取有三种方式:</p>
<ol type="1">
<li>寄存器操作数:直接用R1,R2等显式表示寄存器</li>
<li>内存操作数:内存地址被表达为符号名,例如NUMBER和SIX</li>
<li>立即数操作数:数值被显式表达,“#”表示十进制,“x”表示十六进制,“b”表示二进制.</li>
</ol>
<h5 id="标号">标号</h5>
<p>标号是指向内存单元的符号名,它可以在程序中直接引用.LC-3汇编语言中,一个标号可以包含<span
class="math inline">\(1\)</span>到<span
class="math inline">\(20\)</span>个字符(如大写或者小写的字母或者数字),但是首个字符必须是字母.显式访问内存单元的方式有两种:</p>
<ol type="1">
<li>该单元的内容是指令,该单元地址是跳转指令的目标</li>
<li>该单元的内容是Load或者Store指令访问的数值</li>
</ol>
<p>如果一个内存单元从来不被引用,那么就没有必要为其标号.</p>
<h4 id="伪操作">伪操作</h4>
<p>伪操作又被称为<strong>汇编指令</strong>,它们并不代表(被翻译的汇编)程序中的任何操作,或者说程序执行时它们是不产生任何操作的.它们可以理解为程序员传递给汇编器的信息,用于指导汇编器的汇编操作.LC-3汇编器只有<span
class="math inline">\(5\)</span>种伪操作:</p>
<ol type="1">
<li>.ORIG:.ORIG告诉汇编器将LC-3程序放在内存的什么位置,例如<code>.ORIG x3050</code>表示”从”x3050”开始,于是<code>LD R1,SIX</code>这一条指令就被放在”x3050”处.</li>
<li>.FILL:.FILL告诉汇编器开始占用下一个地址,并且填充初始值(如其操作数),如<code>SIX .FILL x0006</code>,即该单元被初始化为”x0006”.</li>
<li>.BLKW:.BLKW告诉汇编器在程序空间中,开始占用一连串的地址空间,具体的占用数目由.BLKW的伪操作数决定</li>
<li>.STRINGZ:.STRINGZ告诉汇编器连续占用并初始化<span
class="math inline">\(n+1\)</span>个内存单元,其参数(或操作数)是双括号括起来的<span
class="math inline">\(n\)</span>个字符.<span
class="math inline">\(n+1\)</span>个内存单元的前<span
class="math inline">\(n\)</span>个字的内容分别是字符串对应字符的ASCII码的零扩展,内存的最后一个字则被初始化为<span
class="math inline">\(0\)</span>.最后的这个字符”x0000”通常为ASCII码的处理提供了”哨兵机制”.例如下面的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      .ORIG x3010</span><br><span class="line">HELLO .STRINGZ &quot;Hello, World!&quot;      </span><br></pre></td></tr></table></figure>
<p>导致汇编器将内存x3010到x301D初始化为如下内容:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;">对应字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x3010</td>
<td style="text-align: center;">x0048</td>
<td style="text-align: center;">H</td>
</tr>
<tr>
<td style="text-align: center;">x3011</td>
<td style="text-align: center;">x0065</td>
<td style="text-align: center;">e</td>
</tr>
<tr>
<td style="text-align: center;">x3012</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3013</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3014</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3015</td>
<td style="text-align: center;">x002C</td>
<td style="text-align: center;">,</td>
</tr>
<tr>
<td style="text-align: center;">x3016</td>
<td style="text-align: center;">x0020</td>
<td style="text-align: center;">空格</td>
</tr>
<tr>
<td style="text-align: center;">x3017</td>
<td style="text-align: center;">x0057</td>
<td style="text-align: center;">W</td>
</tr>
<tr>
<td style="text-align: center;">x3018</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3019</td>
<td style="text-align: center;">x0072</td>
<td style="text-align: center;">r</td>
</tr>
<tr>
<td style="text-align: center;">x301A</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x301B</td>
<td style="text-align: center;">x0064</td>
<td style="text-align: center;">d</td>
</tr>
<tr>
<td style="text-align: center;">x301C</td>
<td style="text-align: center;">x0021</td>
<td style="text-align: center;">!</td>
</tr>
<tr>
<td style="text-align: center;">x301D</td>
<td style="text-align: center;">x0000</td>
<td style="text-align: center;">空字符</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li>.END:.END告诉汇编器”程序结束了”.</li>
</ol>
<h4 id="汇编过程">汇编过程</h4>
<p>我们先看如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         .ORIG    x3000       ;</span><br><span class="line">         AND      R2,R2,#0    ;x3000</span><br><span class="line">         LD       R3,PTR      ;x3001</span><br><span class="line">         TRAP     x23         ;x3002</span><br><span class="line">         LDR      R1,R3,#0    ;x3003</span><br><span class="line"></span><br><span class="line">TEST     .ADD     R4,R1,#-4   ;x3004 检测到TEXT</span><br><span class="line">         BRz      OUTPUT      ;x3005</span><br><span class="line"></span><br><span class="line">         NOT      R1,R1       ;x3006</span><br><span class="line">         ADD      R1,R1,R0    ;x3007</span><br><span class="line">         NOT      R1,R1       ;x3008</span><br><span class="line">         BRnp     GETCHAR     ;x3009</span><br><span class="line">         ADD      R2,R2,#1    ;x300A</span><br><span class="line"></span><br><span class="line">GETCHAR  ADD      R3,R3,#1    ;x300B 检测到GETCHAR</span><br><span class="line">         LDR      R1,R3,#0    ;x300C</span><br><span class="line">         BRnzp    TEST        ;x300D</span><br><span class="line"></span><br><span class="line">OUTPUT   LD       R0,ASCII    ;x300E 检测到OUTPUT</span><br><span class="line">         ADD      R0,R0,R2    ;x300F</span><br><span class="line">         TRAP     x21         ;x3010</span><br><span class="line">         TRAP     x25         ;x3011</span><br><span class="line"></span><br><span class="line">ASCII    .FILL    x0030       ;x3012 检测到ASCII</span><br><span class="line">PTR      .FILL    x4000       ;x3013 检测到PTR</span><br><span class="line">         .END</span><br></pre></td></tr></table></figure>
<h5 id="两遍扫描">两遍扫描</h5>
<p>汇编器在将汇编指令翻译成对应的机器指令前,需要对整个汇编程序从头到尾(从开始到.END)扫描一遍,为的是在第一遍扫描时先确定符号名对应的二进制地址,即确定所有符号和地址之间的映射关系.我们称这个映射集合为<strong>符号表</strong>.在建立完符号表之后,汇编器就可以一行一行进行翻译了.</p>
<h6 id="第一遍扫描">第一遍扫描</h6>
<p>第一遍扫描的具体操作如下:</p>
<ol type="1">
<li>丢弃掉所有注释</li>
<li>.ORIG后面的第一条有效指令所分配的地址就是.ORIG后的参数.为了方便说明,我们采用”地址跟踪计数器LC”,LC的初始值由.ORIG指定,也就是x3000.</li>
<li>每识别出一条有效指令,LC的值加<span
class="math inline">\(1\)</span>.如果当前指令行的<strong>头部存在”标识”字段</strong>,那么就为该标识创建符号表项,其地址值就是当前LC的内容</li>
<li>继续识别下一条指令,直至.END</li>
</ol>
<p>按照上面的操作创建的符号表如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号名</th>
<th style="text-align: center;">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">TEST</td>
<td style="text-align: center;">x3004</td>
</tr>
<tr>
<td style="text-align: center;">GETCHAR</td>
<td style="text-align: center;">x300B</td>
</tr>
<tr>
<td style="text-align: center;">OUTPUT</td>
<td style="text-align: center;">x300E</td>
</tr>
<tr>
<td style="text-align: center;">ASCII</td>
<td style="text-align: center;">x3012</td>
</tr>
<tr>
<td style="text-align: center;">PTR</td>
<td style="text-align: center;">x3013</td>
</tr>
</tbody>
</table>
<h6 id="第二遍扫描">第二遍扫描</h6>
<p>没什么好说的,就是把汇编语言翻译成二进制代码.</p>
<h4 id="其他">其他</h4>
<h5 id="可执行映像">可执行映像</h5>
<p>当计算机开始程序的执行时,执行实体又称为”可执行映像”.可执行映像通常是由多个相互独立的模块组装在一起形成的,而这些模块通常又是由不同的程序员,不同的语言(例如汇编语言,C语言,Python等)分别编写的,且有些模块是用户编写的,有些则是操作系统的库程序.所有这些模块在组装之前,是一个个独立的目标文件,最后通过<strong>连接</strong>操作将这些目标拼装成一个可执行映像.</p>
<h5 id="多目标文件">多目标文件</h5>
<p>待完成</p>
<h3 id="输入输出">输入/输出</h3>
<h4 id="输入输出概述">输入/输出概述</h4>
<h5 id="设备寄存器">设备寄存器</h5>
<p>和一个I/O设备进行交互,我们需要多个设备寄存器,即使是最简单的I/O设备,也至少需要两个寄存器:</p>
<ol type="1">
<li>用来保持和计算机之间传输的数据</li>
<li>指示当前设备的状态信息,如”设备是否空闲”,“最近处理的I/O任务”等</li>
</ol>
<h5 id="内存映射io与专用io指令">内存映射I/O与专用I/O指令</h5>
<p>指令访问I/O设备寄存器时,需要明确指明目标寄存器.通常有两种方法实现:</p>
<ol type="1">
<li>一些计算机厂家采用专门的I/O指令来访问,即”专用I/O指令”(不常见)</li>
<li>采用内存操作指令完成I/O操作,即”内存映射I/O”(常用)</li>
</ol>
<p>程序员使用与内存访问相同的指令来操作I/O,所以设备的每个输入输出寄存器都必须有一个和内存中位置相同的标识方式.为此,在ISA的内存地址空间中,专门划分出一段地址,用于设备寄存器的标识映射.换句话说,I/O设备的寄存器被”映射”到一组地址(这些地址是分配给I/O寄存器的,而不是分配给内存位置的),即所谓”内存映射I/O”方式.</p>
<h5 id="异步io与同步io">异步I/O与同步I/O</h5>
<p>I/O设备和处理器的工作节奏是不一致的,因此我们称I/O设备和CPU之间是异步的.异步通信方式下,需要通过一定的协议或者握手机制来控制发送和接收.</p>
<p>实现同步的最简单方式是采用标志.键盘状态寄存器中的标志位提供了最简单的一种握手机制:打字员每输入一个字符,该标志位(Ready位)就被置位,而每次处理器读取之后,都自动将该标志位清零.所以在每次读取输入字符之前,处理器都会检查该Ready位,如果Ready位为<span
class="math inline">\(0\)</span>,表示没有新的字符输入,处理器不再读取输入寄存器,否则有新的字符输入,则处理器执行Load指令,读入输入寄存器的ASCII码值.</p>
<h5 id="中断驱动和轮询">中断驱动和轮询</h5>
<p>I/O设备和处理器交互的方式有两种:中断驱动和轮询.它们之间的根本区别在于谁控制这个交互.</p>
<p>以键盘和CPU之间的交互为例,如果由键盘控制交互过程,那么处理器只需要做自己的事情,当键盘数据准备好时,它会主动通知寄存器进行读取,这种就是”中断驱动”.而如果交互过程是由处理器控制,那么处理器必须不断读取,测试状态寄存器的内容,直到Ready位被置位(说明有新的字符输入),于是从寄存器中读取数据,这种就是”轮询”.</p>
<h4 id="键盘输入">键盘输入</h4>
<h2 id="第三部分c语言">第三部分:C语言</h2>
<h2 id="附录-lc-3指令集结构">附录 LC-3指令集结构</h2>
<h3 id="概述">概述</h3>
<ul>
<li>内存地址空间:16位地址,对应<span
class="math inline">\(2^{16}\)</span>个内存单元,每个单元包含一个字,每个字宽度是<span
class="math inline">\(16\)</span>位.地址的编号从x0000到xFFFF,地址是用来识别每个内存单元和内存映射的I/O设备寄存器.内存中的部分区段有特殊用途,划分如下:
<ol type="1">
<li>x0000~x00FF:陷入矢量表</li>
<li>x0100~x01FF:中断矢量表</li>
<li>x0200~x2FFF:操作系统及其内核栈空间</li>
<li>x3000~xFDFF:用户程序占用空间</li>
<li>xFE00~xFFFF:设备寄存器地址空间</li>
</ol></li>
<li>位编号:量化数的每个位也是有编号的.通常,最右边的位是<span
class="math inline">\(\rm{bit}[0]\)</span>,最左边的位是<span
class="math inline">\(\rm{bit}[15]\)</span>.</li>
<li>指令:每个指令的宽度是<span
class="math inline">\(16\)</span>位,前四位(<span
class="math inline">\(\rm{bit}[15:12]\)</span>)是操作码.</li>
<li>非法操作码异常:操作码<span
class="math inline">\(\rm{bit}[15:12]=1101\)</span>是没有定义的.</li>
<li>程序计数器:<span
class="math inline">\(16~\rm{bit}\)</span>宽度的一个寄存器,内容是下一条执行指令所在的地址.</li>
<li>通用寄存器:<span
class="math inline">\(16~\rm{bit}\)</span>宽度的八个寄存器,编号从<span
class="math inline">\(000\)</span>到<span
class="math inline">\(111\)</span>.</li>
<li>条件码:<span
class="math inline">\(1~\rm{bit}\)</span>宽度的三个寄存器,分别是N,Z,P.Load类型的指令和运算指令在向任意一个通用寄存器中写入内容时,都会改变条件码.而其他的指令不会改变条件码.</li>
<li>内存映射:设备的输入输出是通过Load和Store指令完成的,所以需要为I/O设备寄存器分配内存地址(xFE00~xFFFF).</li>
<li>中断处理</li>
<li>优先级:LC-3定义了<span
class="math inline">\(8\)</span>个优先级,其中PL7最高,PL0最低.</li>
<li>处理器状态寄存器:<span
class="math inline">\(16~\rm{bit}\)</span>宽度的寄存器,包含了当前执行进程的状态信息.其中PSR的<span
class="math inline">\(8\)</span>个位已经做了定义,PSR[15]定义了执行进程的权限模式,PSR[10:8]表示当前执行进程的优先级别,PSR[2:0]包含的是条件码(PSR[2]=N,PSR[1]=Z,PSR[0]=P).</li>
<li>权限模式:LC-3定义了两种权限模式,特权模式和用户模式.PSR[15]=0表示特权模式,PSR[15]=1表示用户模式.</li>
<li>权限模式异常:如果RTI指令执行在特权模式下,但是你试图在用户模式下执行RTI指令,那么会产生”权限模式异常”</li>
<li>特权模式栈空间:又称为内核栈空间.在特权模式下,通过SSP指针访问该内存区域.事实上,特权模式PSR[15]=0下,栈指针R6就是SSP</li>
<li>用户模式栈空间:在用户模式下,通过USP指针访问该内存区域.事实上,特权模式PSR[15]=1下,栈指针R6就是USP</li>
</ul>
<h3 id="lc-3指令集详解">LC-3指令集详解</h3>
<h4 id="add">ADD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD DR,SR1,SR2</span><br><span class="line">ADD DR,SR1,imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1+SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1+SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R2,R3,R4      ;R2&lt;-R3+R4</span><br><span class="line">ADD R2,R3,#7      ;R2&lt;-R3+7</span><br></pre></td></tr></table></figure>
<h4 id="and">AND</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND DR,SR1,SR2</span><br><span class="line">AND DR,SR1,imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1 AND SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1 ANd SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND R2,R3,R4      ;R2&lt;-R3 AND R4</span><br><span class="line">AND R2,R3,#7      ;R2&lt;-R3 AND 7</span><br></pre></td></tr></table></figure>
<h4 id="br">BR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BR  LABEL   BRnzp LABEL</span><br><span class="line">BRn LABEL   BRzp  LABEL</span><br><span class="line">BRz LABEL   BRnp  LABEL</span><br><span class="line">BRp LABEL   BRnz  LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">z</td>
<td style="text-align: center;">p</td>
<td style="text-align: center;">PCoffset9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n AND N) OR (z AND Z) OR (p AND P))</span><br><span class="line">   PC=(PC+<span class="number">1</span>)+SEXT(PCoffset9)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BRzp LOOP      ;如果最后的结果是零或者正数,那么跳转至LOOP</span><br><span class="line">BR   NEXT      ;无条件跳转至NEXT</span><br></pre></td></tr></table></figure>
<h4 id="jmp和ret">JMP和RET</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   BaseR</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC=BaseR</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   R2    ;PC&lt;-R2</span><br><span class="line">RET         ;PC&lt;-R7</span><br></pre></td></tr></table></figure>
<p>注意:RET指令可以看作JMP指令的一个特例,PC被装入R7的内容,R7扮演的是链接的作用,其内容指向子程序调用指令之后的指令地址.</p>
<h3 id="jsr和jsrr">JSR和JSRR</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   LABEL</span><br><span class="line">JSRR  BaseR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PCoffet11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (bit[<span class="number">11</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=BaseR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   PC=PC+SEXT(PCoffset11);</span><br></pre></td></tr></table></figure>
<p>解释:增量PC值先保存在R7中,这是返回调用代码的链接地址,然后PC装入被调用子程序的入口地址,即等价于无条件跳转至该地址.子程序的入口地址来自基址寄存器或者是PC增量和偏移量的符号扩展之和.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   QUEUE    ;将JSR指令之后的地址装入R7,然后跳转至QUEUE</span><br><span class="line">JSRR  R3       ;将JSRR指令之后的地址装入R7,然后跳转至R3内容所指定的地址</span><br></pre></td></tr></table></figure>
<h3 id="load系列指令">Load系列指令</h3>
<h4 id="ld">LD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD DR,LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem((PC+<span class="number">1</span>)+SEXT(PCoffset9));</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD  R4,VALUE      ;R4&lt;-mem[VALUE]</span><br></pre></td></tr></table></figure>
<h4 id="ldi">LDI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI DR,LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将其对应地址中的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI  R4,ONEMORE      ;R4&lt;-mem[mem[ONEMORE]]</span><br></pre></td></tr></table></figure>
<h4 id="ldr">LDR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR DR,BaseR,offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">PCoffet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[BaseR+SEXT(offset6)];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR  R4,R2,#-5    ;R4&lt;-mem[R2-5]</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA DR,LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=(PC+<span class="number">1</span>)+SEXT(PCoffset9);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址直接装入DR寄存器(无需访问内存,只是将计算出来的内存单元的地址放入DR中),同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA  R4,TERTGET    ;R4&lt;-address of TARTGET</span><br></pre></td></tr></table></figure>
<h3 id="not">NOT</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT DR,SR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11111</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=NOT(SR);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT R4,R2    ;R4&lt;-NOT(R2)</span><br></pre></td></tr></table></figure>
<h3 id="rti">RTI</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTI</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">000000000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PSR[<span class="number">15</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=mem[R6];    <span class="comment">//R6是SSP</span></span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   TEMP=mem[R6];</span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   PSR=TEMP;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释:如果当前处理器运行在特权模式,则该指令是合法的,特权模式栈顶部两个单元的内容被弹出,并分别赋值给PC和PSR.如果当前处理器运行在用户模式,则该指令的执行将引发”特权模式冲突”异常.</p>
<h3 id="store系列指令">Store系列指令</h3>
<h4 id="st">ST</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST SR,LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offset6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[(PC+<span class="number">1</span>)+SEXT(PCoffset9)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入改地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST    R4,HERE     ;mem[HERE]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="sti">STI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI SR,LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1011</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将SR的内容装入这个地址中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI   R4,NOT_HERE      ;mem[mem[NOT_HERE]]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="str">STR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   SR,BaseR,offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[BaseR+SEXT(offset6)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入该地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   R4,R2,#5   ;mem[R2+5]&lt;-R4</span><br></pre></td></tr></table></figure>
<h3 id="trap-1">TRAP</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRAP  trapvector8</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1111</td>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">trapvect8</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line">PC=mem[ZEXT(trapvect8)];</span><br></pre></td></tr></table></figure>
<p>解释:首先将PC增量装入R7(为服务返回程序做准备).然后将由trapvector8指定的系统调用的入口地址装入PC(等价于跳转).注意,这个入口地址的计算是间接的,即先将trapvector8零扩展为一个<span
class="math inline">\(16~\rm{bit}\)</span>地址,然后读取该地址单元的内容,作为服务程序的入口地址.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LC-3/" rel="tag"># LC-3</a>
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/04/%E8%B4%B9%E6%9B%BC%E5%9B%BE/" rel="prev" title="Phy">
                  <i class="fa fa-angle-left"></i> Phy
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/04/hello-world/" rel="next" title="Hello World">
                  Hello World <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
