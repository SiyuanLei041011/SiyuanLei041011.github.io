<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="算法的概念 算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成。比如第 3 节 “递归”习题1中的Euclid算法，输入是两个正整数，输出是它们的最大公约数，计算步骤是取模、比较等操作，这个算法一定能在有限的步骤和时间内完成（想一想为什么？）。再比如将一组数从小到大排序，输入是一组原始数据，输出是排序之后的数据，计算步骤包括比较、移动数据等操作">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言:排序与查找">
<meta property="og:url" content="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:description" content="算法的概念 算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成。比如第 3 节 “递归”习题1中的Euclid算法，输入是两个正整数，输出是它们的最大公约数，计算步骤是取模、比较等操作，这个算法一定能在有限的步骤和时间内完成（想一想为什么？）。再比如将一组数从小到大排序，输入是一组原始数据，输出是排序之后的数据，计算步骤包括比较、移动数据等操作">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:%5Cblog%5CBlog%5Cimages%5CC%5Csortsearch.calcrecurrence.png">
<meta property="og:image" content="c:%5Cblog%5CBlog%5Cimages%5CC%5Csortsearch.calcrecurrence.png">
<meta property="article:published_time" content="2025-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-07T10:18:57.397Z">
<meta property="article:author" content="SiyuanLei">
<meta property="article:tag" content="C">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:%5Cblog%5CBlog%5Cimages%5CC%5Csortsearch.calcrecurrence.png">


<link rel="canonical" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/","path":"2025/05/04/C语言第十一章/","title":"C语言:排序与查找"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言:排序与查找 | SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SiyuanLei's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">算法的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">算法的时间复杂度分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="nav-number">5.</span> <span class="nav-text">线性查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">6.</span> <span class="nav-text">折半查找</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言:排序与查找 | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言:排序与查找
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 18:18:57" itemprop="dateModified" datetime="2025-08-07T18:18:57+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="算法的概念">算法的概念</h2>
<p>算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成。比如第 3 节 “递归”习题1中的Euclid算法，输入是两个正整数，输出是它们的最大公约数，计算步骤是取模、比较等操作，这个算法一定能在有限的步骤和时间内完成（想一想为什么？）。再比如将一组数从小到大排序，输入是一组原始数据，输出是排序之后的数据，计算步骤包括比较、移动数据等操作。</p>
<p>算法是用来解决一类计算问题的，注意是一类问题，而不是一个特定的问题。例如，一个排序算法应该能对任意一组数据进行排序，而不是仅对<code>int a[] = &#123; 1, 3, 4, 2, 6, 5 &#125;;</code>这样一组数据排序，如果只需要对这一组数据排序可以写这样一个函数来做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">    a[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这显然不叫算法，因为不具有通用性。由于算法是用来解决一类问题的，它必须能够正确地解决这一类问题中的任何一个实例，这个算法才是正确的。对于排序算法，任意输入一组数据，它必须都能输出正确的排序结果，这个排序算法才是正确的。不正确的算法有两种可能，一是对于该问题的某些输入，该算法会无限计算下去，不会终止，二是对于该问题的某些输入，该算法终止时输出的是错误的结果。有时候不正确的算法也是有用的，如果对于某个问题寻求正确的算法很困难，而某个不正确的算法可以在有限时间内终止，并且能把误差控制在一定范围内，那么这样的算法也是有实际意义的。例如有时候寻找最优解的开销很大，往往会选择能给出次优解的算法。</p>
<p>本章介绍几种典型的排序和查找算法，并围绕这几种算法做时间复杂度分析。学完本章之后如果想进一步学习，可以参考一些全面系统地介绍算法的书，例如[TAOCP]和[算法导论]。</p>
<h2 id="插入排序">插入排序</h2>
<p>插入排序算法类似于玩扑克时抓牌的过程，玩家每拿到一张牌都要插入到手中已有的牌里，使之从小到大排好序。</p>
<p>也许你没有意识到，但其实你的思考过程是这样的：现在抓到一张7，把它和手里的牌从右到左依次比较，7比10小，应该再往左插，7比5大，好，就插这里。为什么比较了10和5就可以确定7的位置？为什么不用再比较左边的4和2呢？因为这里有一个重要的前提：手里的牌已经是排好序的。现在我插了7之后，手里的牌仍然是排好序的，下次再抓到的牌还可以用这个方法插入。</p>
<p>编程对一个数组进行插入排序也是同样道理，但和插入扑克牌有一点不同，不可能在两个相邻的存储单元之间再插入一个单元，因此要将插入点之后的数据依次往后移动一个单元。排序算法如下：</p>
<p>例 插入排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 5</span></span><br><span class="line"><span class="type">int</span> a[LEN] = &#123; <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; LEN; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d, %d\n&quot;</span>,</span><br><span class="line">               a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>]);</span><br><span class="line">        key = a[j];</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; a[i] &gt; key) &#123;</span><br><span class="line">            a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %d, %d\n&quot;</span>,</span><br><span class="line">           a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    insertion_sort();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更清楚地观察排序过程，我们在每次循环开头插了打印语句，在排序结束后也插了打印语句。程序运行结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10, 5, 2, 4, 7</span><br><span class="line">5, 10, 2, 4, 7</span><br><span class="line">2, 5, 10, 4, 7</span><br><span class="line">2, 4, 5, 10, 7</span><br><span class="line">2, 4, 5, 7, 10</span><br></pre></td></tr></table></figure>
<p>如何严格证明这个算法是正确的？换句话说，只要反复执行该算法的<code>for</code>循环体，执行<code>LEN-1</code>次，就一定能把数组<code>a</code>排好序，而不管数组<code>a</code>的原始数据是什么，如何证明这一点呢？我们可以借助Loop Invariant的概念和数学归纳法来理解循环结构的算法，假如某个判断条件满足以下三条准则，它就称为Loop Invariant：</p>
<p>第一次执行循环体之前该判断条件为真。</p>
<p>如果“第N-1次循环之后（或者说第N次循环之前）该判断条件为真”这个前提可以成立，那么就有办法证明第N次循环之后该判断条件仍为真。</p>
<p>如果在所有循环结束后该判断条件为真，那么就有办法证明该算法正确地解决了问题。</p>
<p>只要我们找到这个Loop Invariant，就可以证明一个循环结构的算法是正确的。上述插入排序算法的Loop Invariant是这样的判断条件：第<code>j</code>次循环之前，子序列<code>a[0..j-1]</code>是排好序的。在上面的打印结果中，我把子序列<code>a[0..j-1]</code>加粗表示。下面我们验证一下Loop Invariant的三条准则：</p>
<p>第一次执行循环之前，<code>j=1</code>，子序列<code>a[0..j-1]</code>只有一个元素<code>a[0]</code>，只有一个元素的序列显然是排好序的。</p>
<p>第<code>j</code>次循环之前，如果“子序列<code>a[0..j-1]</code>是排好序的”这个前提成立，现在要把<code>key=a[j]</code>插进去，按照该算法的步骤，把<code>a[j-1]</code>、<code>a[j-2]</code>、<code>a[j-3]</code>等等比<code>key</code>大的元素都依次往后移一个，直到找到合适的位置给<code>key</code>插入，就能证明循环结束时子序列<code>a[0..j]</code>是排好序的。就像插扑克牌一样，“手中已有的牌是排好序的”这个前提很重要，如果没有这个前提，就不能证明再插一张牌之后也是排好序的。</p>
<p>当循环结束时，<code>j=LEN</code>，如果“子序列<code>a[0..j-1]</code>是排好序的”这个前提成立，那就是说<code>a[0..LEN-1]</code>是排好序的，也就是说整个数组<code>a</code>的<code>LEN</code>个元素都排好序了。</p>
<p>可见，有了这三条，就可以用数学归纳法证明这个循环是正确的。这和第 3 节 “递归”证明递归程序正确性的思想是一致的，这里的第一条就相当于递归的Base Case，第二条就相当于递归的递推关系。这再次说明了递归和循环是等价的。</p>
<h2 id="算法的时间复杂度分析">算法的时间复杂度分析</h2>
<p>解决同一个问题可以有很多种算法，比较评价算法的好坏，一个重要的标准就是算法的时间复杂度。现在研究一下插入排序算法的执行时间，按照习惯，输入长度<code>LEN</code>以下用<code>n</code>表示。设循环中各条语句的执行时间分别是c1、c2、c3、c4、c5这样五个常数[23]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">void</span>)</span>                 执行时间</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; LEN; j++) &#123;</span><br><span class="line">        key = a[j];                         c1</span><br><span class="line">        i = j - <span class="number">1</span>;                          c2</span><br><span class="line">        <span class="title function_">while</span> <span class="params">(i &gt;= <span class="number">0</span> &amp;&amp; a[i] &gt; key)</span> &#123;</span><br><span class="line">            a[i+<span class="number">1</span>] = a[i];                  c3</span><br><span class="line">            i--;                            c4</span><br><span class="line">        &#125;</span><br><span class="line">        a[i+<span class="number">1</span>] = key;                       c5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然外层<code>for</code>循环的执行次数是<code>n-1</code>次，假设内层的<code>while</code>循环执行<code>m</code>次，则总的执行时间粗略估计是(n-1)<em>(c1+c2+c5+m</em>(c3+c4))。当然，<code>for</code>和<code>while</code>后面<code>()</code>括号中的赋值和条件判断的执行也需要时间，而我没有设一个常数来表示，这不影响我们的粗略估计。</p>
<p>这里有一个问题，<code>m</code>不是个常数，也不取决于输入长度<code>n</code>，而是取决于具体的输入数据。在最好情况下，数组<code>a</code>的原始数据已经排好序了，<code>while</code>循环一次也不执行，总的执行时间是(c1+c2+c5)*n-(c1+c2+c5)，可以表示成an+b的形式，是n的线性函数（Linear Function）。那么在最坏情况（Worst Case）下又如何呢？所谓最坏情况是指数组a的原始数据正好是从大到小排好序的，请读者想一想为什么这是最坏情况，然后把上式中的m替换掉算一下执行时间是多少。</p>
<p>数组<code>a</code>的原始数据属于最好和最坏情况的都比较少见，如果原始数据是随机的，可称为平均情况（Average Case）。如果原始数据是随机的，那么每次循环将已排序的子序列<code>a[1..j-1]</code>与新插入的元素<code>key</code>相比较，子序列中平均都有一半的元素比<code>key</code>大而另一半比<code>key</code>小，请读者把上式中的m替换掉算一下执行时间是多少。最后的结论应该是：在最坏情况和平均情况下，总的执行时间都可以表示成an2+bn+c的形式，是n的二次函数（Quadratic Function）。</p>
<p>在分析算法的时间复杂度时，我们更关心最坏情况而不是最好情况，理由如下：</p>
<p>最坏情况给出了算法执行时间的上界，我们可以确信，无论给什么输入，算法的执行时间都不会超过这个上界，这样为比较和分析提供了便利。</p>
<p>对于某些算法，最坏情况是最常发生的情况，例如在数据库中查找某个信息的算法，最坏情况就是数据库中根本不存在该信息，都找遍了也没有，而某些应用场合经常要查找一个信息在数据库中存在不存在。</p>
<p>虽然最坏情况是一种悲观估计，但是对于很多问题，平均情况和最坏情况的时间复杂度差不多，比如插入排序这个例子，平均情况和最坏情况的时间复杂度都是输入长度n的二次函数。</p>
<p>比较两个多项式a1n+b1和a2n2+b2n+c2的值（n取正整数）可以得出结论：n的最高次指数是最主要的决定因素，常数项、低次幂项和系数都是次要的。比如100n+1和n2+1，虽然后者的系数小，当n较小时前者的值较大，但是当n&gt;100时，后者的值就远远大于前者了。如果同一个问题可以用两种算法解决，其中一种算法的时间复杂度为线性函数，另一种算法的时间复杂度为二次函数，当问题的输入长度n足够大时，前者明显优于后者。因此我们可以用一种更粗略的方式表示算法的时间复杂度，把系数和低次幂项都省去，线性函数记作Θ(n)，二次函数记作Θ(n2)。</p>
<p>Θ(g(n))表示和g(n)同一量级的一类函数，例如所有的二次函数f(n)都和g(n)=n2属于同一量级，都可以用Θ(n2)来表示，甚至有些不是二次函数的也和n2属于同一量级，例如2n2+3lgn。</p>
<p>如果可以找到两个正的常数c1和c2，使得n足够大的时候（也就是n≥n0的时候）f(n)总是夹在c1g(n)和c2g(n)之间，就说f(n)和g(n)是同一量级的，f(n)就可以用Θ(g(n))来表示。</p>
<p>以二次函数为例，比如1/2n2-3n，要证明它是属于Θ(n2)这个集合的，我们必须确定c1、c2和n0，这些常数不随n改变，并且当n≥n0以后，c1n2≤1/2n2-3n≤c2n2总是成立的。为此我们从不等式的每一边都除以n2，得到c1≤1/2-3/n≤c2。</p>
<p>这样就很容易看出来，无论n取多少，该函数一定小于1/2，因此c2=1/2，当n=6时函数值为0，n&gt;6时该函数都大于0，可以取n0=7，c1=1/14，这样当n≥n0时都有1/2-3/n≥c1。通过这个证明过程可以得出结论，当n足够大时任何an2+bn+c都夹在c1n2和c2n2之间，相对于n2项来说bn+c的影响可以忽略，a可以通过选取合适的c1、c2来补偿。</p>
<p>几种常见的时间复杂度函数按数量级从小到大的顺序依次是：Θ(lgn)，Θ(sqrt(n))，Θ(n)，Θ(nlgn)，Θ(n2)，Θ(n3)，Θ(2n)，Θ(n!)。其中，lgn通常表示以10为底n的对数，但是对于Θ-notation来说，Θ(lgn)和Θ(log2n)并无区别（想一想这是为什么），在算法分析中lgn通常表示以2为底n的对数。可是什么算法的时间复杂度里会出现lgn呢？回顾插入排序的时间复杂度分析，无非是循环体的执行时间乘以循环次数，只有加和乘运算，怎么会出来lg呢？下一节归并排序的时间复杂度里面就有lg，请读者留心lg运算是从哪出来的。</p>
<p>除了Θ-notation之外，表示算法的时间复杂度常用的还有一种Big-O notation。我们知道插入排序在最坏情况和平均情况下时间复杂度是Θ(n2)，在最好情况下是Θ(n)，数量级比Θ(n2)要小，那么总结起来在各种情况下插入排序的时间复杂度是O(n2)。Θ的含义和“等于”类似，而大O的含义和“小于等于”类似。</p>
<h2 id="归并排序">归并排序</h2>
<p>插入排序算法采取增量式（Incremental）的策略解决问题，每次添一个元素到已排序的子序列中，逐渐将整个数组排序完毕，它的时间复杂度是O(n2)。下面介绍另一种典型的排序算法－－归并排序，它采取分而治之（Divide-and-Conquer）的策略，时间复杂度是Θ(nlgn)。归并排序的步骤如下：</p>
<p>Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。</p>
<p>Conquer: 对这两个子序列分别采用归并排序。</p>
<p>Combine: 将两个排序好的子序列合并成一个最终的排序序列。</p>
<p>在描述归并排序的步骤时又调用了归并排序本身，可见这是一个递归的过程。</p>
<p>例 归并排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 8</span></span><br><span class="line"><span class="type">int</span> a[LEN] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - start + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = end - mid;</span><br><span class="line">    <span class="type">int</span> left[n1], right[n2];</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n1; i++) <span class="comment">/* left holds a[start..mid] */</span></span><br><span class="line">        left[i] = a[start+i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n2; j++) <span class="comment">/* right holds a[mid+1..end] */</span></span><br><span class="line">        right[j] = a[mid+<span class="number">1</span>+j];</span><br><span class="line"></span><br><span class="line">    i = j = <span class="number">0</span>;</span><br><span class="line">    k = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2)</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt; right[j])</span><br><span class="line">            a[k++] = left[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[k++] = right[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) <span class="comment">/* left[] is not exhausted */</span></span><br><span class="line">        a[k++] = left[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) <span class="comment">/* right[] is not exhausted */</span></span><br><span class="line">        a[k++] = right[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sort (%d-%d, %d-%d) %d %d %d %d %d %d %d %d\n&quot;</span>, </span><br><span class="line">               start, mid, mid+<span class="number">1</span>, end, </span><br><span class="line">               a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>], a[<span class="number">6</span>], a[<span class="number">7</span>]);</span><br><span class="line">        sort(start, mid);</span><br><span class="line">        sort(mid+<span class="number">1</span>, end);</span><br><span class="line">        merge(start, mid, end);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;merge (%d-%d, %d-%d) to %d %d %d %d %d %d %d %d\n&quot;</span>, </span><br><span class="line">               start, mid, mid+<span class="number">1</span>, end, </span><br><span class="line">               a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>], a[<span class="number">6</span>], a[<span class="number">7</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sort(<span class="number">0</span>, LEN<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sort (0-3, 4-7) 5 2 4 7 1 3 2 6</span><br><span class="line">sort (0-1, 2-3) 5 2 4 7 1 3 2 6</span><br><span class="line">sort (0-0, 1-1) 5 2 4 7 1 3 2 6</span><br><span class="line">merge (0-0, 1-1) to 2 5 4 7 1 3 2 6</span><br><span class="line">sort (2-2, 3-3) 2 5 4 7 1 3 2 6</span><br><span class="line">merge (2-2, 3-3) to 2 5 4 7 1 3 2 6</span><br><span class="line">merge (0-1, 2-3) to 2 4 5 7 1 3 2 6</span><br><span class="line">sort (4-5, 6-7) 2 4 5 7 1 3 2 6</span><br><span class="line">sort (4-4, 5-5) 2 4 5 7 1 3 2 6</span><br><span class="line">merge (4-4, 5-5) to 2 4 5 7 1 3 2 6</span><br><span class="line">sort (6-6, 7-7) 2 4 5 7 1 3 2 6</span><br><span class="line">merge (6-6, 7-7) to 2 4 5 7 1 3 2 6</span><br><span class="line">merge (4-5, 6-7) to 2 4 5 7 1 2 3 6</span><br><span class="line">merge (0-3, 4-7) to 1 2 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>sort</code>函数把<code>a[start..end]</code>平均分成两个子序列，分别是<code>a[start..mid]</code>和<code>a[mid+1..end]</code>，对这两个子序列分别递归调用<code>sort</code>函数进行排序，然后调用<code>merge</code>函数将排好序的两个子序列合并起来，由于两个子序列都已经排好序了，合并的过程很简单，每次循环取两个子序列中最小的元素进行比较，将较小的元素取出放到最终的排序序列中，如果其中一个子序列的元素已取完，就把另一个子序列剩下的元素都放到最终的排序序列中。为了便于理解程序，我在<code>sort</code>函数开头和结尾插了打印语句，可以看出调用过程是这样的：</p>
<p><img src="C:%5Cblog%5CBlog%5Cimages%5CC%5Csortsearch.calcrecurrence.png" alt="归并排序调用过程"></p>
<p>图中S表示<code>sort</code>函数，M表示<code>merge</code>函数，整个控制流程沿虚线所示的方向调用和返回。由于<code>sort</code>函数递归调用了自己两次，所以各函数之间的调用关系呈树状结构。画这个图只是为了清楚地展现归并排序的过程，读者在理解递归函数时一定不要全部展开来看，而是要抓住Base Case和递推关系来理解。我们分析一下归并排序的时间复杂度，以下分析出自[算法导论]。</p>
<p>首先分析<code>merge</code>函数的时间复杂度。在<code>merge</code>函数中演示了C99的新特性－－可变长数组，当然也可以避免使用这一特性，比如把<code>left</code>和<code>right</code>都按最大长度<code>LEN</code>分配。不管用哪种办法，定义数组并分配存储空间的执行时间都可以看作常数，与数组的长度无关，常数用Θ-notation记作Θ(1)。设子序列<code>a[start..mid]</code>的长度为n1，子序列<code>[mid+1..end]</code>的长度为n2，<code>a[start..end]</code>的总长度为n=n1+n2，则前两个<code>for</code>循环的执行时间是Θ(n1+n2)，也就是Θ(n)，后面三个for循环合在一起看，每走一次循环就会在最终的排序序列中确定一个元素，最终的排序序列共有n个元素，所以执行时间也是Θ(n)。两个Θ(n)再加上若干常数项，merge函数总的执行时间仍是Θ(n)，其中n=end-start+1。</p>
<p>然后分析<code>sort</code>函数的时间复杂度，当输入长度<code>n=1</code>，也就是<code>start==end</code>时，<code>if</code>条件不成立，执行时间为常数Θ(1)，当输入长度<code>n&gt;1</code>时：</p>
<p>总的执行时间 = 2 × 输入长度为n/2的sort函数的执行时间 + merge函数的执行时间Θ(n)</p>
<p>设输入长度为<code>n</code>的<code>sort</code>函数的执行时间为T(n)，综上所述</p>
<p>$$T(n)=\begin{cases}<br>
\Theta(1)~~~~~~~~~~~~~~~~~~~~~~<s>\rm{if}<s>n=1,\<br>
2T(n/2)+\Theta(n)</s></s>\rm{if}~~n&gt;1.<br>
\end{cases}$$</p>
<p>这是一个递推公式（Recurrence），我们需要消去等号右侧的T(n)，把T(n)写成n的函数。其实符合一定条件的Recurrence的展开有数学公式可以套，这里我们略去严格的数学证明，只是从直观上看一下这个递推公式的结果。当n=1时可以设T(1)=c1，当n&gt;1时可以设T(n)=2T(n/2)+c2n，我们取c1和c2中较大的一个设为c，把原来的公式改为：</p>
<p>$$T(n)=\begin{cases}<br>
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~\rm{if}<s>n=1,\<br>
2T(n/2)+cn</s>~~~~\rm{if}~~n&gt;1.<br>
\end{cases}$$</p>
<p>这样计算出的结果应该是T(n)的上界。下面我们把T(n/2)展开成2T(n/4)+cn/2（下图中的©），然后再把T(n/4)进一步展开，直到最后全部变成T(1)=c（下图中的(d)）：</p>
<p><img src="C:%5Cblog%5CBlog%5Cimages%5CC%5Csortsearch.calcrecurrence.png" alt="归并排序调用过程"></p>
<p>把图(d)中所有的项加起来就是总的执行时间。这是一个树状结构，每一层的和都是cn，共有lgn+1层，因此总的执行时间是cnlgn+cn，相比nlgn来说，cn项可以忽略，因此T(n)的上界是Θ(nlgn)。</p>
<p>如果先前取c1和c2中较小的一个设为c，计算出的结果应该是T(n)的下界，然而推导过程一样，结果也是Θ(nlgn)。既然T(n)的上下界都是Θ(nlgn)，显然T(n)就是Θ(nlgn)。</p>
<p>和插入排序的平均情况相比归并排序更快一些，虽然merge函数的步骤较多，引入了较大的常数、系数和低次项，但是对于较大的输入长度n，这些都不是主要因素，归并排序的时间复杂度是Θ(nlgn)，而插入排序的平均情况是Θ(n2)，这就决定了归并排序是更快的算法。但是不是任何情况下归并排序都优于插入排序呢？哪些情况适用插入排序而不适用归并排序？留给读者思考。</p>
<h2 id="线性查找">线性查找</h2>
<p>有些查找问题要用时间复杂度为O(n)的算法来解决。例如写一个<code>indexof</code>函数，从任意输入字符串中找出某个字母的位置并返回这个位置，如果找不到就返回<code>-1</code>：</p>
<p>例 线性查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexof</span><span class="params">(<span class="type">char</span> letter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == letter)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, indexof(<span class="string">&#x27;o&#x27;</span>), indexof(<span class="string">&#x27;z&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是最直观和最容易想到的，但它是不是最快的算法呢？我们知道插入排序也比归并排序更容易想到，但通常不如归并排序快。那么现在这个问题－－给定一个随机排列的序列，找出其中某个元素的位置－－有没有比O(n)更快的算法？比如O(lgn)？请读者思考一下。</p>
<h2 id="折半查找">折半查找</h2>
<p>如果不是从一组随机的序列里查找，而是从一组排好序的序列里找出某个元素的位置，则可以有更快的算法：</p>
<p>例 折半查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LEN 8</span></span><br><span class="line"><span class="type">int</span> a[LEN] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid, start = <span class="number">0</span>, end = LEN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; number)</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; number)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, binarysearch(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个序列已经从小到大排好序了，每次取中间的元素和待查找的元素比较，如果中间的元素比待查找的元素小，就说明“如果待查找的元素存在，一定位于序列的后半部分”，这样可以把搜索范围缩小到后半部分，然后再次使用这种算法迭代。这种“每次将搜索范围缩小一半”的思想称为折半查找（Binary Search）。思考一下，这个算法的时间复杂度是多少？</p>
<p>这个算法的思想很简单，不是吗？可是[编程珠玑]上说作者在课堂上讲完这个算法的思想然后让学生写程序，有90%的人写出的程序中有各种各样的Bug，读者不信的话可以不看书自己写一遍试试。这个算法容易出错的地方很多，比如<code>mid = (start + end) / 2;</code>这一句，在数学概念上其实是<code>mid = ⌊(start + end) / 2⌋</code>，还有<code>start = mid + 1;</code>和<code>end = mid - 1;</code>，如果前者写成了<code>start = mid;</code>或后者写成了<code>end = mid;</code>那么很可能会导致死循环（想一想什么情况下会死循环）。</p>
<p>怎样才能保证程序的正确性呢？在第 2 节 “插入排序”我们讲过借助Loop Invariant证明循环的正确性，binarysearch这个函数的主体也是一个循环，它的Loop Invariant可以这样描述：待查找的元素<code>number</code>如果存在于数组<code>a</code>之中，那么一定存在于<code>a[start..end]</code>这个范围之间，换句话说，在这个范围之外的数组<code>a</code>的元素中一定不存在<code>number</code>这个元素。以下为了书写方便，我们把这句话表示成<code>mustbe(start, end, number)</code>。可以一边看算法一边做推理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid, start = <span class="number">0</span>, end = LEN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 假定a是排好序的 */</span></span><br><span class="line">    <span class="comment">/* mustbe(start, end, number)，因为a[start..end]就是整个数组a[0..LEN-1] */</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="comment">/* mustbe(start, end, number)，因为一开始进入循环时是正确的，每次循环也都维护了这个条件 */</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; number)</span><br><span class="line">            <span class="comment">/* 既然a是排好序的，a[start..mid]应该都比number小，所以mustbe(mid+1, end, number) */</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* 维护了mustbe(start, end, number) */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; number)</span><br><span class="line">            <span class="comment">/* 既然a是排好序的，a[mid..end]应该都比number大，所以mustbe(start, mid-1, number) */</span></span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* 维护了mustbe(start, end, number) */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* a[mid] == number，说明找到了 */</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * mustbe(start, end, number)一直被循环维护着，到这里应该仍然成立，在a[start..end]范围之外一定不存在number，</span></span><br><span class="line"><span class="comment">     * 但现在a[start..end]是空序列，在这个范围之外的正是整个数组a，因此整个数组a中都不存在number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个算法有一个非常重要的前提－－<code>a</code>是排好序的。缺了这个前提，“如果<code>a[mid] &lt; number</code>，那么<code>a[start..mid]</code>应该都比<code>number</code>小”这一步推理就不能成立，这个函数就不能正确地完成查找。从更普遍的意义上说，函数的调用者（Caller）和函数的实现者（Callee，被调用者）之间订立了一个契约（Contract），在调用函数之前，Caller要为Callee提供某些条件，比如确保a是排好序的，确保<code>a[start..end]</code>都是有效的数组元素而没有访问越界，这称为Precondition，然后Callee对一些Invariant进行维护（Maintenance），这些Invariant保证了Callee在函数返回时能够对Caller尽到某些义务，比如确保“如果<code>number</code>在数组<code>a</code>中存在，一定能找出来并返回它的位置，如果<code>number</code>在数组<code>a</code>中不存在，一定能返回<code>-1</code>”，这称为Postcondition。如果每个函数的文档都非常清楚地记录了Precondition、Maintenance和Postcondition是什么，那么每个函数都可以独立编写和测试，整个系统就会易于维护。这种编程思想是由Eiffel语言的设计者Bertrand Meyer提出来的，称为Design by Contract（DbC）。</p>
<p>测试一个函数是否正确需要把Precondition、Maintenance和Postcondition这三方面都测试到，比如binarysearch这个函数，即使它写得非常正确，既维护了Invariant也保证了Postcondition，如果调用它的Caller没有保证Precondition，最后的结果也还是错的。我们编写几个测试用的Predicate函数，然后把相关的测试插入到binarysearch函数中：</p>
<p>例 带有测试代码的折半查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LEN 8</span></span><br><span class="line"><span class="type">int</span> a[LEN] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_sorted</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; LEN; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mustbe</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; start; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == number)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = end+<span class="number">1</span>; i &lt; LEN; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == number)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LEN; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid, start = <span class="number">0</span>, end = LEN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    assert(is_sorted()); <span class="comment">/* Precondition */</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        assert(mustbe(start, end, number)); <span class="comment">/* Maintenance */</span></span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; number)</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; number)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(mid &gt;= start &amp;&amp; mid &lt;= end</span><br><span class="line">                   &amp;&amp; a[mid] == number) <span class="comment">/* Postcondition 1 */</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!contains(number)); <span class="comment">/* Postcondition 2 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, binarysearch(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>assert</code>是头文件<code>assert.h</code>中的一个宏定义，执行到<code>assert(is_sorted())</code>这句时，如果<code>is_sorted()</code>返回值为真，则当什么事都没发生过，继续往下执行，如果<code>is_sorted()</code>返回值为假（例如把数组的排列顺序改一改），则报错退出程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.c:33: binarysearch: Assertion `is_sorted()&#x27; failed.</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>
<p>在代码中适当的地方使用断言（Assertion）可以有效地帮助我们测试程序。也许有人会问：我们用几个测试函数来测试binarysearch，那么这几个测试函数又用什么来测试呢？在实际工作中我们要测试的代码绝不会像binarysearch这么简单，而我们编写的测试函数往往都很简单，比较容易保证正确性，也就是用简单的、不容易出错的代码去测试复杂的、容易出错的代码。</p>
<p>测试代码只在开发和调试时有用，如果正式发布（Release）的软件也要运行这些测试代码就会严重影响性能了，如果在包含<code>assert.h</code>之前定义一个<code>NDEBUG</code>宏（表示No Debug），就可以禁用<code>assert.h</code>中的<code>assert</code>宏定义，这样代码中的所有<code>assert</code>测试都不起作用了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意<code>NDEBUG</code>和我们以前使用的宏定义有点不同，例如<code>#define N 20</code>将<code>N</code>定义为<code>20</code>，在预处理时把代码中所有的标识符<code>N</code>替换成<code>20</code>，而<code>#define NDEBUG</code>把<code>NDEBUG</code>定义为空，在预处理时把代码中所有的标识符<code>NDEBUG</code>替换成空。这样的宏定义主要是为了用<code>#ifdef</code>等预处理指示测试它定义过没有，而不是为了做替换，所以定义成什么值都无所谓，一般定义成空就足够了。</p>
<p>还有另一种办法，不必修改源文件，在编译命令行加上选项<code>-DNDEBUG</code>就相当于在源文件开头定义了<code>NDEBUG</code>宏。宏定义和预处理到第 21 章 预处理再详细解释，在第 4 节 “其它预处理特性”将给出<code>assert.h</code>一种实现。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" rel="prev" title="C语言:数据类型">
                  <i class="fa fa-angle-left"></i> C语言:数据类型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AD%E7%AB%A0/" rel="next" title="C语言:循环语句">
                  C语言:循环语句 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
