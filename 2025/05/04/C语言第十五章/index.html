<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="整型 我们知道，在C语言中char型占一个字节的存储空间，一个字节通常是8个bit。如果这8个bit按无符号整数来解释，取值范围是0~255，如果按有符号整数来解释，采用2’s Complement表示法，取值范围是-128~127。C语言规定了signed和unsigned两个关键字，unsigned char型表示无符号数，signed char型表示有符号数。 那么以前我们常用的不带s">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言:数据类型">
<meta property="og:url" content="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:description" content="整型 我们知道，在C语言中char型占一个字节的存储空间，一个字节通常是8个bit。如果这8个bit按无符号整数来解释，取值范围是0~255，如果按有符号整数来解释，采用2’s Complement表示法，取值范围是-128~127。C语言规定了signed和unsigned两个关键字，unsigned char型表示无符号数，signed char型表示有符号数。 那么以前我们常用的不带s">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-08T11:53:53.637Z">
<meta property="article:author" content="SiyuanLei">
<meta property="article:tag" content="C">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/","path":"2025/05/04/C语言第十五章/","title":"C语言:数据类型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C语言:数据类型 | SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SiyuanLei's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#integer-promotion"><span class="nav-number">3.1.</span> <span class="nav-text">Integer Promotion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#usual-arithmetic-conversion"><span class="nav-number">3.2.</span> <span class="nav-text">Usual Arithmetic Conversion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E8%B5%8B%E5%80%BC%E4%BA%A7%E7%94%9F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.</span> <span class="nav-text">由赋值产生的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.5.</span> <span class="nav-text">编译器如何处理类型转换</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C语言:数据类型 | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言:数据类型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:53" itemprop="dateModified" datetime="2025-08-08T19:53:53+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="整型">整型</h2>
<p>我们知道，在C语言中<code>char</code>型占一个字节的存储空间，一个字节通常是8个bit。如果这8个bit按无符号整数来解释，取值范围是0~255，如果按有符号整数来解释，采用2’s
Complement表示法，取值范围是-128~127。C语言规定了<code>signed</code>和<code>unsigned</code>两个关键字，<code>unsigned char</code>型表示无符号数，<code>signed char</code>型表示有符号数。</p>
<p>那么以前我们常用的不带<code>signed</code>或<code>unsigned</code>关键字的<code>char</code>型是无符号数还是有符号数呢？C标准规定这是Implementation
Defined，编译器可以定义<code>char</code>型是无符号的，也可以定义<code>char</code>型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现，x86平台的gcc定义<code>char</code>型是有符号的。这也是C标准的Rationale之一：优先考虑效率，而可移植性尚在其次。这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如Linux内核代码使用了很多只有gcc支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由故意写不可移植的代码。从现在开始，我们会接触到很多Implementation
Defined的特性，C语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论C语言，就只能讨论到本书第一部分的程度了。注意，ASCII码的取值范围是0~127，所以不管<code>char</code>型是有符号的还是无符号的，存一个ASCII码都没有问题，一般来说，如果用<code>char</code>型存ASCII码字符，就不必明确写是<code>signed</code>还是<code>unsigned</code>，如果用<code>char</code>型表示8位的整数，为了可移植性就必须写明是<code>signed</code>还是<code>unsigned</code>。</p>
<p>Implementation-defined、Unspecified和Undefined
在C标准中没有做明确规定的地方会用Implementation-defined、Unspecified或Undefined来表述，在本书中有时把这三种情况统称为“未明确定义”的。这三种情况到底有什么不同呢？</p>
<p>我们刚才看到一种Implementation-defined的情况，C标准没有明确规定<code>char</code>是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。</p>
<p>而对于Unspecified的情况，往往有几种可选的处理方式，C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是Unspecified的。</p>
<p>Undefined的情况则是完全不确定的，C标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多Undefined的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是Undefined的。</p>
<p>初学者看到这些规则通常会很不舒服，觉得这不是在学编程而是在啃法律条文，结果越学越泄气。是的，C语言并不像一个数学定理那么完美，现实世界里的东西总是不够完美的。但还好啦，C程序员已经很幸福了，只要严格遵照C标准来写代码，不要去触碰那些阴暗角落，写出来的代码就有很好的可移植性。想想那些可怜的JavaScript程序员吧，他们甚至连一个可以遵照的标准都没有，一个浏览器一个样，甚至同一个浏览器的不同版本也差别很大，程序员不得不为每一种浏览器的每一个版本分别写不同的代码。</p>
<p>除了<code>char</code>型之外，整型还包括<code>short int</code>（或者简写为<code>short</code>）、<code>int</code>、<code>long int</code>（或者简写为<code>long</code>）、<code>long long int</code>（或者简写为<code>long long</code>）等几种，这些类型都可以加上<code>signed</code>或<code>unsigned</code>关键字表示有符号或无符号数。其实，对于有符号数在计算机中的表示是Sign
and Magnitude、1’s Complement还是2’s
Complement，C标准也没有明确规定，也是Implementation
Defined。大多数体系结构都采用2’s
Complement表示法，x86平台也是如此，从现在开始我们只讨论2’s
Complement表示法的情况。还有一点要注意，除了<code>char</code>型以外的这些类型如果不明确写<code>signed</code>或<code>unsigned</code>关键字都表示<code>signed</code>，这一点是C标准明确规定的，不是Implementation
Defined。</p>
<p>除了<code>char</code>型在C标准中明确规定占一个字节之外，其它整型占几个字节都是Implementation
Defined。通常的编译器实现遵守ILP32或LP64规范，如下表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>ILP32（位数）</th>
<th>LP64（位数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>64</td>
</tr>
<tr>
<td>指针</td>
<td>32</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>ILP32这个缩写的意思是<code>int</code>（I）、<code>long</code>（L）和指针（P）类型都占32位，通常32位计算机的C编译器采用这种规范，x86平台的gcc也是如此。LP64是指long（L）和指针占64位，通常64位计算机的C编译器采用这种规范。指针类型的长度总是和计算机的位数一致，至于什么是计算机的位数，指针又是一种什么样的类型，我们到第
17 章 计算机体系结构基础和第 23 章
指针再分别详细解释。从现在开始本书做以下约定：在以后的陈述中，缺省平台是x86/Linux/gcc，遵循ILP32，并且char是有符号的，我不会每次都加以说明，但说到其它平台时我会明确指出是什么平台。</p>
<p>在第 2 节
“常量”讲过C语言的常量有整数常量、字符常量、枚举常量和浮点数常量四种，其实字符常量和枚举常量的类型都是<code>int</code>型，因此前三种常量的类型都属于整型。整数常量有很多种，不全是<code>int</code>型的，下面我们详细讨论整数常量。</p>
<p>以前我们只用到十进制的整数常量，其实在C语言中也可以用八进制和十六进制的整数常量[26]。八进制整数常量以0开头，后面的数字只能是0<sub>7，例如022，因此十进制的整数常量就不能以0开头了，否则无法和八进制区分。十六进制整数常量以0x或0X开头，后面的数字可以是0</sub>9、a<sub>f和A</sub>F。在第
6 节
“字符类型与字符编码”讲过一种转义序列，以，这种表示方式相当于把八进制和十六进制整数常量开头的0替换成。</p>
<p>整数常量还可以在末尾加u或U表示“<code>unsigned</code>”，加l或L表示“<code>long</code>”，加ll或LL表示“<code>long long</code>”，例如0x1234U，98765ULL等。但事实上u、l、ll这几种后缀和上面讲的<code>unsigned</code>、<code>long</code>、<code>long long</code>关键字并不是一一对应的。这个对应关系比较复杂，准确的描述如下表所示（出自[C99]条款6.4.4.1）。</p>
<p>表 15.2. 整数常量的类型</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>后缀</th>
<th>十进制常量</th>
<th>八进制或十六进制常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>int<br>long int<br>long long int<br></td>
<td>int<br>unsigned int<br>long int<br>unsigned long int<br>long long
int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>u或U</td>
<td>unsigned int<br>unsigned long int<br>unsigned long long int<br></td>
<td>unsigned int<br>unsigned long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>l或L</td>
<td>long int<br>long long int<br></td>
<td>long int<br>unsigned long int<br>long long int<br>unsigned long long
int<br></td>
</tr>
<tr>
<td>既有u或U，又有l或L</td>
<td>unsigned long int<br>unsigned long long int<br></td>
<td>unsigned long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>ll或LL</td>
<td>long long int</td>
<td>long long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>既有u或U，又有ll或LL</td>
<td>unsigned long long int</td>
<td>unsigned long long int</td>
</tr>
</tbody>
</table>
<p>给定一个整数常量，比如1234U，那么它应该属于“u或U”这一行的“十进制常量”这一列，这个表格单元中列了三种类型<code>unsigned int</code>、<code>unsigned long int</code>、<code>unsigned long long int</code>，从上到下找出第一个足够长的类型可以表示1234这个数，那么它就是这个整数常量的类型，如果<code>int</code>是32位的那么<code>unsigned int</code>就可以表示。</p>
<p>再比如0xffff0000，应该属于第一行“无”的第二列“八进制或十六进制常量”，这一列有六种类型<code>int</code>、<code>unsigned int</code>、<code>long int</code>、<code>unsigned long int</code>、<code>long long int</code>、<code>unsigned long long int</code>，第一个类型<code>int</code>表示不了0xffff0000这么大的数，我们写这个十六进制常量是要表示一个正数，而它的MSB（第31位）是1，如果按有符号<code>int</code>类型来解释就成了负数了，第二个类型<code>unsigned int</code>可以表示这个数，所以这个十六进制常量的类型应该算<code>unsigned int</code>。所以请注意，0x7fffffff和0xffff0000这两个常量虽然看起来差不多，但前者是<code>int</code>型，而后者是<code>unsigned int</code>型。</p>
<p>讲一个有意思的问题。我们知道x86平台上<code>int</code>的取值范围是-2147483648~2147483647，那么用<code>printf("%d\n", -2147483648);</code>打印<code>int</code>类型的下界有没有问题呢？如果用<code>gcc main.c -std=c99</code>编译会有警告信息：<code>warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’</code>。这是因为，虽然-2147483648这个数值能够用<code>int</code>型表示，但在C语言中却没法写出对应这个数值的<code>int</code>型常量，C编译器会把它当成一个整数常量2147483648和一个负号运算符组成的表达式，而整数常量2147483648已经超过了<code>int</code>型的取值范围，在x86平台上<code>int</code>和<code>long</code>的取值范围相同，所以这个常量也超过了<code>long</code>型的取值范围，根据上表第一行“无”的第一列十进制常量，这个整数常量应该算<code>long long</code>型的，前面再加个负号组成的表达式仍然是<code>long long</code>型，而<code>printf</code>的<code>%d</code>转换说明要求后面的参数是<code>int</code>型，所以编译器报警告。之所以编译命令要加<code>-std=c99</code>选项是因为C99以前对于整数常量的类型规定和上表有一些出入，即使不加这个选项也会报警告，但警告信息不准确，读者可以试试。如果改成<code>printf("%d\n", -2147483647-1);</code>编译器就不会报警告了，<code>-</code>号运算符的两个操作数-2147483647和1都是<code>int</code>型，计算结果也应该是<code>int</code>型，并且它的值也没有超出<code>int</code>型的取值范围；或者改成<code>printf("%lld\n", -2147483648);</code>也可以，转换说明<code>%lld</code>告诉<code>printf</code>后面的参数是<code>long long</code>型，有些转换说明格式目前还没讲到，详见第
2.9 节 “格式化I/O函数”。</p>
<p>怎么样，整数常量没有你原来想的那么简单吧。再看一个不简单的问题。<code>long long i = 1234567890 * 1234567890;</code>编译时会有警告信息：<code>warning: integer overflow in expression</code>。1234567890是<code>int</code>型，两个<code>int</code>型相乘的表达式仍然是<code>int</code>型，而乘积已经超过<code>int</code>型的取值范围了，因此提示计算结果溢出。如果改成<code>long long i = 1234567890LL * 1234567890;</code>，其中一个常量是<code>long long</code>型，另一个常量也会先转换成<code>long long</code>型再做乘法运算，两数相乘的表达式也是<code>long long</code>型，编译器就不会报警告了。有关类型转换的规则将在第
3 节 “类型转换”详细介绍。</p>
<h2 id="浮点型">浮点型</h2>
<p>C标准规定的浮点型有<code>float</code>、<code>double</code>、<code>long double</code>，和整型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大，有的处理器有浮点运算单元（FPU，Floating
Point
Unit），称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单元，只能做整数运算，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。大部分平台的浮点数实现遵循IEEE
754，<code>float</code>型通常是32位，<code>double</code>型通常是64位。</p>
<p><code>long double</code>型通常是比<code>double</code>型精度更高的类型，但各平台的实现有较大差异。在x86平台上，大多数编译器实现的<code>long double</code>型是80位，因为x86的浮点运算单元具有80位精度，gcc实现的<code>long double</code>型是12字节（96位），这是为了对齐到4字节边界（在第
4 节
“结构体和联合体”详细讨论对齐的问题），也有些编译器实现的<code>long double</code>型和<code>double</code>型精度相同，没有充分利用x86浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上的<code>long double</code>型通常是128位。</p>
<p>以前我们只用到最简单的浮点数常量，例如3.14，现在看看浮点数常量还有哪些写法。由于浮点数在计算机中的表示是基于科学计数法的，所以浮点数常量也可以写成科学计数法的形式，尾数和指数之间用e或E隔开，例如314e-2表示314×10-2，注意这种表示形式基数是10[27]，如果尾数的小数点左边或右边没有数字则表示这一部分为零，例如3.e-1，.987等等。浮点数也可以加一个后缀，例如3.14f、.01L，浮点数的后缀和类型之间的对应关系比较简单，没有后缀的浮点数常量是<code>double</code>型的，有后缀f或F的浮点数常量是<code>float</code>型的，有后缀l或L的浮点数常量是<code>long double</code>型的。</p>
<h2 id="类型转换">类型转换</h2>
<p>如果有人问C语法规则中最复杂的是哪一部分，我一定会说是类型转换。从上面两节可以看出，有符号、无符号整数和浮点数加起来有那么多种类型，每两种类型之间都要定义一个转换规则，转换规则的数量自然很庞大，更何况由于各种体系结构对于整数和浮点数的实现很不相同，很多类型转换的情况都是C标准未做明确规定的阴暗角落。虽然我们写代码时不会故意去触碰这些阴暗角落，但有时候会不小心犯错，所以了解一些未明确规定的情况还是有必要的，可以在出错时更容易分析错误原因。本节分成几小节，首先介绍哪些情况下会发生类型转换，会把什么类型转成什么类型，然后介绍编译器如何处理这样的类型转换。</p>
<h3 id="integer-promotion">Integer Promotion</h3>
<p>在一个表达式中，凡是可以使用<code>int</code>或<code>unsigned int</code>类型做右值的地方也都可以使用有符号或无符号的<code>char</code>型、<code>short</code>型和Bit-field。如果原始类型的取值范围都能用<code>int</code>型表示，则其类型被提升为<code>int</code>，如果原始类型的取值范围用<code>int</code>型表示不了，则提升为<code>unsigned int</code>型，这称为Integer
Promotion。做Integer
Promotion只影响上述几种类型的值，对其它类型无影响。C99规定Integer
Promotion适用于以下几种情况：</p>
<p>1、如果一个函数的形参类型未知，例如使用了Old Style
C风格的函数声明（详见第 2 节
“自定义函数”），或者函数的参数列表中有…，那么调用函数时要对相应的实参做Integer
Promotion，此外，相应的实参如果是<code>float</code>型的也要被提升为<code>double</code>型，这条规则称为Default
Argument
Promotion。我们知道<code>printf</code>的参数列表中有…，除了第一个形参之外，其它形参的类型都是未知的，比如有这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure>
<p><code>ch</code>要被提升为<code>int</code>型之后再传给<code>printf</code>。</p>
<p>2、算术运算中的类型转换。有符号或无符号的<code>char</code>型、<code>short</code>型和Bit-field在做算术运算之前首先要做Integer
Promotion，然后才能参与计算。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c1 = <span class="number">255</span>, c2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n = c1 + c2;</span><br></pre></td></tr></table></figure>
<p>计算表达式<code>c1 + c2</code>的过程其实是先把<code>c1</code>和<code>c2</code>提升为<code>int</code>型然后再相加（<code>unsigned char</code>的取值范围是0~255，完全可以用<code>int</code>表示，所以提升为<code>int</code>就可以了，不需要提升为<code>unsigned int</code>），整个表达式的值也是<code>int</code>型，最后的结果是257。假如没有这个提升的过程，<code>c1 + c2</code>就溢出了，溢出会得到什么结果是Undefined，在大多数平台上会把进位截掉，得到的结果应该是1。</p>
<p>除了<code>+</code>号之外还有哪些运算符在计算之前需要做Integer
Promotion呢？我们在下一小节先介绍Usual Arithmetic
Conversion规则，然后再解答这个问题。</p>
<h3 id="usual-arithmetic-conversion">Usual Arithmetic Conversion</h3>
<p>两个算术类型的操作数做算术运算，比如<code>a + b</code>，如果两边操作数的类型不同，编译器会自动做类型转换，使两边类型相同之后才做运算，这称为Usual
Arithmetic Conversion。转换规则如下：</p>
<p>如果有一边的类型是<code>long double</code>，则把另一边也转成<code>long double</code>。</p>
<p>否则，如果有一边的类型是<code>double</code>，则把另一边也转成<code>double</code>。</p>
<p>否则，如果有一边的类型是<code>float</code>，则把另一边也转成<code>float</code>。</p>
<p>否则，两边应该都是整型，首先按上一小节讲过的规则对<code>a</code>和<code>b</code>做Integer
Promotion，然后如果类型仍不相同，则需要继续转换。首先我们规定<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>的转换级别（Integer
Conversion
Rank）一个比一个高，同一类型的有符号和无符号数具有相同的Rank。转换规则如下：</p>
<p>如果两边都是有符号数，或者都是无符号数，那么较低Rank的类型转换成较高Rank的类型。例如<code>unsigned int</code>和<code>unsigned long</code>做算术运算时都转成<code>unsigned long</code>。</p>
<p>否则，如果一边是无符号数另一边是有符号数，无符号数的Rank不低于有符号数的Rank，则把有符号数转成另一边的无符号类型。例如<code>unsigned long</code>和<code>int</code>做算术运算时都转成<code>unsigned long</code>，<code>unsigned long</code>和<code>long</code>做算术运算时也都转成<code>unsigned long</code>。</p>
<p>剩下的情况是：一边有符号另一边无符号，并且无符号数的Rank低于有符号数的Rank。这时又分为两种情况，如果这个有符号数类型能够覆盖这个无符号数类型的取值范围，则把无符号数转成另一边的有符号类型。例如遵循LP64的平台上<code>unsigned int</code>和<code>long</code>在做算术运算时都转成<code>long</code>。</p>
<p>否则，也就是这个有符号数类型不足以覆盖这个无符号数类型的取值范围，则把两边都转成有符号数的Rank对应的无符号类型。例如在遵循ILP32的平台上<code>unsigned int</code>和<code>long</code>在做算术运算时都转成<code>unsigned long</code>。</p>
<p>可见有符号和无符号整数的转换规则是十分复杂的，虽然这是有明确规定的，不属于阴暗角落，但为了程序的可读性不应该依赖这些规则来写代码。我讲这些规则，不是为了让你用，而是为了让你了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段。</p>
<p>到目前为止我们学过的<code>+ - * / % &gt; &lt; &gt;= &lt;= == !=</code>运算符都需要做Usual
Arithmetic
Conversion，因为都要求两边操作数的类型一致，在下一章会介绍几种新的运算符也需要做Usual
Arithmetic
Conversion。单目运算符<code>+ - ~</code>只有一个操作数，移位运算符<code>&lt;&lt; &gt;&gt;</code>两边的操作数类型不要求一致，这些运算不需要做Usual
Arithmetic Conversion，但也需要做Integer
Promotion，运算符<code>~ &lt;&lt; &gt;&gt;</code>将在下一章介绍。</p>
<h3 id="由赋值产生的类型转换">由赋值产生的类型转换</h3>
<p>如果赋值或初始化时等号两边的类型不相同，则编译器会把等号右边的类型转换成等号左边的类型再做赋值。例如<code>int c = 3.14;</code>，编译器会把右边的<code>double</code>型转成<code>int</code>型再赋给变量c。</p>
<p>我们知道，函数调用传参的过程相当于定义形参并且用实参对其做初始化，函数返回的过程相当于定义一个临时变量并且用<code>return</code>的表达式对其做初始化，所以由赋值产生的类型转换也适用于这两种情况。例如一个函数的原型是<code>int foo(int, int);</code>，则调用<code>foo(3.1, 4.2)</code>时会自动把两个<code>double</code>型的实参转成<code>int</code>型赋给形参，如果这个函数定义中有返回语句<code>return 1.2;</code>，则返回值1.2会自动转成<code>int</code>型再返回。</p>
<p>在函数调用和返回过程中发生的类型转换往往容易被忽视，因为函数原型和函数调用并没有写在一起。例如<code>char c = getchar();</code>，看到这一句往往会想当然地认为<code>getchar</code>的返回值是<code>char</code>型，而事实上<code>getchar</code>的返回值是<code>int</code>型，这样赋值会引起类型转换，可能产生Bug，我们在第
2.5 节 “以字节为单位的I/O函数”详细讨论这个问题。</p>
<h3 id="强制类型转换">强制类型转换</h3>
<p>以上三种情况通称为隐式类型转换（Implicit
Conversion，或者叫Coercion），编译器根据它自己的一套规则将一种类型自动转换成另一种类型。除此之外，程序员也可以通过类型转换运算符（Cast
Operator）自己规定某个表达式要转换成何种类型，这称为显式类型转换（Explicit
Conversion）或强制类型转换（Type
Cast）。例如计算表达式<code>(double)3 + i</code>，首先将整数3强制转换成<code>double</code>型（值为3.0），然后和整型变量<code>i</code>相加，这时适用Usual
Arithmetic
Conversion规则，首先把<code>i</code>也转成<code>double</code>型，然后两者相加，最后整个表达式也是<code>double</code>型的。这里的<code>(double)</code>就是一个类型转换运算符，这种运算符由一个类型名套<code>()</code>括号组成，属于单目运算符，后面的3是这个运算符的操作数。注意操作数的类型必须是标量类型，转换之后的类型必须是标量类型或者<code>void</code>型。</p>
<h3 id="编译器如何处理类型转换">编译器如何处理类型转换</h3>
<p>以上几小节介绍了哪些情况下会发生类型转换，并且明确了每种情况下会把什么类型转成什么类型，本节介绍编译器如何处理任意两种类型之间的转换。现在要把一个M位的类型（值为X）转换成一个N位的类型，所有可能的情况如下表所示。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>待转换的类型</th>
<th>M &gt; N的情况</th>
<th>M == N的情况</th>
<th>M &lt; N的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed integer to signed integer</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>值不变</td>
<td>值不变</td>
</tr>
<tr>
<td>unsigned integer to signed integer</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>值不变</td>
</tr>
<tr>
<td>signed integer to unsigned integer</td>
<td>X % 2N</td>
<td>X % 2N</td>
<td>X % 2N</td>
</tr>
<tr>
<td>unsigned integer to unsigned integer</td>
<td>X % 2N</td>
<td>值不变</td>
<td>值不变</td>
</tr>
<tr>
<td>floating-point to signed or unsigned integer</td>
<td>Truncate toward
Zero，如果X的整数部分超出目标类型的取值范围则Undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed or unsigned integer to floating-point</td>
<td>如果X在目标类型的取值范围内则值不变，但有可能损失精度，如果X超出目标类型的取值范围则Undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td>floating-point to floating-point</td>
<td>如果X在目标类型的取值范围内则值不变，但有可能损失精度，如果X超出目标类型的取值范围则Undefined</td>
<td>值不变</td>
<td>值不变</td>
</tr>
</tbody>
</table>
<p>注意上表中的“X %
2N”，我想表达的意思是“把X加上或者减去2N的整数倍，使结果落入[0,
2N-1]的范围内”，当X是负数时运算结果也得是正数，即运算结果和除数同号而不是和被除数同号，这不同于C语言%运算的定义。写程序时不要故意用上表中的规则，尤其不要触碰Implementation-defined和Undefined的情况，但程序出错时可以借助上表分析错误原因。</p>
<p>下面举几个例子说明上表的用法。比如把<code>double</code>型转换成<code>short</code>型，对应表中的“floating-point
to signed or unsigned integer”，如果原值在(-32769.0,
32768.0)之间则截掉小数部分得到转换结果，否则产生溢出，结果是Undefined，例如对于<code>short s = 32768.4;</code>这个语句gcc会报警告。</p>
<p>比如把<code>int</code>型转换成<code>unsigned short</code>型，对应表中的“signed
integer to unsigned
integer”，如果原值是正的，则把它除以216取模，其实就是取它的低16位，如果原值是负的，则加上216的整数倍，使结果落在[0,
65535]之间。</p>
<p>比如把<code>int</code>类型转换成<code>short</code>类型，对应表中的“signed
integer to signed integer”，如果原值在[-32768,
32767]之间则值不变，否则产生溢出，结果是Implementation-defined，例如对于<code>short s = -32769;</code>这个语句gcc会报警告。</p>
<p>最后一个例子，把<code>short</code>型转换成<code>int</code>型，对应表中的“signed
integer to signed
integer”，转换之后应该值不变。那怎么维持值不变呢？是不是在高位补16个0就行了呢？如果原值是-1，十六进制表示就是ffff，要转成<code>int</code>型的-1需要变成ffffffff，因此需要在高位补16个1而不是16个0。换句话说，要维持值不变，在高位补1还是补0取决于原来的符号位，这称为符号扩展（Sign
Extension）。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" rel="prev" title="C语言:数据类型">
                  <i class="fa fa-angle-left"></i> C语言:数据类型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" rel="next" title="C语言:栈与队列">
                  C语言:栈与队列 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
