<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">RISC-V处理器设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-22 19:54:23" itemprop="dateModified" datetime="2026-01-22T19:54:23+08:00">2026-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="chapter-1-pc计数器">Chapter 1 PC计数器</h2>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps                                                                                     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span>   AW = <span class="number">32</span>    <span class="comment">// 地址宽度参数，默认为32位（用于RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值（指令地址输出）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，用于存储当前地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主PC更新逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿或复位下降沿触发</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时PC初始化为0</span></span><br><span class="line">        <span class="comment">// RISC-V架构中复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转使能时，PC更新为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常顺序执行时，PC每次增加4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令长度为32位（4字节）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加逻辑：存储跳转前的PC值</span></span><br><span class="line"><span class="comment">// 这个寄存器可能用于异常处理或调试目的</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;  <span class="comment">// 复位清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存跳转前的PC值</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转前的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：else分支缺失，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是一个设计缺陷或未完成部分</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-2-rom">Chapter 2 ROM</h2>
<p>现在在PC计数器的基础上, 添加ROM模块.</p>
<p>现在我们有:</p>
<ol type="1">
<li>PC计数器</li>
<li>ROM</li>
<li>顶层模块</li>
</ol>
<h3 id="stage-2-pc计数器">Stage-2 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="comment">// 特点：同步复位，时钟上升沿触发，字节寻址（每次+4）</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效（低有效复位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效，1：执行跳转，0：顺序执行</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部寄存器声明</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 当前地址寄存器，暂存跳转前的PC值</span></span><br><span class="line">                              <span class="comment">// 可用于异常处理或调试接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 应用场景：分支指令、跳转指令、异常/中断处理</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可能用于：</span></span><br><span class="line"><span class="comment">//       1. 异常返回地址保存</span></span><br><span class="line"><span class="comment">//       2. 调试信息记录</span></span><br><span class="line"><span class="comment">//       3. 流水线冲刷恢复</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转使能信号有效时的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于jal指令的返回地址保存</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计缺陷，或者current_addr只在跳转时更新</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-rom模块">Stage-2 ROM模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="comment">// 特点：异步读取，支持参数化配置，从文件加载初始化数据</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位（RISC-V指令长度）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（ROM通常不需要时钟，这里提供接口用于同步设计）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,         <span class="comment">// 时钟信号（未使用，为统一接口保留）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,       <span class="comment">// 复位信号（未使用，为统一接口保留）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// 功能：构建完整的指令文件路径</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 功能：仿真开始时从文本文件加载指令到ROM存储器</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址异步读取指令</span></span><br><span class="line"><span class="comment">// 注意：由于RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 指令读取：将字节地址转换为字地址</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：原代码中注释掉的时序逻辑版本</span></span><br><span class="line"><span class="comment">// 如果希望同步读取，可以使用以下代码：</span></span><br><span class="line"><span class="comment">// always_ff @(posedge clk or negedge rst_n)</span></span><br><span class="line"><span class="comment">//   if(!rst_n)</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= &#x27;h0;      // 复位时输出0</span></span><br><span class="line"><span class="comment">//   else</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= rom_mem[instr_addr[AW-1:2]];  // 时钟上升沿读取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-顶层模块">Stage-2 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成PC计数器和ROM，构成基本的取指流水线</span></span><br><span class="line"><span class="comment">// 当前状态：最小化测试版本，仅支持顺序执行</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径（传递给ROM）</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,     <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n    <span class="comment">// 异步复位，低电平有效</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;       <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;     <span class="comment">// 跳转目标地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;    <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;   <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前版本）</span></span><br><span class="line"><span class="comment">// 功能：在当前简化版本中，固定为顺序执行模式</span></span><br><span class="line"><span class="comment">// 后续开发：这些信号将由控制单元根据指令解码结果生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;      <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;       <span class="comment">// 跳转地址固定为0（实际未使用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line"><span class="comment">// 功能：生成指令地址，控制程序流</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)                    <span class="comment">// 传递地址宽度参数</span></span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>       (clk),         <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst_n</span>     (rst_n),       <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.jump_en</span>   (jump_en),     <span class="comment">// 跳转使能（当前为0）</span></span><br><span class="line">    <span class="variable">.jump_addr</span> (jump_addr),   <span class="comment">// 跳转地址（当前为0）</span></span><br><span class="line">    <span class="variable">.pc_pointer</span>(pc_pointer)   <span class="comment">// 输出的PC值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line"><span class="comment">// 功能：存储并输出指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),              <span class="comment">// 传递指令文件路径</span></span><br><span class="line">    <span class="variable">.AW</span>  (AW),                <span class="comment">// 传递地址宽度</span></span><br><span class="line">    <span class="variable">.DW</span>  (DW)                 <span class="comment">// 传递数据宽度</span></span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),        <span class="comment">// 时钟（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),      <span class="comment">// 复位（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer), <span class="comment">// 指令地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction) <span class="comment">// 输出的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 当前模块功能说明：</span></span><br><span class="line"><span class="comment">// 1. 复位后，PC从0x00000000开始</span></span><br><span class="line"><span class="comment">// 2. 每个时钟周期，PC自动+4（顺序执行）</span></span><br><span class="line"><span class="comment">// 3. ROM根据PC值输出对应指令</span></span><br><span class="line"><span class="comment">// 4. 当前不支持跳转、分支等控制流指令</span></span><br><span class="line"><span class="comment">// 5. 这是一个最小化的测试框架，用于验证取指功能</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 后续扩展方向：</span></span><br><span class="line"><span class="comment">// 1. 添加指令解码模块</span></span><br><span class="line"><span class="comment">// 2. 添加寄存器文件</span></span><br><span class="line"><span class="comment">// 3. 添加ALU执行单元</span></span><br><span class="line"><span class="comment">// 4. 添加控制单元生成jump_en和jump_addr</span></span><br><span class="line"><span class="comment">// 5. 添加数据存储器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-3-decode">Chapter 3 DECODE</h2>
<h3 id="stage-3-pc计数器模块">Stage-3 PC计数器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是为了保存跳转前的PC值用于后续处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-rom">Stage-3 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-译码模块">Stage-3 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址（当前未使用）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据（当前未使用）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-流水线寄存器模块">Stage-3 流水线寄存器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 解决流水线冒险 3. 提高时钟频率</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的PC值</span></span><br><span class="line"><span class="comment">// 用途：可用于计算PC相对偏移或异常处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的二进制编码</span></span><br><span class="line"><span class="comment">// 用途：为译码阶段提供稳定的指令输入</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-顶层模块">Stage-3 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 后续应由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs1_data = <span class="number">&#x27;d50</span>;          <span class="comment">// 硬连线：源寄存器1数据=50</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs2_data = <span class="number">&#x27;d100</span>;         <span class="comment">// 硬连线：源寄存器2数据=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-4-register">Chapter 4 Register</h2>
<h3 id="stage-4-pc计数器">Stage-4 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-rom">Stage-4 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-译码模块">Stage-4 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前实现存在问题：源寄存器地址分配错误</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line"><span class="comment">// 存在问题：源寄存器地址分配错误（见下文）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// <span class="doctag">BUG:</span> 这里将rs1分配给了rd_rs2_addr，应该是错误的</span></span><br><span class="line">        <span class="comment">// 正确的ADDI指令格式：rd = rs1 + imm</span></span><br><span class="line">        <span class="comment">// 所以应该是：rd_rs1_addr = rs1, rd_rs2_addr = 0</span></span><br><span class="line">        rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// <span class="doctag">BUG:</span> 应该为rs1</span></span><br><span class="line">        rd_rs2_addr = rs1;                  <span class="comment">// <span class="doctag">BUG:</span> 应该为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;; <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                   <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-ifid流水线寄存器">Stage-4 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-寄存器文件">Stage-4 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-顶层模块">Stage-4 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="comment">// 当前版本：连接了PC、ROM、IF/ID寄存器、译码器和寄存器文件</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器写回信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr_reg;    <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_en   = <span class="number">1&#x27;b1</span>;          <span class="comment">// 始终允许写寄存器（可能有问题）</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_data = op2_out;       <span class="comment">// BUG：写回数据应该是ALU结果，不是立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),    <span class="comment">// 输出到寄存器文件</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-5-alu">Chapter 5 ALU</h2>
<h3 id="stage-5-pc计数器">Stage-5 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-rom">Stage-5 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-译码模块">Stage-5 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-执行模块">Stage-5 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令执行：加法操作</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">        wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">        wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：禁用写回，输出清零</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">        wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">        wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-ifid流水线寄存器">Stage-5 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// <span class="doctag">BUG:</span> 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// <span class="doctag">BUG:</span> 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-idex流水线寄存器">Stage-5 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-寄存器文件">Stage-5 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-顶层模块">Stage-5 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-6-参数定义">Chapter 6 参数定义</h2>
<h3 id="stage-6-参数定义模块">Stage-6 参数定义模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址宽度和数据宽度</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW 						32  </span><span class="comment">// 地址宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW 						32  </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE					&quot;instr_data.txt&quot;  </span><span class="comment">// 默认指令文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I 	7&#x27;b0010011  </span><span class="comment">// I-type操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI		 	3&#x27;b000       </span><span class="comment">// 加法立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI		 	3&#x27;b010       </span><span class="comment">// 有符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU		3&#x27;b011       </span><span class="comment">// 无符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI			3&#x27;b100       </span><span class="comment">// 异或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI			3&#x27;b110       </span><span class="comment">// 或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI			3&#x27;b111       </span><span class="comment">// 与立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI			3&#x27;b001       </span><span class="comment">// 逻辑左移立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI			3&#x27;b101       </span><span class="comment">// 移位右移立即数指令（SRLI/SRAI）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L 	7&#x27;b0000011  </span><span class="comment">// 加载指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB			 	3&#x27;b000       </span><span class="comment">// 加载字节（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH			 	3&#x27;b001       </span><span class="comment">// 加载半字（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW				3&#x27;b010       </span><span class="comment">// 加载字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU			3&#x27;b100       </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU			3&#x27;b101       </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S 	7&#x27;b0100011  </span><span class="comment">// 存储指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB			 	3&#x27;b000       </span><span class="comment">// 存储字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH			 	3&#x27;b001       </span><span class="comment">// 存储半字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW				3&#x27;b010       </span><span class="comment">// 存储字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M 7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB	3&#x27;b000       </span><span class="comment">// 加法/减法指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL		 	3&#x27;b001       </span><span class="comment">// 逻辑左移</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT			3&#x27;b010       </span><span class="comment">// 有符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU			3&#x27;b011       </span><span class="comment">// 无符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR			3&#x27;b100       </span><span class="comment">// 异或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR				3&#x27;b101       </span><span class="comment">// 移位右移（SRL/SRA）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR				3&#x27;b110       </span><span class="comment">// 或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND			3&#x27;b111       </span><span class="comment">// 与</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL			3&#x27;b000       </span><span class="comment">// 乘法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH		 	3&#x27;b001       </span><span class="comment">// 乘法高位（有符号×有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU		3&#x27;b010       </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU		3&#x27;b011       </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV			3&#x27;b100       </span><span class="comment">// 有符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU			3&#x27;b101       </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM			3&#x27;b110       </span><span class="comment">// 有符号取余</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU			3&#x27;b111       </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL			7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR			7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI  		7&#x27;b0110111   </span><span class="comment">// 加载高位立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC		7&#x27;b0010111   </span><span class="comment">// PC相对加载高位立即数指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP			32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP		7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET			32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET			32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE		7&#x27;b0001111    </span><span class="comment">// 内存屏障指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL		32&#x27;h00000073  </span><span class="comment">// 环境调用指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK		32&#x27;h00100073  </span><span class="comment">// 断点指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_J 	7&#x27;b1100011   </span><span class="comment">// 分支指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ			3&#x27;b000        </span><span class="comment">// 相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE		 	3&#x27;b001        </span><span class="comment">// 不相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT			3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE			3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU			3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU			3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-pc计数器">Stage-6 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-rom">Stage-6 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-译码模块">Stage-6 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    <span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">                    <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">                    op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-执行模块">Stage-6 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    <span class="comment">// ADDI指令：加法操作</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-ifid流水线寄存器">Stage-6 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="comment">// 这是一个需要修复的BUG</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_out &lt;= `INST_NOP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-idex流水线寄存器">Stage-6 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="comment">// 指令寄存器加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= `INST_NOP;  <span class="comment">// 加载NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-寄存器文件">Stage-6 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-顶层模块">Stage-6 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 注意：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-7-整体架构">Chapter 7 整体架构</h2>
<h3 id="stage-7-参数定义">Stage-7 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-sub.txt&quot;  </span><span class="comment">// 默认指令文件（SUB指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-pc计数器">Stage-7 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-rom">Stage-7 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-译码模块">Stage-7 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;  <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-执行模块">Stage-7 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-ifid流水线寄存器">Stage-7 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了（应该修复）</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-idex流水线寄存器">Stage-7 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令编码清零</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-寄存器文件">Stage-7 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-顶层模块">Stage-7 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-8-流水线">Chapter 8 流水线</h2>
<h3 id="stage-8-参数定义">Stage-8 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-andi.txt&quot;  </span><span class="comment">// 默认指令文件（ANDI指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-pc计数器">Stage-8 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号（来自执行阶段）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值（用于异常返回）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-rom">Stage-8 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-译码模块">Stage-8 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// RISC-V不同指令类型的立即数格式不同</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-执行模块">Stage-8 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令（BNE）</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-ifid流水线寄存器">Stage-8 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,         <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                                  <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 指令数据加载NOP（空操作）</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令，避免错误指令执行</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 插入NOP指令</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out  &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out       &lt;= instr_in;       <span class="comment">// 锁存指令数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-idex流水线寄存器">Stage-8 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,     <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                              <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 指令编码加载NOP（空操作）</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 插入NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-寄存器文件">Stage-8 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-顶层模块">Stage-8 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿机制处理控制冒险</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>     (jump_en),          <span class="comment">// 跳转时停顿流水线，冲刷错误指令</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>       (jump_en),              <span class="comment">// 跳转时停顿流水线</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),       <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),            <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),           <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),           <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),   <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),        <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),          <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)           <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">第五章:仿真验证和Testbench编写</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 07:56:37" itemprop="dateModified" datetime="2026-01-15T07:56:37+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="verilog-hdl电路仿真和验证概述">Verilog
HDL电路仿真和验证概述</h2>
<p>仿真, 也称模拟, 是通过EDA仿真工具, 对所设计的电路或系统输入测试信号,
然后根据输出信号(如波形, 文本或者VCD文件)与期望值进行比较,
来确认是否得到与所期望一致的设计结果, 从而验证设计的正确性.</p>
<p>在设计过程中, 仿真是在综合之前完成的, 这就是通常所说的行为级仿真,
RTL仿真或者前仿真. 在RTL设计阶段只包含了时钟和时序,
并未包含门延时和线延时. 因此RTL仿真对于时钟来说是正确的,
并且不用考虑竞争冒险, 毛刺, 建立和保持时间以及其他一些详细的问题.</p>
<p>验证则是一系列测试平台的集合,
是一个证明设计思路如何实现及保证设计在功能上正确的过程. 验证在Verilog
HDL设计中分为4个阶段:</p>
<ol type="1">
<li>功能验证</li>
<li>综合后验证</li>
<li>时序验证</li>
<li>板级验证</li>
</ol>
<p>前三个验证是在PC平台上依靠EDA工具来完成的,
最后一个阶段则需要在真正的硬件平台(如FPGA, CPLD等)上进行,
需要借助一些调试工具和专业的分析仪来测试.</p>
<p>常用的功能验证有黑盒法, 白盒法, 灰盒法.</p>
<ol type="1">
<li>黑盒法: 把测试代码看成一个黑盒, 不需要考虑内部逻辑结构和特性,
只需要根据程序的需求规格说明书, 检查程序的功能是否符合其功能的说明.</li>
<li>白盒法: 白盒法又称为结构测试或逻辑驱动测试,
它是按照RTL级代码内部结构进行测试,
通过测试来检验RTL级代码内部实现是否按照设计规格说明书的规定正常运行,
检验RTL代码的每条路径是否能按照预定要求正确工作.</li>
<li>灰盒法: 介于黑盒法和白盒法之间的一种测试方法.</li>
</ol>
<h2 id="verilog-hdl测试程序设计基础">Verilog HDL测试程序设计基础</h2>
<h3 id="testbench及其结构">Testbench及其结构</h3>
<p>在Verilog HDL中, 常采用测试平台(Testbench)方式进行仿真和验证. 仿真时,
Testbench用来产生测试激励给待验证设计(Design Under Verification, DUV),
或者称为待测试设计(Design Under Test, DUT),
同时检查DUV/DUT的输出是否与期望一致, 从而达到验证设计功能的目的.</p>
<p>编写Testbench需要注意的问题:</p>
<ol type="1">
<li>Testbench代码不需要可综合性, 不会被实现为电路.</li>
<li>行为级描述效率高. Verilog HDL有5个描述层次, 分别为开关级, 门级,
RTL级, 算法级, 系统级.</li>
<li>结构化, 程式化的描述方式</li>
</ol>
<h3 id="测试平台举例">测试平台举例</h3>
<h4 id="组合逻辑电路仿真环境的搭建">组合逻辑电路仿真环境的搭建</h4>
<p>组合逻辑电路的仿真验证, 主要是检查设计结果是否符合电路真值表的功能,
因此在搭建仿真环境时,
用<code>initial</code>语句把被测试电路的输入按照真值表提供的数据变化作为测试条件.
组合逻辑电路的特点决定了仿真中只需对输入信号进行设计即可, 没有时序,
定时信息和全局复位, 置位等需求.</p>
<p>下面搭建全加器的仿真环境</p>
<table>
<thead>
<tr>
<th style="text-align: center;">a</th>
<th style="text-align: center;">b</th>
<th style="text-align: center;">ci</th>
<th style="text-align: center;">so</th>
<th style="text-align: center;">co</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder1(a,b,ci,so,co);</span><br><span class="line">    <span class="keyword">input</span>   a,b,ci;</span><br><span class="line">    <span class="keyword">output</span>  so,co;</span><br><span class="line">    <span class="keyword">assign</span>  &#123;co,so&#125;=a+b+ci;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder1_tb;</span><br><span class="line">    <span class="keyword">wire</span>    so,co;</span><br><span class="line">    <span class="keyword">reg</span>     a,b,ci;</span><br><span class="line">    adder1  U1(a,b,ci,so,so);<span class="comment">//模块实例化</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">0</span>;b=<span class="number">0</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">0</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">1</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">1</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">0</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">0</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">1</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">1</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">200</span> <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="时序逻辑电路仿真环境的搭建">时序逻辑电路仿真环境的搭建</h4>
<p>时序逻辑电路仿真环境的搭建要求与组合逻辑电路基本相同,
但是需要考虑时序, 定时信息和全局复位, 置位等信号要求,
并定义这些信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cnt10(clk,rst,ena,q,cnt)</span><br><span class="line">    <span class="keyword">input</span>           clk,rst,ena;</span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">3</span>:<span class="number">0</span>]   q;</span><br><span class="line">    <span class="keyword">output</span>          cnt;</span><br><span class="line">    <span class="keyword">reg</span>     [<span class="number">3</span>:<span class="number">0</span>]   q;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(rst)         q=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ena)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(q&lt;<span class="number">9</span>) q=q+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>    q=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">assign</span>  cnt=q[<span class="number">3</span>]&amp;q[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt10_tb;</span><br><span class="line">    <span class="keyword">reg</span>         clk,rst,ena;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]  q;</span><br><span class="line">    <span class="keyword">wire</span>        cnt;</span><br><span class="line">    cnt10 U1(clk,rst,ena,q,cnt);</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">50</span>  clk=~clk;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            clk=<span class="number">0</span>;rst=<span class="number">0</span>;ena=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">1200</span>   rst=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">120</span>    rst=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">2000</span>   ena=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">200</span>    ena=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20000</span>  <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span>   </span><br></pre></td></tr></table></figure>
<h2 id="与仿真相关的系统任务">与仿真相关的系统任务</h2>
<h3 id="display与write">$display与$write</h3>
<p>Verilog HDL有两种主要的标准输出任务: <code>$display</code>和
<code>$write</code>. 这两个系统函数用来输出信息且语法格式相同.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>,&lt;signal1,signal2,...,signaln&gt;);</span><br><span class="line"><span class="built_in">$write</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>,&lt;signal1,signal2,...,signaln&gt;);</span><br></pre></td></tr></table></figure>
<p>其中<code>"&lt;format_specifiers&gt;"</code>称为格式控制,
<code>&lt;signal1,signal2,...,signaln&gt;</code>称为信号控制列表.</p>
<p><code>$display</code>将特定信息输入到标准输出设备,
并且带有行结束字符,
即自动地在输出后进行换行;但是<code>$write</code>输出特点信息时不自动换行,
如果想要在一行中输出多个信息, 可以使用<code>$write</code>.</p>
<p>输出格式说明由<code>%</code>和格式字符组成,
其作用是将输出的数据转换成指定的格式输出,
格式说明总是由<code>%</code>开始, 后面加上一个字母选择特定的输出格式.
见下表</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>输出格式</th>
<th>说明</th>
<th>输出格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%h %H</code></td>
<td>以十六进制数输出</td>
<td><code>%m %M</code></td>
<td>输出等级层次的名字</td>
</tr>
<tr>
<td><code>%d %D</code></td>
<td>以十进制数输出</td>
<td><code>%s %S</code></td>
<td>以字符串的形式输出</td>
</tr>
<tr>
<td><code>%o %O</code></td>
<td>以八进制数输出</td>
<td><code>%t %T</code></td>
<td>以当前的时间格式输出</td>
</tr>
<tr>
<td><code>%b %B</code></td>
<td>以二进制数输出</td>
<td><code>%e %E</code></td>
<td>以指数的形式输出实数型</td>
</tr>
<tr>
<td><code>%c %C</code></td>
<td>以ASCII码字符的形式输出</td>
<td><code>%f %F</code></td>
<td>以十进制数的形式输出实型数</td>
</tr>
<tr>
<td><code>%v %V</code></td>
<td>输出wire型数据信号强度</td>
<td><code>%g %G</code></td>
<td>以指数或十进制数的形式输出实型数</td>
</tr>
</tbody>
</table>
<p>下面是一些特殊的字符</p>
<table>
<thead>
<tr>
<th>换码序列</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>横向跳格, 即调到下一个输出区</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠字符<code>\</code></td>
</tr>
<tr>
<td><code>\"</code></td>
<td>双引号字符<code>"</code></td>
</tr>
<tr>
<td><code>\o</code></td>
<td>1到3位的八进制数代表的字符</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分符号<code>%</code></td>
</tr>
</tbody>
</table>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> disp_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rval;</span><br><span class="line">    <span class="keyword">pulldown</span>(pd);</span><br><span class="line">        intial</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                rval=<span class="number">101</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;\\\t%%\n\&quot;\123&quot;</span>);     <span class="comment">//八进制数123就是字符S</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval=%h hex %d decimal&quot;</span>, rval, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval=%o otal %b binary&quot;</span>, rval, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval has %c ASCII character value&quot;</span>, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;pd strength value is %v&quot;</span>, pd);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;current scope is %m&quot;</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;%s is ASCII value for 101&quot;</span>, <span class="number">101</span>);</span><br><span class="line">                <span class="built_in">$write</span>(<span class="string">&quot;simulation time is&quot;</span>);</span><br><span class="line">                <span class="built_in">$write</span>(<span class="string">&quot;%t\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\%</span><br><span class="line"><span class="string">&quot;S</span></span><br><span class="line"><span class="string">rval=00000065 hex 101 decimal</span></span><br><span class="line"><span class="string">rval=00000000145 otal 00000000000000000000000001100101 binary</span></span><br><span class="line"><span class="string">rval has e ASCII character value</span></span><br><span class="line"><span class="string">pd strength value is StX</span></span><br><span class="line"><span class="string">current scope is disp</span></span><br><span class="line"><span class="string">e is ASCII value for 101</span></span><br><span class="line"><span class="string">simulation time is 0</span></span><br></pre></td></tr></table></figure>
<h3 id="monitor与strobe">$monitor与$strobe</h3>
<p><code>$monitor</code>和<code>$strobe</code>都属于信号的输出显示的系统任务,
同时它们也提供了监控和输出参数列表中字符或变量的值的功能.</p>
<p><code>$monitor</code>的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$monitor</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>, &lt;signal1, signal2, ..., signaln&gt;);</span><br></pre></td></tr></table></figure>
<p><code>$monitor</code>提供了监控和输出参数列表中的表达式或变量值的功能.
其参数列表中输出控制格式字符串和输出列表的规则与<code>$display</code>一样.
当启动一个带有一个或者多个参数的<code>$monitor</code>任务时,
仿真器则会建立一个处理机制,
使得每当参数列表中变量或者表达式的值<strong>发生变化</strong>时,
<strong>整个</strong>参数列表中变量或表达式的值都会被输出显式.
如果同一时刻多个参数的值发生变化, 那么在该时刻只输出一次.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$monitor</span>(<span class="built_in">$time</span>, , <span class="string">&quot;rxd=%b txd=%b&quot;</span>, rxd, rxd);</span><br></pre></td></tr></table></figure>
<p>说明: <code>$monitor</code>中, 参数可以是<code>$time</code>系统函数,
这样参数列表中变量或者表达式的值发生变化时,
对应的时刻可以通过标明同一时刻的多行输出来显示.
上面的语句中<code>, ,</code>表示一个空参数, 输出一个空格.</p>
<p><code>$monitor</code>还提供了两个常用的系统任务<code>$monitoron</code>和<code>$monitoroff</code>,
它们的作用是通过打开和关闭监控标志来控制监控任务<code>$monitor</code>的启动和停止.
通常在通过调用<code>$monitoron</code>启动<code>$monitor</code>时,
不管参数列表中的值是否发生变化, 总是立刻输出当前时刻参数列表中的值,
这在用于监控的初始时刻设定初始比较值. 缺省情况下,
控制标准在仿真的起始时刻就已经打开了. 在多模块调试的情况下,
许多模块中都调用了<code>$monitor</code>,
但是因为任何一个时刻都只能有一个<code>$monitor</code>工作,
因此需要配合<code>$monitoron</code>和<code>$monitoroff</code>使用,
也就是说, 把需要监视的模块用<code>$monitoron</code>打开,
在监视完毕之后及时用<code>$monitoroff</code>关闭,
以便把<code>$monitor</code>让给其他模块使用.</p>
<p><code>$monitor</code>和<code>$display</code>的不同之处还在于前者往往在<code>initial</code>块中调用,
只要不调用<code>$monitoroff</code>,
<code>$monitor</code>就会不间断地对所设定的信号进行监控.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> monitor_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">2</span>;</span><br><span class="line">                b=<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">forever</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        #<span class="number">5</span> a=a+b;</span><br><span class="line">                        #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    a=<span class="number">2</span>,  b=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>    a=<span class="number">6</span>,  b=<span class="number">4</span></span><br><span class="line"><span class="number">10</span>   a=<span class="number">6</span>,  b=<span class="number">5</span></span><br><span class="line"><span class="number">15</span>   a=<span class="number">11</span>, b=<span class="number">5</span></span><br><span class="line"><span class="number">20</span>   a=<span class="number">11</span>, b=<span class="number">10</span></span><br><span class="line"><span class="number">25</span>   a=<span class="number">21</span>, b=<span class="number">10</span></span><br><span class="line"><span class="number">30</span>   a=<span class="number">21</span>, b=<span class="number">20</span></span><br><span class="line"><span class="number">35</span>   a=<span class="number">41</span>, b=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><code>$strobe</code>的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$strobe</span>(&lt;functions_or_signals&gt;);</span><br><span class="line"><span class="built_in">$strobe</span>(<span class="string">&quot;&lt;string_and/or_variables&gt;&quot;</span>, &lt;functions_or_signals&gt;);</span><br></pre></td></tr></table></figure>
<p><code>$strobe</code>系统任务用于某时刻所有时间处理完后,
在这个时间步的结尾输出一行格式化的文本. Verilog
HDL提供了除<code>$strobe</code>外的其他几个相关的扩展系统任务,
见下表</p>
<table>
<thead>
<tr>
<th>系统任务</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$strobe</code></td>
<td>在所有时间处理完后, 以十进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeb</code></td>
<td>在所有时间处理完后, 以二进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeo</code></td>
<td>在所有时间处理完后, 以八进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeh</code></td>
<td>在所有时间处理完后, 以十六进制格式输出一行格式化的文本</td>
</tr>
</tbody>
</table>
<p>这些系统任务在指定时间显示模拟数据,
但是这种任务的执行是在该特定时间步结束时才显示模拟数据.
“时间步结束”指的是对于指定时间步内的所有时间都已经处理了.
<code>$strobe</code>任务的参数定义和<code>$monitor</code>相同,
但是<code>$strobe</code>任务在被调用时刻所有的赋值语句都完成后,
才输出相应的文字信息.
因此<code>$strobe</code>任务提供了另一种数据显示机制,
可以保证数据只在所有赋值语句执行完毕之后才被显示.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> strobe_tb;</span><br><span class="line">    <span class="keyword">reg</span> a, b;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;a by display is: &quot;</span>, a);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;a by strobe is: &quot;</span>, a);</span><br><span class="line">                a=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                b&lt;=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;b by display is: &quot;</span>, b);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;b by strobe is: &quot;</span>, b);</span><br><span class="line">                #<span class="number">5</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;#5 b by display is: &quot;</span>, b);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;#5 b by strobe is: &quot;</span>, b);</span><br><span class="line">                b&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a by display is: <span class="number">0</span></span><br><span class="line">b by display is: x</span><br><span class="line">a by strobe is: <span class="number">1</span></span><br><span class="line">b by strobe is: <span class="number">0</span></span><br><span class="line">#<span class="number">5</span> b by display is: <span class="number">0</span></span><br><span class="line">#<span class="number">5</span> b by strobe is: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="time与realtime">$time与$realtime</h3>
<p><code>$time</code>和<code>$realtime</code>这两个函数被调用后都返回当前时刻相对开始仿真时的时间值,
前者以64位整数值的形式返回, 后者以实型数据的形式返回仿真时间.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> time_tb;</span><br><span class="line">    <span class="keyword">reg</span> ts;</span><br><span class="line">    <span class="keyword">parameter</span> delay=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            #delay ts=<span class="number">1</span>;</span><br><span class="line">            #delay ts=<span class="number">0</span>;</span><br><span class="line">            #delay ts=<span class="number">1</span>;</span><br><span class="line">            #delay ts=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, , , <span class="string">&quot;ts=%b&quot;</span>, ts);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  ts=x</span><br><span class="line"><span class="number">2</span>  ts=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>  ts=<span class="number">0</span></span><br><span class="line"><span class="number">6</span>  ts=<span class="number">1</span></span><br><span class="line"><span class="number">8</span>  ts=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> realtime_tb;</span><br><span class="line">    <span class="keyword">reg</span> set;</span><br><span class="line">    <span class="keyword">parameter</span> p=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$realtime</span>, , <span class="string">&quot;set=%b&quot;</span>, set);</span><br><span class="line">            #p set=<span class="number">0</span>;</span><br><span class="line">            #p set=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> set=x</span><br><span class="line"><span class="number">2</span> set=<span class="number">0</span></span><br><span class="line"><span class="number">4</span> set=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="finish与stop">$finish与$stop</h3>
<p>系统任务<code>\$finish</code>和<code>\$stop</code>用于对仿真过程的控制,
分别表示结束仿真和中断仿真. 语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$finish</span></span><br><span class="line"><span class="built_in">$finish</span>(n)</span><br><span class="line"><span class="built_in">$stop</span></span><br><span class="line"><span class="built_in">$stop</span>(n)</span><br></pre></td></tr></table></figure>
<p>其中参数n的含义如下表:</p>
<table>
<thead>
<tr>
<th>n的取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不输出任何信息</td>
</tr>
<tr>
<td>1</td>
<td>给出仿真时间和位置</td>
</tr>
<tr>
<td>2</td>
<td>给出仿真时间和位置,同时还有所用memory及CPU时间的统计</td>
</tr>
</tbody>
</table>
<p>系统任务<code>$finish</code>的作用是退出仿真器, 返回主操作系统,
也就是结束仿真过程. 可以带上参数, 输出不同的信息. 如果不带参数,
则默认设置为1.</p>
<p>系统任务<code>$stop</code>的作用是把EDA工具暂停,
在仿真环境下给出一个交互式的命令提示符, 将控制权交给用户.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> finish_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">2</span>;</span><br><span class="line">            b=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">forever</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    #<span class="number">5</span> a=a+b;</span><br><span class="line">                    #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$finish</span>;    <span class="comment">//程序执行到第40个时间单位时退出仿真器</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> stop_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">2</span>;</span><br><span class="line">            b=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">forever</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    #<span class="number">5</span> a=a+b;</span><br><span class="line">                    #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$stop</span>;  <span class="comment">//程序执行到第40个时间单位时停止仿真，将EDA仿真器设置为暂停模式</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="readmemh与readmemb">$readmemh与$readmemb</h3>
<p><code>$readmemh</code>和<code>$readmemb</code>用来从文件中读取数据到存储器中.
这两个系统任务可以在仿真的任何时刻被执行使用, 其语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;);</span><br><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;,&lt;finish_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;,&lt;finish_addr&gt;);</span><br></pre></td></tr></table></figure>
<p>在这两个任务系统中, 被读取的数据文件的内容只能包含空白位置(空格,
换行符, 制表符(tab)和form-feeds),
注释行(<code>//</code>和<code>/**/</code>形式), 二进制或十六进制数字.
数字中不能包含位宽说明和格式说明, 对于<code>$readmemb</code>,
每个数字必须是二进制; 对于<code>$readmemh</code>,
每个数字必须是十六进制. 不定值<code>x/X</code>,
高阻值<code>z/Z</code>和下划线<code>_</code>的使用方法与Verilog
HDL中的一样. 数字必须用空白位置或者注释行分开.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> read_mem_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory_b [<span class="number">0</span>:<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory_h [<span class="number">0</span>:<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">integer</span>   i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;init_b.txt&quot;</span>, memory_b);<span class="comment">//把数据文件init_b.txt读取到存储器中给定的地址</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;init_h.txt&quot;</span>, memory_h);<span class="comment">//把数据文件init_h.txt读取到存储器中给定的地址</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i+<span class="number">1</span>)<span class="comment">//显示存储器中的内容</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;memory_b [%0d]=%b&quot;</span>, i, memory_b[i]);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;memory_h [%0h]=%h&quot;</span>, i, memory_h[i]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>文件init_b.txt和init_h.txt包含初始化数据.
用<code>@&lt;address&gt;</code>在数据文件中指定地址如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init_b<span class="variable">.txt</span>文件:</span><br><span class="line">    @<span class="number">002</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">01010101</span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">10101010</span></span><br><span class="line">    @<span class="number">006</span></span><br><span class="line">    <span class="number">1111</span>zzzz <span class="number">00001111</span></span><br><span class="line">init_h<span class="variable">.txt</span>文件:</span><br><span class="line">    @<span class="number">001</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_0011</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_0111</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_1111</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0001_1111</span></span><br></pre></td></tr></table></figure>
<p>其中”init_b.txt”指定二进制数据从第二位地址开始写入,
“init_h.txt”指定十六进制数据从第一位地址开始写入.</p>
<h3 id="random">$random</h3>
<p><code>$random</code>是产生随机数的系统函数,
每次使用该函数都会返回一个32位的随机数, 该随机数是一个带符号的整型数.
语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$random</span>%&lt;number&gt;;</span><br></pre></td></tr></table></figure>
<p>当该函数被调用时, 就会返回一个32位的有符号整数.</p>
<p>一般用法为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$random</span> % b;</span><br></pre></td></tr></table></figure>
<p>其中<code>b</code>是一个常数且要求大于零,
它给出了一个范围在<code>-b+1~b-1</code>之间的随机数.</p>
<p>利用位拼接操作符<code>&#123;&#125;</code>可以将函数<code>$random</code>返回的有符号整数变为无符号整数,
用法为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">$random</span>&#125;%b;</span><br></pre></td></tr></table></figure>
<p>其中<code>b</code>是一个常数且要求大于零,
它给出了一个范围在<code>0~b-1</code>之间的随机数.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> random_pulse(dout);</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">9</span>:<span class="number">0</span>] dout;</span><br><span class="line">    <span class="keyword">reg</span>          dout;</span><br><span class="line">    <span class="keyword">integer</span> delay1, delay2, k;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span> dout=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k=k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                delay1=<span class="number">20</span>*(&#123;<span class="built_in">$random</span>&#125;%<span class="number">6</span>);        <span class="comment">//delay1在0~100ns范围内变化</span></span><br><span class="line">                delay2=<span class="number">20</span>*(<span class="number">1</span>+&#123;<span class="built_in">$random</span>&#125;%<span class="number">3</span>);      <span class="comment">//delay2在20~60ns范围内变化</span></span><br><span class="line">                #delay1 dout=<span class="number">1</span>&lt;&lt;(&#123;<span class="built_in">$random</span>&#125;%<span class="number">10</span>); <span class="comment">//dout的0~9位中随机出现1，且出现的时间在0~100ns范围内变化</span></span><br><span class="line">                #delay2 dout=<span class="number">0</span>;                 <span class="comment">//脉冲的宽度在20~60ns的范围变化</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="值变转储文件系统任务">值变转储文件系统任务</h3>
<h2 id="信号时间赋值语句">信号时间赋值语句</h2>
<p>在集成电路设计和验证阶段,
经常需要对特定信号进行延时来实现相应的时序控制,
或者避免信号冲突形成电路中的热点.</p>
<p>信号的时间延迟可以通过两类方式完成: 一类是延时控制,
它是行为语句的执行指定一个延迟时间的信号时间延迟方式,
可以分成串行延时控制, 并行延时控制, 阻塞式延时控制, 非阻塞延时控制;
另一类是事件控制, 它是行为语句的执行指定触发事件的信号延迟方式,
可以分成边沿触发事件控制和电平敏感事件控制.</p>
<ul>
<li>延时控制
<ul>
<li>串行延时控制</li>
<li>并行延时控制</li>
<li>阻塞式延时控制</li>
<li>非阻塞式延时控制</li>
</ul></li>
<li>事件控制
<ul>
<li>边沿触发事件控制</li>
<li>电平敏感事件控制</li>
</ul></li>
</ul>
<h3 id="时间延迟的语法说明">时间延迟的语法说明</h3>
<p>Verilog HDL的延时控制的语法格式有如下两类:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&lt;延迟时间&gt;行为语句;</span><br><span class="line">#&lt;延迟时间&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>#</code>是延时控制的关键字符, 后面跟需要延时的时间.</p>
<p>根据时间控制部分在过程赋值语句中出现的位置,
可以把过程赋值语句的时间控制分成外部时间控制方式和内部时间控制方式.</p>
<p>外部时间控制方式: 时间控制出现在整个过程赋值语句的最左端,
也就是出现在赋值目标变量的左边的时间控制方式. 例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">5</span> a=b;</span><br></pre></td></tr></table></figure>
<p>这等价于</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">5</span>;</span><br><span class="line">        a=b;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">//这就是说先等5个时间单位，然后把b赋给a</span></span><br></pre></td></tr></table></figure>
<p>内部时间控制方式:
过程赋值语句中的时间控制部分还可以出现在”赋值操作符”和”赋值表达式”之间的时间控制方式.
例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=#<span class="number">5</span>b;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        temp=b;<span class="comment">//先求b的值</span></span><br><span class="line">        $<span class="number">5</span>;</span><br><span class="line">        a=temp;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">//这就是说先把b求出来之后，等5个时间单位，然后赋给a</span></span><br></pre></td></tr></table></figure>
<h3 id="时间延迟的描述形式">时间延迟的描述形式</h3>
<h4 id="串行延时控制">串行延时控制</h4>
<p>串行延时控制是最常用的信号延时控制,
它是由<code>begin-end</code>过程块加上延时赋值语句构成,
其中延时赋值语句可以是外部时间控制方式, 也可以是内部时间控制方式.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> serial_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="并行延时控制">并行延时控制</h4>
<p>并行延时控制是由<code>fork-join</code>过程块加上延时赋值语句构成,
其中延时赋值语句可以是外部时间控制方式, 也可以是内部时间控制方式.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> parallel_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">                    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">150</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">250</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">300</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">400</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">450</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">500</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">600</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">                     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">200</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">250</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">350</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">400</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">500</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">550</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">600</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这个波形和串行延时控制中的例子的波形相同</span></span><br></pre></td></tr></table></figure>
<h4 id="阻塞式延时控制">阻塞式延时控制</h4>
<p>以赋值操作符<code>=</code>来标识的赋值操作称为”阻塞式过程赋值”,
阻塞式延时控制就是在阻塞式过程赋值的基础上加上延时控制.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        a=      <span class="number">0</span>;</span><br><span class="line">        a=#<span class="number">5</span>    <span class="number">1</span>;</span><br><span class="line">        a=#<span class="number">10</span>   <span class="number">0</span>;</span><br><span class="line">        a=#<span class="number">15</span>   <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>说明: 仿真开始时刻将0赋给<code>a</code>,
这条赋值语句完成后才执行下一条语句; 在第一条语句执行完后,
等待5个时间单位, 把1赋给<code>a</code>;
第三条赋值语句在第二条赋值语句执行完后等待10个时间单位后,
把0赋给<code>a</code>;
最后一条赋值语句在第三条赋值语句执行完后等待15个时间单位后,
将1赋给<code>a</code>.</p>
<h4 id="非阻塞式延时控制">非阻塞式延时控制</h4>
<p>以赋值操作符<code>&lt;=</code>来标识的赋值操作称为”非阻塞式过程赋值”,
非阻塞式延时控制就是在非阻塞式过程赋值的基础上加上延时控制.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        a&lt;=<span class="number">0</span>;</span><br><span class="line">        a&lt;=#<span class="number">5</span> <span class="number">1</span>;</span><br><span class="line">        a&lt;=#<span class="number">10</span> <span class="number">0</span>;</span><br><span class="line">        a&lt;=#<span class="number">15</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>说明: 在仿真进程开始时刻同时执行四条延时赋值语句. 在仿真进程开始时,
把0赋给<code>a</code>; 在距离仿真开始时刻5个时间单位时,
将1赋给<code>a</code>; 在距离仿真开始时刻10个时间单位时,
将0赋给<code>a</code>; 在距离仿真开始时刻15个时间单位时,
将1赋给<code>a</code>;</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> non_blocking_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q0_out&lt;=         <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">50</span>      <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">150</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">250</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">300</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">400</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">450</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">500</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">600</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q1_out&lt;=         <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">100</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">200</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">250</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">350</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">400</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">500</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">550</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">600</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这个波形和串行延时控制中的例子的波形相同</span></span><br></pre></td></tr></table></figure>
<p>说明:
每一条延时赋值语句的执行不需要等待上一条延时赋值语句执行完之后再执行,
而是从仿真开始的时刻同时执行.</p>
<h3 id="边沿触发事件控制">边沿触发事件控制</h3>
<p>边沿事件控制方式是在指定的信号变化时刻,
即指定的信号跳变边沿才触发语句的执行,
而当信号处于稳定状态时则不会触发语句的执行.</p>
<p>边沿触发事件的语法格式有如下四种形式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@(&lt;事件表达式&gt;)行为语句;</span><br><span class="line">@(&lt;事件表达式&gt;);</span><br><span class="line">@(&lt;事件表达式<span class="number">1</span>&gt; <span class="keyword">or</span> &lt;事件表达式<span class="number">2</span>&gt; <span class="keyword">or</span> ... <span class="keyword">or</span> &lt;事件表达式n&gt;)行为语句;</span><br><span class="line">@(&lt;事件表达式<span class="number">1</span>&gt; <span class="keyword">or</span> &lt;事件表达式<span class="number">2</span>&gt; <span class="keyword">or</span> ... <span class="keyword">or</span> &lt;事件表达式n&gt;);</span><br></pre></td></tr></table></figure>
<p>其中<code>@</code>是边沿触发事件控制的标识符,
<code>事件表达式</code>表示触发事件,
<code>行为语句</code>表示触发时需要执行的操作.
而`事件表达式有如下三种形式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;信号名&gt;</span><br><span class="line"><span class="keyword">posedge</span>&lt;信号名&gt;</span><br><span class="line"><span class="keyword">negedge</span>&lt;信号名&gt;</span><br></pre></td></tr></table></figure>
<p>逻辑信号的正负跳变定义如下表:</p>
<table>
<thead>
<tr>
<th>正跳变<code>posedge</code></th>
<th>负跳变<code>negedge</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0<span class="math inline">\(\to\)</span>x</td>
<td>1<span class="math inline">\(\to\)</span>x</td>
</tr>
<tr>
<td>0<span class="math inline">\(\to\)</span>z</td>
<td>1<span class="math inline">\(\to\)</span>z</td>
</tr>
<tr>
<td>0$<span class="math inline">\(1|1\)</span><span
class="math inline">\(0|
|x\)</span><span class="math inline">\(1|x\)</span><span
class="math inline">\(0|
|z\)</span><span class="math inline">\(1|z\)</span>$0</td>
<td></td>
</tr>
</tbody>
</table>
<p>边沿触发的4种形式:</p>
<ol type="1">
<li><code>@(&lt;事件表达式&gt;)行为语句;</code>: 只包含一个触发事件,
只有这个事件发生后, 后面的行为语句才能执行. 在仿真进程中遇到这种语句时,
如果指定的触发事件还没有发生, 则仿真进程就会停留在此处等待,
直到指定触发事件发生后才执行后面的行为语句, 仿真进制继续向下进行.</li>
<li><code>@(&lt;事件表达式&gt;);</code>: 在仿真进程中遇到这种语句时,
如果指定的触发事件还没有发生, 则仿真进程就会停留在此处等待,
直到指定触发事件发生后才开始下一条语句的执行.</li>
<li><code>@(&lt;事件表达式1&gt; or &lt;事件表达式2&gt; or ... or &lt;事件表达式n&gt;)行为语句;</code>:
只要其中任意一个触发事件发生, 后面的行为语句就会执行.</li>
<li><code>@(&lt;事件表达式1&gt; or &lt;事件表达式2&gt; or ... or &lt;事件表达式n&gt;);</code>:
只要其中任意一个触发事件发生, 仿真进程就会继续进行.</li>
</ol>
<h3 id="电平敏感事件控制">电平敏感事件控制</h3>
<p>电平敏感事件控制是在指定的条件表达式为真时启动需要执行的语句.
电平敏感事件控制是用关键词<code>wait</code>来表示的.</p>
<p>电平敏感事件控制的语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait</span>(条件表达式) 行为语句;</span><br><span class="line"><span class="keyword">wait</span>(条件表达式);</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>电平敏感事件控制的第一种形式中包含了行为语句,
它可以是串行块也可以是并行块,
也可以是单条行为语句.行为语句执行条件是条件表达式的值为真.
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为真,
那么语句块立即执行,
否则语句块要一直等到条件表达式的值变成真时才会执行.</li>
<li>电平敏感事件控制的第二种形式中没有包含行为语句.
在这种电平敏感事件控制下,
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为真,
那么那么立即结束该<code>wait</code>事件控制语句的执行, 仿真进程继续进行;
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为假,
那么仿真进程进入等待状态, 一直到条件表达式变成真时才退出等待状态,
同时结束<code>wait</code>语句的执行, 仿真进程继续进行.</li>
</ol>
<h2 id="任务和函数">任务和函数</h2>
<p>在行为级设计中, 设计者经常需要在程序的多个地方实现相同的功能.
因此有必要把这些相同的部分提取出来组成子程序, 然后直接调用即可.</p>
<p>任务具有输入, 输出, 输入输出双向变量, 而函数具有输入变量,
这样数据能够传入任务和函数, 并且能够将结果输出.</p>
<h3 id="任务">任务</h3>
<p>Verilog
HDL使用关键字<code>task</code>和<code>endtask</code>对任务进行声明.
如果子程序满足以下任一条件,
则公共子程序的描述必须使用任务而不是函数:</p>
<ol type="1">
<li>子程序中包含延时, 时序或者事件控制结构</li>
<li>没有输出或者输出变量的数量大于一</li>
<li>没有输入变量</li>
</ol>
<p>任务定义的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span>&lt;任务名&gt;;</span><br><span class="line">    端口类型声明</span><br><span class="line">    局部变量声明</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            语句<span class="number">1</span>;</span><br><span class="line">            语句<span class="number">2</span>;</span><br><span class="line">            ...</span><br><span class="line">            语句n;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>任务定义在<code>task</code>和<code>endtask</code>之间,
任务名之后是分号.</li>
<li>端口和类型声明用于对各个端口的类型和宽度进行声明,
其语法和在模块中声明端口的格式一样.</li>
<li>局部变量声明用来对<strong>任务内</strong>用到的局部变量进行类型和宽度的声明.</li>
<li>任务中由<code>begin</code>和<code>end</code>关键词定义的一系列语句指明了任务被调用时需要进行的操作.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> read_mem;              <span class="comment">//任务名为read_mem</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>] address;  <span class="comment">//输入端口声明</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data;     <span class="comment">//输出端口声明</span></span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]  counter;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]  temp [<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(counter=<span class="number">1</span>; counter&lt;=<span class="number">4</span>; counter=counter+<span class="number">1</span>)</span><br><span class="line">            temp[counter]=mem[address+counter-<span class="number">1</span>];</span><br><span class="line">            data=&#123;temp[<span class="number">1</span>], temp[<span class="number">2</span>], temp[<span class="number">3</span>], temp[<span class="number">4</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>  </span><br></pre></td></tr></table></figure>
<p>说明: 这个例子定义了一个名为<code>read_mem</code>的任务,
用来读取存储器<code>mem</code>中的数据,
该任务由一个16位的输入端口<code>address</code>,
一个32位的输出端口<code>data</code>,
一个4位的局部变量<code>counter</code>和一个8位的存储器<code>temp</code>构成.
当该例的任务被调用时,
<code>begin</code>和<code>end</code>之间的语句得到执行,
它们用来执行对存储器<code>mem</code>进行的四次读操作,
将其结果合并后输出到32位的输出端口<code>data</code>.</p>
<p>任务的调用是用任务语句实现的,
任务调用语句列出了传入任务和传出任务的参数值, 格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;任务名&gt;(端口<span class="number">1</span>, 端口<span class="number">2</span>, ...,端口n);</span><br></pre></td></tr></table></figure>
<p>任务调用时, 任务调用语句只能出现在过程块内,
任务调用语句就像一条普通的行为语句得到处理.
当被调用的任务有输入和输出端口时, 任务调用语句必须包含端口名的列表,
这个列表内各个端口名出现的顺序和类型必须与任务定义结构中端口说明部分的端口顺序和类型一致.
注意, 只有寄存器类型的变量才能和任务的输出端口相对应.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> demo_task_invo_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem [<span class="number">127</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">0</span>;</span><br><span class="line">            read_mem(a,b);<span class="comment">//第一次调用任务，a与address对应，b与data对应</span></span><br><span class="line">            #<span class="number">10</span>;</span><br><span class="line">            a=<span class="number">64</span>;</span><br><span class="line">            read_mem(a,b);<span class="comment">//第二次调用任务</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">task</span> read_mem;</span><br><span class="line">        <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">        <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]  counter;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] temp [<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(counter=<span class="number">1</span>; counter&lt;=<span class="number">4</span>; counter=counter+<span class="number">1</span>)</span><br><span class="line">            temp[counter]=mem[address+counter-<span class="number">1</span>];</span><br><span class="line">            data=&#123;temp[<span class="number">1</span>], temp[<span class="number">2</span>], temp[<span class="number">3</span>], temp[<span class="number">4</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>Verilog
HDL使用关键字<code>function</code>和<code>endfunction</code>对函数进行声明.
对于一个子程序来说, 如果下面的所有条件都成立, 则可以调用函数来完成:</p>
<ol type="1">
<li>子程序内不含有延时, 时序或者事件控制结构</li>
<li>子程序只有一个返回值</li>
<li>至少有一个输入变量</li>
<li>没有输出或者双向变量</li>
<li>不含有非阻塞赋值语句</li>
</ol>
<p>函数定义的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>&lt;返回值或者返回类型&gt;&lt;函数名&gt;;</span><br><span class="line">    &lt;输入参量与类型声明&gt;</span><br><span class="line">    &lt;局部变量声明&gt;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        语句n;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>函数定义是嵌入在<code>function</code>和<code>endfunction</code>之间的,
函数名后面要加上分号;</li>
<li>返回值类型或者位宽是一个可选项,
用来对函数调用返回数据的类型或宽度进行说明, 它有如下三种形式:
<ul>
<li><code>[msb,lsb]</code>:
这种形式说明返回值是一个多位的寄存器变量</li>
<li><code>integer</code>: 这种形式说明返回值是一个整型变量</li>
<li><code>real</code>: 这种形式说明返回值是一个实型变量</li>
</ul></li>
<li>输入参量与类型声明是函数对各个输入端口的宽度和类型进行声明.
在函数定义中, 至少必须有一个输入端口<code>input</code>的声明,
不能有输出端口<code>output</code>的声明.</li>
<li>局部变量声明是对函数内部局部变量进行宽度和类型的声明.</li>
<li>由<code>begin</code>和<code>end</code>关键词界定的一系列语句同任务一样,
用来指明函数被调用时要执行的操作.</li>
</ol>
<p>函数的调用是通过将函数作为表达式中的操作数来实现的,
函数调用的格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数名&gt;(&lt;输入表达式<span class="number">1</span>&gt;, &lt;输入表达式<span class="number">2</span>&gt;, ...,&lt;输入表达式n&gt;);</span><br></pre></td></tr></table></figure>
<p>其中输入表达式应该与函数定义结构中声明的输入端口顺序一一对应,
它们代表着各个输入端口的输入数据.</p>
<p>函数调用时的注意事项:</p>
<ol type="1">
<li>函数的调用不能作为单独的一条语句出现, 它相当于一个操作数</li>
<li>函数的调用既可以出现在过程块中,
也可以出现在<code>assign</code>连续赋值语句中</li>
<li>函数定义中声明的所有局部寄存器都是静态的,
即函数中的局部寄存器在函数的多个调用之间保持它们的值.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tryfact_tb;</span><br><span class="line">    <span class="keyword">function</span> [<span class="number">31</span>:<span class="number">0</span>] factorial;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] operand;</span><br><span class="line">        <span class="keyword">reg</span>   [<span class="number">3</span>:<span class="number">0</span>] index;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            factorial=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(index=<span class="number">1</span>; index&lt;=operand; index=index+<span class="number">1</span>)</span><br><span class="line">            factorial=index*factorial;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] result;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  n;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            result=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;=<span class="number">9</span>; n=n+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                result=factoial(n);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;n=%d result=%d&quot;</span>, n, result);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="任务与函数的区别">任务与函数的区别</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数可以调用另一个函数, 但是不能调用另一个任务</td>
<td>任务可以调用另一个任务或函数</td>
</tr>
<tr>
<td>函数在仿真0时刻就开始执行</td>
<td>任务可以在非0仿真时刻执行</td>
</tr>
<tr>
<td>函数绝对不能包含任何延时, 时序或者事件控制声明语句</td>
<td>任务可以包含延时, 时序或者事件控制声明语句</td>
</tr>
<tr>
<td>函数至少有一个输入变量</td>
<td>任务可以没有输入或者多个输入, 输出, 双向变量</td>
</tr>
<tr>
<td>函数只能返回一个值, 函数不能有输出或者双向变量</td>
<td>任务不返回任何值, 但是可以通过输出或者双向变量传递多个值</td>
</tr>
<tr>
<td>函数不能作为一条单独的语句出现, 它只能作为语句的一部分出现</td>
<td>任务的调用是通过一条单独的语句实现</td>
</tr>
<tr>
<td>函数的调用可以出现在过程块或连续赋值语句中</td>
<td>任务调用只能出现在过程块中</td>
</tr>
<tr>
<td>函数的执行不能由<code>disable</code>语句中断</td>
<td>任务的执行可以由<code>disable</code>语句中断</td>
</tr>
</tbody>
</table>
<h2 id="典型测试向量的设计">典型测试向量的设计</h2>
<h3 id="变量初始化">变量初始化</h3>
<p>在Verilog HDL中, 有两种方法可以初始化变量:
一种是利用<code>initial</code>, 一种是在定义变量时直接赋值初始化.
这两种初始化任务是不可综合的, 主要用于仿真过程.</p>
<p><code>initial</code>初始化方式是最常用的,
<code>initial</code>语句只执行一次,
即在设计被开始模拟执行时开始(0时刻)直到过程结束,
专门用于对输入信号进行初始化和产生特定的信号波形.
一个Testbench可以有多个<code>initial</code>过程语句块,
但是所有的<code>initial</code>都是同时执行的. 注意,
<code>initial</code>语句中的变量必须是<code>reg</code>类型的.
定义变量时初始化直接用等号<code>=</code>在变量右端赋值即可.</p>
<h3 id="数据信号测试向量的产生">数据信号测试向量的产生</h3>
<p>数据信号的产生有两种方式:
一是初始化和产生都在单个<code>initial</code>块中进行;
其二是初始化在<code>initial</code>语句中完成,
而产生在<code>always</code>语句块中完成. 前者时候不规则数据序列,
并且要求长度较短; 后者适合有一定规律的数据序列, 长度不限.</p>
<p>例: 产生位宽为4的质数序列{1, 2, 3, 5, 7, 11, 13}, 并且重复两次,
其中样值间隔为4个仿真时间单位.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> sequence_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] q_out;</span><br><span class="line">    <span class="keyword">parameter</span> sample_period=<span class="number">4</span>;  <span class="comment">//间隔4个时间单位</span></span><br><span class="line">    <span class="keyword">parameter</span> queue_num=<span class="number">2</span>;      <span class="comment">//重复两次</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_out=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">repeat</span>(queue_num) <span class="keyword">begin</span></span><br><span class="line">                # sample_period q_out=<span class="number">1</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">2</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">3</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">5</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">7</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">11</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">13</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="时钟信号测试向量的产生">时钟信号测试向量的产生</h3>
<p>例: 产生占空比为50%的时钟信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk1(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> <span class="variable">#(clk_period/2)</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk2(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(clk_period/2)</span> clk=~clk;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例: 生成占空比可以设置的信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk3(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> high_time=<span class="number">5</span>;<span class="comment">//高电平持续时间</span></span><br><span class="line">    <span class="keyword">parameter</span> low_time=<span class="number">20</span>;<span class="comment">//低电平持续时间</span></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">1</span>;</span><br><span class="line">        # high_time;</span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        # low_time;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例: 产生具有相位偏移的信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk4(clk);</span><br><span class="line">    <span class="keyword">output</span> clk_a, clk_b;</span><br><span class="line">    <span class="keyword">reg</span> clk_a;</span><br><span class="line">    <span class="keyword">wire</span> clk_b;</span><br><span class="line">    <span class="keyword">parameter</span> high_time=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> low_time=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> shift_time=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        clk_a=<span class="number">1</span>;</span><br><span class="line">        # high_time;</span><br><span class="line">        clk_a=<span class="number">0</span>;</span><br><span class="line">        # low_time;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> # shift_time clk_b=clk_a;<span class="comment">//相当于把a时钟延迟两个时间单位后赋给b时钟</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里偏移的相位可以用下式计算</p>
<p><span class="math display">\[\rm{phase}=360\times
\rm{shift\_time}\%(high\_time+low\_time)\]</span></p>
<p>其中<code>%</code>是取模运算.</p>
<p>例: 产生固定数目的时钟信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk5(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_cnt=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span> (clk_cnt)<span class="comment">//重复5次</span></span><br><span class="line">            # clk_period/<span class="number">2</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="总线信号测试向量的产生">总线信号测试向量的产生</h3>
<p>总线是运算部件之间数据流通的公共通道. 在RTL级描述中,
总线指的是由逻辑单元, 寄存器, 存储器,
电路输入或其他总线驱动的一个共享向量.
而总线功能模型则是一种将物理接口的时序操作转化成更高抽象层次接口的总线模型.</p>
<p>在总线中, 对于每个请求端, 有一个输入来选择驱动该总线所对应的请求端.
选择多个请求端时会发生总线冲突, 根据不同的总线类型,
会发生不同的冲突结果. 当有多个请求端发出请求时,
相应的操作由总线的类型决定. 在Verilog HDL测试中,
总线测试信号通常是将片选信号, 读(或写)使能信号, 地址信号,
数据信号以task任务的形式来描述,
并通过调用task形式的总线信号测试向量来完成相应的总线功能.</p>
<p>例: 产生一组具有写操作的AHB总线功能模型</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bus_wr_tb;</span><br><span class="line">    <span class="keyword">reg</span>        clk;</span><br><span class="line">    <span class="keyword">reg</span>        cs;</span><br><span class="line">    <span class="keyword">reg</span>        wr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            cs=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            wr=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">30</span>;</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h1100008a</span>, <span class="number">32&#x27;h11113000</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h1100009a</span>, <span class="number">32&#x27;h11113001</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000aa</span>, <span class="number">32&#x27;h11113002</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000ba</span>, <span class="number">32&#x27;h11113003</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000ca</span>, <span class="number">32&#x27;h11113004</span>);</span><br><span class="line">            addr=<span class="number">32&#x27;bx</span>;</span><br><span class="line">            data=<span class="number">32&#x27;bx</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> bus_wr;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] ADDR;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DATA;</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cs=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                wr=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                addr=ADDR;</span><br><span class="line">                data=DATA;</span><br><span class="line">                #<span class="number">30</span>;</span><br><span class="line">                cs=<span class="number">1&#x27;b1</span>;</span><br><span class="line">                wr=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="用户自定义元件模型">用户自定义元件模型</h2>
<h2 id="基本门级元件和模块的延时建模">基本门级元件和模块的延时建模</h2>
<h3 id="门级延时建模">门级延时建模</h3>
<p>在实际的电路中, 任何一个逻辑门都有延时,
信号从逻辑门的输入到输出的传输延时可以通过门延时来定义.</p>
<p>门级延时可以分成如下四类:</p>
<ol type="1">
<li>上升延时: 表示信号从0, x, z状态变化到1状态时受到的门传输延时</li>
<li>下降延时: 表示信号从1, x, z状态变化到0状态时受到的门传输延时</li>
<li>到不定态的延时: 表示信号从0, 1,
z状态变化到x状态时受到的门传输延时</li>
<li>截止延时: 表示信号从0, 1, x状态变化到z状态时受到的门传输延时</li>
</ol>
<ul>
<li>由于多输入门(and, nand, or, nor, xor, xnor)和多输出门(buf,
not)的输出不可能是高阻态z,
所以这两类元件<strong>没有”到不定态的延时”</strong>.</li>
<li>对于三态门(bufif1， bufif2, notif1, notif0),
由于其输出可以取四种可能的逻辑状态(0, 1, x, z),
所以<strong>具有全部的延时种类</strong>.</li>
<li>对于上拉电阻(pullup)和下拉电阻(pulldown), 由于它们没有输入端口，
所以<strong>没有任何形式的门级延时</strong>.</li>
</ul>
<p>实例引用带延时的参数门的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gate_type #delay instance_name(terminal_list);</span><br></pre></td></tr></table></figure>
<p>其中<code>#delay</code>就是门的延时. 如果没有指定门延时,
那么就默认为0. 同时<code>delay</code>是由一个或者多个延时值组成的,
可以有<strong>基本延时表达</strong>和<strong>最小, 典型,
最大延迟表达</strong>两种形式.</p>
<h4 id="门级延时的基本延时表达形式">门级延时的基本延时表达形式</h4>
<p>在门级延时的基本延时表达形式下,
<code>delay</code>内可以包含0~3个参数值,
如下表给出了指定的不同延时值个数时<code>delay</code>的4种表示形式:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>无延时</th>
<th>1个延时值(d)</th>
<th>2个延时值(d1, d2)</th>
<th>3个延时值(dA, dB, dC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>rise</td>
<td>0</td>
<td>d</td>
<td>d1</td>
<td>dA</td>
</tr>
<tr>
<td>fall</td>
<td>0</td>
<td>d</td>
<td>d2</td>
<td>dB</td>
</tr>
<tr>
<td>to_x</td>
<td>0</td>
<td>d</td>
<td>min(d1,d2)</td>
<td>min(dA,dB,dC)</td>
</tr>
<tr>
<td>turn_off</td>
<td>0</td>
<td>d</td>
<td>min(d1,d2)</td>
<td>dC</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ol type="1">
<li>当<code>delay</code>没有指定门延时, 默认的延时值为0, 即上升, 下降,
截止, 到不定态的延时值都是0.</li>
<li>当<code>delay</code>包含了1个延时值时,
给定的延时值d将同时代表着元件实例的上升, 下降, 截止,
到不定态的延时.</li>
<li>当<code>delay</code>包含了2个延时值时, 原件的上升延时值由d1决定,
下降延时值由d2决定, 而截止和到不定态的延时值由min(d1,d2)决定</li>
<li>当<code>delay</code>包含了3个延时值时, 原件的上升延时值由dA决定,
下降延时值由dB决定, 截止延时值由dC决定,
到不定态的延时由min(dA,dB,dC)决定</li>
</ol>
<h4 id="门级延时的最小-典型-最大延时表达形式">门级延时的最小, 典型,
最大延时表达形式</h4>
<p>采用门级延时的最小, 典型, 最大延时表达形式时,
门级延时量中的每一项由最小延时, 典型延时, 最大延时三个值来表示.
语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">#(d_min:d_type:d_max)</span></span><br></pre></td></tr></table></figure>
<p>采用最小, 典型, 最大延时表达形式时,
<code>delay</code>内可以包含1~3个延时值, 例如</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#delay(dA_min:dA_typ:dA_max)</span><br><span class="line">#delay(dA_min:dA_typ:dA_max,dB_min:dB_typ:dB_max)</span><br><span class="line">#delay(dA_min:dA_typ:dA_max,dB_min:dB_typ:dB_max,dC_min:dC_typ:dC_max)</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(4:5:6) U1(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<p>1个延时值的结果如下表:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>典型延时值</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>最大延时值</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(3:4:5,5:6:7) U2(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<p>2个延时值的结果如下表:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>3</td>
<td>5</td>
<td>min(3,5)</td>
<td>min(3,5)</td>
</tr>
<tr>
<td>典型延时值</td>
<td>4</td>
<td>6</td>
<td>min(4,6)</td>
<td>min(4,6)</td>
</tr>
<tr>
<td>最大延时值</td>
<td>5</td>
<td>7</td>
<td>min(5,7)</td>
<td>min(5,7)</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(2:3:4,3:4:5,4:5:6) U3(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>2</td>
<td>3</td>
<td>min(2,3,4)</td>
<td>4</td>
</tr>
<tr>
<td>典型延时值</td>
<td>3</td>
<td>4</td>
<td>min(3,4,5)</td>
<td>5</td>
</tr>
<tr>
<td>最大延时值</td>
<td>4</td>
<td>5</td>
<td>min(4,5,6)</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="模块延时建模">模块延时建模</h3>
<p>对于由用户自己设计的模块, 可以采用”加入门级延时说明”的方法,
通过”延时说明模块”的结构来对模块的传输延时进行说明. 注意,
延时说明模块既可以出现在行为描述模块内, 也可以出现在结构描述模块内.</p>
<h4 id="延时说明块">延时说明块</h4>
<p>在模块输入和输出引脚之间的延时称为模块路径延时. 在Verilog HDL中,
在关键字<code>specify</code>和<code>endspecipy</code>之间给出路径延时赋值,
关键字之间的语句组成<code>specify</code>块(即指定块).
<code>specify</code>和<code>endspecify</code>分别是延时说明块的起始标识符和终止标识符.</p>
<p><code>specify</code>块中包含下列操作语句:</p>
<ol type="1">
<li>定义穿过模块的所有路径延时</li>
<li>在电路中设置时序检查</li>
<li>定义<code>specparam</code>常量</li>
</ol>
<p>例: 考虑电路:“<code>e=a&amp;b, f=d&amp;c, out=e&amp;f</code>”,
路径延时如下表:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>延时</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a--e--out</code></td>
<td>9</td>
</tr>
<tr>
<td><code>b--e--out</code></td>
<td>9</td>
</tr>
<tr>
<td><code>c--f--out</code></td>
<td>11</td>
</tr>
<tr>
<td><code>d--f--out</code></td>
<td>11</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M(out, a, b, c, d);</span><br><span class="line">    <span class="keyword">input</span>  a,b,c,d;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> e, f;</span><br><span class="line">    <span class="keyword">assign</span> out=(a&amp;b)&amp;(c&amp;d);</span><br><span class="line">    <span class="keyword">specify</span></span><br><span class="line">        (a=&gt;out)=<span class="number">9</span>;</span><br><span class="line">        (b=&gt;out)=<span class="number">9</span>;</span><br><span class="line">        (c=&gt;out)=<span class="number">11</span>;</span><br><span class="line">        (d=&gt;out)=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">endspecify</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="路径延时的描述方式">路径延时的描述方式</h4>
<p>路径延时有两种描述方式, 并行连接和全连接.</p>
<p>并行连接: 每一条路径延时都有源域和目标域, 在<code>specify</code>块中,
用<code>=&gt;</code>表示并行连接, 语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;source_field&gt;=&gt;&lt;destination_field&gt;)=&lt;delay_value&gt;;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;delay_value&gt;</code>可以包含1~3个延时量,
也可以采用最小, 典型, 最大延时表达式. 当延时量超过一个时,
应该使用括号括起来, 例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a=&gt;out)=(<span class="number">8</span>:<span class="number">9</span>:<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>表示的是输入<code>a</code>到输出<code>out</code>的最小, 典型,
最大延时分别是8, 9, 10个时间单位.</p>
<p>在并行连接中, 源域中的每一位与目标域中的相应位连接.
如果源域和目标域是向量, 那么必须有相同的位数, 否则会出现不匹配.
并行连接说明了源域的每一位到目标域每一位之间的延时.</p>
<p>全连接: 在<code>specify</code>块中,
用符号<code>*&gt;</code>表示全连接, 其语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;source_field&gt;*&gt;&lt;destination_field&gt;)=&lt;delay_value&gt;;</span><br></pre></td></tr></table></figure>
<p>全连接中, 源域的每一位与目标域中的每一位相连接.
如果源域和目标域是向量, 那么它们的位数不必相同.
全连接描述了源域的每一位到目标域的每一位之间的延时.</p>
<h4 id="specparam声明语句">specparam声明语句</h4>
<p><code>specparam</code>用来定义<code>specify</code>块中的参数.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> parallel_connected(out, a, b);</span><br><span class="line">    <span class="keyword">input</span>  a, b;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span>   out;</span><br><span class="line">        <span class="keyword">assign</span> out=a&amp;b;</span><br><span class="line">        <span class="keyword">specify</span></span><br><span class="line">            <span class="keyword">specparam</span> a_to_out=<span class="number">9</span>;</span><br><span class="line">            <span class="keyword">specparam</span> b_to_out=<span class="number">11</span>;</span><br><span class="line">            (a=&gt;out)=a_to_out;</span><br><span class="line">            (b=&gt;out)=b_to_out;</span><br><span class="line">        <span class="keyword">endspecify</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><code>specparam</code>和<code>parameter</code>的区别如下:</p>
<ol type="1">
<li><code>specparam</code>语句只能在<code>specify</code>块中使用,
而<code>parameter</code>语句不能在<code>specify</code>块中使用.</li>
<li><code>specparam</code>语句定义的参数是延时参数,
而<code>parameter</code>定义的参数可以是任意数据类型的常参数.</li>
<li><code>specparam</code>语句定义的延时参数只能在<code>specify</code>块中使用,
而<code>parameter</code>定义的参数可以在模块内的任意位置处使用.</li>
</ol>
<h2 id="编译预处理语句">编译预处理语句</h2>
<p>编译预处理是Verilog HDL编译系统的一个组成部分,
指的是编译系统会对一些命令进行一些预处理,
然后将预处理结果和源程序一起再进行通常的编译处理.
以反引号”`“开始的某些标识符是编译预处理语句.</p>
<h3 id="宏定义">宏定义</h3>
<p><code>define</code>指令是一个宏定义命令,
通过一个指定的标识符来代表一个字符串.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span></span></span><br></pre></td></tr></table></figure>
<h2 id="verilog-hdl测试方法简介">Verilog HDL测试方法简介</h2>
<ol type="1">
<li>完全测试法</li>
<li>随机测试法</li>
<li>自动测试法</li>
</ol>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>用Verilog HDL的门级建模描述如下电路, 要求:
输入为<code>a, b, s</code>, 三个<code>wire sa, sb, s0</code>,
输出为<code>y</code>, 满足如下关系:</p>
<p><span class="math display">\[\begin{aligned}
     &amp;s0=\overline{s}\\
     &amp;sa=s0\cdot a\\
     &amp;sb=s\cdot b\\
     &amp;y=sa+sb\\
\end{aligned}\]</span></p>
<p>且延迟时间设定如下表所示:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>最小值min</th>
<th>典型值type</th>
<th>最大值max</th>
</tr>
</thead>
<tbody>
<tr>
<td>a-sa-y</td>
<td>10</td>
<td>12</td>
<td>14</td>
</tr>
<tr>
<td>s-s0-sa-y</td>
<td>15</td>
<td>17</td>
<td>19</td>
</tr>
<tr>
<td>s-sb-y</td>
<td>11</td>
<td>13</td>
<td>15</td>
</tr>
<tr>
<td>b-sb-y</td>
<td>10</td>
<td>12</td>
<td>14</td>
</tr>
</tbody>
</table>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2to1(a, b, s, y);</span><br><span class="line">    <span class="keyword">input</span>  a, b, s;</span><br><span class="line">    <span class="keyword">output</span> y;</span><br><span class="line">    <span class="keyword">wire</span>   sa, sb, s0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span> <span class="variable">#(4, 5, 6) (s0, s)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(6, 7, 8) (sa, s0, a)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(6, 7, 8) (sb, s, b)</span>;</span><br><span class="line">    <span class="keyword">or</span> <span class="variable">#(5, 6, 7) (y, sa, sb)</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在Verilog HDL中产生如下信号</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th>信号名</th>
<th>0~5ns</th>
<th>5~10ns</th>
<th>10~15ns</th>
<th>15~20ns</th>
<th>20~25ns</th>
<th>25~30ns</th>
<th>30~35ns</th>
<th>35~40ns</th>
<th>40~45ns</th>
<th>＞45ns</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>in1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>in2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> signal_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk, in1, in2;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>根据下面的程序, 画出产生的信号波形</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> para(a,b);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">1</span>;</span><br><span class="line">            b=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">100</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                b=<span class="number">0</span>;</span><br><span class="line">                #<span class="number">50</span> b=<span class="number">1</span>;</span><br><span class="line">                #<span class="number">150</span> a=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">join</span></span><br><span class="line">            #<span class="number">100</span> b=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">50</span> a=<span class="number">0</span>;</span><br><span class="line">            b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>0~100ns</th>
<th>100~150ns</th>
<th>150~250ns</th>
<th>250~350ns</th>
<th>350~400ns</th>
<th>&gt;400ns</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>b</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table></li>
<li><p>用任务方式编写4 bit行波加法器, 再调用此任务完成8
bit行波进位加法器. 要求: 输入有三个:<code>A[3:0], B[3:0], Cin</code>,
这三个输入经过4
bit行波加法器后产生两个输出<code>SUM[4:0], Cout</code>.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_8bit(A, B, Cin, SUM, Cout);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] A, B;</span><br><span class="line">    <span class="keyword">input</span>        Cin;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] SUM;</span><br><span class="line">    <span class="keyword">output</span>       Cout;</span><br><span class="line">    <span class="keyword">wire</span> carry_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> adder_4bit;</span><br><span class="line">        <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] A4, B4;</span><br><span class="line">        <span class="keyword">input</span>        Cin4;</span><br><span class="line">        <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] SUM5;</span><br><span class="line">        <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] sum_temp;</span><br><span class="line">        <span class="keyword">reg</span>          cout_temp;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            cout_temp=Cin4;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i=i+<span class="number">1</span>) </span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sum_temp[i]=A4[i]^B4[i]^cout_temp;</span><br><span class="line">                    cout_temp=(A4[i]&amp;B4[i])|(A4[i]&amp;cout_temp)|(B4[i]&amp;cout_temp);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            SUM5 = &#123;cout_temp, sum_temp&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] sum_low, sum_high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        adder_4bit(A[<span class="number">3</span>:<span class="number">0</span>], B[<span class="number">3</span>:<span class="number">0</span>], Cin, sum_low);</span><br><span class="line">        adder_4bit(A[<span class="number">7</span>:<span class="number">4</span>], B[<span class="number">7</span>:<span class="number">4</span>], sum_low[<span class="number">4</span>], sum_high);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> SUM = &#123;sum_high[<span class="number">3</span>:<span class="number">0</span>], sum_low[<span class="number">3</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">assign</span> Cout = sum_high[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用函数编写2 bit 2-1多路选择器, 再调用此函数完成2 bit
4-1多路选择器. 要求: 输入有两个<code>A[1:0], B[1:0]</code>,
这两个输入经过2 bit 2-1MUX后得到一个输出<code>Y[1:0]</code>.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux_4to1_2bit(A, B, C, D, Sel, Y);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] A, B, C, D;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] Sel;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> [<span class="number">1</span>:<span class="number">0</span>] mux_2to1_2bit;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] in0, in1;</span><br><span class="line">        <span class="keyword">input</span>       sel;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            mux_2to1_2bit=sel?in1:in0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] mux0_out, mux1_out;</span><br><span class="line">    <span class="keyword">assign</span> mux0_out=mux_2to1_2bit(A, B, Sel[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> mux1_out=mux_2to1_2bit(C, D, Sel[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> Y=mux_2to1_2bit(mux0_out, mux1_out, Sel[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog HDL为如下的环形移位寄存器编写Testbench,
并利用系统函数<code>$display</code>把当前时间显示出来.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shiftregist1(D, clk, reset);</span><br><span class="line">    <span class="keyword">parameter</span> shiftregist_width=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [shiftregist_width-<span class="number">1</span>:<span class="number">0</span>] D;</span><br><span class="line">    <span class="keyword">input</span>                              clk, reset;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(!reset)</span><br><span class="line">            D&lt;=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D&lt;=&#123;D[shiftregist_width-<span class="number">2</span>:<span class="number">0</span>], D[shiftregist_width-<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> tb_shiftregist1;</span><br><span class="line">    <span class="keyword">reg</span>        clk, reset;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] D;</span><br><span class="line"></span><br><span class="line">    shiftregist1 U1 (<span class="variable">.D</span>(D), <span class="variable">.clk</span>(clk), <span class="variable">.reset</span>(reset));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        reset = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset asserted&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        #<span class="number">20</span> reset = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset deasserted&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        U1<span class="variable">.D</span> = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Initial value set to %b&quot;</span>, <span class="built_in">$time</span>, U1<span class="variable">.D</span>);</span><br><span class="line">        #<span class="number">200</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Test completed&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Clock posedge, D = %b&quot;</span>, <span class="built_in">$time</span>, D);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset changed to %b&quot;</span>, <span class="built_in">$time</span>, reset);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">第四章:Verilog HDL数字逻辑电路设计方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 07:10:50" itemprop="dateModified" datetime="2026-01-15T07:10:50+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="verilog-hdl的设计思想和可综合特性">Verilog
HDL的设计思想和可综合特性</h2>
<p>Verilog HDL主要用于电路设计和验证,
部分语言是为了电路的测试核仿真制定的,
因此其语言分为用于电路设计的可综合性语言和用于仿真测试的不可综合性语言.
对于可综合性语言, EDA综合工具可以将其综合为物理电路.</p>
<h2 id="组合电路的设计">组合电路的设计</h2>
<p>组合电路的特点是, 电路中任意时刻的稳态输出仅与当前时刻输入有关,
而与电路原来的状态无关. 组合电路没有记忆功能, 只有输入到输出的通路,
没有输出到输入的回路.</p>
<p>组合电路的设计需要满足以下几个方面:</p>
<ol type="1">
<li>首先, 所用的逻辑器件数目最少, 器件的种类最少,
且器件之间的连线最简单, 这样的电路称为”最小化”电路.</li>
<li>其次, 为了满足速度要求， 应该使得级数尽量少,
以减少门电路的延时.</li>
<li>电路的功耗尽可能小, 工作时稳定可靠.</li>
</ol>
<p>组合电路的描述方式有4种:</p>
<ol type="1">
<li>真值表</li>
<li>逻辑代数</li>
<li>结构描述</li>
<li>抽象描述</li>
</ol>
<p>例子: 设计一个举重裁判电路, 有A, B, C三个裁判, 只有当两个及以上通过,
才算通过.</p>
<p>先列出真值表, 然后写出逻辑代数, 然后利用卡诺图化简</p>
<p>真值表如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">OUT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>对应的卡诺图如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">C</th>
<th style="text-align: center;">00</th>
<th style="text-align: center;">01</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>0</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;"><em>1</em></td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> design1 (A,B,C,OUT);</span><br><span class="line">    <span class="keyword">input</span>  A,B,C;</span><br><span class="line">    <span class="keyword">output</span> OUT;</span><br><span class="line">    <span class="keyword">assign</span> OUT=(A&amp;B)|(B&amp;C)|(C&amp;A);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> design2 (A,B,C,OUT);</span><br><span class="line">    <span class="keyword">input</span>  A,B,C;</span><br><span class="line">    <span class="keyword">output</span> OUT;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>]sum;</span><br><span class="line">    <span class="keyword">reg</span> OUT;</span><br><span class="line">    <span class="keyword">assign</span> sum=A+B+C;</span><br><span class="line">    <span class="keyword">always</span> @(sum)</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">1</span>) OUT=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>      OUT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="加法器">加法器</h3>
<p>真值表如下:</p>
<p>C_IN是前一位的进位, C_OUT是进位.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C_IN</th>
<th style="text-align: center;">SUM</th>
<th style="text-align: center;">C_OUT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>由此可知</p>
<p>$ SUM=ABC_IN $ $ C_OUT=AB+(AB)C_IN $</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> one_bit_fulladder(A,B,C_IN,SUM,C_OUT)</span><br><span class="line">    <span class="keyword">input</span>   A,B,C_IN;</span><br><span class="line">    <span class="keyword">output</span>  SUM,C_OUT;</span><br><span class="line">        <span class="keyword">assign</span> SUM=(A^B)^C_IN;</span><br><span class="line">        <span class="keyword">assign</span> C_OUT=(A&amp;B)|((A^B)&amp;C_IN);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>另外一种行为级建模:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> one_bit_fulladder(A,B,C_IN,SUM,C_OUT)</span><br><span class="line">    <span class="keyword">input</span>   A,B,C_IN;</span><br><span class="line">    <span class="keyword">output</span>  SUM,C_OUT;</span><br><span class="line">        <span class="keyword">assign</span> &#123;C_OUT,SUM&#125;=A+B+C_IN;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>事实上, 这种行为级建模可以推广到高位全加器, 只需要改变位宽即可:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> eight_bit_fulladder(A,B,C_IN,SUM,C_OUT)</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]   A,B;</span><br><span class="line">    <span class="keyword">input</span>          C_IN;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]   SUM;</span><br><span class="line">    <span class="keyword">output</span>         C_OUT;</span><br><span class="line">        <span class="keyword">assign</span> &#123;C_OUT,SUM&#125;=A+B+C_IN;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="数据比较器">数据比较器</h3>
<p>先来看4位数据比较器的真值表</p>
<table style="width:100%;">
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(A_3~B_3\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(A_2~B_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(A_1~B_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(A_0~B_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(C_{A&gt;B}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(C_{A=B}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(C_{A&lt;B}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_{A&gt;B}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_{A=B}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_{A&lt;B}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3&gt;B_3\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3&lt;B_3\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2&gt;B_2\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2&lt;B_2\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2=B_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_1&gt;B_1\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2=B_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_1&lt;B_1\)</span></td>
<td style="text-align: center;">x x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2=B_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_1=B_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_0&gt;B_0\)</span></td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2=B_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_1=B_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_0&lt;B_0\)</span></td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(A_3=B_3\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_2=B_2\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_1=B_1\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(A_0=B_0\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A&gt;B}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A=B}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A&lt;B}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A&gt;B}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A=B}\)</span></td>
<td style="text-align: center;"><span
class="math inline">\(C_{A&lt;B}\)</span></td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> four_bit_comp1 (A,B,C,F);</span><br><span class="line">    <span class="keyword">parameter</span>   width=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">input</span>       [width-<span class="number">1</span>:<span class="number">0</span>]     A;</span><br><span class="line">    <span class="keyword">input</span>       [width-<span class="number">1</span>:<span class="number">0</span>]     B;<span class="comment">//输入两个4bit二进制数字</span></span><br><span class="line">    <span class="keyword">input</span>       [<span class="number">2</span>:<span class="number">0</span>]           C;<span class="comment">//前一级的比较结果</span></span><br><span class="line">    <span class="keyword">output</span>      [<span class="number">2</span>:<span class="number">0</span>]           F;</span><br><span class="line">    <span class="keyword">reg</span>         [<span class="number">2</span>:<span class="number">0</span>]           F;</span><br><span class="line">    <span class="keyword">always</span> @(A <span class="keyword">or</span> B <span class="keyword">or</span> C) </span><br><span class="line">        <span class="keyword">if</span>(A&gt;B)                 F=<span class="number">3&#x27;b100</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A&lt;B)            F=<span class="number">3&#x27;b001</span>;</span><br><span class="line">        <span class="keyword">else</span>                    F=C;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//四位数据比较器</span></span><br></pre></td></tr></table></figure>
<h3 id="数据选择器">数据选择器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux8to1 (data,sel,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]    data;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]    sel;</span><br><span class="line">    <span class="keyword">output</span>          out;</span><br><span class="line">    <span class="keyword">reg</span>             out;</span><br><span class="line">    <span class="keyword">always</span> @(data,sel)</span><br><span class="line">        <span class="keyword">case</span> (sel)</span><br><span class="line">            <span class="number">3&#x27;b000</span>:out&lt;=data[<span class="number">0</span>];</span><br><span class="line">            <span class="number">3&#x27;b001</span>:out&lt;=data[<span class="number">1</span>];</span><br><span class="line">            <span class="number">3&#x27;b010</span>:out&lt;=data[<span class="number">2</span>];</span><br><span class="line">            <span class="number">3&#x27;b011</span>:out&lt;=data[<span class="number">3</span>];</span><br><span class="line">            <span class="number">3&#x27;b100</span>:out&lt;=data[<span class="number">4</span>];</span><br><span class="line">            <span class="number">3&#x27;b101</span>:out&lt;=data[<span class="number">5</span>];</span><br><span class="line">            <span class="number">3&#x27;b110</span>:out&lt;=data[<span class="number">6</span>];</span><br><span class="line">            <span class="number">3&#x27;b111</span>:out&lt;=data[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//八选一数据选择器</span></span><br></pre></td></tr></table></figure>
<h3 id="数字编码器">数字编码器</h3>
<p>3位二进制8线-3线编码器真值表</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(I_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_3\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_4\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_5\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_6\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(I_7\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(F_0\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> code8to3 (F,I);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]    I;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]    F;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]    F;</span><br><span class="line">    <span class="keyword">always</span> @(I) </span><br><span class="line">        <span class="keyword">case</span> (I)<span class="comment">//照着真值表把case和输出结果F写出来就行了</span></span><br><span class="line">            <span class="number">8&#x27;b00000001</span>:F=<span class="number">3&#x27;b000</span>; </span><br><span class="line">            <span class="number">8&#x27;b00000010</span>:F=<span class="number">3&#x27;b001</span>; </span><br><span class="line">            <span class="number">8&#x27;b00000100</span>:F=<span class="number">3&#x27;b010</span>; </span><br><span class="line">            <span class="number">8&#x27;b00001000</span>:F=<span class="number">3&#x27;b011</span>; </span><br><span class="line">            <span class="number">8&#x27;b00010000</span>:F=<span class="number">3&#x27;b100</span>; </span><br><span class="line">            <span class="number">8&#x27;b00100000</span>:F=<span class="number">3&#x27;b101</span>; </span><br><span class="line">            <span class="number">8&#x27;b01000000</span>:F=<span class="number">3&#x27;b110</span>; </span><br><span class="line">            <span class="number">8&#x27;b10000000</span>:F=<span class="number">3&#x27;b111</span>; </span><br><span class="line">            <span class="keyword">default</span>:    F=<span class="number">3&#x27;bx</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//8线-3线编码器</span></span><br></pre></td></tr></table></figure>
<p>8线-3线优先编码器真值表</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(\overline{S}\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_3\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_4\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_5\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_6\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{I}_7\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_s\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_{ex}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ol type="1">
<li><span class="math inline">\(\overline{S}=1\)</span>时,
电路处于禁止工作状态, 此时无论是什么输入, 输出总为高电平.</li>
<li><span class="math inline">\(\overline{S}=0\)</span>时, 电路工作,
<span class="math inline">\(\overline{I}_7\)</span>优先级最高, <span
class="math inline">\(\overline{I}_0\)</span>优先级最低. 当<span
class="math inline">\(\overline{I}_7=0\)</span>时, 无论其他输入端为何值,
输出总为<span
class="math inline">\(\overline{Y}_2\overline{Y}_1\overline{Y}_0=000\)</span>,
其他状态以此类推.</li>
<li>对于<span
class="math inline">\(\overline{Y}_2\overline{Y}_1\overline{Y}_0=111\)</span>,
有三种状态,若<span
class="math inline">\(\overline{Y}_s\overline{Y}_{ex}=10\)</span>,
则表示电路工作且<span
class="math inline">\(\overline{I}_0\)</span>有编码信号输入; 若<span
class="math inline">\(\overline{Y}_s\overline{Y}_{ex}=01\)</span>,
则表示电路工作且没有编码信号输入; 若<span
class="math inline">\(\overline{Y}_s\overline{Y}_{ex}=11\)</span>,
则表示电路不工作.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux8to3_p(data_out,Ys,Yex,sel,data_in);</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>]     data_out;</span><br><span class="line">    <span class="keyword">output</span>           Ys,Yex;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]     data_in;</span><br><span class="line">    <span class="keyword">input</span>            sel;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]     data_out;</span><br><span class="line">    <span class="keyword">reg</span>              Ys,Yex;</span><br><span class="line">        <span class="keyword">always</span>@(data_in <span class="keyword">or</span> sel)</span><br><span class="line">            <span class="keyword">if</span>(sel) &#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b111</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">casex</span> (data_in)</span><br><span class="line">                        <span class="number">8&#x27;b0</span>???????:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b000</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b10</span>??????:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b001</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b110</span>?????:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b010</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b1110</span>????:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b011</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b11110</span>???:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b100</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b111110</span>??:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b101</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b1111110</span>?:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b110</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b11111110</span>:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b111</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">                        <span class="number">8&#x27;b11111111</span>:&#123;data_out,Ys,Yex&#125;=&#123;<span class="number">3&#x27;b111</span>,<span class="number">1&#x27;b0</span>,<span class="number">1&#x27;b1</span>&#125;;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>二进制转十进制的8421BCD编码器的真值表如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">十进制数</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span
class="math inline">\(0(Y_0)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(1(Y_1)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(2(Y_2)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(3(Y_3)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(4(Y_4)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(5(Y_5)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(6(Y_6)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(7(Y_7)\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(8(Y_8)\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;"><span
class="math inline">\(9(Y_9)\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> BCD8421(data_out,data_in);</span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">3</span>:<span class="number">0</span>]   data_out;</span><br><span class="line">    <span class="keyword">input</span>   [<span class="number">8</span>:<span class="number">0</span>]   data_in;</span><br><span class="line">    <span class="keyword">reg</span>     [<span class="number">3</span>:<span class="number">0</span>]   data_out;</span><br><span class="line">        <span class="keyword">always</span>@(data_in)</span><br><span class="line">            <span class="keyword">case</span>(data_in)<span class="comment">//照着真值表把输入case和输出的8421码抄下来就行</span></span><br><span class="line">                <span class="number">9&#x27;b000000000</span>:data_out=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">                <span class="number">9&#x27;b000000001</span>:data_out=<span class="number">4&#x27;b0001</span>;</span><br><span class="line">                <span class="number">9&#x27;b000000010</span>:data_out=<span class="number">4&#x27;b0010</span>;</span><br><span class="line">                <span class="number">9&#x27;b000000100</span>:data_out=<span class="number">4&#x27;b0011</span>;</span><br><span class="line">                <span class="number">9&#x27;b000001000</span>:data_out=<span class="number">4&#x27;b0100</span>;</span><br><span class="line">                <span class="number">9&#x27;b000010000</span>:data_out=<span class="number">4&#x27;b0101</span>;</span><br><span class="line">                <span class="number">9&#x27;b000100000</span>:data_out=<span class="number">4&#x27;b0110</span>;</span><br><span class="line">                <span class="number">9&#x27;b001000000</span>:data_out=<span class="number">4&#x27;b0111</span>;</span><br><span class="line">                <span class="number">9&#x27;b010000000</span>:data_out=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">                <span class="number">9&#x27;b100000000</span>:data_out=<span class="number">4&#x27;b1001</span>;</span><br><span class="line">                <span class="keyword">default</span>     :data_out=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="数字译码器">数字译码器</h3>
<p>2线-4线译码器的真值表如下</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span
class="math inline">\(E\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(A_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(A_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_0\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_1\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_2\)</span></th>
<th style="text-align: center;"><span
class="math inline">\(\overline{Y}_3\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ol type="1">
<li><span class="math inline">\(N\)</span>位二进制译码器有<span
class="math inline">\(N\)</span>个输入, <span
class="math inline">\(2^N\)</span>个输出. <span
class="math inline">\(E\)</span>为使能端, <span
class="math inline">\(E=1\)</span>时禁止工作, <span
class="math inline">\(E=0\)</span>时正常工作.</li>
<li>输出函数可以写为<span
class="math inline">\(\overline{Y}_i=\overline{\overline{E}m_i}\)</span>,
其中<span
class="math inline">\(m_i\)</span>表示输入地址变量的一个最小项.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decode_2to4(Y,E,A);</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] Y;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] A;</span><br><span class="line">    <span class="keyword">input</span>        E;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] Y;</span><br><span class="line">        <span class="keyword">always</span>@(E <span class="keyword">or</span> A)</span><br><span class="line">            <span class="keyword">case</span>(&#123;E,A&#125;)</span><br><span class="line">                <span class="number">3&#x27;b1</span>?? :Y=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">                <span class="number">3&#x27;b000</span> :Y=<span class="number">4&#x27;b0001</span>;</span><br><span class="line">                <span class="number">3&#x27;b001</span> :Y=<span class="number">4&#x27;b0010</span>;</span><br><span class="line">                <span class="number">3&#x27;b010</span> :Y=<span class="number">4&#x27;b0100</span>;</span><br><span class="line">                <span class="number">3&#x27;b011</span> :Y=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">                <span class="keyword">default</span>:Y=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="时序电路的设计">时序电路的设计</h2>
<p>时序逻辑电路的输出不仅与当前时刻输入变量的取值有关,
而且与电路的原状态(即过去的输入情况)有关. 与组合逻辑电路相比,
时序逻辑电路有两个特点:</p>
<ol type="1">
<li>时序逻辑电路包括组合逻辑电路和存储电路两部分, 存储电路具有记忆功能,
通常由触发器构成.</li>
<li>存储电路的状态反馈到组合逻辑电路的输入端.</li>
</ol>
<p>时序逻辑电路按照状态变化的特点,
可以分为同步时序逻辑电路和异步时序逻辑电路. 同步时序逻辑电路中,
电路状态的变化在同一时钟脉冲作用下发生,
即各个触发器的状态转换同一时刻完成. 在异步时序逻辑电路中,
没有统一的时钟脉冲信号, 即各触发器的状态转换是异步完成的.</p>
<p>时序逻辑电路功能的描述方式有三种:</p>
<ol type="1">
<li>逻辑方程</li>
<li>状态转移表和状态转移图</li>
<li>时序图</li>
</ol>
<p>Verilog HDL对于时序逻辑电路的设计也有三种方式:</p>
<ol type="1">
<li>状态转移图描述</li>
<li>基于状态化简的结构性描述</li>
<li>Verilog HDL抽象描述</li>
</ol>
<h3 id="触发器">触发器</h3>
<p>触发器是时序逻辑的最基本电路单元. 根据功能的不同, 触发器还可以有置位,
复位, 使能, 选择等功能.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DFF(q,clk,data_in)</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span>  clk,data_in;</span><br><span class="line">    <span class="keyword">reg</span>    q;</span><br><span class="line">        <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) q&lt;=data_in;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//最简单的D触发器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DFF(q,clk,reset,data_in)</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span>  clk,reset,data_in;</span><br><span class="line">    <span class="keyword">reg</span>    q;</span><br><span class="line">        <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk);</span><br><span class="line">            <span class="keyword">if</span>(!reset) q&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>       q&lt;=data_in;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//同步清零的D触发器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DFF(q,clk,reset,data_in)</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span>  clk,reset,data_in;</span><br><span class="line">    <span class="keyword">reg</span>    q;</span><br><span class="line">        <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset);</span><br><span class="line">            <span class="keyword">if</span>(!reset) q&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>       q&lt;=data_in;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//异步清零的D触发器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> DFF (q,clk,rst1,rst2,in);</span><br><span class="line">    <span class="keyword">input</span>  clk,rst1,rst2,in;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span>    q;</span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) </span><br><span class="line">            <span class="keyword">if</span>(!rst1) q&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>      q&lt;=in;</span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst2)</span><br><span class="line">            <span class="keyword">if</span>(!rst2) q&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>      q&lt;=in;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//具有同步和异步清零的D触发器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> TFF (T,clk,rst,out);</span><br><span class="line">    <span class="keyword">input</span>  T,clk,rst;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">reg</span> out;</span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">            <span class="keyword">if</span>(!rst)    out&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(T)  out&lt;=~out;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//T触发器</span></span><br></pre></td></tr></table></figure>
<h3 id="计数器">计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> comp2bit(Q,clk,reset);</span><br><span class="line">    <span class="keyword">output</span>  Q;</span><br><span class="line">    <span class="keyword">input</span>   clk,reset;</span><br><span class="line">    <span class="keyword">reg</span>     Q;</span><br><span class="line">        <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">            <span class="keyword">if</span>(!reset)  Q&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">else</span>        Q&lt;=~Q;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//二进制计数器</span></span><br></pre></td></tr></table></figure>
<p>对于<span class="math inline">\(M\)</span>进制的计数器,
首先应该确定计数器所需触发器的个数. <span
class="math inline">\(N\)</span>个触发器对应了<span
class="math inline">\(2^N\)</span>个状态, 所以应该有<span
class="math inline">\(2^N&gt;M\)</span>. 例如,
下面的十一进制计数器最少需要<span
class="math inline">\(4\)</span>个触发器.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter (clk,rst,count);</span><br><span class="line">    <span class="keyword">input</span>           clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]    count;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]    count;</span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">            <span class="keyword">if</span>(rst)                 count&lt;=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">4&#x27;b1010</span>) count&lt;=<span class="number">4&#x27;b0000</span>;<span class="comment">//计数的范围是4&#x27;b0000~4&#x27;b1010，也就是11</span></span><br><span class="line">            <span class="keyword">else</span>                    count&lt;=count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//11进制计数器，在此基础上可以修改成任意进制计数器，只需要调整count的位宽和else if括号里面的值即可</span></span><br></pre></td></tr></table></figure>
<h3 id="移位寄存器">移位寄存器</h3>
<p><span class="math inline">\(N\)</span>位环形移位寄存器由<span
class="math inline">\(N\)</span>个寄存器组成,
将每个寄存器的输出作为下一个寄存器的输入,
并将高位寄存器的输出作为循环的输入.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shiftregist (D,clk,rst);</span><br><span class="line">    <span class="keyword">parameter</span> width=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">input</span>               clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [width-<span class="number">1</span>:<span class="number">0</span>]  D;</span><br><span class="line">    <span class="keyword">reg</span>    [width-<span class="number">1</span>:<span class="number">0</span>]  D;</span><br><span class="line">        <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) </span><br><span class="line">            <span class="keyword">if</span>(!rst) D&lt;=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">else</span>     D&lt;=&#123;D[width-<span class="number">2</span>:<span class="number">0</span>],D[width-<span class="number">1</span>]&#125;;<span class="comment">//把第一位搬到最后一位，第一位之后的位整体前移一位</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//环形移位寄存器</span></span><br></pre></td></tr></table></figure>
<h3 id="序列信号发生器">序列信号发生器</h3>
<p>序列信号发生器按照循环长度<span
class="math inline">\(M\)</span>与触发器数目<span
class="math inline">\(n\)</span>的关系可以分成三种:</p>
<ol type="1">
<li>最大循环长度序列码, <span class="math inline">\(M=2^n\)</span></li>
<li>最长线性序列码(<span class="math inline">\(M\)</span>序列码), <span
class="math inline">\(M=2^n-1\)</span></li>
<li>任意循环长度序列码, <span
class="math inline">\(M&lt;2^n\)</span></li>
</ol>
<p>序列信号发生器可以由纯时序逻辑电路构成,
也可以由时序和组合逻辑电路组成.</p>
<p>例: 用Verilog HDL设计一个产生100111序列的序列信号发生器.</p>
<p>第一种方法是采用循环移位寄存器, 在电路工作前,
先把需要的序列码放入移位寄存器中, 然后循环移位, 将最高位输出.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> signal_maker (out,clk,load,D);</span><br><span class="line">    <span class="keyword">parameter</span> M=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">input</span>               clk,load;</span><br><span class="line">    <span class="keyword">input</span>  [M-<span class="number">1</span>:<span class="number">0</span>]      D;</span><br><span class="line">    <span class="keyword">output</span>              out;</span><br><span class="line">    <span class="keyword">reg</span>    [M-<span class="number">1</span>:<span class="number">0</span>]      Q;</span><br><span class="line">        <span class="keyword">initial</span> Q=<span class="number">6&#x27;b100111</span>;            <span class="comment">//初始化序列码</span></span><br><span class="line">            <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">                <span class="keyword">if</span>(load) Q&lt;=D;          <span class="comment">//可以根据需要加载新的序列码</span></span><br><span class="line">                <span class="keyword">else</span>     Q&lt;=&#123;Q[M-<span class="number">2</span>:<span class="number">0</span>],Q[M-<span class="number">1</span>]&#125;;<span class="comment">//把第一位搬到最后一位，第一位之后的位整体前移一位</span></span><br><span class="line">        <span class="keyword">assign</span> out=Q[M-<span class="number">1</span>];<span class="comment">//利用连续赋值语句输出最高位，组合电路</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是一个产生100111序列的信号发生器，由时序逻辑组成</span></span><br></pre></td></tr></table></figure>
<p>第二种方法是利用时序和组合逻辑电路设计序列信号发生器,
设计步骤如下:</p>
<ol type="1">
<li>根据给定的序列信号循环周期<span class="math inline">\(M\)</span>,
确定移位寄存器的个数<span class="math inline">\(n\)</span>, <span
class="math inline">\(2^{n-1}&lt;M\leq 2^n\)</span></li>
<li>确定移位寄存器的<span class="math inline">\(M\)</span>个独立状态,
将给定的序列码按照移位规律每<span
class="math inline">\(n\)</span>位一组, 划分为<span
class="math inline">\(M\)</span>个状态. 若<span
class="math inline">\(M\)</span>个状态里出现重复现象,
则应该增加移位寄存器的个数. 用<span
class="math inline">\(n+1\)</span>位重复上述过程, 直至划分为<span
class="math inline">\(M\)</span>个独立状态.</li>
<li>根据<span
class="math inline">\(M\)</span>个不同的状态列出移位寄存器的态序表和反馈函数表,
求出反馈函数<span class="math inline">\(F\)</span>的表达式</li>
<li>检查自启动功能</li>
</ol>
<p>对于100111的序列信号发生器, 首先确定所需的移位寄存器的个数<span
class="math inline">\(n\)</span>, 因为<span
class="math inline">\(M=6\)</span>, 所以<span
class="math inline">\(n\geq 3\)</span>, 然后确定寄存器的6个独立状态,
按照移位规律每三个一组:100, 001, 011, 111, 111, 110,
其中状态111出现了两次, 这是不行的, 因此取<span
class="math inline">\(n=4\)</span>, 重新划分状态可得: 1001, 0011, 0111,
1111, 1110, 1100. 没有重复状态, 所以<span
class="math inline">\(n=4\)</span>. 第三,
列出态序表和反馈激励函数表如下:</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(Q_0\)</span></th>
<th><span class="math inline">\(Q_1\)</span></th>
<th><span class="math inline">\(Q_2\)</span></th>
<th><span class="math inline">\(Q_3\)</span></th>
<th><span class="math inline">\(F\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>可得反馈激励函数</p>
<p><span
class="math display">\[F=\overline{Q_3}+\overline{Q_1}\cdot\overline{Q_0}+Q_3+\overline{Q_2}\]</span></p>
<p>由此可得</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> signal_maker(out, clk, load, D);</span><br><span class="line">    <span class="keyword">parameter</span> M=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">input</span>           clk, load;</span><br><span class="line">    <span class="keyword">input</span>   [M-<span class="number">1</span>:<span class="number">0</span>] D;</span><br><span class="line">    <span class="keyword">output</span>          out;</span><br><span class="line">    <span class="keyword">reg</span>     [M-<span class="number">1</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">wire</span>            w1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)                            <span class="comment">//时序电路部分, 移位寄存器</span></span><br><span class="line">        <span class="keyword">if</span> (load) Q&lt;=D;</span><br><span class="line">        <span class="keyword">else</span>      Q&lt;=&#123;Q[M-<span class="number">2</span>:<span class="number">0</span>], w1&#125;;</span><br><span class="line">    <span class="keyword">assign</span> w1=(~Q[<span class="number">3</span>])|(~Q[<span class="number">1</span>]&amp;(~Q[<span class="number">0</span>]))|(Q[<span class="number">3</span>]&amp;(~Q[<span class="number">2</span>]));<span class="comment">//组合逻辑电路, 反馈网络</span></span><br><span class="line">    <span class="keyword">assign</span> out=Q[M-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>第三种方法是由计数器构成, 分成两步:</p>
<p>第一步: 根据序列码M的长度设计M进制计数器, 状态自定.</p>
<p>第二步: 按照计数器的状态转移关系和序列码的要求设计组合输出电路</p>
<p>对于100111序列码的信号发生器, 序列信号的M值为6,
因为需要选用模6计数器; 计数器的状态选择从000到101,
得到输出组合逻辑真值表如下:</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(Q_2\)</span></th>
<th><span class="math inline">\(Q_1\)</span></th>
<th><span class="math inline">\(Q_0\)</span></th>
<th>out</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>画出卡诺图并化简得</p>
<p><span
class="math display">\[\rm{out}=Q_2+\overline{Q_1}~\overline{Q_0}+Q_1Q_0\]</span></p>
<p>由此可得</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> signal_maker(out, clk, rst);</span><br><span class="line">    <span class="keyword">parameter</span> M=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">input</span>       clk, rst;</span><br><span class="line">    <span class="keyword">output</span>      out;</span><br><span class="line">    <span class="keyword">reg</span> [M-<span class="number">1</span>:<span class="number">0</span>] counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)<span class="comment">//计数器模块，为时序逻辑电路</span></span><br><span class="line">        <span class="keyword">if</span> (!rst)   counter&lt;=<span class="number">3&#x27;b000</span>;</span><br><span class="line">        <span class="keyword">else</span>        counter&lt;=counter+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">assign</span> out=counter[<span class="number">2</span>]|((~counter[<span class="number">1</span>])&amp;(~counter[<span class="number">2</span>]))|(counter[<span class="number">1</span>]&amp;counter[<span class="number">0</span>]);<span class="comment">//输出模块，为组合逻辑电路</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="有限同步状态机">有限同步状态机</h2>
<p>有限状态机分为同步和异步, 这里只讨论同步.
有限状态机是时序电路的通用模型, 即任何时序电路都可以表示成有限状态机.
由时序电路表示的有限状态机中,
各个状态之间的转移总是在时钟的触发下进行的, 状态信息储存在寄存器中.
因为状态个数是有限的, 所以称为有限同步状态机.</p>
<p>和时序电路一样, 有限同步状态机也由两部分组成: 存储电路和组合逻辑电路.
存储电路用来生成状态机的状态,
组合逻辑电路用来提供输出以及状态机跳转的条件.</p>
<p>根据输出信号的产生方式, 有限状态机可以分成Mealy型和Moore型,
Mealy型状态机的输出和当前状态和输入有关,
Moore型状态机的输出只依赖于当前状态而与输入无关.</p>
<p>在Verilog HDL中, 有限状态机的描述方式有很多,
一般有两段式和三段式.</p>
<p>两段式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个进程, 同步时序always模块, 格式化描述次态寄存器迁移到现态寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)<span class="comment">//异步复位</span></span><br><span class="line">    <span class="keyword">if</span>(!rst) current_state&lt;=IDLE;</span><br><span class="line">    <span class="keyword">else</span>     current_state&lt;=next_state;</span><br><span class="line"><span class="comment">//第二个进程, 组合逻辑always模块, 描述状态转移条件判断</span></span><br><span class="line"><span class="keyword">always</span> @(current_state <span class="keyword">or</span> 其他输入信号)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        next_state=x;</span><br><span class="line">        <span class="keyword">case</span>(current_state)</span><br><span class="line">            S1: <span class="keyword">if</span>(...)</span><br><span class="line">                next_state=S2;</span><br><span class="line">                out1&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>三段式描述方法</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个进程, 同步时序always模块, 格式化描述次态寄存器迁移到现态寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)<span class="comment">//异步复位</span></span><br><span class="line">    <span class="keyword">if</span>(!rst) current_state&lt;=IDLE;</span><br><span class="line">    <span class="keyword">else</span>     current_state&lt;=next_state;</span><br><span class="line"><span class="comment">//第二个进程, 组合逻辑always模块, 描述状态转移条件判断</span></span><br><span class="line"><span class="keyword">always</span> @(current_state <span class="keyword">or</span> 输入信号)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        next_state=x;</span><br><span class="line">        <span class="keyword">case</span>(current_state)</span><br><span class="line">            S1: <span class="keyword">if</span>(...)</span><br><span class="line">            next_state=S2;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//第三个进程, 同步时序always模块, 格式化描述次态寄存器输出</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    ...<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">case</span>(next_state <span class="keyword">or</span> 输入信号)</span><br><span class="line">            S1:</span><br><span class="line">            out1&lt;=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            S2:</span><br><span class="line">            out1&lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">default</span>:...</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>例: 设计顺序脉冲发生器</p>
<p>以4位顺序脉冲发射器为例, 它有4路输出<span class="math inline">\(S_0,
S_1, S_2, S_3\)</span>, 每路输出上高电平脉冲依次出现, 输出在1000, 0100,
0010, 0001之间循环. 4位顺序脉冲发生器的状态转移图如下:</p>
<p><span class="math display">\[S_0:00/1000\rightarrow
S_1:01/0100\rightarrow S_2:10/0010\rightarrow S_3:11/0001\rightarrow
S_0\cdots\]</span></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> state4(out, clk, rst);</span><br><span class="line">    <span class="keyword">input</span>        clk, rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">1</span>:<span class="number">0</span>] state, next_state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(state)</span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            <span class="number">2&#x27;b00</span>:</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    out&lt;=<span class="number">4&#x27;b0001</span>;</span><br><span class="line">                    next_state&lt;=<span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>:</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    out&lt;=<span class="number">4&#x27;b0010</span>;</span><br><span class="line">                    next_state&lt;=<span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>:</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    out&lt;=<span class="number">4&#x27;b0100</span>;</span><br><span class="line">                    next_state&lt;=<span class="number">2&#x27;b11</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b11</span>:</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    out&lt;=<span class="number">4&#x27;b1000</span>;</span><br><span class="line">                    next_state&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">if</span>(!rst)    state&lt;=<span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">else</span>        state&lt;=next_state;</span><br><span class="line"><span class="keyword">endmodule</span>   </span><br></pre></td></tr></table></figure>
<p>例: 设计一个自动售报机, 报纸价格为每份8角, 纸币有1角, 2角, 5角, 1元,
其他情况不考虑.</p>
<p>设<span class="math inline">\(S_0\sim S_7\)</span>为状态机的8个状态,
其中下标表示已经投币的总和, 如<span
class="math inline">\(S_1\)</span>为投入1角, <span
class="math inline">\(S_2\)</span>为投入2角. <span
class="math inline">\(M\)</span>表示输入, <span
class="math inline">\(M1\)</span>表示投入1角, <span
class="math inline">\(M2\)</span>表示投入2角, <span
class="math inline">\(M5\)</span>表示投入5角, <span
class="math inline">\(M10\)</span>表示投入1元.</p>
<p><code>data_out=1</code>表示给出报纸,
<code>data_out_return1=1</code>表示找回1角,
<code>data_out_return2=1</code>表示找回2角.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> auto_sellor(current_state, data_out, data_out_return1, data_out_return2, clk, rst, data_in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> state_width=<span class="number">3</span>, data_in_width=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">output</span> [state_width-<span class="number">1</span>:<span class="number">0</span>]   current_state;</span><br><span class="line">    <span class="keyword">output</span>                     data_out, data_out_return1, data_out_return2;</span><br><span class="line">    <span class="keyword">input</span>  [data_in_width-<span class="number">1</span>:<span class="number">0</span>] data_in;</span><br><span class="line">    <span class="keyword">input</span>                      clk, rst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>    [state_width-<span class="number">1</span>:<span class="number">0</span>]   current_state, next_state;</span><br><span class="line">    <span class="keyword">reg</span>                        data_out, data_out_return1, data_out_return2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(current_state <span class="keyword">or</span> data_in)</span><br><span class="line">        <span class="keyword">case</span>(current_state)</span><br><span class="line">        <span class="comment">//下面一部分是S_0</span></span><br><span class="line">            <span class="number">3&#x27;b000</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//保持S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b001</span>;  <span class="comment">//跳转到S_1</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b010</span>;  <span class="comment">//跳转到S_2</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b101</span>;  <span class="comment">//跳转到S_5</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b100</span>:                             <span class="comment">//投入1元</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//找回2角</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面一部分是S_1</span></span><br><span class="line">            <span class="number">3&#x27;b001</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b001</span>;  <span class="comment">//保持S_1</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b010</span>;  <span class="comment">//跳转到S_2</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b011</span>;  <span class="comment">//跳转到S_3</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b110</span>;  <span class="comment">//跳转到S_6</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面一部分是S_2</span></span><br><span class="line">            <span class="number">3&#x27;b010</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b010</span>;  <span class="comment">//保持S_2</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b011</span>;  <span class="comment">//跳转到S_3</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b100</span>;  <span class="comment">//跳转到S_4</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b111</span>;  <span class="comment">//跳转到S_7</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面是S_3</span></span><br><span class="line">            <span class="number">3&#x27;b011</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b011</span>;  <span class="comment">//保持S_3</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b100</span>;  <span class="comment">//跳转到S_4</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b101</span>;  <span class="comment">//跳转到S_5</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面是S_4$</span></span><br><span class="line">            <span class="number">3&#x27;b100</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b100</span>;  <span class="comment">//保持S_4</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b101</span>;  <span class="comment">//跳转到S_5</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b110</span>;  <span class="comment">//跳转到S_6</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//找回1角</span></span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面是S_5</span></span><br><span class="line">            <span class="number">3&#x27;b101</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b101</span>;  <span class="comment">//保持S_5</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b110</span>;  <span class="comment">//跳转到S_6</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b111</span>;  <span class="comment">//跳转到S_7</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b011</span>:                             <span class="comment">//投入5角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//找回2角</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面是S_6</span></span><br><span class="line">            <span class="number">3&#x27;b110</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b110</span>;  <span class="comment">//保持S_6</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b111</span>;  <span class="comment">//保持S_7</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b010</span>:                             <span class="comment">//投入2角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">        <span class="comment">//下面是S_7</span></span><br><span class="line">            <span class="number">3&#x27;b111</span>: <span class="keyword">case</span>(data_in)</span><br><span class="line">                        <span class="number">3&#x27;b000</span>:                             <span class="comment">//不操作</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b111</span>;  <span class="comment">//保持S_7</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                        <span class="number">3&#x27;b001</span>:                             <span class="comment">//投入1角</span></span><br><span class="line">                            <span class="keyword">begin</span></span><br><span class="line">                                next_state       &lt;=<span class="number">3&#x27;b000</span>;  <span class="comment">//跳转到S_0</span></span><br><span class="line">                                data_out         &lt;=<span class="number">1&#x27;b1</span>;    <span class="comment">//给出报纸</span></span><br><span class="line">                                data_out_return1 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                                data_out_return2 &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> rst)</span><br><span class="line">        <span class="keyword">if</span>(!rst)    current_state&lt;=<span class="number">3&#x27;b000</span>;</span><br><span class="line">        <span class="keyword">else</span>        current_state&lt;=next_state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例: 11010序列检测器</p>
<p>序列检测器就是将一个指定的序列从数字码流中检测出来.
当输入端出现序列11010时, 输出为1, 否则为0. 此处不考虑重复序列,
即出现指定序列后就重新开始序列检测, 不再考虑以前的数据.
规定数据从右端输入,即按照<span class="math inline">\(1\rightarrow
1\rightarrow 0\rightarrow 1\rightarrow 0\)</span>的顺序输入.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> seqdet(dout, din, clk, rst);</span><br><span class="line">    <span class="keyword">parameter</span> IDLE=<span class="number">3&#x27;d0</span>, A=<span class="number">3&#x27;d1</span>, B=<span class="number">3&#x27;d2</span>, C=<span class="number">3&#x27;d3</span>, D=<span class="number">3&#x27;d4</span>, E=<span class="number">3&#x27;d5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">input</span>        din, clk, rst;</span><br><span class="line">    <span class="keyword">output</span>       dout;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>] state, next_state;</span><br><span class="line">    <span class="keyword">wire</span>         dout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> dout=(state==E)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(state <span class="keyword">or</span> din)</span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            IDLE: <span class="keyword">if</span>(din) next_state=A;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=IDLE;</span><br><span class="line">            A:    <span class="keyword">if</span>(din) next_state=B;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=IDLE;</span><br><span class="line">            B:    <span class="keyword">if</span>(din) next_state=B;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=C;</span><br><span class="line">            C:    <span class="keyword">if</span>(din) next_state=D;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=IDLE;</span><br><span class="line">            D:    <span class="keyword">if</span>(din) next_state=B;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=E;</span><br><span class="line">            E:    <span class="keyword">if</span>(din) next_state=IDLE;</span><br><span class="line">                  <span class="keyword">else</span>    next_state=A;</span><br><span class="line">            <span class="keyword">default</span>:      next_state=IDLE;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        state&lt;=next_state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>用查找表的方式实现真值表中的加法器, 写出Verilog HDL代码</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Cin</th>
<th style="text-align: center;">ain</th>
<th style="text-align: center;">bin</th>
<th style="text-align: center;">sum</th>
<th style="text-align: center;">Cout</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder(Cin, ain, bin, sum, Cout);</span><br><span class="line">    <span class="keyword">input</span>       Cin, ain, bin;</span><br><span class="line">    <span class="keyword">output</span>      sum, Cout;</span><br><span class="line">    <span class="keyword">reg</span>         sum, Cout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(Cin <span class="keyword">or</span> ain <span class="keyword">or</span> bin) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(&#123;Cin, ain, bin&#125;)<span class="comment">//按照真值表直接抄下来就好</span></span><br><span class="line">                <span class="number">3&#x27;b000</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">                <span class="number">3&#x27;b001</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="number">3&#x27;b010</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="number">3&#x27;b011</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="number">3&#x27;b100</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="number">3&#x27;b101</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="number">3&#x27;b110</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="number">3&#x27;b111</span>:  &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">                <span class="keyword">default</span>: &#123;Cout, sum&#125; &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog
HDL描述用D触发器实现带有同步清零功能(低电平有效)的二分频电路,
并设计功能模块的测试程序,要求输入两个信号<code>CLK1, RESET</code>,经过这个二分频电路后输出<code>CLK2</code>.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：基于D触发器的二分频电路，带有同步清零功能（低电平有效）</span></span><br><span class="line"><span class="comment">// 工作原理：每个输入时钟的上升沿，输出时钟状态翻转；当复位有效时输出清零</span></span><br><span class="line"><span class="keyword">module</span> div2(CLK1, RESET, CLK2);</span><br><span class="line">    <span class="comment">// 输入端口声明</span></span><br><span class="line">    <span class="keyword">input</span>   CLK1;     <span class="comment">// 输入时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>   RESET;    <span class="comment">// 同步复位信号，低电平有效（0=复位，1=工作）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出端口声明</span></span><br><span class="line">    <span class="keyword">output</span>  CLK2;     <span class="comment">// 二分频输出时钟信号</span></span><br><span class="line">    <span class="keyword">reg</span>     CLK2;     <span class="comment">// 将输出声明为reg类型，因为它在always块中被赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// always块：在CLK1的每个上升沿触发</span></span><br><span class="line">    <span class="comment">// 描述时序逻辑，实现D触发器的功能</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> CLK1) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 同步复位：当RESET为低电平（0）时，在时钟上升沿将CLK2清零</span></span><br><span class="line">            <span class="keyword">if</span> (!RESET)  <span class="comment">// !RESET 表示 RESET == 1&#x27;b0</span></span><br><span class="line">                CLK2 &lt;= <span class="number">1&#x27;b0</span>;  <span class="comment">// 同步清零输出</span></span><br><span class="line">            <span class="comment">// 正常工作：当RESET为高电平（1）时，每个时钟上升沿翻转CLK2</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                CLK2 &lt;= ~CLK2; <span class="comment">// 输出取反，实现二分频</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：&lt;= 是非阻塞赋值，用于时序逻辑，确保在时钟边沿同时更新所有寄存器</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：测试div2模块的功能，验证同步清零和二分频功能</span></span><br><span class="line"><span class="comment">// 测试方法：生成激励信号，观察输出响应</span></span><br><span class="line"><span class="keyword">module</span> div2_tb;</span><br><span class="line">    <span class="comment">// 测试信号声明</span></span><br><span class="line">    <span class="keyword">reg</span>  CLK1, RESET;  <span class="comment">// reg类型，用于驱动被测模块的输入</span></span><br><span class="line">    <span class="keyword">wire</span> CLK2;         <span class="comment">// wire类型，连接被测模块的输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化被测模块</span></span><br><span class="line">    <span class="comment">// U1是被测模块的实例名称，括号内是端口映射（位置映射方式）</span></span><br><span class="line">    div2 U1(<span class="variable">.CLK1</span>(CLK1), <span class="variable">.RESET</span>(RESET), <span class="variable">.CLK2</span>(CLK2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个initial块：生成输入时钟信号CLK1</span></span><br><span class="line">    <span class="comment">// 初始值设为0，然后每隔10个时间单位翻转一次</span></span><br><span class="line">    <span class="keyword">initial</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            CLK1 = <span class="number">0</span>;          <span class="comment">// 初始时刻，时钟设为0</span></span><br><span class="line">            <span class="keyword">forever</span> #<span class="number">10</span> CLK1 = ~CLK1;  <span class="comment">// 每隔10个时间单位翻转一次，产生周期为20的时钟</span></span><br><span class="line">            <span class="comment">// 时钟频率计算：周期=20，频率=1/20=0.05时间单位^-1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个initial块：生成复位信号RESET，控制测试过程</span></span><br><span class="line">    <span class="keyword">initial</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 初始化复位信号为0（复位状态）</span></span><br><span class="line">            RESET = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保持复位状态100个时间单位，观察复位效果</span></span><br><span class="line">            #<span class="number">100</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 释放复位（设为1），让电路正常工作200个时间单位</span></span><br><span class="line">            RESET = <span class="number">1</span>;</span><br><span class="line">            #<span class="number">200</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次复位100个时间单位，测试复位功能的重复性</span></span><br><span class="line">            RESET = <span class="number">0</span>;</span><br><span class="line">            #<span class="number">100</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次释放复位200个时间单位，继续观察正常分频</span></span><br><span class="line">            RESET = <span class="number">1</span>;</span><br><span class="line">            #<span class="number">200</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结束仿真</span></span><br><span class="line">            <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：测试模块中两个initial块并行执行</span></span><br><span class="line">    <span class="comment">// CLK1始终以20个时间单位为周期运行，直到$finish</span></span><br><span class="line">    <span class="comment">// RESET按照指定时间序列变化，测试不同工作状态</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog HDL设计实现函数表达式<span
class="math inline">\(out=AB+BC+AC\)</span></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">logic</span>(A, B, C, out);</span><br><span class="line">    <span class="keyword">input</span>  A, B, C;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">assign</span> out=(A&amp;B)|(B&amp;C)|(A&amp;C);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog
HDL设计实现一个4-2二进制编码器.当输入编码不是4中取1码时,编码输出全为0.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> encoder_4to2(in, out);</span><br><span class="line">    <span class="keyword">input</span>      [<span class="number">3</span>:<span class="number">0</span>] in;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(in) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (in == <span class="number">4&#x27;b0001</span>) out = <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in == <span class="number">4&#x27;b0010</span>) out = <span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in == <span class="number">4&#x27;b0100</span>) out = <span class="number">2&#x27;b10</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (in == <span class="number">4&#x27;b1000</span>) out = <span class="number">2&#x27;b11</span>;</span><br><span class="line">            <span class="keyword">else</span>                    out = <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog HDL内置的基本门级元件, 描述如下电路, 要求:
输入为<code>in1, in2, in3</code>, 两个<code>wire wire1, wire2</code>,
一个输出<code>out</code>, 满足关系:</p>
<p><span class="math display">\[\begin{aligned}
     &amp;\rm{wire1}=\rm{in1in2}\\
     &amp;\rm{wire2}=\rm{wire1in3}\\
     &amp;\rm{out}=\rm{wire2}\oplus \rm{in1}\\
\end{aligned}\]</span></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> circuit3(in1, in2, in3, out);</span><br><span class="line">    <span class="keyword">input</span>  in1, in2, in3;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span>   wire1, wire2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">and</span> (wire1, in1, in2);</span><br><span class="line">    <span class="keyword">and</span> (wire2, wire1, in3);</span><br><span class="line">    <span class="keyword">xor</span> (out, wire2, in1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/WPS%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/WPS%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">WPS软件入门教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-24 00:34:27" itemprop="dateModified" datetime="2025-12-24T00:34:27+08:00">2025-12-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">常用软件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="wps-word">WPS Word</h2>
<h3 id="论文排版技巧">论文排版技巧</h3>
<h4 id="样式设置">样式设置</h4>
<p>开始-&gt;样式一栏-&gt;标题1(一级标题,
大标题)/标题2(二级标题)/标题3(三级标题)/标题4(四级标题)/正文,
右键打开设置, 然后点击左下角的”格式(O)“按键进行详细设置. 另外,
还可以自己创建一个样式.</p>
<p>在应用这些样式时, 只需要选中想要修改的文字,
然后点击样式一栏中我们设置好的样式,
就可以把选中的文字变成目标样式了.</p>
<h4 id="多级列表">多级列表</h4>
<p>开始-&gt;段落一栏-&gt;有一个123的按钮,
点击它-&gt;自定义编号-&gt;多级编号-&gt;自定义-&gt;高级-&gt;将级别链接到样式,
比如第一级链接到标题1, 第二级链接到标题2等等.</p>
<h4 id="题注和引用">题注和引用</h4>
<p>当我们插入图片时, 会因为行间距导致正文把图片挡住了,
这时我们只需要点击图片, 然后在段落一栏中把行间距改成1.0即可.
然后我们给图片进行标号, 在图片下方另起一行, 然后点击 引用-&gt;题注,
标签选择”图”, 位置就是所选项目下方, 编号中可以自己设置.
对于表格同理.</p>
<p>在正文中, 也可以对这些图表进行交叉引用, 点击
引用-&gt;题注一栏-&gt;交叉引用, 在引用类型中选择图或者表,
引用内容一般选择”只有标签和编号”, 在”引用哪一个题注”的框中,
可以看到之前编好号的一些图和表, 点击即可.</p>
<p>在开始-&gt;样式一栏中可以设置题注的样式.</p>
<p>如果我们删除了一张图片,
那么可以按住<code>Ctrl+C</code>然后按<code>F9</code>就可以对所有内容更新编号了.</p>
<h4 id="插入参考文献">插入参考文献</h4>
<h4 id="生成目录">生成目录</h4>
<p>点击引用-&gt;目录, 就可以自行设置目录了. 在修改后,
点击更新目录即可.</p>
<h4 id="设置页码">设置页码</h4>
<p>把光标放到要分开的页数的前面, 在插入-&gt;页一栏-&gt;分页.</p>
<p>如果想要在一篇文章里面使用多个从1开始的页码, 那么在从1开始的那一页,
选中页码, 点击重新编号选项, 即可进行设置.</p>
<h4 id="图片的插入">图片的插入</h4>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-09 14:40:47" itemprop="dateModified" datetime="2025-05-09T14:40:47+08:00">2025-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/math/" itemprop="url" rel="index"><span itemprop="name">math</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF%E7%89%88%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%B7%AF%E7%89%88%E5%9B%BE/" class="post-title-link" itemprop="url">模拟电路版图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-04 00:33:08" itemprop="dateModified" datetime="2026-01-04T00:33:08+08:00">2026-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="集成电路版图设计详细复习笔记">集成电路版图设计详细复习笔记</h2>
<h3 id="第一章版图设计基础与概念">第一章：版图设计基础与概念</h3>
<h4 id="版图的本质与重要性">1.1 版图的本质与重要性</h4>
<h5 id="版图的定义解析">1.1.1 版图的定义解析</h5>
<p><strong>版图（Layout）</strong>
是集成电路设计的物理实现，它是将电路逻辑描述转化为可以在硅片上制造的几何图形的过程。具体来说：</p>
<ul>
<li><strong>几何层面</strong>：由不同工艺层（Layer）组成的二维图形集合</li>
<li><strong>电气层面</strong>：实现电路功能的导体、绝缘体和半导体区域</li>
<li><strong>物理层面</strong>：满足制造工艺约束的三维结构投影</li>
<li><strong>功能层面</strong>：确保电路性能、功耗和可靠性的空间布局</li>
</ul>
<h5 id="版图设计的核心目标">1.1.2 版图设计的核心目标</h5>
<ol type="1">
<li><strong>功能正确性</strong>：准确实现电路功能</li>
<li><strong>性能优化</strong>：满足速度、功耗等性能指标</li>
<li><strong>面积最小化</strong>：减少芯片成本</li>
<li><strong>可制造性</strong>：符合工艺约束，提高良率</li>
<li><strong>可靠性</strong>：确保长期稳定工作</li>
</ol>
<h5 id="版图与电路图的关系">1.1.3 版图与电路图的关系</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电路原理图（Schematic） → 物理版图（Layout） → 制造掩模（Mask） → 硅片芯片（Chip）</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>正向设计</strong>：电路图 → 版图（设计实现）</li>
<li><strong>反向验证</strong>：版图 → 电路图（一致性检查）</li>
</ul>
<h4 id="版图设计的层次结构">1.2 版图设计的层次结构</h4>
<h5 id="物理层次">1.2.1 物理层次</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统级（System） → 模块级（Block） → 单元级（Cell） → 晶体管级（Transistor） → 几何级（Geometry）</span><br></pre></td></tr></table></figure>
<h5 id="设计抽象层次">1.2.2 设计抽象层次</h5>
<table>
<thead>
<tr>
<th>层次</th>
<th>描述</th>
<th>关注点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>架构级</strong></td>
<td>功能模块划分</td>
<td>数据流、控制流</td>
</tr>
<tr>
<td><strong>逻辑级</strong></td>
<td>门电路连接</td>
<td>逻辑功能、时序</td>
</tr>
<tr>
<td><strong>电路级</strong></td>
<td>晶体管连接</td>
<td>电气特性、功耗</td>
</tr>
<tr>
<td><strong>版图级</strong></td>
<td>几何图形</td>
<td>物理实现、制造约束</td>
</tr>
</tbody>
</table>
<h3
id="第二章cmos工艺与版图制造流程">第二章：CMOS工艺与版图制造流程</h3>
<h4 id="cmos工艺基础">2.1 CMOS工艺基础</h4>
<h5 id="基本材料与结构">2.1.1 基本材料与结构</h5>
<p><strong>衬底类型</strong>：</p>
<ul>
<li><strong>P型衬底</strong>：掺杂硼（B），多数载流子为空穴</li>
<li><strong>N型衬底</strong>：掺杂磷（P）或砷（As），多数载流子为电子</li>
</ul>
<p><strong>典型工艺组合</strong>：</p>
<ul>
<li><strong>N阱CMOS</strong>：P型衬底，制作N阱容纳PMOS</li>
<li><strong>P阱CMOS</strong>：N型衬底，制作P阱容纳NMOS</li>
<li><strong>双阱CMOS</strong>：轻掺杂衬底，同时制作N阱和P阱</li>
</ul>
<h4 id="关键工艺层详解">2.1.2 关键工艺层详解</h4>
<h5 id="阱区well">1. 阱区（Well）</h5>
<p><strong>N阱形成过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 氧化层生长（SiO₂，约50nm）</span><br><span class="line">2. 光刻胶涂覆（PR，约1μm）</span><br><span class="line">3. N阱掩模曝光</span><br><span class="line">4. 显影去除曝光区域PR</span><br><span class="line">5. 磷（P）或砷（As）离子注入</span><br><span class="line">   能量：80-200 keV</span><br><span class="line">   剂量：1×10¹² - 1×10¹³ cm⁻²</span><br><span class="line">6. 高温退火（900-1100°C，30-60分钟）</span><br><span class="line">7. 杂质扩散形成N阱</span><br></pre></td></tr></table></figure>
<p><strong>设计要点</strong>：</p>
<ul>
<li>阱深：2-5μm</li>
<li>表面浓度：10¹⁶ - 10¹⁷ cm⁻³</li>
<li>阱间距：防止穿通和闩锁效应</li>
</ul>
<h5 id="有源区active-area-aa">2. 有源区（Active Area, AA）</h5>
<p><strong>LOCOS（局部氧化）工艺</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 衬底清洗</span><br><span class="line">2. 垫氧生长（Pad Oxide，20-30nm）</span><br><span class="line">3. 氮化硅沉积（Si₃N₄，100-200nm）</span><br><span class="line">4. 有源区光刻</span><br><span class="line">5. 氮化硅刻蚀</span><br><span class="line">6. 场氧生长（FOX，400-600nm）</span><br><span class="line">7. 氮化硅去除</span><br></pre></td></tr></table></figure>
<p><strong>STI（浅槽隔离）工艺</strong>（先进工艺使用）：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 沟槽刻蚀（0.3-0.5μm深）</span><br><span class="line">2. 氧化层生长（衬底保护）</span><br><span class="line">3. CVD氧化硅填充</span><br><span class="line">4. CMP平整化</span><br></pre></td></tr></table></figure></p>
<h5 id="栅极gate">3. 栅极（Gate）</h5>
<p><strong>栅氧生长</strong>： - 厚度（tₒₓ）：根据工艺节点决定 -
0.35μm：7-9nm - 0.18μm：3-4nm - 90nm：1.5-2nm -
28nm：1.2nm（高k介质）</p>
<p><strong>多晶硅栅形成</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 多晶硅沉积（200-300nm）</span><br><span class="line">2. 掺杂（N⁺或P⁺）</span><br><span class="line">3. 栅极光刻</span><br><span class="line">4. 干法刻蚀（RIE）</span><br><span class="line">5. 侧墙形成（Spacer）</span><br></pre></td></tr></table></figure></p>
<h5 id="源漏区sourcedrain">4. 源漏区（Source/Drain）</h5>
<p><strong>N⁺注入</strong>： - 杂质：磷（P）或砷（As） - 能量：30-80 keV
- 剂量：5×10¹⁴ - 5×10¹⁵ cm⁻² - 结深：0.1-0.3μm</p>
<p><strong>P⁺注入</strong>： - 杂质：硼（B） - 能量：10-30 keV -
剂量：5×10¹⁴ - 5×10¹⁵ cm⁻² - 结深：0.15-0.25μm</p>
<h5 id="接触与互连">5. 接触与互连</h5>
<p><strong>接触孔（Contact）</strong>： -
尺寸：最小特征尺寸×最小特征尺寸 - 材料：钨（W） - 工艺：CVD填充 +
CMP</p>
<p><strong>金属层</strong>： | 金属层 | 典型材料 | 厚度 | 用途 |
|——–|———-|——|——| | M1 | Al或Cu | 0.5-0.8μm | 器件级互连 | | M2-M4 |
Al或Cu | 0.6-1.0μm | 模块内互连 | | M5以上 | Al或Cu | 1.0-3.0μm |
全局互连，电源 |</p>
<p><strong>通孔（Via）</strong>： - 连接相邻金属层 -
尺寸通常与接触孔相同 - 材料：钨或铜</p>
<h3 id="完整cmos制造流程以0.18μm-n阱工艺为例">2.2
完整CMOS制造流程（以0.18μm N阱工艺为例）</h3>
<h4 id="步骤1起始材料准备">步骤1：起始材料准备</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[P型硅片] --&gt; B[清洗]</span><br><span class="line">    B --&gt; C[热氧化]</span><br><span class="line">    C --&gt; D[生长100nm SiO₂]</span><br><span class="line">    D --&gt; E[N阱光刻]</span><br></pre></td></tr></table></figure>
<h4 id="步骤2n阱形成">步骤2：N阱形成</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. N阱光刻（掩模#1）</span><br><span class="line">2. 磷注入：能量150keV，剂量2×10¹² cm⁻²</span><br><span class="line">3. 硼注入：能量50keV，剂量1×10¹² cm⁻²（调整Vth）</span><br><span class="line">4. 退火：1050°C，60分钟</span><br><span class="line">5. N阱深度：2.5μm</span><br><span class="line">6. N阱表面浓度：2×10¹⁶ cm⁻³</span><br></pre></td></tr></table></figure>
<h4 id="步骤3有源区定义">步骤3：有源区定义</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 垫氧生长：20nm SiO₂</span><br><span class="line">2. 氮化硅沉积：150nm Si₃N₄</span><br><span class="line">3. 有源区光刻（掩模#2）</span><br><span class="line">4. 氮化硅刻蚀</span><br><span class="line">5. 场注入：防止场区反型</span><br><span class="line">6. 场氧生长：500nm</span><br><span class="line">7. 氮化硅去除</span><br></pre></td></tr></table></figure>
<h4 id="步骤4栅极形成">步骤4：栅极形成</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 栅氧生长：4nm SiO₂</span><br><span class="line">2. 多晶硅沉积：200nm</span><br><span class="line">3. N⁺多晶硅掺杂（磷注入）</span><br><span class="line">4. 栅极光刻（掩模#3）</span><br><span class="line">5. 多晶硅刻蚀</span><br><span class="line">6. 侧墙形成：80nm SiO₂</span><br></pre></td></tr></table></figure>
<h4 id="步骤5源漏注入">步骤5：源漏注入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. PMOS光刻（掩模#4）</span><br><span class="line">2. P⁺注入：硼，能量10keV，剂量4×10¹⁵ cm⁻²</span><br><span class="line">3. NMOS光刻（掩模#5）</span><br><span class="line">4. N⁺注入：砷，能量50keV，剂量3×10¹⁵ cm⁻²</span><br><span class="line">5. 快速退火：1050°C，10秒</span><br></pre></td></tr></table></figure>
<h4 id="步骤6接触孔制作">步骤6：接触孔制作</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. BPSG沉积：600nm</span><br><span class="line">2. CMP平整化</span><br><span class="line">3. 接触孔光刻（掩模#6）</span><br><span class="line">4. 接触孔刻蚀</span><br><span class="line">5. 钨CVD填充</span><br><span class="line">6. 钨CMP</span><br></pre></td></tr></table></figure>
<h4 id="步骤7金属互连">步骤7：金属互连</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Ti/TiN衬垫层沉积</span><br><span class="line">2. Al-Cu合金沉积：500nm</span><br><span class="line">3. 金属1光刻（掩模#7）</span><br><span class="line">4. 金属1刻蚀</span><br><span class="line">5. IMD1沉积：SiO₂，800nm</span><br><span class="line">6. 通孔1光刻（掩模#8）</span><br><span class="line">7. 重复步骤形成多层金属</span><br></pre></td></tr></table></figure>
<h4 id="步骤8钝化与压焊点">步骤8：钝化与压焊点</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 钝化层沉积：Si₃N₄/SiO₂，1μm</span><br><span class="line">2. 压焊点光刻（掩模#9）</span><br><span class="line">3. 钝化层刻蚀</span><br><span class="line">4. 铝再分布层沉积</span><br><span class="line">5. 压焊点光刻（掩模#10）</span><br></pre></td></tr></table></figure>
<h2 id="第三章版图设计要素详解">第三章：版图设计要素详解</h2>
<h3 id="晶体管版图设计">3.1 晶体管版图设计</h3>
<h4 id="mos晶体管结构参数">3.1.1 MOS晶体管结构参数</h4>
<p><strong>基本参数定义</strong>： -
<strong>沟道长度（L）</strong>：栅极下源漏间距 -
<strong>沟道宽度（W）</strong>：垂直于沟道方向的栅宽 -
<strong>宽长比（W/L）</strong>：决定晶体管驱动能力</p>
<p><strong>实际尺寸计算</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">绘制长度（Drawn Length, Ldrawn） = 版图标注的栅长</span><br><span class="line">实际长度（Effective Length, Leff） = Ldrawn - 2ΔL</span><br><span class="line">其中ΔL为横向扩散量，通常0.05-0.15μm</span><br></pre></td></tr></table></figure></p>
<h4 id="nmos版图设计要点">3.1.2 NMOS版图设计要点</h4>
<p><strong>标准NMOS版图层次</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Layer Stack:</span><br><span class="line">Top: M1（源漏连接）</span><br><span class="line">     ↓</span><br><span class="line">    CONT（接触孔）</span><br><span class="line">     ↓</span><br><span class="line">    N+（源漏注入区）</span><br><span class="line">     ↓</span><br><span class="line">    AA（有源区）</span><br><span class="line">     ↓</span><br><span class="line">    P-Substrate（衬底）</span><br><span class="line">Side: POLY（栅极）穿过AA</span><br></pre></td></tr></table></figure></p>
<p><strong>关键尺寸计算</strong>： 1. <strong>栅长L</strong> = POLY宽度
2. <strong>栅宽W</strong> = AA内POLY覆盖的长度 3.
<strong>源漏区尺寸</strong> = AA宽度 × （POLY到AA边缘距离） 4.
<strong>接触孔数量</strong> = ceil(W / 最大接触孔间距)</p>
<p><strong>设计规则检查项</strong>： - 栅长 ≥ 最小栅长（Lmin） -
栅到源漏接触孔间距 ≥ 最小间距 - 源漏区对栅的延伸 ≥ 最小延伸 -
阱对NMOS的包围 ≥ 最小包围</p>
<h4 id="pmos版图设计要点">3.1.3 PMOS版图设计要点</h4>
<p><strong>PMOS特有考虑</strong>： 1. <strong>N阱要求</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阱宽 ≥ 有源区宽度 + 2 × 阱包围</span><br><span class="line">阱深 ≈ 2-3μm（需考虑横向扩散）</span><br></pre></td></tr></table></figure> 2. <strong>阱接触（Well Tap）</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个PMOS附近必须有阱接触</span><br><span class="line">阱接触间距 ≤ 最大允许距离（通常50-100μm）</span><br><span class="line">阱接触结构：N+注入 + 接触孔 + M1连接到VDD</span><br></pre></td></tr></table></figure></p>
<h4 id="晶体管匹配设计">3.1.4 晶体管匹配设计</h4>
<p><strong>匹配性影响因素</strong>： 1.
<strong>工艺梯度</strong>：掺杂浓度、氧化层厚度、线宽等随位置变化 2.
<strong>应力效应</strong>：浅槽隔离（STI）引起的机械应力 3.
<strong>温度梯度</strong>：功耗不均匀导致温度分布差异 4.
<strong>周边环境</strong>：相邻图形引起的蚀刻负载效应</p>
<p><strong>共质心（Common Centroid）布局</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2×2阵列示例：</span><br><span class="line">┌─────┬─────┐</span><br><span class="line">│ M1A │ M2B │</span><br><span class="line">├─────┼─────┤</span><br><span class="line">│ M2B │ M1A │</span><br><span class="line">└─────┴─────┘</span><br><span class="line">特点：质心重合，抵消一阶梯度效应</span><br></pre></td></tr></table></figure></p>
<p><strong>叉指（Interdigitated）结构</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：4指NMOS</span><br><span class="line">┌─┬─┬─┬─┐</span><br><span class="line">│S│D│S│D│  ← 栅极（POLY）</span><br><span class="line">├─┼─┼─┼─┤</span><br><span class="line">│D│S│D│S│</span><br><span class="line">└─┴─┴─┴─┘</span><br><span class="line">优点：减小栅电阻，改善匹配</span><br></pre></td></tr></table></figure></p>
<p><strong>虚拟器件（Dummy Device）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">布局示例：</span><br><span class="line">┌─┬─┬─┬─┬─┐</span><br><span class="line">│D│M1│M2│M3│D│ ← 有源器件 + 虚拟器件</span><br><span class="line">└─┴─┴─┴─┴─┘</span><br><span class="line">作用：保证边缘器件与内部器件环境一致</span><br><span class="line">规则：虚拟器件与真实器件尺寸相同但栅极单独连接</span><br></pre></td></tr></table></figure></p>
<h3 id="电阻版图设计">3.2 电阻版图设计</h3>
<h4 id="电阻类型与特性">3.2.1 电阻类型与特性</h4>
<p><strong>扩散电阻</strong>： | 类型 | 方块电阻 | 温度系数 | 电压系数 |
匹配精度 | |——|———-|———-|———-|———-| | N+扩散 | 50-100 Ω/□ | 1500 ppm/°C
| 200 ppm/V | 10-20% | | P+扩散 | 100-200 Ω/□ | 1500 ppm/°C | 200 ppm/V
| 10-20% | | N阱 | 1000-2000 Ω/□ | 5000 ppm/°C | 10000 ppm/V | 20-30%
|</p>
<p><strong>多晶硅电阻</strong>： | 类型 | 方块电阻 | 温度系数 | 匹配精度
| 特点 | |——|———-|———-|———-|——| | 重掺杂 | 5-20 Ω/□ | 1000 ppm/°C | 1-2%
| 低阻值，线性度好 | | 轻掺杂 | 500-1000 Ω/□ | 1500 ppm/°C | 0.5-1% |
中等精度 | | 高阻值 | 2-10 kΩ/□ | 3000 ppm/°C | 2-5% |
高阻值，温度系数大 |</p>
<h4 id="电阻设计计算公式">3.2.2 电阻设计计算公式</h4>
<p><strong>基本公式</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R = R₀ × (L/W) × (1 + TC1 × ΔT + TC2 × ΔT²) × (1 + VC × V)</span><br><span class="line">其中：</span><br><span class="line">R₀：方块电阻值（Ω/□）</span><br><span class="line">L：电阻长度（μm）</span><br><span class="line">W：电阻宽度（μm）</span><br><span class="line">TC1、TC2：温度系数（ppm/°C）</span><br><span class="line">VC：电压系数（ppm/V）</span><br><span class="line">ΔT：温度变化（°C）</span><br><span class="line">V：施加电压（V）</span><br></pre></td></tr></table></figure></p>
<p><strong>端头电阻修正</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实际电阻值 R_total = R_body + 2 × R_end</span><br><span class="line">R_body = R₀ × (L - 2 × ΔL) / W</span><br><span class="line">R_end：端头电阻，通常0.5-2 Ω（与接触有关）</span><br><span class="line">ΔL：端头修正量，通常0.1-0.3μm</span><br></pre></td></tr></table></figure></p>
<h4 id="高精度电阻设计技巧">3.2.3 高精度电阻设计技巧</h4>
<p><strong>匹配设计原则</strong>： 1. <strong>单位电阻法</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设计单位电阻 R_unit = R₀ × (L_unit/W_unit)</span><br><span class="line">目标电阻 R_target = N × R_unit（串联）</span><br><span class="line">             = R_unit / M（并联）</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>相同方向</strong>：所有电阻条沿同一方向布局</p></li>
<li><p><strong>相同环境</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">置于相同的阱中</span><br><span class="line">周围添加虚拟电阻</span><br><span class="line">远离功率器件和时钟线</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>温度梯度考虑</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沿等温线排列</span><br><span class="line">对称布局抵消梯度影响</span><br><span class="line">避免靠近发热源</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>蛇形（Serpentine）电阻布局</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：4段蛇形电阻</span><br><span class="line">┌─┐   ┌─┐</span><br><span class="line">│ │   │ │</span><br><span class="line">└─┘ │ └─┘</span><br><span class="line">    │</span><br><span class="line">┌─┐ │ ┌─┐</span><br><span class="line">│ │   │ │</span><br><span class="line">└─┘   └─┘</span><br><span class="line">优点：节省面积</span><br><span class="line">注意：转角处电场集中，需要特殊设计</span><br></pre></td></tr></table></figure></p>
<h3 id="电容版图设计">3.3 电容版图设计</h3>
<h4 id="电容类型比较">3.3.1 电容类型比较</h4>
<p><strong>MOS电容</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结构：多晶硅 - 栅氧 - 衬底</span><br><span class="line">电容密度：Cox = εₒₓ / tₒₓ</span><br><span class="line">  0.18μm：~8 fF/μm²</span><br><span class="line">  0.13μm：~12 fF/μm²</span><br><span class="line">  90nm：~15 fF/μm²</span><br><span class="line">优点：工艺兼容，无需额外步骤</span><br><span class="line">缺点：电压非线性，需要偏置</span><br></pre></td></tr></table></figure></p>
<p><strong>MIM（金属-绝缘层-金属）电容</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构：底层金属 - 高k介质 - 顶层金属</span><br><span class="line">电容密度：0.5-5 fF/μm²（取决于介质）</span><br><span class="line">介质材料：Si₃N₄、SiO₂、高k材料</span><br><span class="line">优点：高线性度，低电压系数</span><br><span class="line">缺点：需要额外工艺步骤</span><br></pre></td></tr></table></figure></p>
<p><strong>MOS变容二极管</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构：栅极作为一端，源漏短接作为另一端</span><br><span class="line">特点：电容值随电压变化</span><br><span class="line">应用：VCO调谐、滤波器</span><br></pre></td></tr></table></figure></p>
<h4 id="电容设计要点">3.3.2 电容设计要点</h4>
<p><strong>匹配性设计</strong>： 1. <strong>单位电容法</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设计单位电容 C_unit</span><br><span class="line">目标电容 C_target = N × C_unit</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>共质心布局</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重要电容对采用共质心结构</span><br><span class="line">如差分电路的输入电容对</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>周边环境一致</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加虚拟电容</span><br><span class="line">相同金属填充密度</span><br><span class="line">相同距离到衬底接触</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>寄生效应考虑</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总电容 C_total = C_main + C_para</span><br><span class="line">C_para包括：</span><br><span class="line">- 底板寄生电容（20-30%）</span><br><span class="line">- 侧壁寄生电容</span><br><span class="line">- 连线寄生电容</span><br></pre></td></tr></table></figure></p>
<p><strong>连线对称性</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">差分电容对：</span><br><span class="line">┌─────────┬─────────┐</span><br><span class="line">│  C1+    │  C2+    │</span><br><span class="line">│   │     │   │     │</span><br><span class="line">│   V     │   V     │</span><br><span class="line">│ 同长度同宽度连线   │</span><br><span class="line">└─────────┴─────────┘</span><br></pre></td></tr></table></figure></p>
<h3 id="互连设计">3.4 互连设计</h3>
<h4 id="金属连线设计规则">3.4.1 金属连线设计规则</h4>
<p><strong>电流承载能力</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最大电流密度 J_max：</span><br><span class="line">Al：0.5-1.0 mA/μm²（DC）</span><br><span class="line">Cu：1.0-2.0 mA/μm²（DC）</span><br><span class="line">高频时需考虑趋肤效应</span><br></pre></td></tr></table></figure></p>
<p><strong>线宽计算</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所需最小线宽 W_min = I_max / (J_max × t_metal)</span><br><span class="line">其中：</span><br><span class="line">I_max：最大电流（mA）</span><br><span class="line">J_max：最大电流密度（mA/μm²）</span><br><span class="line">t_metal：金属厚度（μm）</span><br></pre></td></tr></table></figure></p>
<p><strong>电阻计算</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">金属线电阻 R = ρ × L / (W × t)</span><br><span class="line">其中：</span><br><span class="line">ρ：电阻率（Al: 2.7 μΩ·cm, Cu: 1.7 μΩ·cm）</span><br><span class="line">L：线长（μm）</span><br><span class="line">W：线宽（μm）</span><br><span class="line">t：厚度（μm）</span><br></pre></td></tr></table></figure></p>
<h4 id="通孔与接触孔设计">3.4.2 通孔与接触孔设计</h4>
<p><strong>接触电阻</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单个接触孔电阻 R_contact = ρ_c / A</span><br><span class="line">其中：</span><br><span class="line">ρ_c：接触电阻率（Ω·cm²）</span><br><span class="line">  TiSi₂：~50 Ω·μm²</span><br><span class="line">  CoSi₂：~20 Ω·μm²</span><br><span class="line">  NiSi：~15 Ω·μm²</span><br><span class="line">A：接触孔面积（μm²）</span><br></pre></td></tr></table></figure></p>
<p><strong>通孔数量计算</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所需通孔数 N = ceil(I_max / (J_via × A_via))</span><br><span class="line">其中：</span><br><span class="line">J_via：通孔最大电流密度（~0.1 mA/μm²）</span><br><span class="line">A_via：单个通孔面积（μm²）</span><br></pre></td></tr></table></figure></p>
<p><strong>阵列排列</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：3×3接触孔阵列</span><br><span class="line">┌───┬───┬───┐</span><br><span class="line">│ ● │ ● │ ● │</span><br><span class="line">├───┼───┼───┤</span><br><span class="line">│ ● │ ● │ ● │</span><br><span class="line">├───┼───┼───┤</span><br><span class="line">│ ● │ ● │ ● │</span><br><span class="line">└───┴───┴───┘</span><br><span class="line">间距满足设计规则</span><br><span class="line">外围增加冗余孔提高可靠性</span><br></pre></td></tr></table></figure></p>
<h4 id="信号完整性考虑">3.4.3 信号完整性考虑</h4>
<p><strong>串扰（Crosstalk）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">耦合电容 C_c = ε × H × L / D</span><br><span class="line">其中：</span><br><span class="line">ε：介电常数</span><br><span class="line">H：平行线高度</span><br><span class="line">L：平行线长度</span><br><span class="line">D：线间距</span><br><span class="line">减小串扰方法：</span><br><span class="line">1. 增加线间距（最有效）</span><br><span class="line">2. 插入屏蔽线（GND或VDD）</span><br><span class="line">3. 使用差分信号</span><br><span class="line">4. 避免长距离平行走线</span><br></pre></td></tr></table></figure></p>
<p><strong>延迟计算</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RC延迟 τ = R × C</span><br><span class="line">分布RC线延迟 ≈ 0.5 × R_total × C_total</span><br><span class="line">其中：</span><br><span class="line">R_total = R_unit × L</span><br><span class="line">C_total = C_unit × L</span><br><span class="line">Elmore延迟：τ = Σ(R_i × C_downstream)</span><br></pre></td></tr></table></figure></p>
<p><strong>传输线效应</strong>（高频时需考虑）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特征阻抗 Z₀ = √(L_unit / C_unit)</span><br><span class="line">传播延迟 t_pd = √(L_unit × C_unit)</span><br><span class="line">临界频率 f_crit = 1 / (2 × π × t_pd × L)</span><br><span class="line">当频率 &gt; f_crit/10时需考虑传输线效应</span><br></pre></td></tr></table></figure></p>
<h2 id="第四章版图验证与可靠性">第四章：版图验证与可靠性</h2>
<h3 id="设计规则检查drc">4.1 设计规则检查（DRC）</h3>
<h4 id="drc规则分类详解">4.1.1 DRC规则分类详解</h4>
<p><strong>几何规则</strong>： 1. <strong>最小宽度（Width）</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：INT layer &lt; value</span><br><span class="line">示例：INT METAL1 &lt; 0.24</span><br><span class="line">意义：METAL1宽度不能小于0.24μm</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>最小间距（Space）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：EXT layer &lt; value</span><br><span class="line">示例：EXT METAL1 &lt; 0.28</span><br><span class="line">意义：METAL1间距不能小于0.28μm</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>最小延伸（Extension）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：ENCLOSE layer1 BY layer2 &lt; value OUTSIDE ONLY</span><br><span class="line">示例：ENCLOSE POLY BY AA &lt; 0.30 OUTSIDE ONLY</span><br><span class="line">意义：AA超出POLY部分不能小于0.30μm</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>最小包围（Enclosure）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：ENCLOSE layer1 BY layer2 &lt; value</span><br><span class="line">示例：ENCLOSE CONT BY METAL1 &lt; 0.10</span><br><span class="line">意义：METAL1包围CONT不能小于0.10μm</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>电气规则</strong>： 1. <strong>天线规则</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：ANTENNA layer RATIO &gt; value</span><br><span class="line">示例：ANTENNA METAL1 GATE RATIO &gt; 400</span><br><span class="line">意义：连接到栅极的METAL1面积与栅面积比不能超过400</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><strong>阱偏置规则</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：NWELL WITHOUT NTAP SPACE &gt; value</span><br><span class="line">示例：NWELL WITHOUT NTAP SPACE &gt; 50</span><br><span class="line">意义：没有阱接触的N阱最大尺寸不能超过50μm</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>可靠性规则</strong>： 1. <strong>电迁移规则</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：WIDTH layer FOR CURRENT &gt; value</span><br><span class="line">示例：WIDTH METAL1 FOR CURRENT 1mA &gt; 1.0</span><br><span class="line">意义：承载1mA电流需要METAL1宽度至少1.0μm</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><strong>密度规则</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查：DENSITY layer &lt; min OR &gt; max</span><br><span class="line">示例：DENSITY METAL1 &lt; 0.2 OR &gt; 0.8</span><br><span class="line">意义：METAL1密度必须在20%-80%之间</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="drc检查流程实例">4.1.2 DRC检查流程实例</h4>
<p><strong>示例：多晶硅栅设计规则检查</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 规则文件片段</span><br><span class="line">POLY &#123;</span><br><span class="line">    // 规则<span class="number">1</span>：最小栅长</span><br><span class="line">    W<span class="number">.1</span> &#123;</span><br><span class="line">        @ 最小栅长检查</span><br><span class="line">        INT POLY &lt; <span class="number">0.18</span> ABUT&lt;<span class="number">90</span> SINGULAR</span><br><span class="line">        MESSAGE <span class="string">&quot;POLY宽度小于0.18μm&quot;</span></span><br><span class="line">        SEVERITY ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 规则<span class="number">2</span>：栅间距</span><br><span class="line">    S<span class="number">.1</span> &#123;</span><br><span class="line">        @ 相同电位栅间距</span><br><span class="line">        EXT POLY &lt; <span class="number">0.24</span> ABUT&lt;<span class="number">90</span></span><br><span class="line">        MESSAGE <span class="string">&quot;POLY间距小于0.24μm&quot;</span></span><br><span class="line">        SEVERITY ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 规则<span class="number">3</span>：栅对有源区包围</span><br><span class="line">    E<span class="number">.1</span> &#123;</span><br><span class="line">        @ 栅对有源区的最小包围</span><br><span class="line">        ENCLOSE POLY BY AA &lt; <span class="number">0.15</span> OUTSIDE ONLY</span><br><span class="line">        MESSAGE <span class="string">&quot;AA对POLY包围不足0.15μm&quot;</span></span><br><span class="line">        SEVERITY ERROR</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 规则<span class="number">4</span>：栅端头到接触孔距离</span><br><span class="line">    S<span class="number">.2</span> &#123;</span><br><span class="line">        @ 栅端头到接触孔最小距离</span><br><span class="line">        POLY_NO_AA = POLY NOT INSIDE AA</span><br><span class="line">        SPACE POLY_NO_AA TO CONT &lt; <span class="number">0.25</span></span><br><span class="line">        MESSAGE <span class="string">&quot;栅端头到接触孔距离小于0.25μm&quot;</span></span><br><span class="line">        SEVERITY ERROR</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="版图与原理图对照lvs">4.2 版图与原理图对照（LVS）</h3>
<h4 id="lvs提取原理">4.2.1 LVS提取原理</h4>
<p><strong>器件识别算法</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 层次展开：将版图扁平化处理</span><br><span class="line">2. 层运算：通过布尔运算识别器件</span><br><span class="line">   NMOS识别：GT与AA交叉且被SN覆盖</span><br><span class="line">   PMOS识别：GT与AA交叉且被SP覆盖且在NW内</span><br><span class="line">3. 连接提取：通过CONNECT语句定义连接关系</span><br><span class="line">4. 参数计算：计算W、L、面积等参数</span><br><span class="line">5. 网表生成：生成SPICE格式网表</span><br></pre></td></tr></table></figure></p>
<p><strong>连接关系提取</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 连接定义示例</span><br><span class="line">CONNECT BY CONT &#123;</span><br><span class="line">    // CONT连接METAL1和AA/POLY</span><br><span class="line">    FROM METAL1</span><br><span class="line">    TO   AA</span><br><span class="line">    VIA  CONT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONNECT BY VIA1 &#123;</span><br><span class="line">    // VIA1连接METAL1和METAL2</span><br><span class="line">    FROM METAL1</span><br><span class="line">    TO   METAL2</span><br><span class="line">    VIA  VIA1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 短路连接定义</span><br><span class="line">CONNECT SHORT &#123;</span><br><span class="line">    // 同一金属层自动连接</span><br><span class="line">    METAL1 METAL1</span><br><span class="line">    POLY   POLY</span><br><span class="line">    AA     AA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="lvs比较算法">4.2.2 LVS比较算法</h4>
<p><strong>比较步骤</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 初始比较：器件数量和类型</span><br><span class="line">2. 网络比较：连接关系匹配</span><br><span class="line">3. 属性比较：器件参数匹配</span><br><span class="line">4. 递归比较：层次化设计逐层比较</span><br><span class="line">5. 等价性检查：识别电路等价但布局不同的结构</span><br></pre></td></tr></table></figure></p>
<p><strong>容差设置</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 参数容差定义</span><br><span class="line">TOLERANCE &#123;</span><br><span class="line">    // 器件参数容差</span><br><span class="line">    MOSFET &#123;</span><br><span class="line">        W   <span class="number">3</span>%    // 宽度容差<span class="number">3</span>%</span><br><span class="line">        L   <span class="number">3</span>%    // 长度容差<span class="number">3</span>%</span><br><span class="line">        M   <span class="number">0</span>     // 并联数必须精确匹配</span><br><span class="line">        NF  <span class="number">0</span>     // 指数必须精确匹配</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    RESISTOR &#123;</span><br><span class="line">        R   <span class="number">5</span>%    // 电阻值容差<span class="number">5</span>%</span><br><span class="line">        W   <span class="number">3</span>%    // 宽度容差<span class="number">3</span>%</span><br><span class="line">        L   <span class="number">3</span>%    // 长度容差<span class="number">3</span>%</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CAPACITOR &#123;</span><br><span class="line">        C   <span class="number">5</span>%    // 电容值容差<span class="number">5</span>%</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="lvs调试技巧">4.2.3 LVS调试技巧</h4>
<p><strong>常见不匹配原因及解决</strong>：</p>
<ol type="1">
<li><p><strong>器件数量不匹配</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可能原因：</span><br><span class="line">- 版图中器件识别错误</span><br><span class="line">- 原理图中器件重复或遗漏</span><br><span class="line">- 虚拟器件被错误识别</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">- 检查器件识别层定义</span><br><span class="line">- 确认虚拟器件正确标注</span><br><span class="line">- 使用LVS调试工具定位差异</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>参数不匹配</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">可能原因：</span><br><span class="line">- 版图尺寸与原理图参数不一致</span><br><span class="line">- 提取算法计算错误</span><br><span class="line">- 容差设置过小</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">- 检查版图关键尺寸</span><br><span class="line">- 验证提取计算公式</span><br><span class="line">- 调整容差设置</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>连接关系不匹配</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可能原因：</span><br><span class="line">- 版图连线错误</span><br><span class="line">- 原理图连线错误</span><br><span class="line">- 接触孔/通孔缺失</span><br><span class="line">- 悬空节点</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">- 使用LVS调试工具高亮差异网络</span><br><span class="line">- 检查连接关系定义</span><br><span class="line">- 验证电源/地网络</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="电气规则检查erc">4.3 电气规则检查（ERC）</h3>
<h4 id="erc检查内容">4.3.1 ERC检查内容</h4>
<p><strong>连接性检查</strong>： 1. <strong>悬空节点检查</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查所有网络是否有适当的连接</span><br><span class="line">允许悬空的节点：测试点、不用的输入等</span><br><span class="line">不允许悬空的节点：栅极、动态节点</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>短路检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查不应连接的节点是否意外短路</span><br><span class="line">特别是电源和地之间的短路</span><br><span class="line">不同电源域之间的短路</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>开路检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查应连接的节点是否开路</span><br><span class="line">多晶硅连线跨过有源区时的连续性</span><br><span class="line">金属线跨过通孔时的连续性</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>偏置检查</strong>： 1. <strong>阱偏置检查</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">检查所有阱是否都有偏置连接</span><br><span class="line">N阱必须连接到最高电位（通常VDD）</span><br><span class="line">P阱必须连接到最低电位（通常GND）</span><br><span class="line">阱接触间距是否符合要求</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>衬底偏置检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查衬底接触是否足够</span><br><span class="line">衬底接触间距要求（通常&lt;100μm）</span><br><span class="line">衬底接触电阻是否足够低</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>器件偏置检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">检查MOSFET的体端是否正确偏置</span><br><span class="line">检查二极管是否反偏</span><br><span class="line">检查电阻两端电压是否在安全范围</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="可靠性相关检查">4.3.2 可靠性相关检查</h4>
<p><strong>电迁移检查</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 电迁移规则定义</span><br><span class="line">EMCHECK &#123;</span><br><span class="line">    // 金属层电流密度限制</span><br><span class="line">    METAL1 &#123;</span><br><span class="line">        DC  <span class="number">0.5</span> mA/μm    // 直流电流密度</span><br><span class="line">        RMS <span class="number">1.0</span> mA/μm    // RMS电流密度</span><br><span class="line">        PEAK <span class="number">2.0</span> mA/μm   // 峰值电流密度</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    METAL2 &#123;</span><br><span class="line">        DC  <span class="number">0.8</span> mA/μm</span><br><span class="line">        RMS <span class="number">1.5</span> mA/μm</span><br><span class="line">        PEAK <span class="number">3.0</span> mA/μm</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 通孔电流限制</span><br><span class="line">    VIA1 &#123;</span><br><span class="line">        DC  <span class="number">0.2</span> mA/μm²</span><br><span class="line">        RMS <span class="number">0.4</span> mA/μm²</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电流密度计算</span><br><span class="line">CURRENT_DENSITY &#123;</span><br><span class="line">    METHOD  <span class="number">3</span>D    // 使用<span class="number">3</span>D场求解器</span><br><span class="line">    TEMP    <span class="number">125</span>   // 最高工作温度<span class="number">125</span>°C</span><br><span class="line">    LIFETIME <span class="number">10</span>   // 设计寿命<span class="number">10</span>年</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>天线效应检查</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 天线比率计算</span><br><span class="line">ANTENNA_RATIO &#123;</span><br><span class="line">    // 计算连接到栅极的导体面积与栅面积比</span><br><span class="line">    FOR LAYER METAL1 METAL2 METAL3 METAL4 POLY &#123;</span><br><span class="line">        RATIO <span class="number">500</span>   // 最大比率<span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 跳线规则</span><br><span class="line">    JUMPER &#123;</span><br><span class="line">        // 允许通过高层金属跳线</span><br><span class="line">        ALLOW METAL3 METAL4</span><br><span class="line">        // 跳线后重新计算比率</span><br><span class="line">        RECALCULATE YES</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 二极管保护</span><br><span class="line">    DIODE_PROTECTION &#123;</span><br><span class="line">        // 允许添加保护二极管</span><br><span class="line">        ALLOW YES</span><br><span class="line">        // 二极管最小面积</span><br><span class="line">        MIN_AREA <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="寄生参数提取pex">4.4 寄生参数提取（PEX）</h3>
<h4 id="寄生参数类型">4.4.1 寄生参数类型</h4>
<p><strong>寄生电阻</strong>： 1. <strong>扩散区电阻</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R_diff = R_sheet × (L/W) × F</span><br><span class="line">其中F为几何因子，考虑电流拥挤效应</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>接触电阻</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R_contact = ρ_c / (N × A)</span><br><span class="line">N：接触孔数量</span><br><span class="line">A：单个接触孔面积</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>金属线电阻</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R_metal = ρ × L / (W × t) × (1 + α × ΔT)</span><br><span class="line">α：温度系数（Al: 0.0043/°C, Cu: 0.0039/°C）</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>寄生电容</strong>： 1. <strong>平行板电容</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C_pp = ε × A / d</span><br><span class="line">A：重叠面积</span><br><span class="line">d：介质厚度</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>边缘电容</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C_fringe = ε × L × K</span><br><span class="line">K：边缘电容系数，与几何形状有关</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>耦合电容</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C_coupling = ε × L × H / D</span><br><span class="line">L：平行长度</span><br><span class="line">H：导线高度</span><br><span class="line">D：导线间距</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>寄生电感</strong>（高频时重要）： 1. <strong>自感</strong>：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L_self = (μ₀ × L / 2π) × [ln(2L/W) + 0.5]</span><br><span class="line">适用于直导线</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><strong>互感</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = (μ₀ × L / 2π) × [ln(L/D) + D/L - 1]</span><br><span class="line">D：导线间距</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="pex提取设置">4.4.2 PEX提取设置</h4>
<p><strong>提取选项</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 提取类型选择</span><br><span class="line">EXTRACTION &#123;</span><br><span class="line">    // 提取哪些寄生参数</span><br><span class="line">    RESISTANCE    YES   // 提取电阻</span><br><span class="line">    CAPACITANCE   YES   // 提取电容</span><br><span class="line">    INDUCTANCE    NO    // 不提取电感（除非RF设计）</span><br><span class="line">    </span><br><span class="line">    // 提取精度</span><br><span class="line">    ACCURACY      HIGH  // 高精度提取</span><br><span class="line">    // 可选：LOW, MEDIUM, HIGH</span><br><span class="line">    </span><br><span class="line">    // 三维效应</span><br><span class="line">    THREE_D       YES   // 考虑三维效应</span><br><span class="line">    </span><br><span class="line">    // 网络简化</span><br><span class="line">    REDUCE        YES   // 简化网络</span><br><span class="line">    // 合并小电阻/电容</span><br><span class="line">    RES_THRESHOLD <span class="number">1.0</span>   // 小于<span class="number">1</span>Ω的电阻合并</span><br><span class="line">    CAP_THRESHOLD <span class="number">0.1</span>   // 小于<span class="number">0.1</span>fF的电容合并</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 层定义</span><br><span class="line">LAYERS &#123;</span><br><span class="line">    // 定义哪些层参与提取</span><br><span class="line">    METAL1   YES</span><br><span class="line">    METAL2   YES</span><br><span class="line">    METAL3   YES</span><br><span class="line">    METAL4   YES</span><br><span class="line">    POLY     YES</span><br><span class="line">    DIFF     YES</span><br><span class="line">    CONT     YES</span><br><span class="line">    VIA1     YES</span><br><span class="line">    VIA2     YES</span><br><span class="line">    VIA3     YES</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 器件定义</span><br><span class="line">DEVICES &#123;</span><br><span class="line">    // 定义哪些器件需要提取寄生</span><br><span class="line">    MOSFET   YES</span><br><span class="line">    RESISTOR YES</span><br><span class="line">    CAPACITOR YES</span><br><span class="line">    DIODE    YES</span><br><span class="line">    BJT      YES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>输出格式</strong>： <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 输出网表格式</span><br><span class="line">OUTPUT &#123;</span><br><span class="line">    FORMAT SPECTRE   // 输出Spectre格式</span><br><span class="line">    // 可选：SPICE, HSPICE, ELDO</span><br><span class="line">    </span><br><span class="line">    // 网表类型</span><br><span class="line">    NETLIST_TYPE SPICE  // 标准SPICE网表</span><br><span class="line">    // 可选：DSPF（详细寄生格式）</span><br><span class="line">    </span><br><span class="line">    // 注释信息</span><br><span class="line">    COMMENTS    YES   // 包含注释</span><br><span class="line">    HEADER      YES   // 包含文件头</span><br><span class="line">    </span><br><span class="line">    // 单位</span><br><span class="line">    RES_UNIT    OHM   // 电阻单位：欧姆</span><br><span class="line">    CAP_UNIT    FF    // 电容单位：飞法</span><br><span class="line">    IND_UNIT    NH    // 电感单位：纳亨</span><br><span class="line">    LEN_UNIT    U     // 长度单位：微米</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后仿真验证流程">4.4.3 后仿真验证流程</h4>
<p><strong>后仿真步骤</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 前仿真（Pre-layout Simulation）</span><br><span class="line">   - 使用理想模型</span><br><span class="line">   - 验证电路功能</span><br><span class="line">   - 优化电路参数</span><br><span class="line"></span><br><span class="line">2. 版图设计</span><br><span class="line">   - 绘制物理版图</span><br><span class="line">   - DRC/LVS验证</span><br><span class="line"></span><br><span class="line">3. 寄生参数提取</span><br><span class="line">   - 运行PEX工具</span><br><span class="line">   - 生成带寄生参数的网表</span><br><span class="line"></span><br><span class="line">4. 后仿真（Post-layout Simulation）</span><br><span class="line">   - 加载寄生网表</span><br><span class="line">   - 重新仿真验证性能</span><br><span class="line"></span><br><span class="line">5. 结果比较与分析</span><br><span class="line">   - 比较前后仿真结果</span><br><span class="line">   - 分析寄生影响</span><br><span class="line">   - 必要时优化版图</span><br></pre></td></tr></table></figure></p>
<p><strong>关键性能指标变化</strong>： 1.
<strong>延迟增加</strong>：通常增加10-30% 2.
<strong>功耗增加</strong>：动态功耗可能增加5-15% 3.
<strong>带宽降低</strong>：高频特性恶化 4.
<strong>噪声裕度变化</strong>：可能减小 5.
<strong>稳定性变化</strong>：可能产生振荡</p>
<h2 id="第五章先进版图设计技术">第五章：先进版图设计技术</h2>
<h3 id="深亚微米效应与对策">5.1 深亚微米效应与对策</h3>
<h4 id="短沟道效应">5.1.1 短沟道效应</h4>
<p><strong>现象</strong>： 1. <strong>阈值电压下降</strong>（Vth
roll-off）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当L &lt; 临界长度时，Vth随L减小而下降</span><br><span class="line">原因：源漏耗尽区向沟道扩展</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>漏致势垒降低</strong>（DIBL）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vth随Vds增加而下降</span><br><span class="line">对数字电路：增加静态功耗</span><br><span class="line">对模拟电路：降低增益</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>速度饱和</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">载流子速度不再随电场线性增加</span><br><span class="line">影响电流公式：Ids ∝ (Vgs - Vth)而不是(Vgs - Vth)²</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p><strong>版图对策</strong>： 1.
<strong>增加栅长</strong>：对关键晶体管使用较大L 2.
<strong>口袋注入</strong>（Halo/Pocket Implant）：抑制短沟道效应 3.
<strong>轻掺杂漏</strong>（LDD）：减小电场峰值 4.
<strong>环形栅</strong>（Gate-around）：改善栅控能力</p>
<h4 id="窄宽度效应">5.1.2 窄宽度效应</h4>
<p><strong>现象</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当W变窄时，Vth增加</span><br><span class="line">原因：边缘电场使耗尽区扩展</span><br></pre></td></tr></table></figure></p>
<p><strong>版图对策</strong>： 1.
<strong>避免最小宽度</strong>：关键晶体管使用较大W 2.
<strong>增加宽度裕量</strong>：W = W_min + ΔW 3.
<strong>使用叉指结构</strong>：将宽晶体管拆分为多个窄指并联</p>
<h4 id="应力工程">5.1.3 应力工程</h4>
<p><strong>应力来源</strong>： 1.
<strong>浅槽隔离应力</strong>：STI引起的压缩应力 2.
<strong>接触孔应力</strong>：钨填充引起的应力 3.
<strong>金属化应力</strong>：金属与介质CTE不匹配 4.
<strong>封装应力</strong>：芯片与封装材料CTE不匹配</p>
<p><strong>应力影响</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">载流子迁移率变化：</span><br><span class="line">- 张应力：提高电子迁移率，降低空穴迁移率</span><br><span class="line">- 压应力：提高空穴迁移率，降低电子迁移率</span><br></pre></td></tr></table></figure></p>
<p><strong>版图对策</strong>： 1.
<strong>增加有源区到STI距离</strong>：减小STI应力影响 2.
<strong>对称布局</strong>：使应力分布对称 3.
<strong>应力隔离</strong>：添加应力缓冲层 4.
<strong>利用应力</strong>：有意引入应力提高性能</p>
<h3 id="低功耗设计技术">5.2 低功耗设计技术</h3>
<h4 id="电源门控power-gating">5.2.1 电源门控（Power Gating）</h4>
<p><strong>技术原理</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在休眠期间切断模块电源</span><br><span class="line">使用头开关（Header）或脚开关（Footer）</span><br></pre></td></tr></table></figure></p>
<p><strong>版图实现</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">电源开关设计要点：</span><br><span class="line">1. 尺寸：根据漏电流和唤醒时间折中</span><br><span class="line">2. 布局：靠近被控模块</span><br><span class="line">3. 网格：使用专用电源网格</span><br><span class="line">4. 隔离：添加隔离单元</span><br></pre></td></tr></table></figure></p>
<p><strong>版图示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">睡眠模式：</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│  电源开关       │ Header SW</span><br><span class="line">│  ┌──────┐      │</span><br><span class="line">│  │ PMOS │      │ 尺寸：W/L=100/0.18</span><br><span class="line">│  └──────┘      │ 数量：根据电流需求</span><br><span class="line">│      │         │</span><br><span class="line">└──────┼─────────┘</span><br><span class="line">       │ Virtual VDD</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│  逻辑模块       │</span><br><span class="line">│  ┌──────┐      │</span><br><span class="line">│  │ INV  │      │</span><br><span class="line">│  └──────┘      │</span><br><span class="line">│  ┌──────┐      │</span><br><span class="line">│  │ NAND │      │</span><br><span class="line">│  └──────┘      │</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure></p>
<h4 id="多阈值设计multi-vt">5.2.2 多阈值设计（Multi-Vt）</h4>
<p><strong>技术原理</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用不同阈值电压的晶体管</span><br><span class="line">高速路径：低Vt晶体管</span><br><span class="line">低功耗路径：高Vt晶体管</span><br></pre></td></tr></table></figure></p>
<p><strong>版图考虑</strong>： 1.
<strong>布局分离</strong>：不同Vt器件分开布局 2.
<strong>阱隔离</strong>：防止闩锁效应 3.
<strong>连接检查</strong>：确保正确偏置</p>
<h4 id="动态电压频率缩放dvfs">5.2.3 动态电压频率缩放（DVFS）</h4>
<p><strong>版图支持</strong>： 1.
<strong>多电源域</strong>：不同电压区域的物理隔离 2.
<strong>电平转换器</strong>：跨电压域接口设计 3.
<strong>电源管理单元</strong>：专用布局区域</p>
<h3 id="射频rf版图设计">5.3 射频（RF）版图设计</h3>
<h4 id="射频特性考虑">5.3.1 射频特性考虑</h4>
<p><strong>趋肤效应</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">高频电流集中在导体表面</span><br><span class="line">趋肤深度 δ = √(ρ / (π × f × μ))</span><br><span class="line">f=1GHz时，Cu的δ≈2.1μm</span><br><span class="line">对策：使用厚金属或铜线</span><br></pre></td></tr></table></figure></p>
<p><strong>邻近效应</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相邻导线电流分布相互影响</span><br><span class="line">增加交流电阻</span><br><span class="line">对策：增加线间距或使用差分线</span><br></pre></td></tr></table></figure></p>
<p><strong>介质损耗</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tanδ = ε&#x27;&#x27;/ε&#x27;</span><br><span class="line">低k介质减少损耗</span><br><span class="line">对策：使用低损耗介质材料</span><br></pre></td></tr></table></figure></p>
<h4 id="电感设计">5.3.2 电感设计</h4>
<p><strong>平面螺旋电感</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关键参数：</span><br><span class="line">1. 电感值：L ∝ N² × D_avg</span><br><span class="line">2. 品质因数：Q = ωL/R_s</span><br><span class="line">3. 自谐振频率：f_sr = 1/(2π√(LC_para))</span><br></pre></td></tr></table></figure></p>
<p><strong>版图优化</strong>： 1.
<strong>几何形状</strong>：方形、八角形、圆形 2.
<strong>金属宽度</strong>：权衡电阻和电容 3.
<strong>线间距</strong>：减小耦合电容 4.
<strong>衬底屏蔽</strong>：减小衬底损耗</p>
<p><strong>设计示例</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方形螺旋电感（2.5圈）：</span><br><span class="line">外尺寸：200μm × 200μm</span><br><span class="line">线宽：10μm</span><br><span class="line">线间距：2μm</span><br><span class="line">金属层：顶层厚金属</span><br><span class="line">衬底：高阻硅或屏蔽层</span><br><span class="line">估计电感值：~3nH @ 1GHz</span><br><span class="line">Q值：~10 @ 1GHz</span><br></pre></td></tr></table></figure></p>
<h4 id="传输线设计">5.3.3 传输线设计</h4>
<p><strong>微带线（Microstrip）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构：信号线在介质上，参考地在背面</span><br><span class="line">特性阻抗：Z₀ ≈ 87/√(ε_r+1.41) × ln(5.98h/(0.8w+t))</span><br><span class="line">其中：h介质厚度，w线宽，t线厚</span><br></pre></td></tr></table></figure></p>
<p><strong>共面波导（CPW）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构：信号线两侧有地线</span><br><span class="line">优点：易于并联元件连接</span><br><span class="line">特性阻抗由w/h和g/h决定</span><br></pre></td></tr></table></figure></p>
<p><strong>版图要点</strong>： 1.
<strong>阻抗控制</strong>：精确控制线宽和间距 2.
<strong>弯曲补偿</strong>：直角弯曲添加切角 3.
<strong>过渡设计</strong>：不同线型间平滑过渡 4.
<strong>端接匹配</strong>：添加匹配电阻或网络</p>
<h2 id="第六章实践案例与设计流程">第六章：实践案例与设计流程</h2>
<h3 id="运算放大器版图设计实例">6.1 运算放大器版图设计实例</h3>
<h4 id="电路结构与要求">6.1.1 电路结构与要求</h4>
<p><strong>两级运放电路</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一级：差分输入对（M1, M2）</span><br><span class="line">第二级：共源放大器（M6）</span><br><span class="line">偏置电路：M3, M4, M5, M7, M8</span><br><span class="line">补偿：Miller电容Cc</span><br></pre></td></tr></table></figure></p>
<p><strong>性能指标</strong>： - 增益：&gt;80dB - 带宽：&gt;10MHz -
相位裕度：&gt;60° - 电源电压：3.3V - 工艺：0.35μm CMOS</p>
<h4 id="版图规划">6.1.2 版图规划</h4>
<p><strong>布局规划</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">整体布局（宽高比~1.5）：</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│  差分输入对     │ 关键匹配区域</span><br><span class="line">│  M1 M2 M3 M4    │ 共质心布局</span><br><span class="line">├─────────────────┤</span><br><span class="line">│  第二级         │ 大尺寸晶体管</span><br><span class="line">│  M6  Cc         │ 靠近输出焊盘</span><br><span class="line">├─────────────────┤</span><br><span class="line">│  偏置电路       │ 紧凑布局</span><br><span class="line">│  M5 M7 M8       │ 远离输入</span><br><span class="line">├─────────────────┤</span><br><span class="line">│  电源线         │ 顶层厚金属</span><br><span class="line">│  VDD  GND       │ 低阻抗网格</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure></p>
<p><strong>匹配设计</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">差分输入对（M1, M2）：</span><br><span class="line">布局：2×2共质心</span><br><span class="line">┌───┬───┐</span><br><span class="line">│ M1 │ M2 │</span><br><span class="line">├───┼───┤</span><br><span class="line">│ M2 │ M1 │</span><br><span class="line">└───┴───┘</span><br><span class="line">尺寸：W=20μm, L=0.35μm</span><br><span class="line">环境：相同N阱，周围虚拟器件</span><br></pre></td></tr></table></figure></p>
<p><strong>电流镜匹配</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M3, M4, M5, M7, M8：</span><br><span class="line">布局：单位晶体管阵列</span><br><span class="line">取向：所有晶体管同方向</span><br><span class="line">连线：对称布线</span><br></pre></td></tr></table></figure></p>
<h4 id="详细实现步骤">6.1.3 详细实现步骤</h4>
<p><strong>步骤1：创建单元和引脚</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 创建新单元：opamp</span><br><span class="line">2. 添加引脚：VDD, GND, INP, INN, OUT</span><br><span class="line">3. 规划引脚位置</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤2：绘制晶体管</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 调用NMOS和PMOS PCELL</span><br><span class="line">2. 设置参数：</span><br><span class="line">   - 差分对：W=20μm, L=0.35μm</span><br><span class="line">   - 电流镜：W=10μm, L=0.35μm</span><br><span class="line">   - 输出级：W=100μm, L=0.35μm</span><br><span class="line">3. 按规划布局</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤3：匹配性设计</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 差分对：共质心布局</span><br><span class="line">2. 添加虚拟晶体管</span><br><span class="line">3. 相同环境：相同阱，相同STI距离</span><br><span class="line">4. 对称连线</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤4：连线设计</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 关键信号线：加宽，增加间距</span><br><span class="line">2. 电源线：使用厚金属，多通孔</span><br><span class="line">3. 对称布线：输入对对称走线</span><br><span class="line">4. 屏蔽：敏感信号线添加屏蔽</span><br></pre></td></tr></table></figure></p>
<p><strong>步骤5：电源网格</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 顶层金属：VDD和GND网格</span><br><span class="line">2. 通孔阵列：降低电阻</span><br><span class="line">3. 去耦电容：电源引脚附近</span><br></pre></td></tr></table></figure></p>
<h4 id="验证与优化">6.1.4 验证与优化</h4>
<p><strong>DRC检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行DRC，修正违规：</span><br><span class="line">1. 检查最小间距</span><br><span class="line">2. 检查阱接触</span><br><span class="line">3. 检查天线效应</span><br><span class="line">4. 检查密度规则</span><br></pre></td></tr></table></figure></p>
<p><strong>LVS检查</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 提取版图网表</span><br><span class="line">2. 与原理图比较</span><br><span class="line">3. 调试不匹配</span><br><span class="line">4. 验证参数一致性</span><br></pre></td></tr></table></figure></p>
<p><strong>寄生提取与后仿真</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 运行PEX提取寄生</span><br><span class="line">2. 后仿真验证性能</span><br><span class="line">3. 分析寄生影响</span><br><span class="line">4. 必要时优化版图</span><br></pre></td></tr></table></figure></p>
<p><strong>性能验证结果</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前仿真 vs 后仿真：</span><br><span class="line">增益：85dB → 82dB (-3.5%)</span><br><span class="line">带宽：12MHz → 10.5MHz (-12.5%)</span><br><span class="line">相位裕度：65° → 62° (-4.6%)</span><br><span class="line">功耗：1.2mW → 1.3mW (+8.3%)</span><br></pre></td></tr></table></figure></p>
<h3 id="版图设计检查清单">6.2 版图设计检查清单</h3>
<h4 id="设计前检查">6.2.1 设计前检查</h4>
<ul class="task-list">
<li><label><input type="checkbox" />工艺文件齐全（.tf, .drf, .drc,
.lvs）</label></li>
<li><label><input type="checkbox" />设计规则文档理解</label></li>
<li><label><input type="checkbox" />电路原理图验证完成</label></li>
<li><label><input type="checkbox" />性能指标明确</label></li>
<li><label><input type="checkbox" />面积预算确定</label></li>
</ul>
<h4 id="设计中检查">6.2.2 设计中检查</h4>
<ul class="task-list">
<li><label><input type="checkbox" />晶体管尺寸与原理图一致</label></li>
<li><label><input type="checkbox" />匹配器件采用共质心布局</label></li>
<li><label><input type="checkbox" />虚拟器件添加完整</label></li>
<li><label><input type="checkbox" />阱接触和衬底接触充足</label></li>
<li><label><input type="checkbox" />电源网格低阻抗</label></li>
<li><label><input type="checkbox" />关键信号线屏蔽</label></li>
<li><label><input type="checkbox" />天线效应避免措施</label></li>
<li><label><input type="checkbox" />密度规则符合要求</label></li>
</ul>
<h4 id="设计后检查">6.2.3 设计后检查</h4>
<ul class="task-list">
<li><label><input type="checkbox" />DRC完全通过</label></li>
<li><label><input type="checkbox" />LVS完全匹配</label></li>
<li><label><input type="checkbox" />ERC检查通过</label></li>
<li><label><input type="checkbox" />寄生提取完成</label></li>
<li><label><input type="checkbox" />后仿真性能达标</label></li>
<li><label><input type="checkbox" />交付文件齐全</label></li>
<li><label><input type="checkbox" />设计文档更新</label></li>
</ul>
<h3 id="常见问题解决方案">6.3 常见问题解决方案</h3>
<h4 id="问题lvs参数不匹配">问题：LVS参数不匹配</h4>
<p><strong>现象</strong>：W或L值超出容差 <strong>原因分析</strong>： 1.
版图尺寸测量错误 2. 提取算法不准确 3. 原理图参数错误</p>
<p><strong>解决步骤</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 检查版图关键尺寸</span><br><span class="line">   使用标尺工具测量实际尺寸</span><br><span class="line">   确认POLY宽度和AA内POLY长度</span><br><span class="line">2. 验证提取规则</span><br><span class="line">   检查LVS文件中的参数计算公式</span><br><span class="line">   确认层定义正确</span><br><span class="line">3. 比较原理图参数</span><br><span class="line">   确认原理图器件参数</span><br><span class="line">   检查单位是否一致</span><br><span class="line">4. 调整设计</span><br><span class="line">   修正版图尺寸或更新原理图</span><br><span class="line">   重新运行LVS验证</span><br></pre></td></tr></table></figure></p>
<h4 id="问题drc密度违规">问题：DRC密度违规</h4>
<p><strong>现象</strong>：金属密度超出范围（&lt;20%或&gt;80%）
<strong>原因</strong>：大面积空白区域或大块金属</p>
<p><strong>解决方案</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 添加虚拟金属（Dummy Metal）</span><br><span class="line">   在空白区域添加无关金属图形</span><br><span class="line">   密度：30-50%</span><br><span class="line">   尺寸：满足最小设计规则</span><br><span class="line">2. 金属开槽（Metal Slotting）</span><br><span class="line">   大块金属中开槽改善均匀性</span><br><span class="line">   槽宽：满足设计规则</span><br><span class="line">   槽间距：均匀分布</span><br><span class="line">3. 调整布局</span><br><span class="line">   重新分布金属填充</span><br><span class="line">   优化走线密度</span><br><span class="line">4. 重新运行DRC验证</span><br></pre></td></tr></table></figure></p>
<h2 id="第七章版图设计进阶话题">第七章：版图设计进阶话题</h2>
<h3 id="可制造性设计dfm">7.1 可制造性设计（DFM）</h3>
<h4 id="光刻增强技术">7.1.1 光刻增强技术</h4>
<p><strong>光学邻近效应校正（OPC）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现象：光刻过程中图形变形</span><br><span class="line">校正方法：</span><br><span class="line">1. 线端加粗（Line End Extension）</span><br><span class="line">2. 角部加衬（Corner Serif）</span><br><span class="line">3. 辅助图形（Sub-Resolution Assist Feature）</span><br></pre></td></tr></table></figure></p>
<p><strong>版图支持</strong>： 1.
<strong>避免最小尺寸</strong>：使用稍大尺寸提高工艺窗口 2.
<strong>规则化设计</strong>：相同方向和间距 3.
<strong>冗余设计</strong>：关键尺寸添加裕量</p>
<h4 id="化学机械抛光考虑">7.1.2 化学机械抛光考虑</h4>
<p><strong>密度梯度限制</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要求：相邻区域密度变化&lt;20%</span><br><span class="line">对策：</span><br><span class="line">1. 虚拟图形填充</span><br><span class="line">2. 金属槽设计</span><br><span class="line">3. 阶梯式密度变化</span><br></pre></td></tr></table></figure></p>
<p><strong>碟形效应（Dishing）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现象：大块金属区域过度抛光</span><br><span class="line">对策：</span><br><span class="line">1. 金属槽设计</span><br><span class="line">2. 虚拟金属图案</span><br><span class="line">3. 限制最大金属面积</span><br></pre></td></tr></table></figure></p>
<h3 id="先进封装版图考虑">7.2 先进封装版图考虑</h3>
<h4 id="焊盘设计">7.2.1 焊盘设计</h4>
<p><strong>焊盘类型</strong>： 1.
<strong>标准焊盘</strong>：外围焊盘，尺寸80μm×80μm 2.
<strong>阵列焊盘</strong>：全阵列分布，减小封装尺寸 3.
<strong>微凸点</strong>：尺寸20-50μm，用于2.5D/3D集成</p>
<p><strong>焊盘规则</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 尺寸：满足封装要求</span><br><span class="line">2. 间距：满足键合或倒装要求</span><br><span class="line">3. 金属层：顶层厚金属</span><br><span class="line">4. 钝化开口：精确对准</span><br><span class="line">5. 静电保护：集成ESD保护结构</span><br></pre></td></tr></table></figure></p>
<h4 id="再分布层rdl设计">7.2.2 再分布层（RDL）设计</h4>
<p><strong>功能</strong>：重新规划焊盘位置 <strong>设计要点</strong>：
1. <strong>线宽/间距</strong>：通常5-10μm/5-10μm 2.
<strong>金属厚度</strong>：2-5μm 3. <strong>介质厚度</strong>：5-10μm 4.
<strong>通孔尺寸</strong>：10-20μm</p>
<h3 id="混合信号版图隔离">7.3 混合信号版图隔离</h3>
<h4 id="衬底噪声隔离">7.3.1 衬底噪声隔离</h4>
<p><strong>噪声耦合路径</strong>： 1.
<strong>衬底耦合</strong>：通过公共衬底 2.
<strong>电源耦合</strong>：通过公共电源线 3.
<strong>电磁耦合</strong>：通过空间电磁场</p>
<p><strong>隔离技术</strong>： 1. <strong>保护环（Guard
Ring）</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型：单环、双环、三环</span><br><span class="line">结构：P+环、N+环、深N阱环</span><br><span class="line">接地：连接到干净地</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li><p><strong>深N阱隔离</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将敏感电路置于深N阱中</span><br><span class="line">与衬底隔离</span><br><span class="line">需要单独的阱接触</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>三重阱技术</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提供更好的隔离</span><br><span class="line">但增加工艺复杂度</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="电源隔离">7.3.2 电源隔离</h4>
<p><strong>技术方案</strong>： 1.
<strong>分离电源线</strong>：模拟和数字电源完全分开 2.
<strong>星型连接</strong>：在芯片外单点连接 3.
<strong>片上稳压器</strong>：为敏感电路提供干净电源 4.
<strong>电源隔离开关</strong>：动态切断噪声路径</p>
<h2 id="第八章总结与展望">第八章：总结与展望</h2>
<h3 id="版图设计发展趋势">8.1 版图设计发展趋势</h3>
<h4 id="工艺技术进步">8.1.1 工艺技术进步</h4>
<ul>
<li><strong>特征尺寸缩小</strong>：向3nm及以下发展</li>
<li><strong>三维集成</strong>：FinFET、GAA、3D IC</li>
<li><strong>新材料</strong>：高k介质、金属栅、III-V族材料</li>
<li><strong>先进封装</strong>：2.5D、3D、Chiplet技术</li>
</ul>
<h4 id="设计方法演进">8.1.2 设计方法演进</h4>
<ul>
<li><strong>自动化程度提高</strong>：AI辅助版图设计</li>
<li><strong>可制造性设计</strong>：DFM成为标准流程</li>
<li><strong>可靠性设计</strong>：考虑老化、软错误等</li>
<li><strong>系统级设计</strong>：架构与版图协同优化</li>
</ul>
<h3 id="版图设计师能力要求">8.2 版图设计师能力要求</h3>
<h4 id="技术能力">8.2.1 技术能力</h4>
<ol type="1">
<li><strong>工艺理解</strong>：深入理解制造工艺</li>
<li><strong>电路知识</strong>：掌握电路原理和性能</li>
<li><strong>工具熟练</strong>：精通EDA工具使用</li>
<li><strong>验证能力</strong>：熟悉DRC/LVS/PEX流程</li>
</ol>
<h4 id="设计能力">8.2.2 设计能力</h4>
<ol type="1">
<li><strong>规划能力</strong>：整体布局规划</li>
<li><strong>优化能力</strong>：性能/面积/功耗权衡</li>
<li><strong>解决问题</strong>：调试和优化能力</li>
<li><strong>创新思维</strong>：新技术和新方法应用</li>
</ol>
<h4 id="软技能">8.2.3 软技能</h4>
<ol type="1">
<li><strong>沟通协调</strong>：与电路设计、工艺工程师协作</li>
<li><strong>文档能力</strong>：设计文档编写和维护</li>
<li><strong>项目管理</strong>：进度控制和质量管理</li>
<li><strong>持续学习</strong>：跟踪技术发展</li>
</ol>
<h3 id="学习资源与路径">8.3 学习资源与路径</h3>
<h4 id="推荐书籍">8.3.1 推荐书籍</h4>
<ol type="1">
<li><strong>基础入门</strong>：
<ul>
<li>《CMOS集成电路版图设计》</li>
<li>《模拟电路版图的艺术》</li>
</ul></li>
<li><strong>进阶提升</strong>：
<ul>
<li>《集成电路掩膜设计》</li>
<li>《深亚微米集成电路设计》</li>
</ul></li>
<li><strong>专业参考</strong>：
<ul>
<li>《Nanometer CMOS ICs》</li>
<li>《FinFETs and Other Multi-Gate Transistors》</li>
</ul></li>
</ol>
<h4 id="实践建议">8.3.2 实践建议</h4>
<ol type="1">
<li><strong>从简单开始</strong>：反相器、门电路</li>
<li><strong>逐步复杂化</strong>：运放、比较器、ADC</li>
<li><strong>实际项目</strong>：参与流片项目</li>
<li><strong>持续改进</strong>：分析测试结果，优化设计</li>
</ol>
<h4 id="工具掌握">8.3.3 工具掌握</h4>
<ol type="1">
<li><strong>主流工具</strong>：Cadence、Synopsys、Mentor</li>
<li><strong>脚本语言</strong>：Skill、Tcl、Python</li>
<li><strong>验证工具</strong>：Calibre、Assura、Hercules</li>
<li><strong>仿真工具</strong>：Spectre、HSPICE、FastSPICE</li>
</ol>
<h3 id="版图设计职业发展">8.4 版图设计职业发展</h3>
<h4 id="职业路径">8.4.1 职业路径</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初级版图工程师 → 中级版图工程师 → 高级版图工程师</span><br><span class="line">      ↓                ↓                ↓</span><br><span class="line">版图设计专家 → 版图技术经理 → 版图设计总监</span><br><span class="line">      ↓                ↓                ↓</span><br><span class="line">技术专家        项目管理        部门管理</span><br></pre></td></tr></table></figure>
<h4 id="发展方向">8.4.2 发展方向</h4>
<ol type="1">
<li><strong>技术专家</strong>：特定工艺或电路类型的版图专家</li>
<li><strong>工具开发</strong>：EDA工具开发和维护</li>
<li><strong>工艺整合</strong>：工艺与设计接口</li>
<li><strong>项目管理</strong>：版图设计项目管理</li>
<li><strong>技术销售</strong>：EDA工具或IP销售支持</li>
</ol>
<h3 id="结语">8.5 结语</h3>
<p>版图设计是集成电路设计的关键环节，连接着电路设计和芯片制造。随着工艺技术的不断发展，版图设计面临着新的挑战和机遇。掌握扎实的基础知识，积累丰富的实践经验，培养良好的设计习惯，是成为一名优秀版图设计师的必由之路。</p>
<p>记住：好的版图设计不仅是正确的，更是优化的；不仅是可制造的，更是可靠的；不仅是满足指标的，更是超越期望的。在每一个细节中追求卓越，是版图设计师的职业追求。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">计算机系统概论笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-31 10:50:02" itemprop="dateModified" datetime="2025-12-31T10:50:02+08:00">2025-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="第一部分基本概念">第一部分:基本概念</h2>
<h3 id="计算机系统概述">计算机系统概述</h3>
<p>从问题描述到电子运转的转换层次如下</p>
<p>问题–&gt;算法–&gt;语言–&gt;机器结构(ISA)–&gt;微结构–&gt;电路–&gt;器件</p>
<ol type="1">
<li>用自然语言提出一个问题</li>
<li>将问题转化成具体的算法, 算法有三大特点
<ol type="1">
<li><strong>确定性</strong>: 每个操作的步骤是清晰的, 可定义的</li>
<li><strong>可计算性</strong>: 每一步都可以被计算机执行</li>
<li><strong>有限性</strong>: 过程是会终止的</li>
</ol></li>
<li>将算法用程序语言实现, 而程序语言就是机器语言,
它又分成高级语言和低级语言
<ol type="1">
<li>高级语言和计算机底层相关性弱, 比如Python,Matlab</li>
<li>低级语言和计算机底层相关性强, 通常一种低级语言对应一种计算机,
称为某某机器的汇编语言</li>
</ol></li>
<li>将编程语言转换成特定计算机的指令集. 指令集架构(Instruction Set
Architecture,ISA)是程序和计算机硬件之间接口的一个完整定义.
将高级语言翻译成ISA指令的过程由<strong>编译器</strong>完成,
而将计算机特定汇编语言翻译成其ISA的过程由<strong>汇编器</strong>完成.
ISA的定义包括:
<ol type="1">
<li>计算机可以执行的<strong>指令集合</strong>,
即计算机所能执行的操作</li>
<li>每个操作所需数据是什么, 即<strong>操作数</strong></li>
<li>可接受的操作数表达方式, 即<strong>数据类型</strong></li>
<li>获取操作数的机制, 即定位各种操作数的不同方法,
称为<strong>寻址模式</strong></li>
</ol></li>
<li>将ISA转换成对应的实现, 实现的具体组织称为<strong>微结构</strong>.
例如很多处理器都实现了X86这种ISA结构,但是每个处理器的实现方法不同,即有自己的微结构.</li>
<li>微结构则是由一些简单的逻辑电路实现的</li>
<li>每个基本的逻辑电路,都是按照特定的器件技术实现的</li>
</ol>
<h3 id="bit-数据类型及其运算">bit, 数据类型及其运算</h3>
<p>表示负数的方法:</p>
<p>思路一: 以最高bit表示符号, 0为正数, 1为负数, 称为符号位表示法.</p>
<p>思路二: 将一个正数的所有bit位全部取反, 即得到该正数对应的复数的编码,
称为反码表示法.</p>
<p>思路三: 补码表示法, 这也是最适合硬件操作的编码方案.</p>
<p>有符号整数的三种表示方法如下:</p>
<table>
<thead>
<tr>
<th>表示</th>
<th>符号位表示法</th>
<th>反码表示法</th>
<th>补码表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>00001</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>00010</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>00011</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>00100</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>00101</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>00110</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>00111</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>01000</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>01001</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>01010</td>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>01011</td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>01100</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>01101</td>
<td>13</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>01110</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>01111</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>10000</td>
<td>-0</td>
<td>-15</td>
<td>-16</td>
</tr>
<tr>
<td>10001</td>
<td>-1</td>
<td>-14</td>
<td>-15</td>
</tr>
<tr>
<td>10010</td>
<td>-2</td>
<td>-13</td>
<td>-14</td>
</tr>
<tr>
<td>10011</td>
<td>-3</td>
<td>-12</td>
<td>-13</td>
</tr>
<tr>
<td>10100</td>
<td>-4</td>
<td>-11</td>
<td>-12</td>
</tr>
<tr>
<td>10101</td>
<td>-5</td>
<td>-10</td>
<td>-11</td>
</tr>
<tr>
<td>10110</td>
<td>-6</td>
<td>-9</td>
<td>-10</td>
</tr>
<tr>
<td>10111</td>
<td>-7</td>
<td>-8</td>
<td>-9</td>
</tr>
<tr>
<td>11000</td>
<td>-8</td>
<td>-7</td>
<td>-8</td>
</tr>
<tr>
<td>11001</td>
<td>-9</td>
<td>-6</td>
<td>-7</td>
</tr>
<tr>
<td>11010</td>
<td>-10</td>
<td>-5</td>
<td>-6</td>
</tr>
<tr>
<td>11011</td>
<td>-11</td>
<td>-4</td>
<td>-5</td>
</tr>
<tr>
<td>11100</td>
<td>-12</td>
<td>-3</td>
<td>-4</td>
</tr>
<tr>
<td>11101</td>
<td>-13</td>
<td>-2</td>
<td>-3</td>
</tr>
<tr>
<td>11110</td>
<td>-14</td>
<td>-1</td>
<td>-2</td>
</tr>
<tr>
<td>11111</td>
<td>-15</td>
<td>-0</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p><strong>原码</strong>第一位是符号位, 0代表正数,
1代表负数.后面的位数都是数值位.</p>
<p><strong>反码</strong>正数的反码和原码相同,
负数的反码保持符号位是1,数值位取反</p>
<p><strong>补码</strong>正数的补码和原码相同,
负数的补码是在其反码的基础上加1.</p>
<p><strong>注意事项</strong></p>
<ul>
<li>如果已知一个数的补码, 对其再求一次补码就可以得到原码</li>
<li>4位字长的原码和反码表示的数值范围都是<code>-7~+7</code>,
补码表示的范围是<code>-8~+7</code>. 规定<code>+0</code>的原码, 反码,
补码都是<code>0000</code>,
<code>-0</code>只有原码(<code>1000</code>)和反码(<code>1111</code>),
没有补码; <code>-8</code>只有补码(<code>1000</code>),
没有原码和反码</li>
</ul>
<p><strong>符号扩展</strong>在二进制补码正数前加上任意多个0不改变它的值,
在二进制补码负数前加上任意多个1不改变它的值.</p>
<p><strong>溢出</strong>两个数进行补码运算, 如果结果的正负号和预期相反,
那么就就称为溢出. 只有在两种同符号运算的情况下, 才会发生溢出.</p>
<p><strong>浮点数</strong>IEEE浮点数的定义如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号位</th>
<th style="text-align: center;">数值范围</th>
<th style="text-align: center;">数值精度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">(S)</td>
<td style="text-align: center;">指数(exponent)</td>
<td style="text-align: center;">尾数(fraction)</td>
</tr>
<tr>
<td style="text-align: center;">1 bit</td>
<td style="text-align: center;">8 bit</td>
<td style="text-align: center;">23 bit</td>
</tr>
</tbody>
</table>
<p>浮点数的计算公式如下: <span class="math display">\[N=(-1)^s\times
1.\rm{fraction}\times 2^{\rm{exponent}-127},~1\leq \rm{exponent}\leq
254\]</span></p>
<p><strong>例1</strong> <span
class="math inline">\(-6\frac{5}{8}\)</span>的IEEE浮点数是多少?</p>
<p><strong>解</strong><span
class="math display">\[-6\frac{5}{8}=-(1\times 2^2+1\times 2^1+0\times
2^0+1\times 2^{-1}+0\times 2^{-1}+1\times 2^{-3})=-1.10101\times
2^2\]</span></p>
<p>符号位是<span class="math inline">\(1\)</span>,指数是<span
class="math inline">\(2+127=129=10000001\)</span>,尾数为<span
class="math inline">\(10101000000000000000000\)</span> 于是IEEE浮点数为
<span
class="math display">\[1(1~bit)~~10000001(8~bit)~~10101000000000000000000(23~bit)\]</span></p>
<p><strong>例2</strong> IEEE浮点数 <span
class="math display">\[0~01111011~00000000000000000000000\]</span>
表示的是什么数?</p>
<p><strong>解</strong> <span
class="math inline">\(01111011-127=123-127=-4\)</span>,位数部分全为<span
class="math inline">\(0\)</span>, 整个数为正数, 所以 <span
class="math display">\[+1.00000000000000000000000\times
2^{-4}=\frac{1}{16}\]</span></p>
<p><strong>例3</strong> 在IEEE浮点数的定义中, 我们看到指数的范围为<span
class="math inline">\(1\leq \rm{exponential}\leq 254\)</span>,
也就是说指数不能为<span class="math inline">\(00000000\)</span>或者<span
class="math inline">\(11111111\)</span>. 如果指数字段的内容为<span
class="math inline">\(00000000\)</span>, 那么规定此时指数为<span
class="math inline">\(-126\)</span>, 且尾数中小数点左边的数为<span
class="math inline">\(0\)</span>, 而不是<span
class="math inline">\(1\)</span>. 此时浮点数的值为</p>
<p><span class="math display">\[(-1)^s\times 0.\rm{fraction}\times
2^{-126}\]</span></p>
<p>比如IEEE浮点数</p>
<p><span
class="math display">\[0~00000000~00001000000000000000000\]</span></p>
<p>解释如下: 最高位<span class="math inline">\(0\)</span>表示为正数,
指数全为<span class="math inline">\(0\)</span>表示<span
class="math inline">\(2^{-126}\)</span>, 尾数部分为<span
class="math inline">\(00001000...\)</span>表示<span
class="math inline">\(2^{-5}\)</span>, 于是该浮点数等于<span
class="math inline">\(2^{-5}\times 2^{-126}=2^{-131}\)</span>.</p>
<h3 id="内存">内存</h3>
<p>内存是由一定数目的”位置”组成的,
其中每个”位置”可以被单独识别并且存放一个数据.
我们称用来<strong>识别位置的一组数</strong>为<strong>地址</strong>,
称存储在<strong>各个位置中的bit数目</strong>为<strong>寻址能力</strong>.
内存中可独立识别的位置总数为内存的<strong>寻址空间</strong>.</p>
<p>例如, <span class="math inline">\(2^3\times 16\)</span>大小的内存,
其寻址空间大小为<span class="math inline">\(2^3=8\)</span>,
寻址能力为<span class="math inline">\(16 bit\)</span>的宽度.</p>
<h2 id="第二部分lc-3及其汇编语言">第二部分:LC-3及其汇编语言</h2>
<h3 id="冯诺依曼模型">冯诺依曼模型</h3>
<h4 id="组成部分">组成部分</h4>
<p>冯诺依曼模型包括五个组成部分:</p>
<ol type="1">
<li>内存memory</li>
<li>处理单元processing unit</li>
<li>输入input</li>
<li>输出output</li>
<li>控制单元control unit</li>
</ol>
<p>下面我们一一介绍</p>
<h5 id="内存-1">内存</h5>
<p>今天的计算机都是<span class="math inline">\(2^{28}\times
8~\rm{bit}\)</span>模式, 也就是说有<span
class="math inline">\(2^{28}\)</span>个存储单元,
每个存储单元可以存储<span
class="math inline">\(8~\rm{bit}\)</span>的信息. 我们称寻址空间为<span
class="math inline">\(2^{28}\)</span>, 寻址能力为<span
class="math inline">\(8\)</span>位(<span
class="math inline">\(1~\rm{byte}=8~\rm{bit}\)</span>).</p>
<p>访问内存的第一步, 就是向内存提供被访问的内存单元的地址</p>
<ul>
<li>读操作: 首先将被访问内存单元的地址放入CPU的内存地址寄存器(Memory
Address Register, MAR), 然后发送读信号通知内存,
最后内存将该内存单元中存放的数据发送到内存数据寄存器(Memory Data
Register, MDR).</li>
<li>写操作: 首先将被访问内存单元的地址放入CPU的MAR,
然后将要写入的数据放入CPU的MDR, 再向内存发送写信号,
最后MDR的内容被写入MAR指向的内存单元.</li>
</ul>
<h5 id="处理单元">处理单元</h5>
<p>处理单元是信息被真正处理的地方,
其中最简单的功能单元是算数逻辑单元ALU.
ALU所能处理的量化大小称为该机器的”字长”, 而量化的基本单位称为一个”字”.
例如, LC-3所能处理的量化大小为<span
class="math inline">\(16\rm{bit}\)</span>, 所以称LC-3是一个<span
class="math inline">\(16\)</span>位的机器.</p>
<p>通常会在ALU周围配置少量存储器, 以便存放最近生成的中间计算结果,
这样可以减少内存访问浪费的时间.
临时存储器最常见的设计方式就是一组寄存器,
其中每个寄存器的宽度和ALU处理数据的宽度一致,
我们说每个寄存器存放了一个字. 在LC-3中, 有<span
class="math inline">\(8\)</span>个这样的寄存器<code>R0, R1, ..., R7</code>,
每个宽度为16 bit.</p>
<h5 id="输入和输出单元">输入和输出单元</h5>
<p>输入和输出设备的种类很多, 我们称它们为”外围设备”.
常见的输入设备是键盘, 输出设备是显示器.</p>
<h5 id="控制单元">控制单元</h5>
<p>控制单元控制其他所有单元之间的协同工作.
控制单元中有几个特殊的寄存器:</p>
<ol type="1">
<li>指令寄存器IR: 保存的是正在被执行的那条指令.</li>
<li>PC寄存器: 指向下一条待处理的指令,
这个寄存器又称为”程序计数器”或者”指令指针”,
这是因为该寄存器的内容实际上指向下一条待处理的指令的地址.</li>
</ol>
<h4 id="指令处理">指令处理</h4>
<p>冯诺依曼模型的核心思想是,
程序和数据都是以bit流的方式存放在计算机内存中, 程序在控制单元的控制下,
依次完成指令的读取和执行.</p>
<h5 id="指令">指令</h5>
<p>指令是计算机执行的最小单位.
指令本身又是由<strong>操作码</strong>和<strong>操作数</strong>两部分组成.
操作码表示该指令是做什么的, 操作数表示该操作的对象有哪些.</p>
<p>LC-3指令长度是16, 其中<span
class="math inline">\(\rm{bit}[15:12]\)</span>表示操作码, <span
class="math inline">\(\rm{bit}[11:0]\)</span>对应操作数的表示.</p>
<p><strong>例1</strong> <code>ADD</code>指令</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>1 1 0</td>
<td>0 1 0</td>
<td>0</td>
<td>0 0</td>
<td>1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=110\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010,\rm{bit}[2:0]=110\)</span>
表示源寄存器<span class="math inline">\(\rm{R2}\)</span>和<span
class="math inline">\(\rm{R6}\)</span> <span
class="math inline">\(\rm{bit}[5:3]\)</span> 的含义以后再进行解释</p>
<p>上述指令的解释为将寄存器<span
class="math inline">\(\rm{R2}\)</span>和寄存器<span
class="math inline">\(\rm{R6}\)</span>的内容相加,
然后将结果放入寄存器R6.</p>
<p><strong>例2</strong> <code>LDR</code>指令</p>
<p>LD表示load, 表示从内存的某个位置读取内容, 然后装入某个寄存器中.
R表示读取内存地址的机制(寻址模式),
这里表示的意思是”base+offset”模式.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 1 0</td>
<td>0 1 1</td>
<td>0 0 0 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示LDR操作 <span class="math inline">\(\rm{bit}[11:9]=010\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=011\)</span> 表示偏移寄存器<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=000110\)</span> 表示基址<span
class="math inline">\(6\)</span></p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{R3}\)</span>的内容和<span
class="math inline">\(\rm{bit}[5:0]\)</span>的补码数值相加得到内存地址,
然后将该地址指向的内存单元的内容放入<span
class="math inline">\(\rm{R2}\)</span>中.</p>
<h5 id="指令周期">指令周期</h5>
<p>指令的处理过程是在控制单元的控制下一步步地完成的.
我们称这个执行的步骤顺序为指令周期, 其中每一步称为节拍.
一个指令周期包括6个节拍:</p>
<ol type="1">
<li>取指令(FETCH)</li>
<li>译码(DECODE)</li>
<li>地址计算(EVALUATE ADDRESS)</li>
<li>取操作数(FETCH OPERAND)</li>
<li>执行(EXECUTE)</li>
<li>存放结果(STORE RESULT)</li>
</ol>
<h6 id="取指令">取指令</h6>
<p>该节拍负责从内存中(整个程序的所有指令都保存在内存里面)取出下一条待执行的指令,
将其放入控制单元的指令寄存器IR. 而取出下一条待执行的指令,
就需要知道它在内存中的地址, 而程序计数器PC就是负责这个任务.
FETCH节拍的具体过程如下:</p>
<ol type="1">
<li>将PC寄存器的内容装入MAR</li>
<li>将MAR对应的内存单元的内容装入MDR</li>
<li>控制单元将MDR的内容装入IR寄存器</li>
<li><strong>PC+1</strong></li>
</ol>
<p>上面的每一个动作就是一个机器周期, 或者叫时钟周期.</p>
<h6 id="译码">译码</h6>
<p>将<span class="math inline">\(\rm{IR}[15:12]\)</span>作为输入,
输出<span class="math inline">\(16\)</span>根使能线, 但是这<span
class="math inline">\(16\)</span>根使能线中有且仅有一条是有效的.</p>
<h6 id="地址计算">地址计算</h6>
<p>不是所有的指令都有这个环节.</p>
<h6 id="取操作数">取操作数</h6>
<p><strong>源操作数既可以来自寄存器,又可以来自内存.</strong></p>
<h6 id="执行">执行</h6>
<p>没什么好说的</p>
<h6 id="存放结果">存放结果</h6>
<p>之前节拍的执行结果被写入目的寄存器.</p>
<h5 id="改变执行顺序">改变执行顺序</h5>
<p>由于任意的指令周期都是从将PC的内容装入MAR中开始的,
如果我们想要改变指令执行的顺序,
就必须在PC+1与下一条指令的取指令节拍开始之前修改PC+1的值.
控制指令就是<strong>用新的地址覆盖PC+1的内容</strong>.</p>
<p><strong>例</strong> <code>JMP</code>指令</p>
<p>假设该指令存放在内存<span
class="math inline">\(\rm{x36A2}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11</th>
<th>10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>0 1 1</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示JMP操作 <span class="math inline">\(\rm{bit}[8:6]=011\)</span>
表示寄存器<span
class="math inline">\(\rm{R3}\)</span>中存储了下一条指令</p>
<p>上述指令的解释为将寄存器3的内容放入PC寄存器, 覆盖掉当前PC+1, 换言之,
下一条要执行的指令在内存中的地址来自<span
class="math inline">\(\rm{R3}\)</span>.</p>
<p>具体来说, 首先在指令执行之初, PC的内容为<code>x36A2</code>,
在取指令节拍, 整条JMP指令放入IR寄存器, 同时PC自增变成<code>x36A3</code>,
假设<span
class="math inline">\(\rm{R3}\)</span>的内容是<code>x5446</code>,
那么在执行节拍, PC的内容就被覆盖为<code>x5446</code>.
这就导致了下一条指令来自内存中地址为<code>x5446</code>,
而不是$<code>x36A3</code>.</p>
<h5 id="停机操作">停机操作</h5>
<p>用户程序是受控于操作系统而执行的, 即操作系统有终值用户程序的办法.
对于计算机来说, 用户程序和操作系统没有区别, 都是一堆指令的集合.</p>
<p>对于用户程序来说, 想要停止用户程序,
就要在用户程序的结尾处放置一个控制指令, 该指令的任务就是修改PC寄存器,
使之跳转到操作系统, 而操作系统也借这个时刻启动一个新的用户程序.</p>
<h3 id="lc-3结构">LC-3结构</h3>
<h4 id="lc-3-isa概述">LC-3 ISA概述</h4>
<p>ISA定义了软件编程所需要的必要而完整的描述, 换言之,
ISA向以机器语言编程的程序员提供有关控制机器所需要的全部信息.
ISA主要包含如下信息:</p>
<ol type="1">
<li>内存组织方式</li>
<li>寄存器组</li>
<li>指令集(包括操作码, 数据类型, 寻址模式)</li>
</ol>
<h5 id="内存组织">内存组织</h5>
<p>LC-3的可寻址空间大小为<span
class="math inline">\(2^{16}\)</span>(这些空间并不是全部用于内存),
寻址基本单位是<span class="math inline">\(16\)</span>位.
LC-3中数据处理的基本单位是<span class="math inline">\(16\)</span>位,
所以称<span class="math inline">\(16\)</span>位为一个字,
也称LC-3是一个<strong>字寻址机器</strong>.</p>
<h5 id="寄存器">寄存器</h5>
<p>由于从内存中获取数据的速度很慢(不止一个周期),
所以计算机会提供临时存储空间, 它们的访问速度是一个周期.
临时存储空间最常见的实现方式是寄存器, LC-3提供了一组通用寄存器,
其中每个寄存器都叫做通用寄存器.</p>
<p>寄存器有以下特性:</p>
<ol type="1">
<li>记忆特性: 存储的信息可以被再次读出. 对于LC-3,
每个寄存器的大小为一个字, 即<span
class="math inline">\(16\)</span>位</li>
<li>独立寻址: 每个寄存器有唯一的标识. LC-3, 提供了<span
class="math inline">\(8\)</span>个寄存器<code>R0, R1, ..., R7</code></li>
</ol>
<h5 id="指令集">指令集</h5>
<p>一条指令分为两个部分, 第一个部分是<strong>操作码</strong>(做什么),
第二个部分是<strong>操作数</strong>(对谁操作).
<strong>一个ISA的指令集定义包括: 操作码的集合, 数据类型, 寻址模式.
其中寻址模式决定了操作数的存放位置.</strong></p>
<h5 id="操作码">操作码</h5>
<p>LC-3的ISA结构定义了<span class="math inline">\(15\)</span>条指令,
注意到<span class="math inline">\(\rm{bit}[15:12]\)</span>这<span
class="math inline">\(4~\rm{bit}\)</span>的操作码本来可以定义<span
class="math inline">\(16\)</span>条指令, 但我们将<span
class="math inline">\(1101\)</span>先预留出来.</p>
<p>所有指令可以分成三类:</p>
<ol type="1">
<li><strong>运算指令:</strong> 算数运算或者逻辑运算, 负责处理信息</li>
<li><strong>数据搬移指令:</strong> 将数据从一个地方搬到另一个地方,
如内存和寄存器之间, 内存, 寄存器和输入输出之间</li>
<li><strong>控制指令:</strong> 改变程序的执行顺序</li>
</ol>
<h5 id="数据类型">数据类型</h5>
<p>数据类型是指信息的表达方式, 即ISA的操作码是怎样理解这些表达信息的.
如果ISA的操作码能识别/处理某种数据类型的信息,
那么我们称该ISA支持这种数据类型.
<strong>LC-3所支持的唯一的数据类型就是补码整数</strong>.</p>
<h5 id="寻址模式">寻址模式</h5>
<p>寻址模式是定义操作数位置的机制.操作数的来源有三个:</p>
<ol type="1">
<li>内存</li>
<li>寄存器</li>
<li>指令本身</li>
</ol>
<p>称存在于指令本身的操作数为”字面值”或”立即数”.</p>
<p>而LC-3总共支持<span class="math inline">\(5\)</span>种寻址模式:</p>
<ol type="1">
<li>立即数</li>
<li>寄存器</li>
<li>相对寻址</li>
<li>间接寻址</li>
<li>基址偏移</li>
</ol>
<h5 id="条件码">条件码</h5>
<p>LC-3具有三个位寄存器, 每当<span
class="math inline">\(8\)</span>个通用寄存器中的任意一个被修改或者写入时,
这三个<span class="math inline">\(\rm{bit}\)</span>位就会发生变化.
这三个位寄存器分别为<span class="math inline">\(N,Z,P\)</span>,
分别代表负数, 零, 正数. 即每当通用寄存器被写入时, 根据写入的结果是负数,
零, 正数, 分别设置这三个位. 例如, 写入负数, 置<span
class="math inline">\(N=1,Z=P=0\)</span>.
我们称这三个位寄存器为”条件码”.</p>
<h4 id="运算指令">运算指令</h4>
<p>LC-3只支持三种运算: <code>ADD</code>, <code>AND</code>,
<code>NOT</code></p>
<p><strong>例1</strong> <code>NOT</code>指令</p>
<p><code>NOT</code>指令是唯一的单操作数指令.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 0 1</td>
<td>0 1 1</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1001\)</span>
表示取反NOT操作 <span class="math inline">\(\rm{bit}[11:9]=011\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=101\)</span> 表示源寄存器<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5:0]\)</span> 全部为<span
class="math inline">\(1\)</span></p>
<p>上述指令的解释为将寄存器5的内容取反,然后放入寄存器3.</p>
<p><strong>例2</strong> <code>AND</code>指令</p>
<p><code>AND</code>(操作码为<code>0101</code>)和<code>ADD</code>(操作码为<code>0001</code>)都是双操作数指令,
它们都需要两个<span class="math inline">\(16\)</span>位源操作数.
<code>AND</code>和<code>ADD</code>的源操作数之一(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)以及目的寄存器(<span
class="math inline">\(\rm{bit}[11:9]\)</span>)都是寄存器寻址.
对于第二个操作数的寻址方式, 则是取决于<span
class="math inline">\(\rm{bit}[5]\)</span>的值, 若为<span
class="math inline">\(1\)</span>, 则是立即数寻址, 此时<span
class="math inline">\(\rm{bit}[4:0]\)</span>表示立即数; 若为<span
class="math inline">\(0\)</span>, 则是寄存器寻址, 此时源寄存器为<span
class="math inline">\(\rm{bit}[2:0]\)</span>, <span
class="math inline">\(\rm{bit}[4:3]=00\)</span>.</p>
<p>下面是<strong>寄存器寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3</th>
<th>2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>0</td>
<td>0 0</td>
<td>1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100,\rm{bit}[2:0]=101\)</span>
表示源寄存器<span class="math inline">\(\rm{R4}\)</span>和<span
class="math inline">\(\rm{R5}\)</span> <span
class="math inline">\(\rm{bit}[5]=0\)</span> 表示寄存器寻址,此时<span
class="math inline">\(\rm{bit}[4:3]=00\)</span></p>
<p>上述指令的解释为将寄存器R4和寄存器R5的内容相加,
然后将结果放入寄存器R1.</p>
<p>下面是<strong>立即数寻址</strong>的一个例子</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5</th>
<th>4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 0 1</td>
<td>0 0 1</td>
<td>1 0 0</td>
<td>1</td>
<td>1 1 1 1 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0001\)</span>
表示加法ADD操作 <span class="math inline">\(\rm{bit}[11:9]=001\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=100\)</span> 表示源寄存器<span
class="math inline">\(\rm{R4}\)</span> <span
class="math inline">\(\rm{bit}[5]=1\)</span> 表示立即数寻址,此时<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>为立即数</p>
<p>上述指令的解释为将<span
class="math inline">\(\rm{bit}[4:0]=11110\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,
然后与寄存器R4的内容相加,然后将结果放入寄存器R1.</p>
<h4 id="数据搬移指令">数据搬移指令</h4>
<p>我们称将数据从内存移入寄存器为”装载(Load)“,
将数据从寄存器放入内存为”存储(Store)“. 注意, 在这种情况下,
数据源的内容不会随着数据的移动而改变, 但是目的操作数的内容会被刷新,
以前的内容会被覆盖.</p>
<p>LC-3有<span class="math inline">\(7\)</span>种数据搬移指令:
<code>LD</code>, <code>LDR</code>, <code>LDI</code>, <code>LEA</code>,
<code>ST</code>, <code>STR</code>, <code>STI</code></p>
<p>Load和Store的指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">操作码</td>
<td style="text-align: center;">DR或SR</td>
<td style="text-align: center;">地址生成位</td>
</tr>
</tbody>
</table>
<p>数据搬移指令需要有两个操作数: 源和目的, 且两个操作数之一必然是寄存器,
另一个则是内存或者输入输出设备.</p>
<p><span class="math inline">\(\rm{bit}[11:9]\)</span>标识了操作数之一,
即寄存器, 如果是Load类型的指令, 那么这代表目的寄存器(DR);
如果是Store类型的指令, 那么这代表源寄存器(SR).</p>
<p><span class="math inline">\(\rm{bit}[8:0]\)</span>是”地址生成位”,
这表示基于<span class="math inline">\(\rm{bit}[8:0]\)</span>的信息,
可以计算出第二个操作数的<span class="math inline">\(16\)</span>位地址.
LC-3中, 有<span
class="math inline">\(4\)</span>种生成地址(或者说阐释<span
class="math inline">\(\rm{bit}[8:0]\)</span>)的方法, 也就是<span
class="math inline">\(4\)</span>种寻址模式.</p>
<h5 id="pc相对寻址">PC相对寻址</h5>
<p><code>LD</code>(操作码为<code>0010</code>)和<code>ST</code>(操作码为<code>0011</code>)采用<strong>PC相对寻址</strong>.
此时<span
class="math inline">\(\rm{bit}[8:0]\)</span>代表的是<strong>对于当前PC值的偏移量</strong>.
地址计算方法是, 将<span
class="math inline">\(\rm{bit}[8:0]\)</span>做<span
class="math inline">\(16\)</span>位符号扩展,
然后和PC当前值(已增量)相加得到内存单元的地址.</p>
<p><strong>例</strong> <code>LD</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 0 1 0</td>
<td>0 1 0</td>
<td>1 1 0 1 0 1 1 1 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示PC相对寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=010\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R2}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span>
表示偏移量,符号扩展之后为<span
class="math inline">\(\rm{xFFAF}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)+\rm{xFFAF}=\rm{x3FC8}\)</span>,
将<span class="math inline">\(\rm{x3FC8}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x3FC8}\)</span>的内容装入MDR中,
最后把MDR的内容加载到<span class="math inline">\(R2\)</span>中.</p>
<p>注意这种寻址方式计算出来的内存地址范围是受限的,
即该地址只能在当前LD或者ST指令所在地址的<span
class="math inline">\(+256\)</span>和<span
class="math inline">\(-255\)</span>范围内, 另外<span
class="math inline">\(\rm{bit}[8:0]\)</span>是有符号数值.</p>
<h5 id="间接寻址">间接寻址</h5>
<p><code>LDI</code>(操作码为<code>1010</code>)和<code>STI</code>(操作码为<code>1011</code>)采用<strong>间接寻址</strong>.
首先用和LD/ST相同的方法算出一个地址, 但是这个地址的内容又是另外一个地址,
这个新的地址的内容才是源操作数.
这种寻址方式的范围是<strong>整个内存空间</strong>.</p>
<p><strong>例</strong> <code>LDI</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4A1B}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 0 1 0</td>
<td>0 1 1</td>
<td>1 1 1 0 0 1 1 0 0</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0010\)</span>
表示间接寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=011\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R3}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=110101111\)</span> 表示偏移量,
符号扩展之后为<span class="math inline">\(\rm{xFFCC}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4A1B}+1)+\rm{xFFCC}=\rm{x49E8}\)</span>,
将<span class="math inline">\(\rm{x49E8}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x49E8}\)</span>的内容(假设为<span
class="math inline">\(\rm{x2110}\)</span>)装入MDR中, 而<span
class="math inline">\(\rm{x2110}\)</span>不是操作数, 而是地址, 所以<span
class="math inline">\(\rm{x2110}\)</span>又被装入MAR,
再次读取内存地址为<span
class="math inline">\(\rm{x2110}\)</span>的内容装入到MDR,
最后把MDR的内容加载到<span class="math inline">\(R3\)</span>中.</p>
<h5 id="基址偏移寻址">基址偏移寻址</h5>
<p><code>LDR</code>(操作码为<code>0110</code>)和<code>STR</code>(操作码为<code>0111</code>)采用<strong>基址+偏移寻址</strong>.
操作数的地址是由<span
class="math inline">\(\rm{bit}[5:0]\)</span>的<span
class="math inline">\(6~\rm{bit}\)</span>偏移量和<span
class="math inline">\(\rm{bit}[8:6]\)</span>的寄存器的内容(基址)相加得出.</p>
<p><strong>例</strong> <code>LD</code>指令</p>
<p>假设下面这条指令存放在<span
class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 1 1 0</td>
<td>0 0 1</td>
<td>0 1 0</td>
<td>0 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0110\)</span>
表示基址+偏移寻址的Load操作 <span
class="math inline">\(\rm{bit}[11:9]=001\)</span> 表示目的寄存器是<span
class="math inline">\(\rm{R1}\)</span> <span
class="math inline">\(\rm{bit}[8:6]=010\)</span> 表示基址寄存器<span
class="math inline">\(\rm{R2}\)</span>, 其内容假设为<span
class="math inline">\(\rm{x2345}\)</span> <span
class="math inline">\(\rm{bit}[5:0]=011101\)</span> 符号扩展为<span
class="math inline">\(\rm{x001D}\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\(\rm{x2345}+\rm{x001D}=\rm{x2362}\)</span>, 将<span
class="math inline">\(\rm{x2362}\)</span>装入MAR,
然后读取内存地址为<span
class="math inline">\(\rm{x2362}\)</span>的内容装入MDR中,
最后把MDR的内容加载到<span class="math inline">\(R1\)</span>中.</p>
<h5 id="立即数寻址">立即数寻址</h5>
<p>立即数寻址模式只用于有效地址装载指令, 用途是对寄存器初始化,
即向寄存器中装入一个地址, 注意该地址需要离当前PC比较近,
且LEA是唯一不需要访问内存的load类型指令.
LEA(操作码为1110)将增量PC直接和<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加, 并装入<span
class="math inline">\(\rm{bit}[11:9]\)</span>指定的寄存器.</p>
<p><strong>例</strong> <code>LEA</code>指令</p>
<p>设这条指令位于<span class="math inline">\(\rm{x4018}\)</span>处.</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 1 0</td>
<td>1 0 1</td>
<td>1 1 1 1 1 1 1 0 1</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=1110\)</span>
表示LEA操作 <span class="math inline">\(\rm{bit}[11:9]=101\)</span>
表示目的寄存器是<span class="math inline">\(\rm{R5}\)</span>,
假设内容为<span class="math inline">\(\rm{x4018}\)</span> <span
class="math inline">\(\rm{bit}[8:0]=111111101\)</span> 为<span
class="math inline">\(-3\)</span></p>
<p>上述指令的解释为先计算<span
class="math inline">\((\rm{x4018}+1)-3=\rm{x4016}\)</span>, 将<span
class="math inline">\(\rm{x4016}\)</span>装入<span
class="math inline">\(\rm{R5}\)</span>.</p>
<h4 id="控制指令">控制指令</h4>
<p>控制指令是指可以改变指令执行顺序的指令. 如果没有控制指令,
那么当前指令完毕后的下一条指令一定是内存位置顺序的下一条,
这是因为取指令之后, PC会自动加一.</p>
<p>LC-3中有<span
class="math inline">\(5\)</span>种操作码可以打破这种顺序: 条件跳转,
无条件跳转, 子程序(又称为函数)调用, TRAP, 中断返回.</p>
<h5 id="条件跳转和无条件跳转">条件跳转和无条件跳转</h5>
<p>条件跳转指令格式如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">P</td>
<td style="text-align: center;">PC偏移</td>
</tr>
</tbody>
</table>
<p>其中:</p>
<p><span
class="math inline">\(\rm{bit}[11],[10],[9]\)</span>分别对应三个条件码.
<strong>任何一个对寄存器进行操作的指令都会设置这三个条件码,
这些指令包括ADD, AND, NOT, LD, LDI, LDR,
LEA.</strong>(注意Store类型的指令不改变条件码).</p>
<p>条件码的使用方法是:
条件跳转指令通过判断条件码来决定是否改变指令流.</p>
<p>控制指令的执行周期如下:</p>
<ol type="1">
<li>取指令和译码节拍正常, 取指令之后, PC自动增量</li>
<li>地址计算节拍, 将增量后的PC和指令中<span
class="math inline">\(\rm{bit}[8:0]\)</span>的符号扩展相加求得地址</li>
<li>执行节拍, 处理器会检测某个(我们指定的)条件码,
如果该条件码的值为<span class="math inline">\(1\)</span>,
那么PC的内容将会被修改成上一个节拍计算出来的地址;
如果该条件码的值为<span class="math inline">\(0\)</span>,
那么PC的内容不变. 如果我们指定三个条件码都为<span
class="math inline">\(1\)</span>, 那么PC内容必然会更新,
这就是无条件跳转指令.</li>
</ol>
<h5 id="jmp">JMP</h5>
<p><code>JMP</code>指令格式如下</p>
<table>
<thead>
<tr>
<th>15 14 13 12</th>
<th>11 10 9</th>
<th>8 7 6</th>
<th>5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 1 0 0</td>
<td>0 0 0</td>
<td>0 1 0</td>
<td>0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<p>JMP指令的任务就是<strong>将基址寄存器(<span
class="math inline">\(\rm{bit}[8:6]\)</span>)的内容装入PC中</strong>.
JMP指令可以使指令跳转到内存空间的任意位置,
这是因为基址寄存器的内容是<span class="math inline">\(16\)</span>位,
它可以表达内存空间的所有地址.</p>
<h5 id="trap">TRAP</h5>
<p>TRAP指令的任务是改变PC的内容, 使其指向操作系统所在的空间内部. 换言之,
就是以当前程序身份跳转至操作系统的某个代码入口开始执行.
按照操作系统的术语来说, 我们称TRAP指令是激活了操作系统的服务调用.</p>
<p>TRAP指令格式如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 1 1</td>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">陷入矢量</td>
</tr>
</tbody>
</table>
<p>其中<span class="math inline">\(\rm{bit}[7:0]\)</span>表示陷入矢量,
陷入矢量表示的是程序希望操作系统执行的服务程序的编号.</p>
<p>操作系统在完成服务调用之后,
程序计数器PC将被设置成TRAP指令后的下一条指令地址.</p>
<h3 id="lc-3-汇编语言">LC-3 汇编语言</h3>
<p>汇编语言属于低级语言, 每一条汇编语言通常对应于一条ISA指令,
高级语言是ISA无关的, 而低级语言是ISA相关的.</p>
<p>在汇编语言中,
我们采用<strong>助记符</strong>方式来表示<code>AND</code>,<code>NOT</code>之类的<strong>操作码</strong>,
而<strong>内存地址</strong>则被SUM,PRODUCT之类的<strong>符号名</strong>所替代.
我们称这种命名方式为<strong>符号地址</strong>.</p>
<p>我们先看一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; Program to multiply an integer by the constant 6</span><br><span class="line">; Before execution, an integer must be stored in NUMBER</span><br><span class="line">         .ORIG    x3050</span><br><span class="line">         LD       R1,SIX</span><br><span class="line">         LD       R2,NUMBER</span><br><span class="line">         AND      R3,R3,#0</span><br><span class="line">; The inner loop</span><br><span class="line">   AGAIN ADD      R3,R3,R2</span><br><span class="line">         ADD      R1,R1,#-1</span><br><span class="line">         BRp      AGAIN</span><br><span class="line"></span><br><span class="line">         HALT</span><br><span class="line"></span><br><span class="line">   NUMBER .BLKW   1</span><br><span class="line">   SIX    .FILL   x0006</span><br><span class="line"></span><br><span class="line">          .END</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ol type="1">
<li>以<code>;</code>开头的内容是注释</li>
<li>以<code>AND</code>, <code>NOT</code>, <code>HALT</code>,
<code>AGAIN</code>开头的代码行是要翻译成LC-3机器指令的,
即真正要运行的</li>
<li><code>.ORIG</code>, <code>NUMBER</code>, <code>SIX</code>,
<code>.END</code>是伪操作,
是程序员传递给汇编器的信息,用于提示帮助翻译的过程.</li>
</ol>
<h4 id="指令-1">指令</h4>
<p>汇编语言的指令格式包含<span
class="math inline">\(4\)</span>个部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL OPCODE OPERANDS ; COMMENTS</span><br></pre></td></tr></table></figure>
<h5 id="操作码和操作数">操作码和操作数</h5>
<p>在一个汇编指令的所有字段中, 操作码(OPCODE,
做什么事情)和操作数(OPERAND, 被操作的对象)两部分是必须的,
操作数的数目取决于具体的操作.</p>
<p>操作数的获取有三种方式:</p>
<ol type="1">
<li>寄存器操作数:
直接用<code>R1</code>,<code>R2</code>等显式表示寄存器</li>
<li>内存操作数:
内存地址被表达为符号名,例如<code>NUMBER</code>和<code>SIX</code></li>
<li>立即数操作数:
数值被显式表达,“#”表示十进制,“x”表示十六进制,“b”表示二进制.</li>
</ol>
<h5 id="标号">标号</h5>
<p>标号是指向内存单元的符号名, 它可以在程序中直接引用. LC-3汇编语言中,
一个标号可以包含<span class="math inline">\(1\)</span>到<span
class="math inline">\(20\)</span>个字符(如大写或者小写的字母或者数字),
但是首个字符必须是字母. 显式访问内存单元的方式有两种:</p>
<ol type="1">
<li>该单元的内容是指令, 该单元地址是跳转指令的目标,
比如<code>AGAIN</code></li>
<li>该单元的内容是Load或者Store指令访问的数值, 比如<code>NUMBER</code>,
<code>SIX</code></li>
</ol>
<p>如果一个内存单元从来不被引用, 那么就没有必要为其标号.</p>
<h4 id="伪操作">伪操作</h4>
<p>伪操作又被称为<strong>汇编指令</strong>,
它们并不代表(被翻译的汇编)程序中的任何操作,
或者说程序执行时它们是不产生任何操作的.
它们可以理解为程序员传递给汇编器的信息, 用于指导汇编器的汇编操作.
LC-3汇编器只有<span class="math inline">\(5\)</span>种伪操作:</p>
<ol type="1">
<li><code>.ORIG</code>:
<code>.ORIG</code>告诉汇编器将LC-3程序放在内存的什么位置,例如<code>.ORIG x3050</code>表示”从”x3050”开始,
于是<code>LD R1,SIX</code>这一条指令就被放在”x3050”处.</li>
<li><code>.FILL</code>: <code>.FILL</code>告诉汇编器开始占用下一个地址,
并且填充初始值(如其操作数),
如<code>SIX .FILL x0006</code>,即该单元被初始化为<code>x0006</code>.</li>
<li><code>.BLKW</code>: <code>.BLKW</code>告诉汇编器在程序空间中,
开始占用一连串的地址空间,
具体的占用数目由<code>.BLKW</code>的伪操作数决定.</li>
<li><code>.STRINGZ</code>:
<code>.STRINGZ</code>告诉汇编器连续占用并初始化<span
class="math inline">\(n+1\)</span>个内存单元,
其参数(或操作数)是双括号括起来的<span
class="math inline">\(n\)</span>个字符. <span
class="math inline">\(n+1\)</span>个内存单元的前<span
class="math inline">\(n\)</span>个字的内容分别是字符串对应字符的ASCII码的零扩展,
内存的最后一个字则被初始化为<span class="math inline">\(0\)</span>.
最后的这个字符<code>x0000</code>通常为ASCII码的处理提供了”哨兵机制”.
例如下面的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      .ORIG x3010</span><br><span class="line">HELLO .STRINGZ &quot;Hello, World!&quot;      </span><br></pre></td></tr></table></figure>
<p>导致汇编器将内存x3010到x301D初始化为如下内容:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;">对应字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x3010</td>
<td style="text-align: center;">x0048</td>
<td style="text-align: center;">H</td>
</tr>
<tr>
<td style="text-align: center;">x3011</td>
<td style="text-align: center;">x0065</td>
<td style="text-align: center;">e</td>
</tr>
<tr>
<td style="text-align: center;">x3012</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3013</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x3014</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3015</td>
<td style="text-align: center;">x002C</td>
<td style="text-align: center;">,</td>
</tr>
<tr>
<td style="text-align: center;">x3016</td>
<td style="text-align: center;">x0020</td>
<td style="text-align: center;">空格</td>
</tr>
<tr>
<td style="text-align: center;">x3017</td>
<td style="text-align: center;">x0057</td>
<td style="text-align: center;">W</td>
</tr>
<tr>
<td style="text-align: center;">x3018</td>
<td style="text-align: center;">x006F</td>
<td style="text-align: center;">o</td>
</tr>
<tr>
<td style="text-align: center;">x3019</td>
<td style="text-align: center;">x0072</td>
<td style="text-align: center;">r</td>
</tr>
<tr>
<td style="text-align: center;">x301A</td>
<td style="text-align: center;">x006C</td>
<td style="text-align: center;">l</td>
</tr>
<tr>
<td style="text-align: center;">x301B</td>
<td style="text-align: center;">x0064</td>
<td style="text-align: center;">d</td>
</tr>
<tr>
<td style="text-align: center;">x301C</td>
<td style="text-align: center;">x0021</td>
<td style="text-align: center;">!</td>
</tr>
<tr>
<td style="text-align: center;">x301D</td>
<td style="text-align: center;">x0000</td>
<td style="text-align: center;">空字符</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li><code>.END</code>: <code>.END</code>告诉汇编器”程序结束了”.</li>
</ol>
<h4 id="汇编过程">汇编过程</h4>
<p>我们先看如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.ORIG    x3000                  ;这是伪操作, 不是第一条指令</span><br><span class="line">         AND      R2, R2, #0    ;x3000 这才是第一条指令</span><br><span class="line">         LD       R3, PTR       ;x3001</span><br><span class="line">         TRAP     x23           ;x3002</span><br><span class="line">         LDR      R1, R3, #0    ;x3003</span><br><span class="line"></span><br><span class="line">TEST     ADD     R4, R1, #-4    ;x3004 检测到TEXT</span><br><span class="line">         BRz     OUTPUT         ;x3005</span><br><span class="line"></span><br><span class="line">         NOT      R1, R1        ;x3006</span><br><span class="line">         ADD      R1, R1, R0    ;x3007</span><br><span class="line">         NOT      R1, R1        ;x3008</span><br><span class="line">         BRnp     GETCHAR       ;x3009</span><br><span class="line">         ADD      R2, R2, #1    ;x300A</span><br><span class="line"></span><br><span class="line">GETCHAR  ADD      R3, R3, #1    ;x300B 检测到GETCHAR</span><br><span class="line">         LDR      R1, R3, #0    ;x300C</span><br><span class="line">         BRnzp    TEST          ;x300D</span><br><span class="line"></span><br><span class="line">OUTPUT   LD       R0, ASCII     ;x300E 检测到OUTPUT</span><br><span class="line">         ADD      R0, R0, R2    ;x300F</span><br><span class="line">         TRAP     x21           ;x3010</span><br><span class="line">         TRAP     x25           ;x3011</span><br><span class="line"></span><br><span class="line">ASCII    .FILL    x0030         ;x3012 检测到ASCII, 这条指令的意思是, 在地址x3012处装入内容x0030</span><br><span class="line">PTR      .FILL    x4000         ;x3013 检测到PTR, 这条指令的意思是, 在地址x3013处装入内容x4000</span><br><span class="line">         .END</span><br></pre></td></tr></table></figure>
<h5 id="两遍扫描">两遍扫描</h5>
<p>汇编器在将汇编指令翻译成对应的机器指令前,
需要对整个汇编程序从头到尾(从开始到<code>.END</code>)扫描一遍,
为的是在第一遍扫描时先确定符号名对应的二进制地址,
即确定所有符号和地址之间的映射关系.
我们称这个映射集合为<strong>符号表</strong>. 在建立完符号表之后,
汇编器就可以一行一行进行翻译了.</p>
<p>总之, 第一遍扫描负责符号表的创建,
第二遍扫描负责将所有汇编指令翻译成对应的机器指令.</p>
<h6 id="第一遍扫描">第一遍扫描</h6>
<p>第一遍扫描的具体操作如下:</p>
<ol type="1">
<li>丢弃掉所有注释</li>
<li><code>.ORIG</code>后面的第一条有效指令所分配的地址就是<code>.ORIG</code>后的参数.
为了方便说明, 我们采用”地址跟踪计数器LC”,
LC的初始值由<code>.ORIG</code>指定, 也就是x3000.</li>
<li>每识别出一条有效指令, LC的值加<span
class="math inline">\(1\)</span>.
如果当前指令行的<strong>头部存在”标识”字段</strong>,
那么就为该标识创建符号表项, 其地址值就是当前LC的内容</li>
<li>继续识别下一条指令, 直至<code>.END</code></li>
</ol>
<p>按照上面的操作创建的符号表如下</p>
<table>
<thead>
<tr>
<th style="text-align: center;">符号名</th>
<th style="text-align: center;">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">TEST</td>
<td style="text-align: center;">x3004</td>
</tr>
<tr>
<td style="text-align: center;">GETCHAR</td>
<td style="text-align: center;">x300B</td>
</tr>
<tr>
<td style="text-align: center;">OUTPUT</td>
<td style="text-align: center;">x300E</td>
</tr>
<tr>
<td style="text-align: center;">ASCII</td>
<td style="text-align: center;">x3012</td>
</tr>
<tr>
<td style="text-align: center;">PTR</td>
<td style="text-align: center;">x3013</td>
</tr>
</tbody>
</table>
<h6 id="第二遍扫描">第二遍扫描</h6>
<p>没什么好说的, 就是把汇编语言翻译成二进制代码.</p>
<p>这里需要说明一下, 在编译到<code>LD R3, PTR ;x3001</code>这一条指令时,
<code>PTR</code>的地址为<code>x3013</code>,
而此时的PC+1为<code>x3002</code>, LC为<code>x3001</code>,
由于<code>PTR</code>的地址为PC+1和符号扩展之后的PCoffset值之和,
因而可以计算出PCoffset字段的内容是<code>x0011</code>. 注意,
<code>LD</code>指令中的源操作数的地址(即<code>PTR</code>)不能超出<code>LD</code>指令所在位置的+256或者-255,
也就是说,如果<code>PTR</code>的地址大于<code>LC+1+256</code>或者小于<code>LC+1-255</code>,
那么该偏移值就会超出了指令<code>bit[8:0]</code>字段所能表示的范围.</p>
<h4 id="其他">其他</h4>
<h5 id="可执行映像">可执行映像</h5>
<p>当计算机开始程序的执行时, 执行实体又称为”可执行映像”.
可执行映像通常是由多个相互独立的模块组装在一起形成的,
而这些模块通常又是由不同的程序员, 不同的语言(例如汇编语言, C语言,
Python等)分别编写的, 且有些模块是用户编写的, 有些则是操作系统的库程序.
所有这些模块在组装之前, 是一个个独立的目标文件,
最后通过<strong>连接</strong>操作将这些目标拼装成一个可执行映像.</p>
<h5 id="多目标文件">多目标文件</h5>
<p>待完成</p>
<h3 id="输入输出">输入/输出</h3>
<h4 id="输入输出概述">输入/输出概述</h4>
<p>我们需要找到一种方法, 将待处理的信息输入到计算机系统中,
并将计算机处理后的结果以人们可以理解的方式输出.</p>
<h5 id="设备寄存器">设备寄存器</h5>
<p>和一个I/O设备进行交互, 我们需要多个<strong>设备寄存器</strong>,
即使是最简单的I/O设备, 也至少需要两个寄存器:</p>
<ol type="1">
<li>用来保持和计算机之间传输的数据</li>
<li>指示当前设备的状态信息, 如”设备是否空闲”, “最近处理的I/O任务”等</li>
</ol>
<h5 id="内存映射io与专用io指令">内存映射I/O与专用I/O指令</h5>
<p>指令访问I/O设备寄存器时, 需要明确指明目标寄存器.
通常有两种方法实现:</p>
<ol type="1">
<li>一些计算机厂家采用专门的I/O指令来访问, 即”专用I/O指令”(不常见)</li>
<li>采用内存操作指令完成I/O操作, 即”内存映射I/O”(常用)</li>
</ol>
<p>程序员使用与内存访问相同的指令来操作I/O,
所以设备的每个输入输出寄存器都必须有一个和内存中位置相同的标识方式.
为此, 在ISA的内存地址空间中, 专门划分出一段地址,
用于设备寄存器的标识映射. 换句话说,
I/O设备的寄存器被”映射”到一组地址(这些地址是分配给I/O寄存器的,
而不是分配给内存位置的), 即所谓”内存映射I/O”方式.</p>
<p>LC-3采用内存映射I/O方式,
其中<code>0x0000~0xFDFF</code>的地址空间用于标识内存,
<code>0xFE00~0xFFFF</code>则保留给外部设备使用.</p>
<h5 id="异步io与同步io">异步I/O与同步I/O</h5>
<p>下面考虑程序员的输入字符操作, 每输入一个字符,
该字符的ASCII码就会被存入键盘输入寄存器中, 然后CPU执行load指令时,
如果目标地址指向键盘输入寄存器, 则将该ASCII码值读入计算机.</p>
<p>I/O设备和处理器的工作节奏是不一致的,
因此我们称I/O设备和CPU之间是异步的. 异步通信方式下,
需要通过一定的协议或者握手机制来控制发送和接收.</p>
<p>实现同步的最简单方式是采用标志.
键盘状态寄存器中的标志位提供了最简单的一种握手机制:
打字员每输入一个字符, 该标志位(Ready位)就被置位, 而每次处理器读取之后,
都自动将该标志位清零. 所以在每次读取输入字符之前,
处理器都会检查该Ready位, 如果Ready位为<span
class="math inline">\(0\)</span>, 表示没有新的字符输入,
处理器不再读取输入寄存器, 否则有新的字符输入, 则处理器执行Load指令,
读入输入寄存器的ASCII码值.</p>
<h5 id="中断驱动和轮询">中断驱动和轮询</h5>
<p>I/O设备和处理器交互的方式有两种: 中断驱动和轮询.
它们之间的根本区别在于谁控制这个交互.</p>
<p>以键盘和CPU之间的交互为例, 如果由键盘控制交互过程,
那么处理器只需要做自己的事情, 当键盘数据准备好时,
它会主动通知寄存器进行读取, 这种就是”中断驱动”.
而如果交互过程是由处理器控制, 那么处理器必须不断读取,
测试状态寄存器的内容, 直到Ready位被置位(说明有新的字符输入),
于是从寄存器中读取数据, 这种就是”轮询”.</p>
<h4 id="键盘输入">键盘输入</h4>
<p>将字符从键盘输入需要两个条件:</p>
<ol type="1">
<li>数据寄存器: 用来存放键盘输入字符的ASCII值,
这可以通过<strong>键盘数据寄存器(<code>KBDR</code>,地址是<code>0xFE02</code>)</strong>实现,<code>KBDR</code>的第0~7位用来储存输入字符的ASCII码.</li>
<li>同步机制: 用告诉处理器数据已经准备好的方法,
这可以通过<strong>键盘状态寄存器(<code>KBSR</code>,地址是<code>0xFE00</code>)</strong>实现,<code>KBSR</code>的第15位用以储存同步信息(Ready位).</li>
</ol>
<p><code>KBSR[15]</code>的作用是控制处理器(快速)和键盘(慢速)之间的同步.
当某个按键被按下, 该键对应的ASCII码被存入<code>KBDR[7:0]</code>的同时,
键盘硬件电路自动将<code>KBSR[15]</code>置为1;
当LC-3读取<code>KBDR</code>时, 键盘自动清除<code>KBSR[15]</code>.
<code>KBSR[15]=0</code>意味着键盘可以继续输入,
而<code>KBSR[15]=1</code>意味着上次输入的字符还没有被取走,
即键盘无法继续输入其他字符. 在轮询(处理器控制的I/O)方式下,
程序将反复读取并测试<code>KBSR[15]</code>位.</p>
<p>如下程序的功能是将键盘<code>KBDR</code>寄存器中的ASCII值读取到本地寄存器<code>R0</code>中,然后跳转至下一个任务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START    LDI   R1,A</span><br><span class="line">         BRzp  START</span><br><span class="line">         LDI   R0,B</span><br><span class="line">         BRnzp NEXT_TASK</span><br><span class="line">A        .FILL xFE00</span><br><span class="line">B        .FILL xFE02</span><br></pre></td></tr></table></figure>
<p>解释: 第一二行构成<code>KBSR[15]</code>的循环测试,
<code>LDI</code>指令将地址<code>0xFE00</code>(<code>0xFE00</code>是<code>KBSR</code>寄存器的内存映射地址)处的值载入<code>R1</code>,
如果<code>KBSR[15]=0</code>, 则程序跳回<code>START</code>处继续循环,
如果有键盘输入的话,
那么该键的ASCII码被装入<code>KBDR</code>,同时<code>KBSR[15]</code>被置位(这是最高位,
如果被置位, 那么<code>R1</code>中的值就是负数, 这一点很重要),
这意味着程序进入第三行代码,
<code>LDI</code>指令将地址<code>0xFE02</code>(<code>0xFE02</code>是<code>KBDR</code>寄存器的内存映射地址)处的值载入<code>R0</code>.于是读取键盘输入过程完毕,程序无条件跳转至<code>NEXT_TASK</code>.</p>
<h4 id="显示器输出">显示器输出</h4>
<p>在显示器工作时:</p>
<ol type="1">
<li>输出数据寄存器是<code>DDR</code>, 内存映射地址是<code>0xFE06</code>,
<code>DDR</code>的第7~0位用来存放数据</li>
<li>状态寄存器是<code>DSR</code>,内存映射地址是<code>0xFE04</code>,
<code>DSR</code>的第15位是Ready位</li>
</ol>
<p><code>DSR[15]</code>用来同步处理器(快速)和显示器(慢速).
在LC-3将单个字符的ASCII码输入到<code>DDR[7:0]</code>的同时,
显示器硬件电路自动把<code>DSR[15]</code>清零(表示显示器”忙”,当前正在处理字符),
然后开始<code>DDR[7:0]</code>的数据的处理;
当显示器完成字符到屏幕的输出后, 电路自动将<code>DSR[15]</code>置位,
这表示显示器已经完成工作, 处理器可以继续下一个字符的输出.</p>
<p>下面这段程序是将<code>R0</code>中的字符输出到显示器上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">START LDI   R1, A</span><br><span class="line">      BRzp  START</span><br><span class="line">      STI   R0, B</span><br><span class="line">      BRnzp NEXT_START</span><br><span class="line">A .FILL xFE04</span><br><span class="line">B .FILL xFE06</span><br></pre></td></tr></table></figure>
<p>解释: 前两行反复测试<code>DSR[15]</code>,
如果其值为1(也就是<code>R1</code>是负数),
表示显示器已经完成前一个字符的显示, 那么程序跳到第三行,
把<code>R0</code>中的值放入<code>xFE06</code>,
也就是<code>DDR[7:0]</code>中,
同时硬件电路将自动清除<code>DSR[15]</code>.</p>
<h4 id="中断驱动io">中断驱动I/O</h4>
<p>中断驱动I/O的本质是, I/O设备可以实现下列功能:</p>
<ol type="1">
<li>强行中止当前程序的运行</li>
<li>使得处理器执行I/O设备的请求</li>
<li>最后恢复中断程序的执行, 并且让它感觉好像什么事情都没发生过一样</li>
</ol>
<p>中断驱动的一个优点就是, 如果I/O设备采用轮询方式,
处理器将会花费大量时间检测Ready位, 但是采用中断方式, 如果中断没有发生,
处理器可以执行其他程序, 当中断发生时, 处理器才暂停当前程序,
并自动调用相应的I/O处理程序.</p>
<h5 id="中断信号的产生">中断信号的产生</h5>
<p>中断驱动I/O包括两部分内容:</p>
<ol type="1">
<li>中断使能机制, 即I/O设备是如何通知处理器的(当设备有输入数据,
或者输出部件准备就绪时)</li>
<li>传输机制, 即I/O数据是如何在处理器和设备之间传输</li>
</ol>
<p>这两部分可以简单描述为:</p>
<ol type="1">
<li>产生中断信号, 中止当前执行程序</li>
<li>处理该中断请求</li>
</ol>
<p>我们这里先介绍第一部分的内容, 而第二部分的内容则需要用到堆栈.
设备是否必须, 且能否中断处理器(也即第一部分内容),
必须具备以下几个条件:</p>
<ol type="1">
<li>I/O设备自身确实需要服务</li>
<li>设备有请求服务的权限</li>
<li>设备中断请求的优先级高于当前处理器所运行程序的优先级</li>
</ol>
<p>如果以上三个要求都满足, 则处理器才会中止当前程序,
并相应设备的中断请求.</p>
<h5 id="来自设备的中断信号">来自设备的中断信号</h5>
<p>对于条件1(I/O设备自身确实需要服务),
就是<code>KBSR</code>和<code>DSR</code>的寄存器Ready位,
I/O设备通过设置Ready位来表示”请求服务”.</p>
<p>对于条件2(设备有请求服务的权限), 是指”中断使能标志”,
处理器通过设置该标志位, 控制I/O设备是否有上报中断的权限.
如果该标志位为1, 表示处理器允许设备发送中断信号, 否则,
表示处理器禁止接收来自该设备的中断信号.
通常状态寄存器中会包含”中断允许标志(IE)“.
<strong><code>KBSR</code>和<code>DSR</code>的第14位即为中断允许标志,
来自I/O设备的中断请求信号是IE和Ready位的逻辑与(AND)结果.</strong></p>
<h5 id="中断优先级">中断优先级</h5>
<p>对于条件3(设备中断请求的优先级高于当前处理器所运行程序的优先级),
LC-3定义了<span class="math inline">\(8\)</span>个优先级别(PL0~PL7),
数值越大, 对应的优先级越高.
一个程序的PL通常与请求运行该程序的PL(即紧迫度)相同.
如果程序当前正在运行一个特定的PL,
而此时来了一个更高级别的PL计算机访问请求,
那么当前这个优先级较低的程序将被挂起, 直到更高级的程序完成那个请求之后,
被挂起的程序才能恢复执行.
<strong>中断优先级是通过优先级编码器(一个组合逻辑电路)实现的,
它可以从中断信号中选出优先级最高的一个,
且如果被选出的优先级比当前程序优先级高, 那么则会成功生成INT中断信号,
并中止当前程序.</strong></p>
<p>详细来说, 假如我们有PL0设备, PL1设备, …, PL7设备,
它们的状态寄存器的第14, 15位AND之后, 同时输入一个优先级编码器,
从中选出一个优先级最高的一个, 产生一个3bit的输出A,
然后将这个3bit的输出A和当前程序的优先级PL B(也是3bit)进行比较,
如果A&gt;B, 那么就会成功生成INt信号.</p>
<h5 id="中断检测">中断检测</h5>
<p>指令的执行过程包括六个节拍:</p>
<p>取指令–&gt;译码–&gt;地址计算–&gt;取操作数–&gt;执行–&gt;存放结果</p>
<p>在增加了中断信号检测逻辑之后, 原先的最后一步操作,
即从存放结果到取指令的操作将出现变化:
<strong>在存放结果的同时还会进行中断信号INT的测试.</strong>
如果INT未被设置, 那么一切照旧, 控制单元将会直接返回取指令节拍;
如果INT信号有效, 则控制单元在返回取指令节拍之前, 必须完成两件事情,
一是保持足够的信息, 以备以后可以正常恢复被中断程序的执行环境,
二是将即将服务于该设备请求的程序入口地址装入PC寄存器.</p>
<h3 id="trap程序及其子程序">TRAP程序及其子程序</h3>
<p>我们需要知道, 一些资源是用户程序无法直接访问的,
它们只能被一些有合适权限的程序访问,
而”操作系统”就是有特权权限的程序.</p>
<p>以<code>TRAP</code>指令为例,
如果用户在<code>x4000</code>处要执行I/O任务,
它会请求操作系统以用户程序的身份完成这个任务. 操作系统接过控制权,
分析并处理<code>TRAP</code>指令传递的服务要求,
然后再将控制权交还给<code>x4001</code>地址的指令.
我们称这种用户程序的请求为服务调用或者系统调用.</p>
<h4 id="trap机制">TRAP机制</h4>
<p>TRAP机制包含以下要素:</p>
<ol type="1">
<li><strong>服务程序集合:</strong> 由操作系统提供, 但以用户身份执行.
这些服务程序是操作系统的组成部分, 起始于各自固定的内存地址.
LC-3最多可以支持256个服务程序.</li>
<li><strong>起始地址表:</strong> 包含256个服务程序的起始地址.
该表位于内存地址<code>x0000~x00FF</code>. 在不同的操作系统中,
该表的名称也不一样, 有的称为”系统控制块”, 有的称为”陷入矢量表”.</li>
<li><strong>TRAP指令:</strong>
用户程序如果希望操作系统以用户程序身份执行某个特定的服务程序,
并在执行结束后将控制权返回, 则可以使用TRAP指令</li>
<li><strong>链接:</strong> 通过链接返回用户程序.
它意味着操作系统所提供的从服务程序返回用户程序的机制</li>
</ol>
<h4 id="trap指令">TRAP指令</h4>
<p>在执行服务程序之前, TRAP指令需要先完成两件事:</p>
<ol type="1">
<li>根据陷入矢量表项的内容, 将PC值修改为对应于服务程序的起始地址</li>
<li>提供一种机制, 返回到调用TRAP指令的子程序.
我们称该返回机制为链接</li>
</ol>
<p>TRAP指令由两部分组成: 操作码<code>1111</code>和陷入矢量编号<span
class="math inline">\(\rm{bit}[7:0]\)</span>. 位<span
class="math inline">\([11:8]\)</span>全部为<span
class="math inline">\(0\)</span>.
陷入矢量标识了用户程序希望操作系统执行的服务程序,
例如下面的陷入矢量为<code>x23</code>.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 1 1</td>
<td style="text-align: center;">0 0 0 0</td>
<td style="text-align: center;">0 0 1 0 0 0 1 1</td>
</tr>
</tbody>
</table>
<p>TRAP指令在执行时,需要完成<span
class="math inline">\(4\)</span>项任务:</p>
<ol type="1">
<li>将8 bit的陷入矢量零扩展为16 bit地址, 并装入MAR,
例如<code>x23</code>扩展为<code>x0023</code>.</li>
<li>陷入矢量表位于内存<code>x0000~x00FF</code>,
表项<code>x0023</code>的内容(假设为<code>x04A0</code>)装入MDR</li>
<li>将当前PC值存入寄存器<code>R7</code>,
以实现返回用户程序的链接机制</li>
<li>将MDR的内容装入PC, 至此完成TRAP指令</li>
</ol>
<p>现在, PC的内容变成了<code>x04A0</code>,
因而程序从地址<code>x04A0</code>开始执行.
<code>x04A0</code>指向的是操作系统”键盘读入”程序的起始.
我们说该陷入矢量指向该TRAP程序的起始.
所以<code>TRAP x23</code>指令的作用是激活操作系统”键盘读入”的服务程序.</p>
<p>TRAP程序能够返回用户程序的下一条指令(服务程序结束之后)的前提是,
必须存在机制以保存下条指令的地址. 所以TRAP指令会在服务程序加载到PC之前,
先将原来的PC值存入<code>R7</code>. 换句话说,
TRAP指令为服务程序返回用户程序提供了所有必要的信息.
由于在TRAP指令的预取阶段, PC已经更新, 指向下一条指令,
所以在TRAP服务程序开始执行时,
<code>R7</code>中包含的是TRAP指令的下一条指令地址.</p>
<h4 id="完整机制">完整机制</h4>
<p>我们知道, 若要改变程序控制流程, 就要在当前指令的”执行”阶段修改PC值,
之后的下一个周期, CPU将会从新地址处读取指令.</p>
<p>因而, 如果要请求字符输入服务, 我们只需要在用户程序中,
调用TRAP指令的第<code>x23</code>号矢量即可.
TRAP指令将从内存地址<code>x0023</code>读取其内容<code>x04A0</code>,
并将其加载到PC中, 同时将下一条指令的地址装入<code>R7</code>.
在下一个指令周期的”取指令”节拍, 将从<code>x04A0</code>开始执行,
即请求键盘输入的操作系统服务程序.
该TRAP服务程序的结尾是<code>JMP R7</code>指令,
其作用是将<code>R7</code>的内容装入PC.
如果<code>R7</code>的内容在服务程序的执行过程中没有改变,
那么该值就是用户程序中TRAP指令的下一条指令的地址. 随后,
用户程序继续执行,
<code>R0</code>的内容就是刚才键盘输入的字符的ASCII码.</p>
<p>在TRAP服务程序中,<code>JMP R7</code>指令非常有用,
为此LC-3汇编语言中专门为这个操作定义了一个专用指令字<code>RET</code>,
如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1 1 0 0</td>
<td style="text-align: center;">0 0 0</td>
<td style="text-align: center;">1 1 1</td>
<td style="text-align: center;">0 0 0 0 0 0</td>
</tr>
</tbody>
</table>
<h4 id="halt中断程序">HALT中断程序</h4>
<p>在现代计算机中,用TRAP指令方式来清除RUN门.在LC-3中,RUN门的内容对应机器控制寄存器(映射内存地址<code>xFFFE</code>)的第15位.</p>
<h4 id="寄存器内容的保持和恢复">寄存器内容的保持和恢复</h4>
<p>在下面的情况中, 我们需要显式地保持寄存器的内容:</p>
<ol type="1">
<li>如果该寄存器的内容会被后续操作修改</li>
<li>如果后续操作会使用该寄存器</li>
</ol>
<p>一个寄存器的原内容, 如果在修改成其他值之后还需要被使用,
那么在修改之前, 必须要将原值保存, 修改后再将其恢复. 保存的方法是,
将寄存器内容存入内存的某个位置, 恢复时, 再重新装入寄存器即可.</p>
<p>对于保存和恢复的问题, 既可以由调用程序在TRAP之前负责,
也可以由被调用程序(TRAP执行之后)来负责.
我们称<strong>由调用程序来负责该问题的方式为”调用者保存”</strong>,
称<strong>由被调用者来保存的方式为”被调用者保存”</strong>. 因此,
对于被调用者来说, 由于它知道自己的程序需要使用哪些寄存器,
所以它在执行之前会将这些程序依次放入内存, 执行结束时,
再将这些原值恢复到寄存器中. 对于调用者来说, 它知道在自己程序的操控下,
哪些寄存器的内容会被破坏, 因此在调用服务程序之前,
就把相关寄存器的内容保存到内存, 在服务程序结束之后,
恢复寄存器的原值.</p>
<h4 id="子程序">子程序</h4>
<p>我们称可以重复利用的代码为”子程序”或者”过程”,
而C语言的属于则称之为”函数”. 它们的使用机制则被称为”调用/返回机制”.</p>
<h5 id="调用返回机制">调用/返回机制</h5>
<p>调用机制的过程是, 首先计算子程序的开始地址, 然后装入PC,
然后保存调用返回地址(下一条指令地址). 在返回机制中,
将把返回地址再装入PC.</p>
<p>调用/返回机制和TRAP指令的执行过程非常相似, 两种情况下,
都是先保存返回调用程序的链接地址,
然后将程序流跳转至代码段(服务程序或者子程序). 其中,
PC装入的都是代码段的起始地址,
<code>R7</code>装入的都是返回调用者的链接地址; 代码段的最后一条语句,
无论是在中断服务程序还是子程序中, 都是<code>JMP R7</code>指令,
也就是将<code>R7</code>的内容装入PC,从而将控制权返回到调用者.</p>
<p>子程序和服务程序之间的主要区别在于TRAP指令, 在TRAP方式下,
服务程序调用了操作系统资源, 因而具备访问计算机底层硬件的特权.
它们通常由系统程序员编写, 相比之下,
子程序和调用程序可以由同一个程序员编写.</p>
<h5 id="jsrjsrr指令">JSR/JSRR指令</h5>
<p>在LC-3中, 子程序调用的指令的操作码是<code>0100</code>.
该指令的寻址模式(计算子程序的起始地址)有两种:
PC相对地址寻址和基地址寻址. 在LC-3汇编语言中, 两种模式的操作码相同,
但是助记符不同. 该指令完成两件事: 首先将返回地址存入<code>R7</code>,
然后将计算子程序起始地址并装入PC, 返回的地址就是跳转前已经增量的PC地址,
它指向调用程序中紧随JSR/JSRR指令之后的那一条指令.</p>
<p>JSR/JSRR指令由三部分组成</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">A</td>
<td style="text-align: center;">address evaluation bits</td>
</tr>
</tbody>
</table>
<p>其中: <span class="math inline">\(\rm{bit}[15:12]=0100\)</span>
为操作码 <span class="math inline">\(\rm{bit}[11]\)</span> 表示寻址模式,
<span class="math inline">\(1\)</span>代表PC相对寻址模式, <span
class="math inline">\(0\)</span>代表基地址寻址 <span
class="math inline">\(\rm{bit}[10:0]\)</span>
用于子程序的起始地址计算</p>
<p>JSR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PCoffet11</td>
</tr>
</tbody>
</table>
<p>地址计算方法是, 将递增后的PC值和符号位扩展后的<span
class="math inline">\(\rm{bit}[10:0]\)</span>相加.</p>
<p>例如, 有一条位于<code>x4200</code>处的JSR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">10000000100</td>
</tr>
</tbody>
</table>
<p>这条指令执行后, R7寄存器的内容为<code>x4201</code>(也就是PC+1).
PCoffset11符号扩展为<span
class="math inline">\(1111~1100~0000~0100\)</span>, 其取反加一为<span
class="math inline">\(0000~0011~1111~1100\)</span>, 用当前的PC+1(<span
class="math inline">\(0100~0010~0000~0001\)</span>)减去这个值得到<span
class="math inline">\(0011~1110~0000~0100\)</span>也就是<code>x3E05</code>,
即此时的PC值为<code>x3E05</code>.</p>
<p>JSRR指令如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>地址计算方法是, 将递增后的PC值和基址寄存器的内容相加.</p>
<p>例如， 有一条位于<code>x420A</code>的JSRR指令如下,
R5的内容为<code>x3002</code>,</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>这条指令执行后, R7的内容为PC+1, 也就是<code>x420B</code>,
而当前PC的内容就是R5寄存器的内容， 也就是<code>x3002</code>.</p>
<h3 id="栈">栈</h3>
<h4 id="栈的基本结构">栈的基本结构</h4>
<p>“栈”的概念, 是指它的访问规则. <strong>“栈”的定义是, 最后存入的东西,
总是被第一个取走的, 我们称这种特点为”后入先出”或”LIFO,Last In First
Out”.</strong> 按照计算机的术语来说,
栈是一种<strong>抽象数据类型</strong>,
抽象数据类型指的是其存储机制的操作方式(而不是实现方法).</p>
<p>下面是栈在内存中的实现</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFB</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFD</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">&lt;-top</td>
</tr>
<tr>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">//////</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">&lt;-top</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x4000</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFF</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFC</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">R6</td>
<td style="text-align: center;">x3FFE</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">初始状态</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">压入一次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">压入三次</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">弹出两次</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>栈是由一段连续内存空间和一个寄存器(栈指针)组成.
所谓”栈指针”就是一个寄存器, 里面的内容是一个地址值,
<strong>始终指向栈的顶部(即最近被压入的元素)</strong>.
上面的第一列代表最初的空栈, 第二列压入了值<span
class="math inline">\(18\)</span>, 第三列依次压入了<span
class="math inline">\(31\)</span>, <span
class="math inline">\(5\)</span>和<span
class="math inline">\(12\)</span>, 最后依次弹出值<span
class="math inline">\(12\)</span>和<span
class="math inline">\(5\)</span>,
其内容依旧存留在内存位置<code>x3FFD</code>和<code>x3FFC</code>处,
但是这两个值不能再被访问, 因为这一段内存只能通过栈机制来访问.</p>
<h5 id="压入">压入</h5>
<p>对于上面的栈的第一列, <code>R6</code>的内容是<code>x4000</code>,
即基地址(<code>x3FFF</code>)之前的一个位置, 这表明此时栈是空的.
当压入<span class="math inline">\(18\)</span>时,
栈指针指向了最后压入的值, 即<code>x3FFF</code>(储存<span
class="math inline">\(18\)</span>的位置). <strong>每压入一个值,
栈指针先递减, 然后将数值存入它所指向的地址位置</strong>,
对应的汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP      ADD   R6,R6,#-1</span><br><span class="line">         STR   R0,R6,#0</span><br></pre></td></tr></table></figure>
<h5 id="弹出">弹出</h5>
<p>如果想要从栈里面弹出一个元素,
<strong>要先通过指针提供的地址读取该数值, 然后递增指针</strong>,
对应的汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP      LDR   R0,R6,#0</span><br><span class="line">         ADD   R6,R6,#1</span><br></pre></td></tr></table></figure>
<p>其中栈顶的元素被弹出, 装入<code>R0</code>.</p>
<h5 id="下溢出">下溢出</h5>
<p>如果试图对一个空栈执行弹出操作, 将造成”下溢”问题.
为了检查是否发生”下溢”, 常用的做法是,
子程序将执行成功或者失败的信息记录在某个寄存器中. 在POP程序的流程中,
将成功或者失败的信息记录在<code>R5</code>中. 那么, POP程序返回后,
调用程序通过<code>R5</code>就可以获知执行是否成功(如果成功,
<code>R5=0</code>, 否则<code>R5=1</code>). 注意,
由于POP程序使用<code>R5</code>记录执行情况,
这就要求调用程序在<code>JSR</code>指令之前, 保持<code>R5</code>的内容.
对应的POP汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POP      LD    R1,EMPTY</span><br><span class="line">         ADD   R2,R6,R1</span><br><span class="line">         BRz   Failure</span><br><span class="line">         LDR   R0,R6,#0</span><br><span class="line">         ADD   R6,R6,#1</span><br><span class="line">         AND   R5,R5,#0</span><br><span class="line">         RET</span><br><span class="line">Failure  AND   R5,R5,#0</span><br><span class="line">         ADD   R5,R5,#1</span><br><span class="line">         RET</span><br><span class="line">EMPTY    .FILL xC000</span><br></pre></td></tr></table></figure>
<p>注意<code>RET</code>之前的那一条指令可以影响条件码,
所以调用程序也可以进行条件位<code>Z</code>的测试,
判断POP程序是否执行成功.</p>
<h5 id="上溢出">上溢出</h5>
<p>如果在栈空间全部被占用的情况下, 再往栈中压入元素,
那么就会发生”上溢”问题. 和”下溢”相似, 通过比较栈指针内容和栈底的地址,
可以判断是否发生”上溢”. 如果两个值相等, 则意味着栈空间已经满了.
要求PUSH程序在执行成功之时, 把数值<span
class="math inline">\(0\)</span>存入<code>R5</code>, 失败时将数值<span
class="math inline">\(1\)</span>存入<code>R5</code>. 于是,
PUSH程序返回后, 调用程序通过检查<code>R5</code>的内容,
即可判断PUSH的执行是否成功. PUSH汇编指令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUSH     LD    R1,MAX</span><br><span class="line">         ADD   R2,R6,R1</span><br><span class="line">         BRz   Failure</span><br><span class="line">         ADD   R6,R6,#-1</span><br><span class="line">         STR   R0,R6,#0</span><br><span class="line">         AND   R5,R5,#0</span><br><span class="line">         RET</span><br><span class="line">Failure  AND   R5,R5,#0</span><br><span class="line">         ADD   R5,R5,#1</span><br><span class="line">         RET</span><br><span class="line">MAX      .FILL xC005</span><br></pre></td></tr></table></figure>
<h4 id="中断驱动io-1">中断驱动I/O</h4>
<p>我们回忆中断驱动I/O包括两个部分:</p>
<ol type="1">
<li>中断使能机制: 在有输入数据需要传递或者准备好接收输出数据的情况下,
I/O设备具备向处理器发出中断的能力.</li>
<li>I/O数据传输的管理能力(即中断处理程序)</li>
</ol>
<p>所谓的中断使能机制, 就是发出INT信号的能力, 通过READY和IE的组合,
设备可以发出中断请求信号,
且只有在中断使能信号大于当前程序优先级的情况下, INT信号才能有效.</p>
<p>而中断处理程序包含以下三个阶段:</p>
<ol type="1">
<li>中断服务程序的启动</li>
<li>中断服务程序的执行</li>
<li>中断服务程序的返回</li>
</ol>
<h5 id="启动和执行">启动和执行</h5>
<p>当一个设备成功发出INT信号时, 就会启动中断. 从处理器角度来看,
它每执行完一条指令之后, 都会检查INT信号, 如果INT信号有效,
则暂停下一条指令的读取, 如果无效, 则继续下一条指令的执行.</p>
<p>此时开始中断执行的准备工作, 以启动中断服务程序,
准备工作包括如下内容:</p>
<ol type="1">
<li><strong>保存当前执行程序的状态</strong>, 使得从中断服务程序返回时,
可以从当前的程序继续运行</li>
<li><strong>装载中断服务程序的工作状态</strong>, 开始中断请求的服务</li>
</ol>
<h6 id="程序状态">程序状态</h6>
<p>所谓程序状态, 就是该程序运行所涉及的资源的快照.
<strong>它包括程序的内存空间和通用寄存器的内容,
以及两个重要的寄存器PC和PSR.</strong> PSR寄存器就是处理器状态寄存器,
它包含了与运行程序相关的重要信息, 具体字段含义如下:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">15</th>
<th style="text-align: center;">14 13 12 11</th>
<th style="text-align: center;">10 9 8</th>
<th style="text-align: center;">7 6 5 4 3</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Pr</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PL</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Z</td>
<td style="text-align: center;">P</td>
</tr>
</tbody>
</table>
<p>其中</p>
<ol type="1">
<li><code>PSR[15]</code>表示该程序的运行模式,
特权模式/超级用户模式和非特权模式/用户模式. 所谓特权模式,
就是指在该模式下, 程序可以访问一般用户程序所不能访问的资源.</li>
<li><code>PSR[10:8]</code>表示正在执行程序的优先级别,
总共有8种优先级PL0~PL8</li>
<li><code>PSR[2:0]</code>表示条件码</li>
</ol>
<h6 id="被中断程序的状态保存">被中断程序的状态保存</h6>
<p>中断启动的第一个任务, 就是保存正在运行程序的状态,
使得I/O设备请求的服务完成后, 程序可以继续运行. 对于LC-3,
也就是保存PC和PSR.</p>
<ol type="1">
<li>保存<strong>PC</strong>,
是因为它保存了中断返回后的下一条指令的地址</li>
<li>保存<strong>条件码</strong>, 是因为后续程序可以用它完成条件跳转</li>
<li>保存<strong>被中断程序的优先级</strong>,
是因为它提供被中断程序与其他程序相比的迫切程度, 被中断程序的恢复执行时,
可能还会有其他级别的程序再次中断它</li>
<li>保存<strong>被中断程序的特权级别</strong>,
是因为它表明了被中断程序可以访问的资源范围</li>
</ol>
<p>注意第2, 3, 4条都包含在PSR中.</p>
<p>一般情况下, 我们认为通用寄存器的内容没有必要进行保存,
因为我们假定中断服务程序在动用它们之前已经自动保存了,
并且在中断返回前恢复原值.</p>
<p>LC-3将这些需要保持的信息存放在”超级用户栈”中,
该栈空间只供特权模式下的程序使用, 它们也是内存空间的一部分,
只是它与用户程序的用户栈空间是相互隔离的.</p>
<p>所有程序都通过<code>R6</code>栈指针来访问栈空间: 在用户模式下,
<code>R6</code>指向用户栈空间, 在超级用户模式下,
<code>R6</code>指向超级用户栈空间. 在未使用的情况下,
内部寄存器Saved.SSP(超级用户栈指针寄存器)和Saved.USP(用户栈指针寄存器)分别用于保存两个栈指针的内容,
例如, 当特权模式从用户模式切换到超级用户模式时,
原先的<code>R6</code>内容就会被放入Saved.USP内,
然后将Saved.SSP的内容放入<code>R6</code>.
这意味着在中断服务程序开始之前,
<code>R6</code>已经装入了超级用户栈指针的内容,
而PC和PSR寄存器的内容已经被压入超级用户栈.</p>
<h6 id="中断服务程序的状态装入">中断服务程序的状态装入</h6>
<p>被中断程序的状态信息被装入超级用户栈之后,
下一步的任务是装入中断服务程序的PC和PSR内容,
中断服务程序和TRAP指令很相似, 它们的代码都事先存放于特定的内存地址中,
它们服务的都是中断请求.</p>
<p>在中断情况下, I/O设备在发出中断时, 向处理器传递一个8
bit的矢量值(以及中断请求信号和设备优先级).
在多个设备同时请求中断处理的情况下, 优先级最高的请求被选中并交给处理器,
我们称之为INTV, 如果该中断被处理器接收, 它将该8
bit的中断矢量(INTV)扩展成一个16 bit的地址,
即中断矢量表中的某一个表项地址.
中断矢量表的内存地址为<code>x0100~x01FF</code>(TRAP矢量表的内存地址为<code>x0000~x00FF</code>),
每个表项包含了一个中断服务程序的起始地址,
处理器将扩展之后的中断矢量INTV地址的内容(即表项矢量的内容)装入PC.</p>
<p>PSR寄存器的装入过程如下: 由于在中断服务程序中, 还没有指令执行过,
所以<code>PSR[2:0]</code>的内容初始化为0,
而中断服务程序是在特权模式下运行的, 所以<code>PSR[15]=0</code>,
<code>PSR[10:8]</code>被设置为中断请求者(即设备)的优先级.</p>
<p>至此我们就完成了中断服务的启动阶段.</p>
<h6 id="中断服务">中断服务</h6>
<p>此时PC的内容就是中断服务程序的起始地址,
所以下一个开始执行的就是中断服务程序了, 即I/O设备的请求开始被服务了</p>
<h6 id="中断返回">中断返回</h6>
<p>中断服务程序的最后, 是中断返回指令RTI. 当处理器遇到RTI指令时,
表明I/O设备的请求已经完成.</p>
<p>RTI指令(操作码1000)的任务是, 将PC和PSR的内容弹出超级用户栈,
然后将它们填入处理器中的正确的位置. 现在,
条件码的值已经恢复成程序被中断之前的值,
同样特权级别<code>PSR[15]</code>和优先级别<code>PSR[10:8]</code>的内容也被恢复,
PC的内容恢复成中断前的下一条待执行指令.</p>
<h6 id="例子-嵌套中断">例子: 嵌套中断</h6>
<p>程序A位于内存地址<code>x3000~x3010</code>,
在执行<code>x3006</code>的<code>ADD</code>指令时, 设备B发出了中断请求,
导致矢量<code>xF1</code>的INT产生.</p>
<p>设备B的中断服务程序位于内存地址<code>x6200~x6210</code>中,
<code>x6210</code>处为RTI指令,
在执行<code>x6202</code>的<code>AND</code>指令时, 设备C又发出了中断请求,
导致矢量<code>xF2</code>的INT产生.</p>
<p>设备C的中断服务程序位于内存地址<code>x6300~x6315</code>中,
<code>x6315</code>处为RTI指令</p>
<p>下面是该例子在运行过程中, 超级用户栈和PC的内容快照:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
<th style="text-align: center;">地址</th>
<th style="text-align: center;">内容</th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">对应设备B的PSR</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;">&lt;-R6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">程序A的PSR</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;">&lt;-Saved.SSP</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">????</td>
<td style="text-align: center;">&lt;-Saved.SSP</td>
</tr>
<tr>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x3006</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6200</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6300</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x6203</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">PC</td>
<td style="text-align: center;">x3007</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>第一列是程序A在读取<code>x3006</code>指令前的超级用户栈和PC值.
注意图中标识的栈指针是Saved.SSP, 而不是<code>R6</code>.
由于此时中断尚未发生, 所以<code>R6</code>指向的是用户栈.
在<code>x3006</code>指令执行的最后, 检测到INT信号(来自设备B的中断).</p>
<p>第二列是程序A的状态被保存在超级用户栈, 为了可以使用超级用户栈,
先将当前<code>R6</code>的内容放入Saved.USP寄存器,
然后将Saved.SSP的内容放入<code>R6</code>,
随后PC的内容(也就是程序A的下一条指令的地址)<code>x3007</code>被压入超级用户栈,
同样, <code>ADD</code>指令产生的操作码和PSR信息也被压入超级用户栈;
再随后, 设备B的中断矢量扩展为<code>x01F1</code>,
<code>x01F1</code>的内容<code>x6200</code>被装入PC.
设备B的中断服务程序开始执行</p>
<p>第三列是在<code>x6202</code>指令执行周期结束时,
又检测到更高优先级的中断, 随后,
地址<code>x6203</code>被压入超级用户栈中,
同时被压入的还有B程序的PSR内容(包含<code>AND</code>指令产生的条件码信息),
设备C的中断矢量被扩展为<code>x01F2</code>,
<code>x01F2</code>的内容<code>x6300</code>被装入PC.
设备C的中断服务程序开始执行.</p>
<p>第四列是程序C在执行<code>x6315</code>的RTI指令之后,
超级用户栈被两次弹出,
一是恢复程序B的PSR内容(包含位于<code>x6202</code>的<code>AND</code>指令所产生的条件码),
二是恢复PC的内容为<code>x6203</code>.</p>
<p>第五列是程序B从<code>x6203</code>开始恢复执行,
直到<code>x6210</code>的RTI指令结束, 超级用户栈再次被弹出两次,
恢复程序A的PSR(包括位于<code>x3006</code>处的<code>ADD</code>指令所产生的条件码)和PC(<code>x3007</code>).
之后, 由于程序A运行在用户模式下,
所以<code>R6</code>的内容被存入Saved.SSP,
装入<code>R6</code>的是Saved.USP的内容. 最后,
程序A从<code>x3007</code>的指令开始继续执行.</p>
<h2 id="第三部分c语言">第三部分:C语言</h2>
<h3 id="高级语言翻译">高级语言翻译</h3>
<p>高级语言有两种翻译方法:</p>
<ol type="1">
<li>解释执行, 负责翻译的程序称为”解释器”, 它读入高级语言程序,
然后按照高级程序的语义执行相应的操作. 真正的执行者不是高级语言代码本身,
而是解释器程序</li>
<li>编译执行, 负责翻译的程序称为”编译器”, 它将高级语言程序读入,
然后翻译成机器代码, 又称为可执行映像,
该映像是可以直接在机器上执行的.</li>
</ol>
<p>无论是解释器还是编译器, 其本身也是一个程序.</p>
<h4 id="解释执行">解释执行</h4>
<p>解释器逐个读入每条命令, 然后按照语言规范的语义完成命令.
高级语言程序只是向解释器提供一组”数据”, 而不能直接被硬件执行. 换句话说,
解释器如同一个虚拟机, 高级语言只是在虚拟机上被执行的程序.</p>
<h4 id="编译执行">编译执行</h4>
<p>在编译执行方式中, 整个高级语言被全部翻译成机器码, 然后在机器上执行.
为了保证程序翻译的有效性, 在翻译之前,
编译器会在更大的范围内做分析(通常是整个源文件). 通常程序只需要编译一次,
然后就可以多次执行. 编译器是这样一个系统,
它能处理一个或者多个包含高级语言程序的文件, 生成一个”可执行映像”,
编译器本身不执行程序, 它只负责翻译任务, 即将高级语言翻译成机器语言.</p>
<h3 id="c编程语言">C编程语言</h3>
<p>这里采用的C语言遵循ANSI C标准, 只要编译器是ANSI C兼容的,
那么就可以编译这里的C语言代码.</p>
<h4 id="c编译器">C编译器</h4>
<p>C编译器能够将C源程序翻译为一个可执行映像.
可执行映像是一个用机器语言表示的, 具备内存装载信息的可执行程序.
整个编译过程将涉及预处理器, 编译器和链接器等组件.
通常我们把它们统称为”编译器”. 编译器在处理过程中,
将自动调用预处理器和链接器等组件.</p>
<ol type="1">
<li>预处理器: C预处理器扫描所有的C源文件,
寻找并执行其中的预处理指令.</li>
<li>编译器: 经过预处理之后的程序, 由编译器继续翻译成”目标模块”.
目标模块是程序的一个组成部分, 是机器语言代码形式. 编译过程包括两个阶段.
一是”分析”或”语法分析”, 即将源程序分解为更小的组成单元; 二是”合成”,
即生成机器语言代码. 分析阶段的任务是读入, 分析源代码,
并构建编译器内部格式的数据结构; 而合成阶段的任务则是生成机器码,
以及根据编译指令优化机器代码. 符号表是编译器中一个重要的内部数据结构,
它记录了程序中使用过的所有符号.</li>
<li>链接器: 所有的目标代码生成后, 将由链接器完成后续处理.
链接器的任务是将各个目标模块组装成一个可执行映像.
可执行映像是一种具有特定格式的机器语言程序,
具有可装载性和可直接执行这两个特性. C程序对于库函数的依赖非常强.
库函数中包含了最常用的一些操作函数, 它们以库函数的方式存在.
这些库函数通常由系统软件(如操作系统, 编译器)的开发者编写. 在用户程序中,
如果调用了库函数, 则链接器将负责查找该函数在库文件中的位置,
并拷贝对应目标代码, 然后”链接”入可执行映像.</li>
</ol>
<h3 id="变量和运算符">变量和运算符</h3>
<h4 id="变量">变量</h4>
<h5
id="三种基本数据类型intchardouble">三种基本数据类型:int,char,double</h5>
<ol type="1">
<li><code>int</code>: 标识符<code>int</code>声明的是一个有符号整数变量.
整数类型的内部表示及其数值大小的范围, 取决于不同的ISA以及所使用的编译器.
一般情况下, C语言的<code>int</code>和底层的ISA的字长相对应.</li>
<li><code>char</code>:
标识符<code>char</code>声明的是一个字符类型的数据.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> key=<span class="string">&#x27;Q&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里变量<code>key</code>的初始值是大写字母<code>Q</code>的ASCII码值.注意<code>Q</code>被单引号包围,表明这是一个ASCII字符值.</p>
<ol start="3" type="1">
<li><code>double</code>:
标识符<code>double</code>声明的是一个浮点类型变量.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">2.1E2</span>; <span class="comment">/*这是210.0*/</span></span><br><span class="line"><span class="type">double</span> b = <span class="number">-2E-1</span>; <span class="comment">/*这是-0.2*/</span></span><br></pre></td></tr></table></figure>
<h5 id="局部变量和全局变量">局部变量和全局变量</h5>
<p>在C语言中, 程序中的变量声明是向编译器传递以下三类信息: 变量的标识符,
类型, 作用域. 对于前两者, 编译器可以直接从变量声明语句中获取,
但是有关作用域, 编译器则要通过声明语句所在位置判断.</p>
<ol type="1">
<li>局部变量: 有些变量是在它们所在代码块的开始处声明, 我们称为局部变量.
这里所说的代码块指的是用一对大括号包括起来的代码.
局部变量只能在当前代码块中被访问.</li>
<li>全局变量: 全局变量在整个程序的生命周期内都占有独立的空间及其内容,
可以在程序的任意地方被访问.</li>
</ol>
<h4 id="运算符">运算符</h4>
<h5 id="赋值运算符">赋值运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">x = x + <span class="number">4</span>;</span><br><span class="line">x = x + <span class="number">4.0</span>;  </span><br></pre></td></tr></table></figure>
<h5 id="算数运算符">算数运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x + y;</span><br><span class="line">x - y;</span><br><span class="line">x * y;</span><br><span class="line">x / y;</span><br><span class="line">x % y; <span class="comment">/*取余数*/</span></span><br></pre></td></tr></table></figure>
<h5 id="位运算符">位运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1234</span> &amp; <span class="number">0x5678</span>;  <span class="comment">/*按位与，等于0x567C*/</span></span><br><span class="line"><span class="number">0x1234</span> | <span class="number">0x5678</span>;  <span class="comment">/*按位或，等于0x1230*/</span></span><br><span class="line"><span class="number">0x1234</span> ^ <span class="number">0x5678</span>;  <span class="comment">/*按位异或，等于0x444C*/</span></span><br><span class="line">~<span class="number">0x1234</span>;          <span class="comment">/*按位取反，等于0xEDCB*/</span></span><br><span class="line"><span class="number">1234</span> &amp; <span class="number">5678</span>;      <span class="comment">/*按位与，等于1026*/</span></span><br><span class="line"><span class="number">0x1234</span> &lt;&lt; <span class="number">3</span>;      <span class="comment">/*左移3位，右边补0，等于0x91A0*/</span></span><br><span class="line"><span class="number">0x1234</span> &gt;&gt; <span class="number">2</span>;      <span class="comment">/*右移2位，左边符号扩展，等于0x048D*/</span></span><br><span class="line"><span class="number">1234</span> &lt;&lt; <span class="number">3</span>;        <span class="comment">/*等于9872*/</span></span><br><span class="line"><span class="number">1234</span> &gt;&gt; <span class="number">2</span>;        <span class="comment">/*等于308*/</span></span><br></pre></td></tr></table></figure>
<h5 id="关系运算符">关系运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;,&lt;,&lt;=,&gt;=,==,!=;</span><br></pre></td></tr></table></figure>
<h5 id="逻辑运算符">逻辑运算符</h5>
<p>在C语言中, 任何非零值都是逻辑真, 数值零被认为逻辑假.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!        <span class="comment">/*逻辑非*/</span></span><br><span class="line">&amp;&amp;       <span class="comment">/*逻辑与*/</span></span><br><span class="line">||       <span class="comment">/*逻辑或*/</span></span><br></pre></td></tr></table></figure>
<h5 id="递增递减运算符">递增/递减运算符</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = x++;    <span class="comment">/*先把x赋给y，然后自增*/</span></span><br><span class="line">y = ++x;    <span class="comment">/*x先自增，然后把新的值赋给y*/</span></span><br></pre></td></tr></table></figure>
<h4 id="编译器处理">编译器处理</h4>
<p>编译器在完成翻译工作的时候, 需要借助于两个机制:</p>
<ol type="1">
<li>符号表: 编译器在编译过程中, 将与变量相关的信息记录在”符号表”中.</li>
<li>内存的系统分配: 根据变量特性分配内存. 编译器将从整个系统层面,
为不同类别的对象划分不同的内存区域.</li>
</ol>
<p>我们看一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> amount;</span><br><span class="line">   <span class="type">int</span> rate;</span><br><span class="line">   <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> hours;</span><br><span class="line">   <span class="type">int</span> minutes;</span><br><span class="line">   <span class="type">int</span> seconds;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;How many bytes of data to be transferred?&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;amount);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;What is the transfer rate?&quot;</span>)</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rate)</span><br><span class="line"></span><br><span class="line">   time = amount / rate;</span><br><span class="line"></span><br><span class="line">   hours = time / <span class="number">3600</span>;</span><br><span class="line">   minutes = (time % <span class="number">3600</span>) /<span class="number">60</span>;</span><br><span class="line">   seconds = ((time % <span class="number">3600</span>) % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Time: %dh %dm %ds\n&quot;</span>, hours, minutes, seconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="符号表">符号表</h5>
<p>编译器在扫描程序代码时, 每遇到一个变量声明语句,
就在符号表中创造一个新的表项. 表项结构中包含很多字段信息,
这些字段信息与变量的存储空间管理以及变量操作代码生成等都有关.
这些字段包括: 名字, 类型, 已分配的内存地址,
变量声明域或作用域等信息.</p>
<p>下面的符号表对应上面的代码. 注意,
编译器采用偏移方式记录变量在内存中的位置.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">标识</th>
<th style="text-align: center;">类型</th>
<th style="text-align: center;">位置(偏移量)</th>
<th style="text-align: center;">范围</th>
<th style="text-align: center;">其他信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">amount</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">hours</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-3</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">minutes</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-4</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">rate</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">seconds</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-5</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
<tr>
<td style="text-align: center;">time</td>
<td style="text-align: center;">int</td>
<td style="text-align: center;">-2</td>
<td style="text-align: center;">main</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
<h5 id="变量的空间分配">变量的空间分配</h5>
<p>在C语言中, 存放变量内容的内存空间(变量的分配空间)有两种区段:
<strong>全局数据段</strong>和<strong>运行时栈</strong>.
全局数据段是内存中存放全局变量的区段, 运行时栈是局部变量所在的地方.
符号表中的偏移字段提供了有关变量在内存中的更精确的位置信息,
它代表的是变量存储地址距离内存段基地址的偏移(或距离).</p>
<p>在编译器生成的机器代码中, R4是一个专用寄存器,
它存放的是全局数据段的基地址(或起始地址), 所以R4可以被视为是全局指针.
而一个函数中所有的局部变量都存放在一个被称为<strong>活动记录</strong>或者<strong>堆栈帧</strong>的内存模板中.
所谓的活动记录, 就是一段连续的内存空间,
它包含了当前函数中所有的局部变量. 每个函数都有自己的活动记录.
当我们调用一个函数时, 该函数活动记录的最大地址将存放在寄存器R5中,
因此R5又被称为<strong>帧指针</strong>.</p>
<p>当我们调用一个函数时, 该函数的活动记录被压入当前栈.
同时R5的内容被调整, 指向当前栈顶(即记录的基地址).
这表明可以通过栈指针访问函数内的局部变量. 当该函数结束,
即将把控制权交还给调用者时, 活动记录将被弹出当前栈. 同样,
指针R5的内容也会被修改, 指向调用者活动记录所在位置. 整个过程中,
寄存器R6始终指向运行时栈顶, 我们称R6为<strong>栈指针</strong>.</p>
<h3 id="控制结构">控制结构</h3>
<p>一个大问题被分解成多个子任务, 然后对每个子任务独立编程.
各种子任务的基本编程结构可以分为顺序, 条件和循环.</p>
<h4 id="条件结构">条件结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">10</span>)</span><br><span class="line">   y= x^<span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">   y= x^<span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line">   z= <span class="number">2</span>*y - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x)&#123;</span><br><span class="line">   y++;</span><br><span class="line">   z--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   y--;</span><br><span class="line">   z++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> month;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of the month:&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(month==<span class="number">4</span> || month==<span class="number">6</span> || month==<span class="number">9</span> || month==<span class="number">11</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has 30 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(month==<span class="number">1</span> || month==<span class="number">3</span> || month==<span class="number">5</span> || month==<span class="number">7</span> || month==<span class="number">8</span> || month==<span class="number">10</span> || month==<span class="number">12</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has 31 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(month==<span class="number">2</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The month has either 29 days or 28 days\n&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t know that month.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环结构">循环结构</h4>
<h5 id="while语句">while语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      x = x + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="for语句">for语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> multiplicand;</span><br><span class="line">   <span class="type">int</span> multiplier;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(multiplicant=<span class="number">0</span>; multiplicant&lt;<span class="number">10</span>; multiplicant++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(multiplier=<span class="number">0</span>; multiplier&lt;<span class="number">10</span>; multiplier++)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, multiplier*multiplicant);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-while循环">do-while循环</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, x);</span><br><span class="line">   x = x + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (x &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="其他控制结构">其他控制结构</h4>
<h5 id="switch语句">switch语句</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> keypress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(keypress)&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement A*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement B*/</span></span><br><span class="line">   <span class="keyword">break</span>;   </span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement C*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">   <span class="comment">/*statement D*/</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="break和continue语句">break和continue语句</h5>
<p><code>break</code>的作用是立即结束其所在的循环体.<code>continue</code>的作用是,立即跳转至下一次循环.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;<span class="comment">/*output:0 1 2 3 4*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;<span class="comment">/*output:0 1 2 3 4 6 7 8 9*/</span></span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<h4 id="c语言中的函数">C语言中的函数</h4>
<h5 id="声明">声明</h5>
<p>函数声明告诉编译器函数的一些相关属性,我们又称之为”函数原型”.函数声明的内容包括:函数名,返回值类型以及输入参数列表.函数声明语句以分号结尾.</p>
<ol type="1">
<li>函数返回值类型是声明语句的第一个字段.该类型可以说int,char,double等,它描述了函数将产生的输出结果(唯一的).但是不是所有函数都有返回值,如果没有返回值,那么就称它的返回类型是void.</li>
<li>第二个字段是函数名.</li>
<li>第三个字段描述了函数所需的输入参数的类型和顺序,它们是该函数期望从调用者获取的参数类型和传入顺序.</li>
</ol>
<h5 id="调用">调用</h5>
<p>调用是只需提供函数名和对应的输入参数,注意输入参数的类型要与声明中的类型相匹配.</p>
<h5 id="定义">定义</h5>
<p>函数定义和函数声明几乎一样,除了前者后面不需要分号.函数名后面是函数的正则化参数列表,所谓正则化参数列表就是一组变量的声明,每个变量的内容都被初始化为调用者提供的对应数值.调用者传递的形式参数必须和正则化参数列表中定义的参数类型和顺序相匹配.</p>
<h5 id="返回">返回</h5>
<p>如果函数要返回一个值,那么关键词<code>return</code>必须跟随一个表达式,且该表达式的类型必须与函数声明的返回值类型相匹配.而没有返回值的函数(声明为<code>void</code>的函数),不需要<code>return</code>语句.</p>
<h4 id="c语言函数的实现">C语言函数的实现</h4>
<h2 id="第四部分cache">第四部分:Cache</h2>
<h3 id="计算机存储系统概述">计算机存储系统概述</h3>
<p>内部存储器有寄存器, 主存, Cache, 以字节或者字为单位表示;
外部存储器有光盘, 磁带, 磁盘等, 以字节表示.</p>
<p>存取时间: 从地址放到总线上到获得有效数据所需的时间,
是一次读/写操作的时间.</p>
<p>存储周期: 存取时间+下一次存取开始之前所需的时间</p>
<p>传送速率: 数据传入或传出存储单元的速率</p>
<p>物理类型: 半导体, 磁介质, 光介质; 物理特性: 易失性存储器,
非易失性存储器.</p>
<p>计算机的存储系统利用了局部性原理.</p>
<h3 id="cache存储器原理">Cache存储器原理</h3>
<p>Cache的作用: Cache位于CPU和主存之间, 当CPU试图访问主存内的某个字时,
首先检查这个字是否在Cache中, 如果是, 那么直接把这个字传送给CPU; 否则,
就将存储中<strong>包含这个字的固定大小的块</strong>读入Cache中,
然后再传送改字到CPU.</p>
<p>主存的结构: 由<span
class="math inline">\(2^n\)</span>个可寻址的字/字节组成(<span
class="math inline">\(n\)</span>为地址线长度),
主存分成定长的块(每块包含<span class="math inline">\(K\)</span>字节),
因此主存有<span class="math inline">\(M=2^n/K\)</span>个块.</p>
<p>Cache的结构: 包含<span class="math inline">\(m\)</span>行,
每一行包括: <span
class="math inline">\(K\)</span>个字节的块+标记Tag(标记当前存储的哪一行)+控制位.</p>
<p><strong>主存的每一个块对应于Cache的一行.</strong></p>
<h4 id="cache的读操作流程">Cache的读操作流程</h4>
<ol type="1">
<li>CPU请求内存位置的内容</li>
<li>检查此数据的Cache</li>
<li>如果存在, 则直接从Cache中获取</li>
<li>如果不存在, 则从主存中读取所需的块到Cache</li>
<li>然后Cache交付给CPU</li>
<li>Cache包括标签, 用于标识每个缓存行对应哪个主存块</li>
</ol>
<h3 id="cache结构的设计">Cache结构的设计</h3>
<h4 id="cache的映射">Cache的映射</h4>
<h5 id="直接映射">直接映射</h5>
<p>直接映射就是主存中的块会映射到一个固定的Cache行.</p>
<p>在直接映射关系中地址(<span
class="math inline">\(s+w\)</span>)可以分成两部分:</p>
<ul>
<li>高<span
class="math inline">\(s\)</span>位用于指定主存中唯一的块</li>
<li>低<span
class="math inline">\(w\)</span>位用于指定某个块中唯一的一个字或者字节</li>
</ul>
<p>高<span
class="math inline">\(s\)</span>位又被分成一个Cache行字段<span
class="math inline">\(r\)</span>(用于确定块属于哪一确定的行)和一个<span
class="math inline">\(s-r\)</span>位的标签Tag(用于区分属于同一行的不同块).</p>
<p>总结:</p>
<ul>
<li>地址长度<span class="math inline">\(=s+w\)</span>位</li>
<li>可寻址单位数<span
class="math inline">\(=2^{s+w}\)</span>字/字节</li>
<li>块大小<span class="math inline">\(=\)</span>行大小<span
class="math inline">\(=2^w\)</span>字/字节</li>
<li>主存中块数<span class="math inline">\(=2^{s+w}/2^w=2^s\)</span></li>
<li>Cache中的行数<span class="math inline">\(=m=2^r\)</span></li>
<li>标签的大小<span class="math inline">\(=s-r\)</span>位</li>
</ul>
<p>优点: 技术简单, 实现起来花费少. 缺点: 可能出现抖动现象.</p>
<h5 id="全相联映射">全相联映射</h5>
<p>存储器地址只有两部分:</p>
<ul>
<li>标签Tag: 可确定并标识唯一的一个主存的块</li>
<li>字Word: 可确定块中的唯一一个字节</li>
</ul>
<p>主存中的某个块可以被对应到任意的Cache的行.</p>
<p>优点: 替换旧的数据块很灵活.</p>
<p>缺点: 硬件复杂.</p>
<h5 id="组相连映射">组相连映射</h5>
<p>组相连映射是直接映射和全相联映射折中的方法.</p>
<p>Cache被划分为多个组, 每一组又被划分成多个行,
主存中的一个块可以被映射到一个固定组的任一行.</p>
<ul>
<li>地址长度为<span class="math inline">\(s+w\)</span>位</li>
<li>块大小<span class="math inline">\(=\)</span>行大小<span
class="math inline">\(=2^w\)</span>个字/字节</li>
<li>主存的块数<span class="math inline">\(2^s\)</span></li>
<li>Cache每个组的行数<span class="math inline">\(=k\)</span></li>
<li>Cache的组数<span class="math inline">\(v=2^d\)</span></li>
<li>Cache的存储容量<span class="math inline">\(=k\times
2^d\)</span></li>
</ul>
<p>Cache被分成<span class="math inline">\(v=2^d\)</span>组,
每一组里面有<span class="math inline">\(k\)</span>行, 内存中的头<span
class="math inline">\(v\)</span>个块, 每个块映射到对应的第<span
class="math inline">\(v\)</span>个组中的任一行.
地址的标记Tag字段只需要与组内的<span
class="math inline">\(k\)</span>行进行匹配即可,
Word字段选择行中的第<span class="math inline">\(2^w\)</span>个字节.</p>
<h4 id="替换算法">替换算法</h4>
<p>对于直接映射, 没有选择, 因为每个数据块必须被映射到Cache的固定行,
直接替换掉对应的行数据即可.</p>
<p>对于全相联和组相联映射, 有如下的替换方法:</p>
<ul>
<li>最近最少使用</li>
<li>先进先出</li>
<li>最不经常使用</li>
<li>随机</li>
</ul>
<h4 id="cache的写策略">Cache的写策略</h4>
<h5 id="写直达策略">写直达策略</h5>
<p>所有写操作同时写主存和缓存, 这样主存中的数据总是有效的.
CPU监控主存流量, 以保持和Cache一致. 缺点是大量的数据交换,
减慢写入速度.</p>
<h5 id="写回策略">写回策略</h5>
<p>最初仅在Cache内进行数据更新, Cache行中设有更新位, 当数据更新发生时,
更新位被设置. 如果块被替换或者被替换算法选中,
只有当更新位被设置才会写入主存, 其他的缓存不同步.
缺点是部分主存内容无效, 由于这部分主存内容无效, I/O不能直接访问主存,
必须通过缓存访问主存, 硬件复杂.</p>
<h2 id="附录-lc-3指令集结构">附录 LC-3指令集结构</h2>
<h3 id="概述">概述</h3>
<ul>
<li>内存地址空间: 16位地址, 对应<span
class="math inline">\(2^{16}\)</span>个内存单元, 每个单元包含一个字,
每个字宽度是<span class="math inline">\(16\)</span>位.
地址的编号从x0000到xFFFF,
地址是用来识别每个内存单元和内存映射的I/O设备寄存器.
内存中的部分区段有特殊用途, 划分如下:
<ol type="1">
<li>x0000~x00FF: 陷入矢量表</li>
<li>x0100~x01FF: 中断矢量表</li>
<li>x0200~x2FFF: 操作系统及其内核栈空间</li>
<li>x3000~xFDFF: 用户程序占用空间</li>
<li>xFE00~xFFFF: 设备寄存器地址空间</li>
</ol></li>
<li>位编号: 量化数的每个位也是有编号的. 通常, 最右边的位是<span
class="math inline">\(\rm{bit}[0]\)</span>, 最左边的位是<span
class="math inline">\(\rm{bit}[15]\)</span>.</li>
<li>指令: 每个指令的宽度是<span class="math inline">\(16\)</span>位,
前四位(<span
class="math inline">\(\rm{bit}[15:12]\)</span>)是操作码.</li>
<li>非法操作码异常: 操作码<span
class="math inline">\(\rm{bit}[15:12]=1101\)</span>是没有定义的.</li>
<li>程序计数器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的一个寄存器,
内容是下一条执行指令所在的地址.</li>
<li>通用寄存器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的八个寄存器, 编号从<span
class="math inline">\(000\)</span>到<span
class="math inline">\(111\)</span>.</li>
<li>条件码: <span
class="math inline">\(1~\rm{bit}\)</span>宽度的三个寄存器, 分别是N , Z,
P. Load类型的指令和运算指令在向任意一个通用寄存器中写入内容时,
都会改变条件码. 而其他的指令不会改变条件码.</li>
<li>内存映射: 设备的输入输出是通过Load和Store指令完成的,
所以需要为I/O设备寄存器分配内存地址(xFE00~xFFFF).</li>
<li>中断处理</li>
<li>优先级: LC-3定义了<span class="math inline">\(8\)</span>个优先级,
其中PL7最高, PL0最低.</li>
<li>处理器状态寄存器: <span
class="math inline">\(16~\rm{bit}\)</span>宽度的寄存器,
包含了当前执行进程的状态信息. 其中PSR的<span
class="math inline">\(8\)</span>个位已经做了定义,
PSR[15]定义了执行进程的权限模式, PSR[10:8]表示当前执行进程的优先级别,
PSR[2:0]包含的是条件码(PSR[2]=N, PSR[1]=Z, PSR[0]=P).</li>
<li>权限模式: LC-3定义了两种权限模式, 特权模式和用户模式.
PSR[15]=0表示特权模式, PSR[15]=1表示用户模式.</li>
<li>权限模式异常: 如果RTI指令执行在特权模式下,
但是你试图在用户模式下执行RTI指令, 那么会产生”权限模式异常”</li>
<li>特权模式栈空间: 又称为内核栈空间. 在特权模式下,
通过SSP指针访问该内存区域. 事实上, 特权模式PSR[15]=0下,
栈指针R6就是SSP</li>
<li>用户模式栈空间: 在用户模式下, 通过USP指针访问该内存区域. 事实上,
特权模式PSR[15]=1下, 栈指针R6就是USP</li>
</ul>
<h3 id="lc-3指令集详解">LC-3指令集详解</h3>
<h4 id="add">ADD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD DR, SR1, SR2</span><br><span class="line">ADD DR, SR1, imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1+SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1+SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD R2, R3, R4      ;R2&lt;-R3+R4</span><br><span class="line">ADD R2, R3, #7      ;R2&lt;-R3+7</span><br></pre></td></tr></table></figure>
<h4 id="and">AND</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND DR, SR1, SR2</span><br><span class="line">AND DR, SR1, imm5</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3</th>
<th style="text-align: center;">2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">SR2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0101</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">imm5</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bit[<span class="number">5</span>]==<span class="number">0</span>)</span><br><span class="line">   DR=SR1 AND SR2;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   DR=SR1 ANd SEXT(imm5);</span><br><span class="line">setcc()</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AND R2, R3, R4      ;R2&lt;-R3 AND R4</span><br><span class="line">AND R2, R3, #7      ;R2&lt;-R3 AND 7</span><br></pre></td></tr></table></figure>
<h4 id="br">BR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BR  LABEL   BRnzp LABEL</span><br><span class="line">BRn LABEL   BRzp  LABEL</span><br><span class="line">BRz LABEL   BRnp  LABEL</span><br><span class="line">BRp LABEL   BRnz  LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">z</td>
<td style="text-align: center;">p</td>
<td style="text-align: center;">PCoffset9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((n AND N) OR (z AND Z) OR (p AND P))</span><br><span class="line">   PC=(PC+<span class="number">1</span>)+SEXT(PCoffset9)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BRzp LOOP      ;如果最后的结果是零或者正数,那么跳转至LOOP</span><br><span class="line">BR   NEXT      ;无条件跳转至NEXT</span><br></pre></td></tr></table></figure>
<h4 id="jmp和ret">JMP和RET</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   BaseR</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1100</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC=BaseR</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMP   R2    ;PC&lt;-R2</span><br><span class="line">RET         ;PC&lt;-R7</span><br></pre></td></tr></table></figure>
<p>注意:RET指令可以看作JMP指令的一个特例,PC被装入R7的内容,R7扮演的是链接的作用,其内容指向子程序调用指令之后的指令地址.</p>
<h4 id="jsr和jsrr">JSR和JSRR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   LABEL</span><br><span class="line">JSRR  BaseR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">PCoffet11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11</th>
<th style="text-align: center;">10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0100</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (bit[<span class="number">11</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=BaseR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   PC=PC+SEXT(PCoffset11);</span><br></pre></td></tr></table></figure>
<p>解释:增量PC值先保存在R7中,这是返回调用代码的链接地址,然后PC装入被调用子程序的入口地址,即等价于无条件跳转至该地址.子程序的入口地址来自基址寄存器或者是PC增量和偏移量的符号扩展之和.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSR   QUEUE    ;将JSR指令之后的地址装入R7,然后跳转至QUEUE</span><br><span class="line">JSRR  R3       ;将JSRR指令之后的地址装入R7,然后跳转至R3内容所指定的地址</span><br></pre></td></tr></table></figure>
<h3 id="load系列指令">Load系列指令</h3>
<h4 id="ld">LD</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem((PC+<span class="number">1</span>)+SEXT(PCoffset9));</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD  R4, VALUE      ;R4&lt;-mem[VALUE]</span><br></pre></td></tr></table></figure>
<h4 id="ldi">LDI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1010</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将其对应地址中的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDI  R4, ONEMORE      ;R4&lt;-mem[mem[ONEMORE]]</span><br></pre></td></tr></table></figure>
<h4 id="ldr">LDR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR DR, BaseR, offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">PCoffet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=mem[BaseR+SEXT(offset6)];</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容装入DR寄存器,同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR  R4, R2, #-5    ;R4&lt;-mem[R2-5]</span><br></pre></td></tr></table></figure>
<h4 id="lea">LEA</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA DR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1110</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=(PC+<span class="number">1</span>)+SEXT(PCoffset9);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址直接装入DR寄存器(无需访问内存,只是将计算出来的内存单元的地址放入DR中),同时设置条件码.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA  R4, TERTGET    ;R4&lt;-address of TARTGET</span><br></pre></td></tr></table></figure>
<h3 id="not">NOT</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT DR, SR</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1001</td>
<td style="text-align: center;">DR</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11111</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR=NOT(SR);</span><br><span class="line">setcc();</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOT R4, R2    ;R4&lt;-NOT(R2)</span><br></pre></td></tr></table></figure>
<h3 id="rti">RTI</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTI</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1000</td>
<td style="text-align: center;">000000000000</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PSR[<span class="number">15</span>]==<span class="number">0</span>)</span><br><span class="line">   PC=mem[R6];    <span class="comment">//R6是SSP</span></span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   TEMP=mem[R6];</span><br><span class="line">   R6=R6+<span class="number">1</span>;</span><br><span class="line">   PSR=TEMP;</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<p>解释:如果当前处理器运行在特权模式,则该指令是合法的,特权模式栈顶部两个单元的内容被弹出,并分别赋值给PC和PSR.如果当前处理器运行在用户模式,则该指令的执行将引发”特权模式冲突”异常.</p>
<h3 id="store系列指令">Store系列指令</h3>
<h4 id="st">ST</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST SR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offset6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[(PC+<span class="number">1</span>)+SEXT(PCoffset9)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入改地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ST    R4, HERE     ;mem[HERE]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="sti">STI</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI SR, LABEL</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1011</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">PCoffet9</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[mem((PC+<span class="number">1</span>)+SEXT(PCoffset9))]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将PC增量和偏移量的符号扩展相加,计算出一个地址,然后将这个地址的内存单元的内容作为地址,再次读取内存,将SR的内容装入这个地址中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STI   R4, NOT_HERE      ;mem[mem[NOT_HERE]]&lt;-R4</span><br></pre></td></tr></table></figure>
<h4 id="str">STR</h4>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   SR, BaseR, offset6</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9</th>
<th style="text-align: center;">8 7 6</th>
<th style="text-align: center;">5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0111</td>
<td style="text-align: center;">SR</td>
<td style="text-align: center;">BaseR</td>
<td style="text-align: center;">offet6</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem[BaseR+SEXT(offset6)]=SR;</span><br></pre></td></tr></table></figure>
<p>解释:将指定寄存器的内容和偏移量的符号扩展相加,计算出一个地址,然后将SR的内容装入该地址指向的内存单元中.</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR   R4, R2, #5   ;mem[R2+5]&lt;-R4</span><br></pre></td></tr></table></figure>
<h3 id="trap-1">TRAP</h3>
<p>汇编器格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRAP  trapvector8</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align: center;">15 14 13 12</th>
<th style="text-align: center;">11 10 9 8</th>
<th style="text-align: center;">7 6 5 4 3 2 1 0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1111</td>
<td style="text-align: center;">0000</td>
<td style="text-align: center;">trapvect8</td>
</tr>
</tbody>
</table>
<p>操作说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R7=PC+<span class="number">1</span>;</span><br><span class="line">PC=mem[ZEXT(trapvect8)];</span><br></pre></td></tr></table></figure>
<p>解释:首先将PC增量装入R7(为服务返回程序做准备).然后将由trapvector8指定的系统调用的入口地址装入PC(等价于跳转).注意,这个入口地址的计算是间接的,即先将trapvector8零扩展为一个<span
class="math inline">\(16~\rm{bit}\)</span>地址,然后读取该地址单元的内容,作为服务程序的入口地址.</p>
<h3 id="一些指令的使用辨析">一些指令的使用辨析</h3>
<p>在LC-3里, 我们应该了解load系列的指令(LD, LDI, LDR,
LEA)和store系列的指令(ST, STI, STR)应该在什么情况下使用, 我们先简要说明,
然后举一些例子.</p>
<h4 id="ld-1">LD</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：加载静态变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, VALUE     ; 将VALUE地址处的值加载到R1</span><br><span class="line">        ADD  R1, R1, #1    ; R1加1</span><br><span class="line">        ST   R1, VALUE     ; 存回VALUE</span><br><span class="line">        HALT</span><br><span class="line">VALUE   .FILL x000A        ; 静态变量，值为10</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：访问数组元素（已知索引）</span><br><span class="line">ARRAY   .FILL x0001</span><br><span class="line">        .FILL x0002</span><br><span class="line">        .FILL x0003</span><br><span class="line">        LD   R2, ARRAY     ; 加载ARRAY[0]到R2</span><br><span class="line">        LD   R3, ARRAY+1   ; 加载ARRAY[1]到R3（+1表示下一个内存位置）</span><br></pre></td></tr></table></figure>
<h4 id="ldi-1">LDI</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 示例：通过指针访问变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        ; 假设我们有一个指针指向某个数据</span><br><span class="line">        LD   R1, POINTER   ; R1 = 指针的值（地址）</span><br><span class="line">        LDI  R2, POINTER   ; R2 = MEM[POINTER]的值（间接加载）</span><br><span class="line">        </span><br><span class="line">        ; 修改指针指向的值</span><br><span class="line">        ADD  R2, R2, #1    ; R2加1</span><br><span class="line">        STI  R2, POINTER   ; 间接存储回原地址</span><br><span class="line">        </span><br><span class="line">        HALT</span><br><span class="line">POINTER .FILL x3100        ; 指针，指向地址x3100</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 在x3100处有数据：</span><br><span class="line">; x3100: .FILL x0005</span><br></pre></td></tr></table></figure>
<h4 id="ldr-1">LDR</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：遍历数组</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R2, ARRAY     ; R2 = 数组起始地址（基址）</span><br><span class="line">        AND  R3, R3, #0    ; R3 = 0（索引）</span><br><span class="line">        ADD  R4, R3, #5    ; R4 = 5（数组长度）</span><br><span class="line">LOOP    BRz  DONE</span><br><span class="line">        LDR  R1, R2, #0    ; 加载ARRAY[R3]到R1（偏移量为0）</span><br><span class="line">        ; 处理R1中的数据...</span><br><span class="line">        ADD  R2, R2, #1    ; 基址加1（下一个元素）</span><br><span class="line">        ADD  R4, R4, #-1   ; 计数器减1</span><br><span class="line">        BR   LOOP</span><br><span class="line">DONE    HALT</span><br><span class="line">ARRAY   .BLKW 5           ; 分配5个字的数组</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：结构体访问</span><br><span class="line">; 假设一个结构体：x坐标、y坐标、状态</span><br><span class="line">STRUCT  .FILL x000A       ; x坐标</span><br><span class="line">        .FILL x0005       ; y坐标</span><br><span class="line">        .FILL x0001       ; 状态</span><br><span class="line">        </span><br><span class="line">        LEA  R2, STRUCT   ; R2指向结构体起始地址</span><br><span class="line">        LDR  R3, R2, #0   ; R3 = x坐标（偏移0）</span><br><span class="line">        LDR  R4, R2, #1   ; R4 = y坐标（偏移1）</span><br><span class="line">        LDR  R5, R2, #2   ; R5 = 状态（偏移2）</span><br></pre></td></tr></table></figure>
<h4 id="lea-1">LEA</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 示例1：获取字符串地址并输出</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R0, MESSAGE   ; 将字符串地址加载到R0</span><br><span class="line">        PUTS               ; 输出字符串（PUTS使用R0作为地址）</span><br><span class="line">        HALT</span><br><span class="line">MESSAGE .STRINGZ &quot;Hello, LC-3!&quot;</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; 示例2：设置数组迭代器</span><br><span class="line">        LEA  R2, ARRAY     ; R2指向数组起始地址</span><br><span class="line">        ADD  R3, R2, #5    ; R3指向数组第6个元素（偏移5）</span><br></pre></td></tr></table></figure>
<h4 id="st-1">ST</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 示例：保存计算结果</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, INPUT1</span><br><span class="line">        LD   R2, INPUT2</span><br><span class="line">        ADD  R3, R1, R2    ; R3 = R1 + R2</span><br><span class="line">        ST   R3, RESULT    ; 将结果保存到RESULT</span><br><span class="line">        HALT</span><br><span class="line">INPUT1  .FILL x0005</span><br><span class="line">INPUT2  .FILL x0003</span><br><span class="line">RESULT  .BLKW 1           ; 为结果预留空间</span><br><span class="line">        .END</span><br></pre></td></tr></table></figure>
<h4 id="sti-1">STI</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 示例：通过指针修改变量</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LD   R1, NEW_VALUE</span><br><span class="line">        STI  R1, POINTER   ; 将R1的值存储到POINTER指向的地址</span><br><span class="line">        HALT</span><br><span class="line">POINTER .FILL x3100        ; 指向x3100</span><br><span class="line">NEW_VALUE .FILL x0007</span><br><span class="line">        .END</span><br><span class="line"></span><br><span class="line">; x3100处原本可能有一个值，现在被修改为7</span><br></pre></td></tr></table></figure>
<h4 id="str-1">STR</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; 示例：向数组写入数据</span><br><span class="line">        .ORIG x3000</span><br><span class="line">        LEA  R2, ARRAY     ; R2指向数组起始地址</span><br><span class="line">        AND  R3, R3, #0</span><br><span class="line">        ADD  R3, R3, #1    ; R3 = 1（要存储的值）</span><br><span class="line">        </span><br><span class="line">        ; 存储到数组的不同位置</span><br><span class="line">        STR  R3, R2, #0    ; ARRAY[0] = 1</span><br><span class="line">        ADD  R3, R3, #1</span><br><span class="line">        STR  R3, R2, #1    ; ARRAY[1] = 2</span><br><span class="line">        ADD  R3, R3, #1</span><br><span class="line">        STR  R3, R2, #2    ; ARRAY[2] = 3</span><br><span class="line">        </span><br><span class="line">        HALT</span><br><span class="line">ARRAY   .BLKW 5           ; 分配5个字的数组</span><br><span class="line">        .END</span><br></pre></td></tr></table></figure>
<h2 id="实验">实验</h2>
<h3 id="习题1">习题1</h3>
<p>比较R2和R3的内容, 并将最大值放入R1寄存器, 如果两个数相同,
则要求R1等于0. 要求程序起始地址为<code>x3000</code>,
程序完成后正常结束.</p>
<h4 id="实验步骤与实验思路">实验步骤与实验思路:</h4>
<p>首先写好起始地址<code>.ORIG x3000</code>和结束语句<code>.END</code>.</p>
<p>比较两个寄存器的内容的大小可以用减法, 但是LC-3指令集没有提供减法运算,
所以具体做法是, 先对<code>R3</code>取反再加一,
放到<code>R0</code>寄存器里面, 然后和<code>R2</code>相加,
结果放在<code>R0</code>寄存器里面.</p>
<p>根据减法的结果(正数, 负数,
零)跳转(也就是使用<code>BR</code>指令)到对应的后续操作. 如果是正数,
说明<code>R2</code>大, 把<code>R2</code>放到<code>R1</code>里面;
如果是零, 说明两个数相等, 把<code>R1</code>清零即可; 如果是负数,
就把<code>R3</code>的值放入<code>R1</code>里面.</p>
<h4 id="实现代码">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    NOT R0, R3</span><br><span class="line">    ADD R0, R0, #1  ;取R3的补码, 放到R0里面</span><br><span class="line">    ADD R0, R2, R0  ;计算R2-R0, 结果放到R0里面</span><br><span class="line">    </span><br><span class="line">    BRz ZERO        ;如果结果为0, 则跳转到ZERO, 把R0的内容放到R1里面</span><br><span class="line">    BRp POSITIVE    ;如果结果为正, 则跳转到POSITIVE, 把R2放到R1里面</span><br><span class="line">    BRn NEGATIVE    ;如果结果为负, 则跳转到NEGATIVE, 把R3放到R1里面</span><br><span class="line"></span><br><span class="line">ZERO:</span><br><span class="line">    AND R1, R0, #0  ;把R1清零</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">POSITIVE:</span><br><span class="line">    ADD R1, R2, #0  ;把R2放到R1里面</span><br><span class="line">    BRnzp FINISH    ;跳转到FINISH</span><br><span class="line"></span><br><span class="line">NEGATIVE:</span><br><span class="line">    ADD R1, R3, #0  ;把R3放到R1里面</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题2">习题2</h3>
<p>实现两个正整数的除法, 要求程序从<code>x3000</code>开始执行,
被除数位于<code>x4000</code>, 除数位于<code>x4001</code>,
商放在<code>x5000</code>, 余数放在<code>x5001</code>.</p>
<h4 id="实验步骤与实验思路-1">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>根据题目要求, 先给指定的地址标签(<code>NUM1 .FILL x4000</code>,
<code>NUM2 .FILL x4001</code>, <code>QUOTIENT .FILL x5000</code>,
<code>REMAINDER .FILL x5001</code>), 方便以后使用.
我们把被除数放在<code>R1</code>里面, 除数放在<code>R2</code>里面.
两个正整数的除法就是, 用被除数减去除数, 看看可以减多少次,
所以选用<code>R3</code>作为计数器, 也就是存放商的寄存器.</p>
<p>我们用<code>R1</code>减去<code>R2</code>,
减法的结果放到<code>R1</code>里面, 如果减完为正,
说明还可以继续除以<code>R2</code>, 所以应该继续减法; 如果减完为零,
说明<code>R2</code>整除<code>R1</code>; 如果减完为负, 说明存在余数,
这时直接用这个负数加上被减数就得到余数.</p>
<h4 id="实现代码-1">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    LDI R1, NUM1  ;加载被除数到R1中</span><br><span class="line">    LDI R2, NUM2  ;加载除数到R2中</span><br><span class="line">    </span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用来计数R1可以被R2减多少次</span><br><span class="line">    NOT R2, R2</span><br><span class="line">    ADD R2, R2, #1   ;对R2取反加一</span><br><span class="line"></span><br><span class="line">DIV:</span><br><span class="line">    ADD R3, R3, #1   ;计数器先加上1</span><br><span class="line">    ADD R1, R1, R2   ;用R1减去R2, 结果存放在R1里面</span><br><span class="line">    BRp DIV          ;如果结果为正, 则重复循环</span><br><span class="line">    BRz FINISH       ;如果结果为零, 则跳转到FINISH, 说明R2整除R1, 余数为0</span><br><span class="line"></span><br><span class="line">    ADD R3 R3 -1     ;如果结果为负, 说明减过头了, 把计数器减去1</span><br><span class="line">    NOT R2 R2</span><br><span class="line">    ADD R2 R2 1</span><br><span class="line">    ADD R2 R1 R2     ;这里是计算余数, 把余数放到R2里面</span><br><span class="line">    STI R2 REMAINDER ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3 QUOTIENT  ;把商R3放到地址x5000处</span><br><span class="line">    BRp EOP</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    AND R2, R2, #0      ;把余数设为0</span><br><span class="line">    STI R2, REMAINDER   ;把余数R2放到地址x5001处</span><br><span class="line">    STI R3, QUOTIENT    ;把商放到地址x5000处</span><br><span class="line">EOP: </span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">NUM1      .FILL x4000</span><br><span class="line">NUM2      .FILL x4001</span><br><span class="line">QUOTIENT  .FILL x5000</span><br><span class="line">REMAINDER .FILL x5001</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题3">习题3</h3>
<p>从键盘输入一个值, 范围是数字<code>0~9</code>,
字母<code>a~z</code>以及<code>A~Z</code>.
检查从<code>x3100</code>开始的十个内存单元中是否有该数值, 如果有,
则设置<code>R0=1</code>, 如果没有, 则设置<code>R0=0</code>.
程序存放于<code>x3000</code>地址.</p>
<h4 id="实验步骤与实验思路-2">实验步骤与实验思路</h4>
<p>首先还是先写好<code>.ORIG x3000</code>和<code>.END</code>.
根据题目要求,
可以使用<code>TRAP x20</code>和<code>TRAP x21</code>进行键盘字符的读取和回显,
读取的字符的ASCII码存放到<code>R0</code>里.
我们把<code>R0</code>的值先装到<code>R1</code>里面便于后续比较,
而<code>R0</code>本身用于存放比较的结果.
我们设置<code>R2</code>作为指针指向搜索的起始地址<code>x3100</code>,
<code>R3</code>作为计数器, 计数十次.</p>
<p>做好上述的准备工作后, 下面我们编写主要的循环.</p>
<p>记循环开始处为<code>LOOP</code>, 在开始处,
首先把<code>R2</code>指向的地址的值给<code>R4</code>,
为了比较<code>R4</code>里面的值是否和<code>R1</code>中的相等,
我们采用减法, 也就是先对<code>R4</code>取反加一,
放到<code>R5</code>里面, 然后用<code>R1</code>加上<code>R5</code>,
如果结果为零, 则跳转到<code>YES</code>处,
这里的<code>YES</code>就是把<code>R0</code>置为<code>1</code>的语句;
如果结果非零, 就更新指针<code>R2</code>和计数器<code>R3</code>,
然后跳回到循环开始的位置进行下一个地址处的比较.
如果<code>R3</code>为零时仍然未找到, 就无条件跳转至<code>NO</code>处,
这里的<code>NO</code>就是把<code>R0</code>置为<code>0</code>,
最后结束程序.</p>
<h4 id="实现代码-2">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">    TRAP x20   ;从键盘读取字符存放到R0</span><br><span class="line">    TRAP x21   ;回显用户输入的字符</span><br><span class="line">    </span><br><span class="line">    ADD R1, R0, #0   ;把R0的内容放入R1便于后续的比较</span><br><span class="line">    AND R3, R3, #0   ;把计数器R3清零</span><br><span class="line">    ADD R3, R3, #10  ;计数10次</span><br><span class="line">    </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向起始地址x3100</span><br><span class="line"></span><br><span class="line">    AND R0, R0, #0   ;把R0清零, 用于存放比较的结果</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    LDR R4, R2, #0   ;把指针R2指向的地址内容放到R4里面进行后续比较</span><br><span class="line">    NOT R5, R4</span><br><span class="line">    ADD R5, R5, #1   ;对R4取补码, 放入R5中</span><br><span class="line">    ADD R5, R1, R5   ;用R1减去R5, 结果放入R5中</span><br><span class="line">    BRz YES          ;如果结果为0, 则说明该内存单元的内容和输入字符是一样的, 程序跳转到YES</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1   ;如果结果不为零, 则继续循环, 把指针加一</span><br><span class="line">    ADD R3, R3, #-1  ;计数器减一</span><br><span class="line">    BRp LOOP         ;如果计数器R3的值仍然大于零, 则重复循环, 直到等于零</span><br><span class="line">    </span><br><span class="line">    AND R0, R0, #0   ;如果循环了10次, 仍然没有找到内存中有相同的字符, 则把R0清零</span><br><span class="line">    BRnzp FINISH     ;跳转到程序结束</span><br><span class="line"></span><br><span class="line">YES:</span><br><span class="line">    ADD R0, R0, #1   ;把R0加1, 说明找到了</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS .FILL x3100</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题4">习题4</h3>
<p>从键盘读取一个字符, 并且统计一个文件中该字符出现的次数,
最后在显示器上显示该数值. 假设一个文件中任意字符的出现次数很小,
即最多只有9次. 文件存放于内存<code>x4000</code>地址起始的内存位置,
内容仅包含<code>1~9, a~z, A~Z</code>.</p>
<h4 id="实验步骤与实验思路-3">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
<code>R0</code>用于读取和输出结果, <code>R1</code>存储键盘输入的结果,
用于和文件的内容比较, <code>R2</code>用作指针,
<code>R3</code>用作计数器. 首先进行初始化:
从键盘读取一个字符放入<code>R0</code>并回显,
把从键盘读取的内容放到<code>R1</code>里面, 供后续的比较,
指针<code>R2</code>指向文件的起始地址<code>x4000</code>,
把<code>R3</code>清零.</p>
<p>做好上述准备工作后, 我们开始编写主要的循环.</p>
<p>循环的开始记为<code>LOOP</code>,
首先把<code>R2</code>指针指向的地址的内容放到<code>R0</code>里面,
如果此时<code>R2</code>指向的地址的内容为空,
则直接跳转到<code>FINISH</code>显示结果; 如果内容不为空,
那么开始进行比较, 首先对<code>R1</code>取补码放到<code>R4</code>里面,
用<code>R0</code>加上<code>R4</code>, 如果结果不为零,
则跳转到<code>NO</code>,
这里<code>NO</code>就是将指针<code>R2</code>加一, 并且返回循环的开头;
如果结果为零, 则将计数器<code>R3</code>加一, 指针<code>R2</code>加一,
然后继续循环.</p>
<p>由于文件的结尾处为<code>0</code>,
所以当<code>R2</code>指向文件的结尾时, 循环结束,
程序跳转到<code>FINISH</code>,
此时计数器<code>R3</code>的内容就是文件中特定字符出现的次数,
但是如果想要把具体的数字打印到屏幕上,
则需要将<code>R3</code>内的数字转换成对应的ASCII码,
一个简单的方式就是加上<code>0</code>的ASCII码,
然后放入<code>R0</code>进行输出即可.</p>
<h4 id="实现代码-3">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20         ;从键盘读取字符放到R0里面</span><br><span class="line">    TRAP x21         ;回显</span><br><span class="line">    ADD R1, R0, #0   ;把读取的字符放到R1里面, 便于后续的比较  </span><br><span class="line">    LD R2, ADDRESS   ;指针R2指向文件起始位置x4000</span><br><span class="line">    AND R3, R3, #0   ;把R3清零, 用作计数器 </span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    LDR R0, R2, #0   ;把指针R2指向的地址内容放入R0</span><br><span class="line">    BRz FINISH       ;如果读到0, 说明文件结束, 跳转到FINISH</span><br><span class="line">    </span><br><span class="line">    NOT R4, R1</span><br><span class="line">    ADD R4, R4, #1   ;把输入的内容R1取补码后放入R4</span><br><span class="line">    ADD R4, R0, R4   ;用R0-R4, 用于比较文件内容是否和输入内容相等</span><br><span class="line">    BRnp NO          ;如果结果非零, 说明不相等, 跳转到NO</span><br><span class="line"></span><br><span class="line">    ADD R3, R3, #1   ;如果结果为零, 说明相等, 计数器R3加一</span><br><span class="line">    </span><br><span class="line">NO:</span><br><span class="line">    ADD R2, R2, #1     ;指针R2加一</span><br><span class="line">    BRnzp LOOP         ;重复循环</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    LD R0, ZERO_ASCII  ;把&#x27;0&#x27;的ASCII码放入R0</span><br><span class="line">    ADD R0, R0, R3     ;R0=&#x27;0&#x27;+R3</span><br><span class="line">    TRAP x21           ;显示R0的内容到屏幕上</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">ADDRESS    .FILL x4000</span><br><span class="line">ZERO_ASCII .FILL x30    ;&#x27;0&#x27;的ASCII</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题5">习题5</h3>
<p>将键盘编写的十进制或者十六进制常数(前缀<code>#</code>代表十进制,
前缀<code>x</code>代表十六进制)转换为二进制表达方式,
并且打印出来(假设常数表示时, 十进制或十六进制的数字不超过两个).
例如键盘输入<code>x2A</code>时, 程序输出<code>00101010</code>,
键盘输入<code>#12</code>时, 程序输出<code>00001100</code>.</p>
<h4 id="实验步骤与实验思路-4">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.</p>
<p>我们需要解决如下的几个问题:</p>
<ol type="1">
<li>如何根据输入的前缀是<code>#</code>或<code>x</code>来判断后续输入的是十进制还是十六进制?</li>
<li>如何判断输入的是单个字符还是两个字符?</li>
<li>如何把输入字符的ASCII码转化成对应的数值?</li>
<li>如何把对应的数值转化成二进制数?</li>
</ol>
<h5 id="问题1的解决方案">问题1的解决方案</h5>
<p>首先把<code>#</code>读取到<code>R1</code>寄存器中,
输入内容放到<code>R0</code>寄存器中, 计算<code>R0-R1</code>,
结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>#</code>, 如果是,
那么程序跳转到<code>DEC_MODE</code>处理十进制输入; 如果不是,
那么程序继续往下执行, 把<code>x</code>读取到<code>R1</code>寄存器中,
计算<code>R0-R1</code>, 结果放入<code>R2</code>中,
根据<code>R2</code>是否为零来判断输入的前缀是否为<code>x</code>, 如果是,
那么程序跳转到<code>HEX_MODE</code>处理十六进制输入; 如果不是,
那么为无效输入, 程序直接结束, 跳转到<code>END</code>.</p>
<p>代码实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">TRAP x21           ;回显</span><br><span class="line"></span><br><span class="line">;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line"></span><br><span class="line">;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">NOT R1, R1</span><br><span class="line">ADD R1, R1, #1</span><br><span class="line">ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line"></span><br><span class="line">BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br></pre></td></tr></table></figure>
<h5 id="问题2的解决方案">问题2的解决方案</h5>
<h6 id="十进制输入">十进制输入</h6>
<p>先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
现在判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>DEC_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5, 因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;调用子程序, 将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0       ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line"></span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0       ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R4, R0, #0       ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0       ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3       ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ; 计算 10 × 十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br></pre></td></tr></table></figure>
<p>这里我们顺便把处理单个字符的子程序<code>DEC_SINGLE</code>和把ASCII码转换成对应数值的子程序<code>ASCII _TO_DECIMAL</code>写好:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEC_SINGLE:</span><br><span class="line">    ; 使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0       ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL ;转换为数值</span><br><span class="line">    ADD R2, R0, #0       ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY  ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<h6 id="十六进制输入">十六进制输入</h6>
<p>和十进制类似,先读取第一个数字字符到<code>R0</code>,
把<code>R0</code>内容先放入<code>R6</code>供后续使用.
然后读取第二个字符到<code>R0</code>,
把<code>R0</code>的内容放入<code>R5</code>供后续使用,
判断这个字符是数字字符还是回车. 如果是回车,
那么程序跳转至单个数字字符的处理子程序<code>HEX_SINGLE</code>;
如果是数字字符, 程序继续向下执行,
依次将第一个字符<code>R6</code>和第二个字符<code>R5</code>转化成对应的数值,
分别放在<code>R3</code>和<code>R4</code>中,
然后计算<code>10×R3+R4</code>的值, 最后把这个数转化成二进制进行输出.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ; 计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ; 计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br></pre></td></tr></table></figure>
<h5 id="问题3的解决方案">问题3的解决方案</h5>
<p>在上面的问题2中,
我们已经用到了子程序<code>ASCII_TO_DECIMAL</code>和<code>ASCII_TO_HEX</code>,
其作用是把我们输入字符的ASCII码分别转换成对应的数值.</p>
<p>这里我们先来看一下ASCII的编码系统, 从而确定字符转换的程序.</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>示例</th>
<th>ASCII码(十进制)</th>
<th>ASCII码(十六进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字字符</td>
<td>‘0’</td>
<td>48</td>
<td>x30</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘1’</td>
<td>49</td>
<td>x31</td>
</tr>
<tr>
<td>数字字符</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>数字字符</td>
<td>‘9’</td>
<td>57</td>
<td>x39</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘A’</td>
<td>65</td>
<td>x41</td>
</tr>
<tr>
<td>大写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>大写字母</td>
<td>‘Z’</td>
<td>90</td>
<td>x5A</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘a’</td>
<td>97</td>
<td>x61</td>
</tr>
<tr>
<td>小写字母</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>小写字母</td>
<td>‘z’</td>
<td>122</td>
<td>x7A</td>
</tr>
</tbody>
</table>
<p>当我们从键盘输入时, 存储到<code>R0</code>寄存器的是ASCII码,
而不是数值本身, 所以我们应该进行数值的转换, 对于数字,
根据上表可知只需要用数字字符对应的ASCII码直接减去<code>0</code>对应的ASCII码就可以得到该数字字符对应的数值了.
同样地, 对于十六进制大写字母,
只需要用大写字母对应的ASCII码直接减去’A’对应的ASCII码就可以得到该大写字母对应的数值了.</p>
<h6 id="十进制转换">十进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h6 id="十六进制转换">十六进制转换</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">; 处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br></pre></td></tr></table></figure>
<h5 id="问题4的解决方案">问题4的解决方案</h5>
<p>接下来我们考虑如何将数值转换成对应的二进制码.
这里我们采用位检测和移位算法, 首先输入数值,
设置计数器的值为8(因为输出的是8位二进制数), 检查当前最高位,
如果最高位是1, 那么输出1, 然后左移一位; 如果最高位是0, 那么输出0,
然后左移一位. 此时把计数器减一, 如果计数器的值大于零, 那么继续循环,
直到完整循环了8次, 也就是输出8位二进制数了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    AND R1, R1, #0     ;初始化循环计数器R1</span><br><span class="line">    ADD R1, R1, #8     ;设置R1=8, 循环8次</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0     ;设置条件码, 检查R2的符号位</span><br><span class="line">    BRn OUTPUT_ONE     ;如果最高位为1(负数)，跳转到输出&#x27;1&#x27;</span><br><span class="line">    </span><br><span class="line">    ;如果最高位为0, 输出&#x27;0&#x27;</span><br><span class="line">    LD R0, ZERO_ASCII  ;R0=&#x27;0&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;0&#x27;</span><br><span class="line">    BRnzp SHIFT_NEXT   ;跳转到移位处理</span><br><span class="line"></span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII   ;R0=&#x27;1&#x27;的ASCII码</span><br><span class="line">    TRAP x21           ;输出&#x27;1&#x27;</span><br><span class="line"></span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2     ;R2左移一位</span><br><span class="line">    ADD R1, R1, #-1    ;计数器减1</span><br><span class="line">    BRp LOOP           ;如果计数器大于0, 继续循环</span><br><span class="line">    </span><br><span class="line">    ;输出换行, 使结果更清晰</span><br><span class="line">    LD R0, NEWLINE     ;R0=换行符</span><br><span class="line">    TRAP x21           ;输出换行</span><br></pre></td></tr></table></figure>
<p>后来我在debug的时候发现有个问题, LC-3是16位机器,
假如我输入<code>#12</code>(也就是十进制数<code>12</code>,
其二进制数为<code>0000_0000_0000_1100</code>), 循环8次后输出全是0,
永远也不可能输出1, 而我们仅仅关心低8位.
所以应该先把<code>R2</code>左移8位, 把低8位变成高8位,
改正后的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br></pre></td></tr></table></figure>
<h4 id="实现代码-4">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">    TRAP x20           ;从键盘读取前缀字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十进制模式前缀&#x27;#&#x27;</span><br><span class="line">    LD R1, DEC         ;R1=&#x27;#&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;#&#x27;, 结果放入R2中</span><br><span class="line">    BRz DEC_MODE       ;如果相等, 跳转到十进制模式</span><br><span class="line">    </span><br><span class="line">    ;检查是否为十六进制模式前缀&#x27;x&#x27;</span><br><span class="line">    LD R1, HEX         ;R1=&#x27;x&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;用R0-R1来判断输入字符是否为&#x27;x&#x27;, 结果放入R2中</span><br><span class="line">    BRz HEX_MODE       ;如果相等, 跳转到十六进制模式</span><br><span class="line">    </span><br><span class="line">    BRnzp END          ;如果既不是&#x27;#&#x27;也不是&#x27;x&#x27;，直接结束程序</span><br><span class="line"></span><br><span class="line">;*************************************************</span><br><span class="line">;****************下面是十进制模式******************</span><br><span class="line">;*************************************************</span><br><span class="line">DEC_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个数字到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ;读取第二个字符(可能是数字或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ;保存第二个字符到R5，因为后续转换会覆盖R0</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ;检查第二个字符是否为回车键(表示只输入单个数字)</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz DEC_SINGLE     ;如果是回车键, 说明是单位数输入, 跳转到单个数字的处理子程序</span><br><span class="line">    </span><br><span class="line">    ;=====两位数输入处理=====</span><br><span class="line">    ;将第一个字符转换为数值</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;调用子程序，将第一位数字的ASCII码转换为十进制数值</span><br><span class="line">    ADD R3, R0, #0          ;把转换好的第一位数字的十进制数值放入R3中</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为数值</span><br><span class="line">    ADD R0, R5, #0          ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R4, R0, #0          ;把转换好的第二位数字的十进制数值放入R4中</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 10×十位数+个位数</span><br><span class="line">    AND R2, R2, #0     ;R2=0(清零用于存储结果)</span><br><span class="line">    ADD R2, R2, R3     ;R2=十位数值</span><br><span class="line"></span><br><span class="line">    ;计算10×十位数</span><br><span class="line">    ADD R5, R2, R2     ;R5=2×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=4×R2</span><br><span class="line">    ADD R5, R5, R5     ;R5=8×R2</span><br><span class="line">    ADD R2, R2, R5     ;R2=9×R2</span><br><span class="line">    ADD R2, R2, R3     ;R2=10×R2</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=10×十位数+个位数</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是处理单个十进制数字的子程序</span><br><span class="line">DEC_SINGLE:</span><br><span class="line">    ;使用之前保存的数字字符进行转换</span><br><span class="line">    ADD R0, R6, #0          ;R0=之前保存到R6的数字字符</span><br><span class="line">    JSR ASCII_TO_DECIMAL    ;转换为数值</span><br><span class="line">    ADD R2, R0, #0          ;R2=数值结果</span><br><span class="line"></span><br><span class="line">    BRnzp OUTPUT_BINARY     ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;***************************************************</span><br><span class="line">;****************下面是十六进制模式******************</span><br><span class="line">;***************************************************</span><br><span class="line">HEX_MODE:</span><br><span class="line">    TRAP x20           ;读取第一个字符到R0里面</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ADD R6, R0, #0     ;将R0保存到R6中, 在输入单个数字时要用到</span><br><span class="line">    </span><br><span class="line">    ; 读取第二个字符(可能是十六进制字符或回车)</span><br><span class="line">    TRAP x20           ;读取第二个字符到R0</span><br><span class="line">    TRAP x21           ;回显</span><br><span class="line">    </span><br><span class="line">    ; 保存第二个字符到R5</span><br><span class="line">    ADD R5, R0, #0     ;R5=第二个字符</span><br><span class="line">    </span><br><span class="line">    ; 检查第二个字符是否为回车键</span><br><span class="line">    LD R1, ENTER_KEY   ;R1=回车键ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R5, R1     ;用R5-R1来判断输入字符是否为回车, 结果放入R2中</span><br><span class="line">    BRz HEX_SINGLE     ;如果是回车键, 说明是单字符输入</span><br><span class="line">    </span><br><span class="line">    ;=====双字符输入处理=====</span><br><span class="line">    ;将第一个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R6, #0     ;R0=之前保存的第一个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;调用子程序, 将第一位数字的ASCII码转换为十六进制数值</span><br><span class="line">    ADD R3, R0, #0     ;R3=高4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;将第二个字符转换为十六进制数值</span><br><span class="line">    ADD R0, R5, #0     ;R0=之前保存的第二个字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为数值</span><br><span class="line">    ADD R4, R0, #0     ;R4=低4位数值(0-15)</span><br><span class="line">    </span><br><span class="line">    ;计算最终数值: 16×高4位+低4位</span><br><span class="line">    ADD R2, R3, #0     ;R2=高4位数值</span><br><span class="line">    </span><br><span class="line">    ;计算16×高4位</span><br><span class="line">    ADD R2, R2, R2     ;R2×2</span><br><span class="line">    ADD R2, R2, R2     ;R2×4</span><br><span class="line">    ADD R2, R2, R2     ;R2×8</span><br><span class="line">    ADD R2, R2, R2     ;R2×16</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, R4     ;R2=16×高4位+低4位</span><br><span class="line">    </span><br><span class="line">    BRnzp OUTPUT_BINARY ;跳转到二进制输出</span><br><span class="line"></span><br><span class="line">;下面是单个十六进制数字的处理</span><br><span class="line">HEX_SINGLE:</span><br><span class="line">    ADD R0, R6, #0     ;R0=R6之前保存的字符</span><br><span class="line">    JSR ASCII_TO_HEX   ;转换为十六进制数值</span><br><span class="line">    ADD R2, R0, #0     ;R2=数值结果</span><br><span class="line"></span><br><span class="line">;*****************************************************</span><br><span class="line">;****************下面是二进制输出程序******************</span><br><span class="line">;*****************************************************</span><br><span class="line">OUTPUT_BINARY:</span><br><span class="line">    ;将R2左移8次, 使低8位变为高8位</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8      ;先使用R1作为左移8次的计数器</span><br><span class="line">SHIFT_LOOP:</span><br><span class="line">    ADD R2, R2, R2      ;左移, 使得低8位变成高8位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp SHIFT_LOOP</span><br><span class="line"></span><br><span class="line">    ; 现在设置输出循环计数器</span><br><span class="line">    AND R1, R1, #0</span><br><span class="line">    ADD R1, R1, #8</span><br><span class="line"></span><br><span class="line">LOOP:</span><br><span class="line">    ADD R2, R2, #0      ;设置条件码</span><br><span class="line">    BRn OUTPUT_ONE</span><br><span class="line">    LD R0, ZERO_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">    BRnzp SHIFT_NEXT</span><br><span class="line">OUTPUT_ONE:</span><br><span class="line">    LD R0, ONE_ASCII</span><br><span class="line">    TRAP x21</span><br><span class="line">SHIFT_NEXT:</span><br><span class="line">    ADD R2, R2, R2      ;左移一位</span><br><span class="line">    ADD R1, R1, #-1</span><br><span class="line">    BRp LOOP</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    HALT               ;程序结束</span><br><span class="line"></span><br><span class="line">;********************************************************</span><br><span class="line">;***************子程序: ASCII转十进制数值*****************</span><br><span class="line">;********************************************************</span><br><span class="line">ASCII_TO_DECIMAL:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1, 避免影响调用者</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;的ASCII码</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R0, R0, R1     ;R0=ASCII字符-&#x27;0&#x27;</span><br><span class="line">    </span><br><span class="line">    ;检查结果是否在0~9范围内</span><br><span class="line">    ADD R1, R0, #0     ;R1=转换结果</span><br><span class="line">    BRn INVALID_DEC    ;如果小于0, 无效</span><br><span class="line">    ADD R1, R0, #-9    ;R1=结果-9</span><br><span class="line">    BRp INVALID_DEC    ;如果大于9, 无效</span><br><span class="line">    </span><br><span class="line">    ;如果结果R0在0~9范围内, 说明有效</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">INVALID_DEC:</span><br><span class="line">    AND R0, R0, #0     ;R0=0, 无效输入返回0</span><br><span class="line">    LD R1, SAVE_R1     ;恢复R1</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;*********************************************************</span><br><span class="line">;**************子程序: ASCII转十六进制数值*****************</span><br><span class="line">;*********************************************************</span><br><span class="line">ASCII_TO_HEX:</span><br><span class="line">    ST R1, SAVE_R1     ;保存R1</span><br><span class="line">    ST R2, SAVE_R2     ;保存R2</span><br><span class="line">    </span><br><span class="line">    ;检查是否为数字字符&#x27;0&#x27;~&#x27;9&#x27;</span><br><span class="line">    LD R1, ZERO_ASCII  ;R1=&#x27;0&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;0&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于&#x27;0&#x27;, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;0&#x27;~&#x27;9&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-9    ;R1=(字符-&#x27;0&#x27;)-9</span><br><span class="line">    BRnz VALID_DEC     ;如果小于等于0, 说明是&#x27;0&#x27;~&#x27;9&#x27;, 有效</span><br><span class="line">    </span><br><span class="line">    ;检查是否为大写字母&#x27;A&#x27;~&#x27;F&#x27;</span><br><span class="line">    LD R1, A_ASCII     ;R1=&#x27;A&#x27;</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R2, R0, R1     ;R2=字符-&#x27;A&#x27;</span><br><span class="line">    BRn INVALID_HEX    ;如果小于0, 为无效字符</span><br><span class="line">    </span><br><span class="line">    ;检查是否在&#x27;A&#x27;~&#x27;F&#x27;范围内</span><br><span class="line">    ADD R1, R2, #-5    ;R1=(字符-&#x27;A&#x27;)-5</span><br><span class="line">    BRp INVALID_HEX    ;如果大于0, 说明大于&#x27;F&#x27;, 无效</span><br><span class="line">    </span><br><span class="line">    ;处理&#x27;A&#x27;~&#x27;F&#x27;字符</span><br><span class="line">    ADD R0, R2, #10    ;R0=(字符-&#x27;A&#x27;)+10</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">;处理&#x27;0&#x27;~&#x27;9&#x27;字符</span><br><span class="line">VALID_DEC:</span><br><span class="line">    ADD R0, R2, #0     ;R0=R2</span><br><span class="line">    BRnzp HEX_DONE     ;跳转到完成</span><br><span class="line"></span><br><span class="line">INVALID_HEX:</span><br><span class="line">    AND R0, R0, #0     ;R0=0</span><br><span class="line"></span><br><span class="line">HEX_DONE:</span><br><span class="line">    LD R1, SAVE_R1     ;恢复寄存器</span><br><span class="line">    LD R2, SAVE_R2</span><br><span class="line">    RET                ;返回</span><br><span class="line"></span><br><span class="line">;数据定义</span><br><span class="line">DEC           .FILL x23   ;&#x27;#&#x27;的ASCII码</span><br><span class="line">HEX           .FILL x78   ;&#x27;x&#x27;的ASCII码</span><br><span class="line">ZERO_ASCII    .FILL x30   ;&#x27;0&#x27;的ASCII码</span><br><span class="line">ONE_ASCII     .FILL x31   ;&#x27;1&#x27;的ASCII码</span><br><span class="line">A_ASCII       .FILL x41   ;&#x27;A&#x27;的ASCII码</span><br><span class="line">ENTER_KEY     .FILL x0A   ;回车键的ASCII码</span><br><span class="line"></span><br><span class="line">SAVE_R1       .BLKW 1     ;用于保存R1</span><br><span class="line">SAVE_R2       .BLKW 1     ;用于保存R2</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="习题6">习题6</h3>
<p>采用轮询方式的控制外设,
通过键盘进行输入并在控制台屏幕显示大写的字母<code>A~I</code>,
要求利用LC-3处理器提供的如下表所示的设备端口,
使用设备端口寄存器来实现键盘输入与显示终端显示的功能.
设备端口寄存器的内存映射如下:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Location</th>
<th>I/O Register</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>xFE00</code></td>
<td>键盘状态寄存器(KBSR)</td>
<td>当键盘接收到一个新字符时, 位[15]为1.</td>
</tr>
<tr>
<td><code>xFE02</code></td>
<td>键盘数据寄存器(KBDR)</td>
<td>位[7:0]包含键盘上键入的最后一个字符.</td>
</tr>
<tr>
<td><code>xFE04</code></td>
<td>显示状态寄存器(DSR)</td>
<td>当设备准备在屏幕上显示另一个字符时, 位[15]是1.</td>
</tr>
<tr>
<td><code>xFE06</code></td>
<td>显示数据寄存器(DDR)</td>
<td>写入位[7:0]的字符将显示在屏幕上.</td>
</tr>
</tbody>
</table>
<h4 id="实验步骤与实验思路-5">实验步骤与实验思路</h4>
<p>首先写好<code>.ORIG x3000</code>和<code>.END</code>.
由于我们使用轮询的方式控制外设,
所以先考虑如何实现键盘输入和显示器输出的轮询,
思路就是<code>R0</code>读取键盘状态寄存器<code>KBSR</code>(<code>LDI R0 KBSR_ADDRESS</code>,
<code>KBSR_ADDRESS .FILL xFE00</code>), 如果最高位是0, 表示没有新的字符,
继续轮询; 如果最高位是1(也就是说<code>KBSR</code>寄存器的内容是负数),
表示有新字符,
这时<code>R0</code>读取键盘数据寄存器<code>KBDR</code>进行后续的操作(<code>LDI R0 KBDR_ADDRESS</code>,
<code>KBDR_ADDRESS .FILL xFE02</code>). 类似地, 对于输出轮询,
<code>R1</code>读取显示状态寄存器<code>DSR</code>(<code>LDI R1 DSR_ADDRESS</code>,
<code>DSR_ADDRESS .FILL xFE04</code>), 如果最高位是0, 表示显示器忙,
继续轮询; 如果最高位是1(也就是说<code>DSR</code>寄存器的内容是负数),
表示显示器准备就绪,
这时<code>R1</code>读取显示数据寄存器<code>DDR</code>进行显示(<code>LDI R1 DDR_ADDRESS</code>,
<code>DDR_ADDRESS .FILL xFE06</code>).</p>
<p>我们期望在键盘上依次输入<code>A~I</code>,
期望在显示器上依次回显<code>A~I</code>,
所以我们可以先把一个寄存器依次初始化为<code>A, B, ..., I</code>,
然后依次和我们的输入相比, 如果一致, 则输出该字符; 如果不一致,
则要求重新输入.</p>
<h4 id="实现代码-5">实现代码</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">MAIN:</span><br><span class="line">    LD R2, A_ASCII  ;把&#x27;A&#x27;的ASCII码放到R2里面, 和输入进行比较</span><br><span class="line">    </span><br><span class="line">LOOP:</span><br><span class="line">    TRAP x20        ;读取输入到R0</span><br><span class="line">    NOT R1, R2</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R0, R1  ;计算R0-R2判断输入和期望是否一致, 结果放入R1</span><br><span class="line">    BRnp LOOP       ;如果结果不为零, 说明不一致, 重新输入</span><br><span class="line">    </span><br><span class="line">    ADD R3, R0, #0  ;如果一致, 把R0放入R3输出</span><br><span class="line">    TRAP x21        ;输出</span><br><span class="line">    </span><br><span class="line">    LD R1, I_ASCII  ;把&#x27;I&#x27;的ASCII码放到R1里面, 和输入进行比较</span><br><span class="line">    NOT R1, R1</span><br><span class="line">    ADD R1, R1, #1</span><br><span class="line">    ADD R1, R2, R1  ;计算R2-R1, 判断当前输入字符是否为&#x27;I&#x27;</span><br><span class="line">    BRz FINISH      ;如果是, 那么程序结束</span><br><span class="line">    </span><br><span class="line">    ADD R2, R2, #1  ;如果不是, 那么R2＋1, 即R2初始化为下一个期望得到的字符</span><br><span class="line">    BRnzp LOOP      ;输入</span><br><span class="line"></span><br><span class="line">FINISH:</span><br><span class="line">    HALT</span><br><span class="line"></span><br><span class="line">A_ASCII .FILL x41           ; &#x27;A&#x27;的ASCII码</span><br><span class="line">I_ASCII .FILL x49           ; &#x27;I&#x27;的ASCII码</span><br><span class="line"></span><br><span class="line">.END</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
