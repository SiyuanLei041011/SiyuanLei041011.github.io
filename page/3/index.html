<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:58" itemprop="dateModified" datetime="2025-08-08T19:53:58+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="位运算">位运算</h2>
<p>整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如第
2 节
“Unicode和UTF-8”介绍的UTF-8编码就是如此，学完本节之后你应该能自己写出UTF-8的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。</p>
<h3 id="按位与或异或取反运算">按位与、或、异或、取反运算</h3>
<p>在第 3 节
“布尔代数”讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C语言提供了按位与（Bitwise
AND）运算符<code>&amp;</code>、按位或（Bitwise
OR）运算符<code>|</code>和按位取反（Bitwise
NOT）运算符<code>~</code>，此外还有按位异或（Bitwise
XOR）运算符<code>^</code>，我们在第 1 节
“为什么计算机用二进制计数”讲过异或运算。</p>
<p>注意，<code>&amp;</code>、<code>|</code>、<code>^</code>运算符都是要做Usual
Arithmetic Conversion的（其中有一步是Integer
Promotion），<code>~</code>运算符也要做Integer
Promotion，所以在C语言中其实并不存在8位整数的位运算，操作数在做位运算之前都至少被提升为<code>int</code>型了.</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0xfc</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = ~c;</span><br></pre></td></tr></table></figure>
<p>计算过程是这样的：常量<code>0xfc</code>是<code>int</code>型的，赋给c要转成<code>unsigned char</code>，值不变；c的十六进制表示是<code>fc</code>，计算<code>~c</code>时先提升为整型<code>000000fc</code>然后取反，最后结果是<code>ffffff03</code>。注意，如果把<code>~c</code>看成是8位整数的取反，最后结果就得3了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。</p>
<h3 id="移位运算">移位运算</h3>
<p>移位运算符（Bitwise
Shift）包括左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。左移将一个整数的各二进制位全部左移若干位.</p>
<p>最高两位的11被移出去了，最低两位又补了两个0，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是<code>unsigned int</code>型，如果左移的位数大于等于32位，则结果是Undefined。移位运算符不同于<code>+ - * / ==</code>等运算符，两边操作数的类型不要求一致，但两边操作数都要做Integer
Promotion，整个表达式的类型和左操作数提升后的类型相同。</p>
<p>复习一下第 2 节
“不同进制之间的换算”讲过的知识可以得出结论，在一定的取值范围内，将一个整数左移1位相当于乘以2。比如二进制11（十进制3）左移一位变成110，就是6，再左移一位变成1100，就是12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以2了，所以我加了个前提“在一定的取值范围内”。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有<code>i * 8</code>，可以编译成移位指令而不是乘法指令。</p>
<p>当操作数是无符号数时，右移运算的规则和左移类似，</p>
<p>比如最低两位的11被移出去了，最高两位又补了两个0，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是Undefined。在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。</p>
<p>当操作数是有符号数时，右移运算的规则比较复杂：</p>
<p>如果是正数，那么高位移入0</p>
<p>如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“右移1位相当于除以2”的性质。</p>
<p>综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，建议只对无符号数做位运算，以减少出错的可能。</p>
<h3 id="掩码">掩码</h3>
<p>如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）来表示。比如掩码0x0000ff00表示对一个32位整数的8~15位进行操作，举例如下。</p>
<p>1、取出8~15位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = (a &amp; mask) &gt;&gt; <span class="number">8</span>; <span class="comment">/* 0x00000056 */</span></span><br></pre></td></tr></table></figure>
<p>这样也可以达到同样的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = (a &gt;&gt; <span class="number">8</span>) &amp; ~(~<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>2、将8~15位清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a &amp; ~mask; <span class="comment">/* 0x12340078 */</span></span><br></pre></td></tr></table></figure>
<p>3、将8~15位置1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a | mask; <span class="comment">/* 0x1234ff78 */</span></span><br></pre></td></tr></table></figure>
<h3 id="异或运算的一些特性">异或运算的一些特性</h3>
<p>1、一个数和自己做异或的结果是0。如果需要一个常数0，x86平台的编译器可能会生成这样的指令：<code>xorl %eax, %eax</code>。不管<code>eax</code>寄存器里的值原来是多少，做异或运算都能得到0，这条指令比同样效果的<code>movl $0, %eax</code>指令快，因为前者只需要在CPU内部计算，而后者需要访问内存，在下一章第
5 节 “Memory Hierarchy”详细介绍。</p>
<p>2、从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">1U</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a ^ mask; <span class="comment">/* flip the 6th bit */</span></span><br></pre></td></tr></table></figure>
<p>3、如果<code>a1 ^ a2 ^ a3 ^ ... ^ an</code>的结果是1，则表示<code>a1、a2、a3...an</code>之中1的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity
Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。</p>
<p>4、<code>x ^ x ^ y == y</code>，因为<code>x ^ x == 0</code>，<code>0 ^ y == y</code>。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用<code>temp = a; a = b; b = temp;</code>的办法了。利用位运算可以这样做交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>分析一下这个过程。为了避免混淆，把<code>a</code>和<code>b</code>的初值分别记为<code>a0</code>和<code>b0</code>。第一行，<code>a = a0 ^ b0；</code>第二行，把<code>a</code>的新值代入，得到<code>b = b0 ^ a0 ^ b0</code>，等号右边的<code>b0</code>相当于上面公式中的<code>x</code>，<code>a0</code>相当于<code>y</code>，所以结果为<code>a0</code>；第三行，把<code>a</code>和<code>b</code>的新值代入，得到<code>a = a0 ^ b0 ^ a0</code>，结果为<code>b0</code>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量<code>temp</code>则可以交换。</p>
<h2 id="其他运算符">其他运算符</h2>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<p>复合赋值运算符（Compound Assignment
Operator）包括<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>，一边做运算一边赋值。例如<code>a += 1</code>相当于<code>a = a + 1</code>。但有一点细微的差别，前者对表达式<code>a</code>只求值一次，而后者求值两次，如果<code>a</code>是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如<code>a[i+j] += 1</code>和<code>a[i+j] = a[i+j] + 1</code>。那么仅仅是效率上的差别吗？对于没有Side
Effect的表达式，求值一次和求值两次的结果是一样的，但对于有Side
Effect的表达式则不一定，例如<code>a[foo()] += 1</code>和<code>a[foo()] = a[foo()] + 1</code>，如果<code>foo()</code>函数调用有Side
Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。</p>
<p>在第 3 节
“for语句”讲自增、自减运算符时说<code>++i</code>相当于<code>i = i + 1</code>，其实更准确地说应该是等价于<code>i += 1</code>，表达式<code>i</code>只求值一次，而<code>--i</code>等价于<code>i -= 1</code>。</p>
<h3 id="条件运算符">条件运算符</h3>
<p>条件运算符（Conditional
Operator）是C语言中唯一一个三目运算符（Ternary
Operator），带三个操作数，它的形式是<code>表达式1 ? 表达式2 : 表达式3</code>，这个运算符所组成的整个表达式的值等于<code>表达式2</code>或<code>表达式3</code>的值，取决于<code>表达式1</code>的值是否为真，可以把它想像成这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><code>表达式1</code>相当于<code>if</code>语句的控制表达式，因此它的值必须是标量类型，而表达式2和3相当于同一个函数在不同情况下的返回值，因此它们的类型要求一致，也要做Usual
Arithmetic Conversion。</p>
<p>下面举个例子，定义一个函数求两个参数中较大的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逗号运算符">逗号运算符</h3>
<p>逗号运算符（Comma
Operator）也是一种双目运算符，它的形式是<code>表达式1, 表达式2</code>，两个表达式不要求类型一致，左边的表达式1先求值，求完了直接把值丢掉，再求右边表达式2的值作为整个表达式的值。逗号运算符是左结合的，类似于<code>+ - * /</code>运算符，根据组合规则可以写出<code>表达式1, 表达式2, 表达式3, ..., 表达式n</code>这种形式，<code>表达式1</code>,
<code>表达式2</code>可以看作一个子表达式，先求<code>表达式1</code>的值，然后求<code>表达式2</code>的值作为这个子表达式的值，然后这个值再和<code>表达式3</code>组成一个更大的表达式，求<code>表达式3</code>的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一个表达式的值成为整个表达式的值。</p>
<p>注意，函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样使用逗号运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a, (t=<span class="number">3</span>, t+<span class="number">2</span>), c)</span><br></pre></td></tr></table></figure>
<p>传给函数<code>f</code>的参数有三个，其中第二个参数的值是表达式<code>t+2</code>的值。</p>
<h3
id="sizeof运算符与typedef类型声明">sizeof运算符与typedef类型声明</h3>
<p><code>sizeof</code>是一个很特殊的运算符，它有两种形式：“<code>sizeof 表达式</code>”和“<code>sizeof(类型名)</code>”。这个运算符很特殊，“<code>sizeof 表达式</code>”中的子表达式并不求值，而只是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成“<code>sizeof(表达式)</code>”的形式也可以，这里的括号和<code>return(1);</code>的括号一样，不起任何作用。但另外一种形式“<code>sizeof(类型名)</code>”的括号则是必须写的，整个表达式的值也是这种类型所占的字节数。</p>
<p>比如用<code>sizeof</code>运算符求一个数组的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span> a/<span class="keyword">sizeof</span> a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，由于<code>sizeof</code>
表达式中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道<code>sizeof a</code>的值是48，<code>sizeof a[0]</code>的值是4，所以在编译时就已经把<code>sizeof a/sizeof a[0]</code>替换成常量12了，这是一个常量表达式。</p>
<p><code>sizeof</code>运算符的结果是<code>size_t</code>类型的，这个类型定义在<code>stddef.h</code>头文件中，不过你的代码中只要不出现<code>size_t</code>这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C标准规定<code>size_t</code>是一种无符号整型，编译器可以用<code>typedef</code>做一个类型声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<p>那么<code>size_t</code>就代表<code>unsigned long</code>型。不同平台的编译器可能会根据自己平台的具体情况定义<code>size_t</code>所代表的类型，比如有的平台定义为<code>unsigned long</code>型，有的平台定义为<code>unsigned long long</code>型，C标准规定<code>size_t</code>这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把<code>size_t</code>类型和它所代表的真实类型混用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">size_t</span> y;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>
<p>如果在一种ILP32平台上定义<code>size_t</code>代表<code>unsigned long long</code>型，这段代码把<code>y</code>赋给<code>x</code>时就把高位截掉了，结果可能是错的。</p>
<p><code>typedef</code>这个关键字用于给某种类型起个新名字，比如上面的<code>typedef</code>声明可以这么看：去掉<code>typedef</code>就成了一个变量声明<code>unsigned long size_t;</code>，<code>size_t</code>是一个变量名，类型是<code>unsigned long</code>，那么加上<code>typedef</code>之后，<code>size_t</code>就是一个类型名，就代表<code>unsigned long</code>类型。再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">array_t</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">array_t</span> a;</span><br></pre></td></tr></table></figure>
<p>这相当于声明<code>char a[10];</code>。类型名也遵循标识符的命名规则，并且通常加个<code>_t</code>后缀表示Type。</p>
<h2 id="side-effect和sequence-point">Side Effect和Sequence Point</h2>
<p>如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了Short-circuit比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">a = (++a)+(++a)+(++a)+(++a);</span><br></pre></td></tr></table></figure>
<p>据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是Undefined。</p>
<p>我们知道，调用一个函数可能产生Side
Effect，使用某些运算符（<code>++ -- =</code> 复合赋值）也会产生Side
Effect，如果一个表达式中隐含着多个Side
Effect，究竟哪个先发生哪个后发生呢？C标准规定代码中的某些点是Sequence
Point，当执行到一个Sequence Point时，在此之前的Side
Effect必须全部作用完毕，在此之后的Side
Effect必须一个都没发生。至于两个Sequence Point之间的多个Side
Effect哪个先发生哪个后发生则没有规定，编译器可以任意选择各Side
Effect的作用顺序。下面详细解释各种Sequence Point。</p>
<p>1、调用一个函数时，在所有准备工作做完之后、函数调用开始之前是Sequence
Point。比如调用<code>foo(f(), g())</code>时，<code>foo</code>、<code>f()</code>、<code>g()</code>这三个表达式哪个先求值哪个后求值是Unspecified，但是必须都求值完了才能做最后的函数调用，所以<code>f()</code>和<code>g()</code>的Side
Effect按什么顺序发生不一定，但必定在这些Side
Effect全部作用完之后才开始调用<code>foo</code>函数。</p>
<p>2、条件运算符<code>?:</code>、逗号运算符、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>的第一个操作数求值之后是Sequence
Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据表达式1的值是否为真决定下一步求表达式2还是表达式3的值，如果决定求表达式2的值，表达式3就不会被求值了，反之也一样，逗号运算符也是这样，表达式1求值结束才继续求表达式2的值。</p>
<p>逻辑与和逻辑或早在第 3 节
“布尔代数”就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如例
8.5 “剪刀石头布”这个程序中的这几句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以写得更简单（类似于[K&amp;R]的简洁风格）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man) != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个控制表达式的求值顺序是：先求<code>scanf("%d", &amp;man) = 1</code>的值，如果<code>scanf</code>调用失败，则返回值不等于1成立，<code>||</code>运算有一个操作数为真则整个表达式为真，这时直接执行下一句<code>printf</code>，根本不会再去求<code>man &lt; 0</code>或<code>man &gt; 2</code>的值；如果<code>scanf</code>调用成功，则读入的数保存在变量<code>man</code>中，并且返回值等于1，那么说它不等于1就不成立了，第一个<code>||</code>运算的左操作数为假，就会去求右操作数<code>man &lt; 0</code>的值作为整个表达式的值，这时变量<code>man</code>的值正是<code>scanf</code>读上来的值，我们判断它是否在[0,
2]之间，如果<code>man &lt; 0</code>不成立，则整个表达式<code>scanf("%d", &amp;man) != 1 || man &lt; 0</code>
的值为假，也就是第二个<code>||</code>运算的左操作数为假，所以最后求右操作数<code>man &gt; 2</code>的值作为整个表达式的值。</p>
<p><code>&amp;&amp;</code>运算与此类似，<code>a &amp;&amp; b</code>的计算过程是：首先求表达式a的值，如果a的值是假则整个表达式的值是假，不会再去求b的值；如果a的值是真，则下一步求b的值作为整个表达式的值。所以，<code>a &amp;&amp; b</code>相当于“<code>if a then b</code>”，而<code>a || b</code>相当于“<code>if not a then b</code>”。这种特性称为Short-circuit，很多人喜欢利用Short-circuit特性简化代码。</p>
<p>3、在一个完整的声明末尾是Sequence
Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明<code>int a[10], b[20];</code>，在<code>a[10]</code>末尾是Sequence
Point，在<code>b[20]</code>末尾也是。</p>
<p>4、在一个完整的表达式末尾是Sequence
Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有<code>f(); g();</code>这样两条语句，<code>f()</code>和<code>g()</code>是两个完整的表达式，<code>f()</code>的Side
Effect必定在<code>g()</code>之前发生。</p>
<p>5、在库函数即将返回时是Sequence
Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（第
2.1 节 “函数式宏定义”），并不是真正的函数，所以才需要有这条规则。</p>
<p>还有两种Sequence
Point和某些C标准库函数的执行过程相关，此处从略，有兴趣的读者可参考[C99]的Annex
C。</p>
<p>现在可以分析一下本节开头的例子了。<code>a = (++a)+(++a)+(++a)+(++a);</code>的结果之所以是Undefined，因为在这个表达式中有五个Side
Effect都在改变<code>a</code>的值，这些Side
Effect按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个<code>++a</code>的值，这时第一个、第三个、第四个<code>++a</code>的Side
Effect发生了没有，<code>a</code>的值被加过几次了，这些都不确定，所以第二个<code>++a</code>的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。</p>
<p>写表达式应遵循的原则一：在两个Sequence
Point之间，同一个变量的值只允许被改变一次。仅有这一条原则还不够，例如<code>a[i++] = i;</code>的变量<code>i</code>只改变了一次，但结果仍是Undefined，因为等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么<code>i = i + 1;</code>就没有歧义呢？虽然也是等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，但你不读出<code>i</code>的值就没法计算<code>i + 1</code>，那拿什么去改<code>i</code>的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：如果在两个Sequence
Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写。</p>
<h2 id="运算符小结">运算符小结</h2>
<p>到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。</p>
<p>运算符<code>+ - * / % &gt; &lt; &gt;= &lt;= == != &amp; | ^</code>以及各种复合赋值运算符要求两边的操作数类型一致，条件运算符<code>?:</code>要求后两个操作数类型一致，这些运算符在计算之前都需要做Usual
Arithmetic Conversion。</p>
<p>下面按优先级从高到低的顺序总结一下C语言的运算符，每一条所列的各运算符具有相同的优先级，对于同一优先级的多个运算符按什么顺序计算也有说明，双目运算符就简单地用“左结合”或“右结合”来说明了。和指针有关的运算符<code>* &amp; -&gt;</code>也在这里列出来了，到第
23 章 指针再详细解释。</p>
<p>1、标识符、常量、字符串和用<code>()</code>括号套起来的表达式是组成表达式的最基本单元，在运算中做操作数，优先级最高。</p>
<p>2、后缀运算符，包括数组取下标<code>[]</code>、函数调用<code>()</code>、结构体取成员<code>“.”</code>、指向结构体的指针取成员<code>-&gt;</code>、后缀自增<code>++</code>、后缀自减<code>--</code>。如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）依次计算，比如<code>a.name++</code>，先算<code>a.name</code>，再<code>++</code>，这里的<code>.name</code>应该看成<code>a</code>的一个后缀，而不是把<code>.</code>看成双目运算符。</p>
<p>3、单目运算符，包括前缀自增<code>++</code>、前缀自减<code>--</code>、<code>sizeof</code>、类型转换<code>()</code>、取地址运算<code>&amp;</code>、指针间接寻址<code>*</code>、正号<code>+</code>、负号<code>-</code>、按位取反<code>~</code>、逻辑非<code>!</code>。如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）依次计算，比如<code>!~a</code>，先算<code>~a</code>，再求<code>!</code>。</p>
<p>4、乘<code>*</code>、除<code>/</code>、模<code>%</code>运算符。这三个运算符是左结合的。</p>
<p>5、加<code>+</code>、减<code>-</code>运算符。左结合。</p>
<p>6、移位运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。左结合。</p>
<p>7、关系运算符<code>&lt; &gt; &lt;= &gt;=</code>。左结合。</p>
<p>8、相等性运算符<code>==</code>和<code>!=</code>。左结合。</p>
<p>9、按位与<code>&amp;</code>。左结合。</p>
<p>10、按位异或<code>^</code>。左结合。</p>
<p>11、按位或<code>|</code>。左结合。</p>
<p>12、逻辑与<code>&amp;&amp;</code>。左结合。</p>
<p>13、逻辑或<code>||</code>。左结合。</p>
<p>14、条件运算符<code>:?</code>。在第 2 节
“if/else语句”讲过Dangling-else问题，条件运算符也有类似的问题。例如<code>a ? b : c ? d : e</code>是看成<code>(a ? b : c) ? d : e</code>还是<code>a ? b : (c ? d : e)</code>呢？C语言规定是后者。</p>
<p>15、赋值<code>=</code>和各种复合赋值（<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>）。在双目运算符中只有赋值和复合赋值是右结合的。</p>
<p>16、逗号运算符。左结合。</p>
<p>[K&amp;R]第2章也有这样一个列表，但是对于结合性解释得不够清楚。左结合和右结合这两个概念只对双目运算符有意义，对于前缀、后缀和三目运算符我单独做了说明。C语言表达式的详细语法规则可以参考[C99]的Annex
A.2，其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些细节用优先级和结合性是表达不了的，只有看C99才能了解完整的语法规则。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:53" itemprop="dateModified" datetime="2025-08-08T19:53:53+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="整型">整型</h2>
<p>我们知道，在C语言中<code>char</code>型占一个字节的存储空间，一个字节通常是8个bit。如果这8个bit按无符号整数来解释，取值范围是0~255，如果按有符号整数来解释，采用2’s
Complement表示法，取值范围是-128~127。C语言规定了<code>signed</code>和<code>unsigned</code>两个关键字，<code>unsigned char</code>型表示无符号数，<code>signed char</code>型表示有符号数。</p>
<p>那么以前我们常用的不带<code>signed</code>或<code>unsigned</code>关键字的<code>char</code>型是无符号数还是有符号数呢？C标准规定这是Implementation
Defined，编译器可以定义<code>char</code>型是无符号的，也可以定义<code>char</code>型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现，x86平台的gcc定义<code>char</code>型是有符号的。这也是C标准的Rationale之一：优先考虑效率，而可移植性尚在其次。这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如Linux内核代码使用了很多只有gcc支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由故意写不可移植的代码。从现在开始，我们会接触到很多Implementation
Defined的特性，C语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论C语言，就只能讨论到本书第一部分的程度了。注意，ASCII码的取值范围是0~127，所以不管<code>char</code>型是有符号的还是无符号的，存一个ASCII码都没有问题，一般来说，如果用<code>char</code>型存ASCII码字符，就不必明确写是<code>signed</code>还是<code>unsigned</code>，如果用<code>char</code>型表示8位的整数，为了可移植性就必须写明是<code>signed</code>还是<code>unsigned</code>。</p>
<p>Implementation-defined、Unspecified和Undefined
在C标准中没有做明确规定的地方会用Implementation-defined、Unspecified或Undefined来表述，在本书中有时把这三种情况统称为“未明确定义”的。这三种情况到底有什么不同呢？</p>
<p>我们刚才看到一种Implementation-defined的情况，C标准没有明确规定<code>char</code>是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。</p>
<p>而对于Unspecified的情况，往往有几种可选的处理方式，C标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是Unspecified的。</p>
<p>Undefined的情况则是完全不确定的，C标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多Undefined的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是Undefined的。</p>
<p>初学者看到这些规则通常会很不舒服，觉得这不是在学编程而是在啃法律条文，结果越学越泄气。是的，C语言并不像一个数学定理那么完美，现实世界里的东西总是不够完美的。但还好啦，C程序员已经很幸福了，只要严格遵照C标准来写代码，不要去触碰那些阴暗角落，写出来的代码就有很好的可移植性。想想那些可怜的JavaScript程序员吧，他们甚至连一个可以遵照的标准都没有，一个浏览器一个样，甚至同一个浏览器的不同版本也差别很大，程序员不得不为每一种浏览器的每一个版本分别写不同的代码。</p>
<p>除了<code>char</code>型之外，整型还包括<code>short int</code>（或者简写为<code>short</code>）、<code>int</code>、<code>long int</code>（或者简写为<code>long</code>）、<code>long long int</code>（或者简写为<code>long long</code>）等几种，这些类型都可以加上<code>signed</code>或<code>unsigned</code>关键字表示有符号或无符号数。其实，对于有符号数在计算机中的表示是Sign
and Magnitude、1’s Complement还是2’s
Complement，C标准也没有明确规定，也是Implementation
Defined。大多数体系结构都采用2’s
Complement表示法，x86平台也是如此，从现在开始我们只讨论2’s
Complement表示法的情况。还有一点要注意，除了<code>char</code>型以外的这些类型如果不明确写<code>signed</code>或<code>unsigned</code>关键字都表示<code>signed</code>，这一点是C标准明确规定的，不是Implementation
Defined。</p>
<p>除了<code>char</code>型在C标准中明确规定占一个字节之外，其它整型占几个字节都是Implementation
Defined。通常的编译器实现遵守ILP32或LP64规范，如下表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>ILP32（位数）</th>
<th>LP64（位数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>32</td>
<td>64</td>
</tr>
<tr>
<td>long long</td>
<td>64</td>
<td>64</td>
</tr>
<tr>
<td>指针</td>
<td>32</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>ILP32这个缩写的意思是<code>int</code>（I）、<code>long</code>（L）和指针（P）类型都占32位，通常32位计算机的C编译器采用这种规范，x86平台的gcc也是如此。LP64是指long（L）和指针占64位，通常64位计算机的C编译器采用这种规范。指针类型的长度总是和计算机的位数一致，至于什么是计算机的位数，指针又是一种什么样的类型，我们到第
17 章 计算机体系结构基础和第 23 章
指针再分别详细解释。从现在开始本书做以下约定：在以后的陈述中，缺省平台是x86/Linux/gcc，遵循ILP32，并且char是有符号的，我不会每次都加以说明，但说到其它平台时我会明确指出是什么平台。</p>
<p>在第 2 节
“常量”讲过C语言的常量有整数常量、字符常量、枚举常量和浮点数常量四种，其实字符常量和枚举常量的类型都是<code>int</code>型，因此前三种常量的类型都属于整型。整数常量有很多种，不全是<code>int</code>型的，下面我们详细讨论整数常量。</p>
<p>以前我们只用到十进制的整数常量，其实在C语言中也可以用八进制和十六进制的整数常量[26]。八进制整数常量以0开头，后面的数字只能是0<sub>7，例如022，因此十进制的整数常量就不能以0开头了，否则无法和八进制区分。十六进制整数常量以0x或0X开头，后面的数字可以是0</sub>9、a<sub>f和A</sub>F。在第
6 节
“字符类型与字符编码”讲过一种转义序列，以，这种表示方式相当于把八进制和十六进制整数常量开头的0替换成。</p>
<p>整数常量还可以在末尾加u或U表示“<code>unsigned</code>”，加l或L表示“<code>long</code>”，加ll或LL表示“<code>long long</code>”，例如0x1234U，98765ULL等。但事实上u、l、ll这几种后缀和上面讲的<code>unsigned</code>、<code>long</code>、<code>long long</code>关键字并不是一一对应的。这个对应关系比较复杂，准确的描述如下表所示（出自[C99]条款6.4.4.1）。</p>
<p>表 15.2. 整数常量的类型</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>后缀</th>
<th>十进制常量</th>
<th>八进制或十六进制常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>int<br>long int<br>long long int<br></td>
<td>int<br>unsigned int<br>long int<br>unsigned long int<br>long long
int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>u或U</td>
<td>unsigned int<br>unsigned long int<br>unsigned long long int<br></td>
<td>unsigned int<br>unsigned long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>l或L</td>
<td>long int<br>long long int<br></td>
<td>long int<br>unsigned long int<br>long long int<br>unsigned long long
int<br></td>
</tr>
<tr>
<td>既有u或U，又有l或L</td>
<td>unsigned long int<br>unsigned long long int<br></td>
<td>unsigned long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>ll或LL</td>
<td>long long int</td>
<td>long long int<br>unsigned long long int<br></td>
</tr>
<tr>
<td>既有u或U，又有ll或LL</td>
<td>unsigned long long int</td>
<td>unsigned long long int</td>
</tr>
</tbody>
</table>
<p>给定一个整数常量，比如1234U，那么它应该属于“u或U”这一行的“十进制常量”这一列，这个表格单元中列了三种类型<code>unsigned int</code>、<code>unsigned long int</code>、<code>unsigned long long int</code>，从上到下找出第一个足够长的类型可以表示1234这个数，那么它就是这个整数常量的类型，如果<code>int</code>是32位的那么<code>unsigned int</code>就可以表示。</p>
<p>再比如0xffff0000，应该属于第一行“无”的第二列“八进制或十六进制常量”，这一列有六种类型<code>int</code>、<code>unsigned int</code>、<code>long int</code>、<code>unsigned long int</code>、<code>long long int</code>、<code>unsigned long long int</code>，第一个类型<code>int</code>表示不了0xffff0000这么大的数，我们写这个十六进制常量是要表示一个正数，而它的MSB（第31位）是1，如果按有符号<code>int</code>类型来解释就成了负数了，第二个类型<code>unsigned int</code>可以表示这个数，所以这个十六进制常量的类型应该算<code>unsigned int</code>。所以请注意，0x7fffffff和0xffff0000这两个常量虽然看起来差不多，但前者是<code>int</code>型，而后者是<code>unsigned int</code>型。</p>
<p>讲一个有意思的问题。我们知道x86平台上<code>int</code>的取值范围是-2147483648~2147483647，那么用<code>printf("%d\n", -2147483648);</code>打印<code>int</code>类型的下界有没有问题呢？如果用<code>gcc main.c -std=c99</code>编译会有警告信息：<code>warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’</code>。这是因为，虽然-2147483648这个数值能够用<code>int</code>型表示，但在C语言中却没法写出对应这个数值的<code>int</code>型常量，C编译器会把它当成一个整数常量2147483648和一个负号运算符组成的表达式，而整数常量2147483648已经超过了<code>int</code>型的取值范围，在x86平台上<code>int</code>和<code>long</code>的取值范围相同，所以这个常量也超过了<code>long</code>型的取值范围，根据上表第一行“无”的第一列十进制常量，这个整数常量应该算<code>long long</code>型的，前面再加个负号组成的表达式仍然是<code>long long</code>型，而<code>printf</code>的<code>%d</code>转换说明要求后面的参数是<code>int</code>型，所以编译器报警告。之所以编译命令要加<code>-std=c99</code>选项是因为C99以前对于整数常量的类型规定和上表有一些出入，即使不加这个选项也会报警告，但警告信息不准确，读者可以试试。如果改成<code>printf("%d\n", -2147483647-1);</code>编译器就不会报警告了，<code>-</code>号运算符的两个操作数-2147483647和1都是<code>int</code>型，计算结果也应该是<code>int</code>型，并且它的值也没有超出<code>int</code>型的取值范围；或者改成<code>printf("%lld\n", -2147483648);</code>也可以，转换说明<code>%lld</code>告诉<code>printf</code>后面的参数是<code>long long</code>型，有些转换说明格式目前还没讲到，详见第
2.9 节 “格式化I/O函数”。</p>
<p>怎么样，整数常量没有你原来想的那么简单吧。再看一个不简单的问题。<code>long long i = 1234567890 * 1234567890;</code>编译时会有警告信息：<code>warning: integer overflow in expression</code>。1234567890是<code>int</code>型，两个<code>int</code>型相乘的表达式仍然是<code>int</code>型，而乘积已经超过<code>int</code>型的取值范围了，因此提示计算结果溢出。如果改成<code>long long i = 1234567890LL * 1234567890;</code>，其中一个常量是<code>long long</code>型，另一个常量也会先转换成<code>long long</code>型再做乘法运算，两数相乘的表达式也是<code>long long</code>型，编译器就不会报警告了。有关类型转换的规则将在第
3 节 “类型转换”详细介绍。</p>
<h2 id="浮点型">浮点型</h2>
<p>C标准规定的浮点型有<code>float</code>、<code>double</code>、<code>long double</code>，和整型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大，有的处理器有浮点运算单元（FPU，Floating
Point
Unit），称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单元，只能做整数运算，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。大部分平台的浮点数实现遵循IEEE
754，<code>float</code>型通常是32位，<code>double</code>型通常是64位。</p>
<p><code>long double</code>型通常是比<code>double</code>型精度更高的类型，但各平台的实现有较大差异。在x86平台上，大多数编译器实现的<code>long double</code>型是80位，因为x86的浮点运算单元具有80位精度，gcc实现的<code>long double</code>型是12字节（96位），这是为了对齐到4字节边界（在第
4 节
“结构体和联合体”详细讨论对齐的问题），也有些编译器实现的<code>long double</code>型和<code>double</code>型精度相同，没有充分利用x86浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如PowerPC上的<code>long double</code>型通常是128位。</p>
<p>以前我们只用到最简单的浮点数常量，例如3.14，现在看看浮点数常量还有哪些写法。由于浮点数在计算机中的表示是基于科学计数法的，所以浮点数常量也可以写成科学计数法的形式，尾数和指数之间用e或E隔开，例如314e-2表示314×10-2，注意这种表示形式基数是10[27]，如果尾数的小数点左边或右边没有数字则表示这一部分为零，例如3.e-1，.987等等。浮点数也可以加一个后缀，例如3.14f、.01L，浮点数的后缀和类型之间的对应关系比较简单，没有后缀的浮点数常量是<code>double</code>型的，有后缀f或F的浮点数常量是<code>float</code>型的，有后缀l或L的浮点数常量是<code>long double</code>型的。</p>
<h2 id="类型转换">类型转换</h2>
<p>如果有人问C语法规则中最复杂的是哪一部分，我一定会说是类型转换。从上面两节可以看出，有符号、无符号整数和浮点数加起来有那么多种类型，每两种类型之间都要定义一个转换规则，转换规则的数量自然很庞大，更何况由于各种体系结构对于整数和浮点数的实现很不相同，很多类型转换的情况都是C标准未做明确规定的阴暗角落。虽然我们写代码时不会故意去触碰这些阴暗角落，但有时候会不小心犯错，所以了解一些未明确规定的情况还是有必要的，可以在出错时更容易分析错误原因。本节分成几小节，首先介绍哪些情况下会发生类型转换，会把什么类型转成什么类型，然后介绍编译器如何处理这样的类型转换。</p>
<h3 id="integer-promotion">Integer Promotion</h3>
<p>在一个表达式中，凡是可以使用<code>int</code>或<code>unsigned int</code>类型做右值的地方也都可以使用有符号或无符号的<code>char</code>型、<code>short</code>型和Bit-field。如果原始类型的取值范围都能用<code>int</code>型表示，则其类型被提升为<code>int</code>，如果原始类型的取值范围用<code>int</code>型表示不了，则提升为<code>unsigned int</code>型，这称为Integer
Promotion。做Integer
Promotion只影响上述几种类型的值，对其它类型无影响。C99规定Integer
Promotion适用于以下几种情况：</p>
<p>1、如果一个函数的形参类型未知，例如使用了Old Style
C风格的函数声明（详见第 2 节
“自定义函数”），或者函数的参数列表中有…，那么调用函数时要对相应的实参做Integer
Promotion，此外，相应的实参如果是<code>float</code>型的也要被提升为<code>double</code>型，这条规则称为Default
Argument
Promotion。我们知道<code>printf</code>的参数列表中有…，除了第一个形参之外，其它形参的类型都是未知的，比如有这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure>
<p><code>ch</code>要被提升为<code>int</code>型之后再传给<code>printf</code>。</p>
<p>2、算术运算中的类型转换。有符号或无符号的<code>char</code>型、<code>short</code>型和Bit-field在做算术运算之前首先要做Integer
Promotion，然后才能参与计算。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c1 = <span class="number">255</span>, c2 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n = c1 + c2;</span><br></pre></td></tr></table></figure>
<p>计算表达式<code>c1 + c2</code>的过程其实是先把<code>c1</code>和<code>c2</code>提升为<code>int</code>型然后再相加（<code>unsigned char</code>的取值范围是0~255，完全可以用<code>int</code>表示，所以提升为<code>int</code>就可以了，不需要提升为<code>unsigned int</code>），整个表达式的值也是<code>int</code>型，最后的结果是257。假如没有这个提升的过程，<code>c1 + c2</code>就溢出了，溢出会得到什么结果是Undefined，在大多数平台上会把进位截掉，得到的结果应该是1。</p>
<p>除了<code>+</code>号之外还有哪些运算符在计算之前需要做Integer
Promotion呢？我们在下一小节先介绍Usual Arithmetic
Conversion规则，然后再解答这个问题。</p>
<h3 id="usual-arithmetic-conversion">Usual Arithmetic Conversion</h3>
<p>两个算术类型的操作数做算术运算，比如<code>a + b</code>，如果两边操作数的类型不同，编译器会自动做类型转换，使两边类型相同之后才做运算，这称为Usual
Arithmetic Conversion。转换规则如下：</p>
<p>如果有一边的类型是<code>long double</code>，则把另一边也转成<code>long double</code>。</p>
<p>否则，如果有一边的类型是<code>double</code>，则把另一边也转成<code>double</code>。</p>
<p>否则，如果有一边的类型是<code>float</code>，则把另一边也转成<code>float</code>。</p>
<p>否则，两边应该都是整型，首先按上一小节讲过的规则对<code>a</code>和<code>b</code>做Integer
Promotion，然后如果类型仍不相同，则需要继续转换。首先我们规定<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>的转换级别（Integer
Conversion
Rank）一个比一个高，同一类型的有符号和无符号数具有相同的Rank。转换规则如下：</p>
<p>如果两边都是有符号数，或者都是无符号数，那么较低Rank的类型转换成较高Rank的类型。例如<code>unsigned int</code>和<code>unsigned long</code>做算术运算时都转成<code>unsigned long</code>。</p>
<p>否则，如果一边是无符号数另一边是有符号数，无符号数的Rank不低于有符号数的Rank，则把有符号数转成另一边的无符号类型。例如<code>unsigned long</code>和<code>int</code>做算术运算时都转成<code>unsigned long</code>，<code>unsigned long</code>和<code>long</code>做算术运算时也都转成<code>unsigned long</code>。</p>
<p>剩下的情况是：一边有符号另一边无符号，并且无符号数的Rank低于有符号数的Rank。这时又分为两种情况，如果这个有符号数类型能够覆盖这个无符号数类型的取值范围，则把无符号数转成另一边的有符号类型。例如遵循LP64的平台上<code>unsigned int</code>和<code>long</code>在做算术运算时都转成<code>long</code>。</p>
<p>否则，也就是这个有符号数类型不足以覆盖这个无符号数类型的取值范围，则把两边都转成有符号数的Rank对应的无符号类型。例如在遵循ILP32的平台上<code>unsigned int</code>和<code>long</code>在做算术运算时都转成<code>unsigned long</code>。</p>
<p>可见有符号和无符号整数的转换规则是十分复杂的，虽然这是有明确规定的，不属于阴暗角落，但为了程序的可读性不应该依赖这些规则来写代码。我讲这些规则，不是为了让你用，而是为了让你了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段。</p>
<p>到目前为止我们学过的<code>+ - * / % &gt; &lt; &gt;= &lt;= == !=</code>运算符都需要做Usual
Arithmetic
Conversion，因为都要求两边操作数的类型一致，在下一章会介绍几种新的运算符也需要做Usual
Arithmetic
Conversion。单目运算符<code>+ - ~</code>只有一个操作数，移位运算符<code>&lt;&lt; &gt;&gt;</code>两边的操作数类型不要求一致，这些运算不需要做Usual
Arithmetic Conversion，但也需要做Integer
Promotion，运算符<code>~ &lt;&lt; &gt;&gt;</code>将在下一章介绍。</p>
<h3 id="由赋值产生的类型转换">由赋值产生的类型转换</h3>
<p>如果赋值或初始化时等号两边的类型不相同，则编译器会把等号右边的类型转换成等号左边的类型再做赋值。例如<code>int c = 3.14;</code>，编译器会把右边的<code>double</code>型转成<code>int</code>型再赋给变量c。</p>
<p>我们知道，函数调用传参的过程相当于定义形参并且用实参对其做初始化，函数返回的过程相当于定义一个临时变量并且用<code>return</code>的表达式对其做初始化，所以由赋值产生的类型转换也适用于这两种情况。例如一个函数的原型是<code>int foo(int, int);</code>，则调用<code>foo(3.1, 4.2)</code>时会自动把两个<code>double</code>型的实参转成<code>int</code>型赋给形参，如果这个函数定义中有返回语句<code>return 1.2;</code>，则返回值1.2会自动转成<code>int</code>型再返回。</p>
<p>在函数调用和返回过程中发生的类型转换往往容易被忽视，因为函数原型和函数调用并没有写在一起。例如<code>char c = getchar();</code>，看到这一句往往会想当然地认为<code>getchar</code>的返回值是<code>char</code>型，而事实上<code>getchar</code>的返回值是<code>int</code>型，这样赋值会引起类型转换，可能产生Bug，我们在第
2.5 节 “以字节为单位的I/O函数”详细讨论这个问题。</p>
<h3 id="强制类型转换">强制类型转换</h3>
<p>以上三种情况通称为隐式类型转换（Implicit
Conversion，或者叫Coercion），编译器根据它自己的一套规则将一种类型自动转换成另一种类型。除此之外，程序员也可以通过类型转换运算符（Cast
Operator）自己规定某个表达式要转换成何种类型，这称为显式类型转换（Explicit
Conversion）或强制类型转换（Type
Cast）。例如计算表达式<code>(double)3 + i</code>，首先将整数3强制转换成<code>double</code>型（值为3.0），然后和整型变量<code>i</code>相加，这时适用Usual
Arithmetic
Conversion规则，首先把<code>i</code>也转成<code>double</code>型，然后两者相加，最后整个表达式也是<code>double</code>型的。这里的<code>(double)</code>就是一个类型转换运算符，这种运算符由一个类型名套<code>()</code>括号组成，属于单目运算符，后面的3是这个运算符的操作数。注意操作数的类型必须是标量类型，转换之后的类型必须是标量类型或者<code>void</code>型。</p>
<h3 id="编译器如何处理类型转换">编译器如何处理类型转换</h3>
<p>以上几小节介绍了哪些情况下会发生类型转换，并且明确了每种情况下会把什么类型转成什么类型，本节介绍编译器如何处理任意两种类型之间的转换。现在要把一个M位的类型（值为X）转换成一个N位的类型，所有可能的情况如下表所示。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>待转换的类型</th>
<th>M &gt; N的情况</th>
<th>M == N的情况</th>
<th>M &lt; N的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed integer to signed integer</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>值不变</td>
<td>值不变</td>
</tr>
<tr>
<td>unsigned integer to signed integer</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>如果X在目标类型的取值范围内则值不变，否则Implementation-defined</td>
<td>值不变</td>
</tr>
<tr>
<td>signed integer to unsigned integer</td>
<td>X % 2N</td>
<td>X % 2N</td>
<td>X % 2N</td>
</tr>
<tr>
<td>unsigned integer to unsigned integer</td>
<td>X % 2N</td>
<td>值不变</td>
<td>值不变</td>
</tr>
<tr>
<td>floating-point to signed or unsigned integer</td>
<td>Truncate toward
Zero，如果X的整数部分超出目标类型的取值范围则Undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed or unsigned integer to floating-point</td>
<td>如果X在目标类型的取值范围内则值不变，但有可能损失精度，如果X超出目标类型的取值范围则Undefined</td>
<td></td>
<td></td>
</tr>
<tr>
<td>floating-point to floating-point</td>
<td>如果X在目标类型的取值范围内则值不变，但有可能损失精度，如果X超出目标类型的取值范围则Undefined</td>
<td>值不变</td>
<td>值不变</td>
</tr>
</tbody>
</table>
<p>注意上表中的“X %
2N”，我想表达的意思是“把X加上或者减去2N的整数倍，使结果落入[0,
2N-1]的范围内”，当X是负数时运算结果也得是正数，即运算结果和除数同号而不是和被除数同号，这不同于C语言%运算的定义。写程序时不要故意用上表中的规则，尤其不要触碰Implementation-defined和Undefined的情况，但程序出错时可以借助上表分析错误原因。</p>
<p>下面举几个例子说明上表的用法。比如把<code>double</code>型转换成<code>short</code>型，对应表中的“floating-point
to signed or unsigned integer”，如果原值在(-32769.0,
32768.0)之间则截掉小数部分得到转换结果，否则产生溢出，结果是Undefined，例如对于<code>short s = 32768.4;</code>这个语句gcc会报警告。</p>
<p>比如把<code>int</code>型转换成<code>unsigned short</code>型，对应表中的“signed
integer to unsigned
integer”，如果原值是正的，则把它除以216取模，其实就是取它的低16位，如果原值是负的，则加上216的整数倍，使结果落在[0,
65535]之间。</p>
<p>比如把<code>int</code>类型转换成<code>short</code>类型，对应表中的“signed
integer to signed integer”，如果原值在[-32768,
32767]之间则值不变，否则产生溢出，结果是Implementation-defined，例如对于<code>short s = -32769;</code>这个语句gcc会报警告。</p>
<p>最后一个例子，把<code>short</code>型转换成<code>int</code>型，对应表中的“signed
integer to signed
integer”，转换之后应该值不变。那怎么维持值不变呢？是不是在高位补16个0就行了呢？如果原值是-1，十六进制表示就是ffff，要转成<code>int</code>型的-1需要变成ffffffff，因此需要在高位补16个1而不是16个0。换句话说，要维持值不变，在高位补1还是补0取决于原来的符号位，这称为符号扩展（Sign
Extension）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:gdb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 17:49:37" itemprop="dateModified" datetime="2025-08-07T17:49:37+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入<code>printf</code>，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的代码行等。掌握了gdb的用法之后，调试手段就更加丰富了。但要注意，即使调试手段丰富了，调试的基本思想仍然是“分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设”这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用而忽略了分析过程，往往会治标不治本地修正Bug，导致一个错误现象消失了但Bug仍然存在，甚至是把程序越改越错。本章通过初学者易犯的几个错误实例来讲解如何使用gdb调试程序，在每个实例后面总结一部分常用的gdb命令。</p>
<h2 id="单步执行和跟踪函数调用">单步执行和跟踪函数调用</h2>
<p>看下面的程序：</p>
<p>例 函数调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">    result[<span class="number">0</span>] = add_range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    result[<span class="number">1</span>] = add_range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>, result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_range</code>函数从<code>low</code>加到<code>high</code>，在<code>main</code>函数中首先从<code>1</code>加到<code>10</code>，把结果保存下来，然后从<code>1</code>加到<code>100</code>，再把结果保存下来，最后打印的两个结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br></pre></td></tr></table></figure>
<p>第一个结果正确[20]，第二个结果显然不正确，在小学我们就听说过高斯小时候的故事，从1加到100应该是5050。一段代码，第一次运行结果是对的，第二次运行却不对，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。在动手调试之前，读者先试试只看代码能不能看出错误原因，只要前面几章学得扎实就应该能看出来。</p>
<p>在编译时要加上<code>-g</code>选项，生成的可执行文件才能用gdb进行源码级调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g main.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">GNU gdb 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入<code>help</code>可以查看命令的类别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure>
<p>也可以进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help files</span><br><span class="line">Specifying and examining files.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">add-shared-symbol-files -- Load the symbols from shared objects in the dynamic linker&#x27;s link map</span><br><span class="line">add-symbol-file -- Load symbols from FILE</span><br><span class="line">add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file</span><br><span class="line">cd -- Set working directory to DIR for debugger and program being debugged</span><br><span class="line">core-file -- Use FILE as core dump for examining memory and registers</span><br><span class="line">directory -- Add directory DIR to beginning of search path for source files</span><br><span class="line">edit -- Edit specified file or function</span><br><span class="line">exec-file -- Use FILE as program for getting contents of pure memory</span><br><span class="line">file -- Use FILE as program to be debugged</span><br><span class="line">forward-search -- Search for regular expression (see regex(3)) from last line listed</span><br><span class="line">generate-core-file -- Save a core file with the current state of the debugged process</span><br><span class="line">list -- List specified function or line</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在试试用<code>list</code>命令从第一行开始列出源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 1</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>一次只列10行，如果要从第11行开始继续列源代码可以输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure>
<p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) （直接回车）</span><br><span class="line">11  int main(void)</span><br><span class="line">12  &#123;</span><br><span class="line">13      int result[100];</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">17      return 0;</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>gdb的很多常用命令有简写形式，例如<code>list</code>命令可以写成<code>l</code>，要列一个函数的源代码也可以用函数名做参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l add_range</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>现在退出gdb的环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>我们做一个实验，把源代码改名或移到别处再用gdb调试，这样就列不出源代码了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> main.c mian.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) l</span><br><span class="line">5	main.c: No such file or directory.</span><br><span class="line">	in main.c</span><br></pre></td></tr></table></figure>
<p>可见gcc的<code>-g</code>选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用<code>start</code>命令开始执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14		result[0] = add_range(1, 10);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb停在<code>main</code>函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句。我们可以用<code>next</code>命令（简写为<code>n</code>）控制这些语句一条一条地执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">15		result[1] = add_range(1, 100);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">16		printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br><span class="line">17		return 0;</span><br></pre></td></tr></table></figure>
<p>用<code>n</code>命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在<code>return</code>语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在<code>main</code>函数中而在<code>add_range</code>函数中，现在用<code>start</code>命令重新来过，这次用<code>step</code>命令（简写为<code>s</code>）钻进<code>add_range</code>函数中去跟踪执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line"></span><br><span class="line">Breakpoint 2 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=10) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br></pre></td></tr></table></figure>
<p>这次停在了<code>add_range</code>函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，<code>backtrace</code>命令（简写为<code>bt</code>）可以查看函数调用的栈帧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=10) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br></pre></td></tr></table></figure>
<p>可见当前的<code>add_range</code>函数是被<code>main</code>函数调用的，<code>main</code>传进来的参数是<code>low=1</code>,
<code>high=10</code>。<code>main</code>函数的栈帧编号为<code>1</code>，<code>add_range</code>的栈帧编号为<code>0</code>。现在可以用<code>info</code>命令（简写为<code>i</code>）查看<code>add_range</code>函数局部变量的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i locals</span><br><span class="line">i = 0</span><br><span class="line">sum = 0</span><br></pre></td></tr></table></figure>
<p>如果想查看<code>main</code>函数当前局部变量的值也可以做到，先用<code>frame</code>命令（简写为<code>f</code>）选择<code>1</code>号栈帧然后再查看局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br><span class="line">14	    result[0] = add_range(1, 10);</span><br><span class="line">(gdb) i locals </span><br><span class="line">result = &#123;0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>result</code>数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用<code>s</code>或<code>n</code>往下走几步，然后用<code>print</code>命令（简写为<code>p</code>）打印出变量<code>sum</code>的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 3</span></span><br></pre></td></tr></table></figure>
<p>第一次循环<code>i</code>是<code>1</code>，第二次循环<code>i</code>是<code>2</code>，加起来是<code>3</code>，没错。这里的<code>$1</code>表示gdb保存着这些中间结果，<code>$</code>后面的编号会自动增长，在命令中可以用<code>$1</code>、<code>$2</code>、<code>$3</code>等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用<code>finish</code>命令让程序一直运行到从当前函数返回为止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=10) at main.c:6</span><br><span class="line">0x080483c1 in main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">Value returned is $2 = 55</span><br></pre></td></tr></table></figure>
<p>返回值是55，当前正准备执行赋值操作，用<code>s</code>命令赋值，然后查看<code>result</code>数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480,</span> </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值55确实赋给了<code>result</code>数组的第<code>0</code>个元素。下面用<code>s</code>命令进入第二次<code>add_range</code>调用，进入之后首先查看参数和局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=100) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=100) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483db <span class="keyword">in</span> main () at main.c:15</span></span><br><span class="line">(gdb) i locals </span><br><span class="line">i = 11</span><br><span class="line">sum = 55</span><br></pre></td></tr></table></figure>
<p>由于局部变量<code>i</code>和<code>sum</code>没初始化，所以具有不确定的值，又由于两次调用是挨着的，<code>i</code>和<code>sum</code>正好取了上次调用时的值，原来这跟例
3.7
“验证局部变量存储空间的分配和释放”是一样的道理，只不过我这次举的例子设法让局部变量<code>sum</code>在第一次调用时初值为<code>0</code>了。<code>i</code>的初值不是<code>0</code>倒没关系，在<code>for</code>循环中会赋值为<code>0</code>的，但<code>sum</code>如果初值不是<code>0</code>，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出gdb修改源代码了。如果我们不想浪费这次调试机会，可以在gdb中马上把<code>sum</code>的初值改为<code>0</code>继续运行，看看这一处改了之后还有没有别的Bug：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var sum=0</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=100) at main.c:6</span><br><span class="line">0x080483db in main () at main.c:15</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">Value returned is $4 = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5050</span><br><span class="line">17      return 0;</span><br></pre></td></tr></table></figure>
<p>这样结果就对了。修改变量的值除了用<code>set</code>命令之外也可以用<code>print</code>命令，因为<code>print</code>命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用<code>print</code>命令修改变量的值或者调用函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 33</span></span><br><span class="line">(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])</span><br><span class="line">result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 13</span></span><br></pre></td></tr></table></figure>
<p>我们讲过，<code>printf</code>的返回值表示实际打印的字符数，所以<code>$6</code>的结果是<code>13</code>。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>backtrace（或bt）</td>
<td>查看各级函数调用及参数</td>
</tr>
<tr>
<td>finish</td>
<td>连续运行到当前函数返回为止，然后停下来等待命令</td>
</tr>
<tr>
<td>frame（或f） 帧编号</td>
<td>选择栈帧</td>
</tr>
<tr>
<td>info（或i） locals</td>
<td>查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td>list（或l）</td>
<td>列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td>list 行号</td>
<td>列出从第几行开始的源代码</td>
</tr>
<tr>
<td>list 函数名</td>
<td>列出某个函数的源代码</td>
</tr>
<tr>
<td>next（或n）</td>
<td>执行下一行语句</td>
</tr>
<tr>
<td>print（或p）</td>
<td>打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td>quit（或q）</td>
<td>退出gdb调试环境</td>
</tr>
<tr>
<td>set var</td>
<td>修改变量的值</td>
</tr>
<tr>
<td>start</td>
<td>开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td>step（或s）</td>
<td>执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
</tbody>
</table>
<h2 id="断点">断点</h2>
<p>看以下程序：</p>
<p>例 断点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用是：首先从键盘读入一串数字存到字符数组<code>input</code>中，然后转换成整型存到<code>sum</code>中，然后打印出来，一直这样循环下去。<code>scanf("%s", input);</code>这个调用的功能是等待用户输入一个字符串并回车，<code>scanf</code>把其中第一段非空白（非空格、<code>Tab</code>、换行）的字符串保存到<code>input</code>数组中，并自动在末尾添加<code>'\0'</code>。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是<code>"2345"</code>，则循环累加的过程是<code>(((0*10+2)*10+3)*10+4)*10+5=2345</code>。注意字符型的<code>'2'</code>要减去<code>'0'</code>的ASCII码才能转换成整数值<code>2</code>。下面编译运行程序看看有什么问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">234</span><br><span class="line">input=123234</span><br><span class="line">（Ctrl-C退出程序）</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅<code>sum</code>赋了初值，连不必赋初值的<code>i</code>都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br></pre></td></tr></table></figure>
<p>有了上一次的经验，<code>sum</code>被列为重点怀疑对象，我们可以用<code>display</code>命令使得每次停下来的时候都显示当前<code>sum</code>的值，然后继续往下走：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display sum</span><br><span class="line">1: sum = -1208103488</span><br><span class="line">(gdb) n</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 0</span><br><span class="line">(gdb) </span><br><span class="line">123</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 0</span><br></pre></td></tr></table></figure>
<p><code>undisplay</code>命令可以取消跟踪显示，变量<code>sum</code>的编号是<code>1</code>，可以用<code>undisplay 1</code>命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用<code>break</code>命令（简写为<code>b</code>）在第9行设一个断点（Breakpoint）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">5       int sum = 0, i;</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">11              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">12          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">13      &#125;</span><br><span class="line">14      return 0;</span><br><span class="line">(gdb) b 9</span><br><span class="line">Breakpoint 2 at 0x80483bc: file main.c, line 9.</span><br></pre></td></tr></table></figure>
<p><code>break</code>命令的参数也可以是函数名，表示在某个函数开头设断点。现在用<code>continue</code>命令（简写为<code>c</code>）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>然后输入新的字符串准备转换：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">234</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>问题暴露出来了，新的转换应该再次从<code>0</code>开始累加，而<code>sum</code>现在已经是<code>123</code>了，原因在于新的循环没有把<code>sum</code>归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，“断点加单步”是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用<code>printf</code>打印中间结果时也要分析应该在哪里插入<code>printf</code>，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用<code>info</code>命令可以查看已经设置的断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 3 at 0x8048411: file main.c, line 12.</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>每个断点都有一个编号，可以用编号指定删除某个断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints 2</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoints 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep n   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) enable 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>
<p>gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当<code>sum</code>不等于<code>0</code>时才中断，然后用<code>run</code>命令（简写为<code>r</code>）重新从程序开头连续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 9 if sum != 0</span><br><span class="line">Breakpoint 5 at 0x80483c3: file main.c, line 9.</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">5       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    stop only if sum != 0</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 5, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>结果是第一次执行<code>scanf</code>之前没有中断，第二次却中断了。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break（或b） 行号</td>
<td>在某一行设置断点</td>
</tr>
<tr>
<td>break 函数名</td>
<td>在某个函数开头设置断点</td>
</tr>
<tr>
<td>break … if …</td>
<td>设置条件断点</td>
</tr>
<tr>
<td>continue（或c）</td>
<td>从当前位置开始连续运行程序</td>
</tr>
<tr>
<td>delete breakpoints 断点号</td>
<td>删除断点</td>
</tr>
<tr>
<td>display 变量名</td>
<td>跟踪查看某个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td>disable breakpoints 断点号</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable 断点号</td>
<td>启用断点</td>
</tr>
<tr>
<td>info（或i） breakpoints</td>
<td>查看当前设置了哪些断点</td>
</tr>
<tr>
<td>run（或r）</td>
<td>从头开始连续运行程序</td>
</tr>
<tr>
<td>undisplay 跟踪显示号</td>
<td>取消跟踪显示</td>
</tr>
</tbody>
</table>
<h2 id="观察点">观察点</h2>
<p>接着上一节的步骤，经过调试我们知道，虽然<code>sum</code>已经赋了初值<code>0</code>，但仍需要在<code>while (1)</code>循环的开头加上<code>sum = 0;</code>：</p>
<p>例 观察点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>scanf</code>函数是非常凶险的，即使修正了这个Bug也还存在很多问题。如果输入的字符串超长了会怎么样？我们知道数组访问越界是不会检查的，所以<code>scanf</code>会写出界。现象是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">67</span><br><span class="line">input=67</span><br><span class="line">12345</span><br><span class="line">input=123407</span><br></pre></td></tr></table></figure>
<p>下面用调试器看看最后这个诡异的结果是怎么出来的[21]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p input</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;12345&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>input</code>数组只有<code>5</code>个元素，写出界的是<code>scanf</code>自动添的<code>'\0'</code>，用<code>x</code>命令看会更清楚一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x00    0x00</span><br></pre></td></tr></table></figure>
<p><code>x</code>命令打印指定存储单元的内容。<code>7b</code>是打印格式，<code>b</code>表示每个字节一组，<code>7</code>表示打印<code>7</code>组[22]，从<code>input</code>数组的第一个字节开始连续打印<code>7</code>个字节。前<code>5</code>个字节是<code>input</code>数组的存储单元，打印的正是十六进制ASCII码的<code>'1'</code>到<code>'5'</code>，第<code>6</code>个字节是写出界的<code>'\0'</code>。根据运行结果，前4个字符转成数字都没错，第5个错了，也就是<code>i</code>从0到3的循环都没错，我们设一个条件断点从<code>i</code>等于4开始单步调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           sum = 0;</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">13          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">14      &#125;</span><br><span class="line">15      return 0;</span><br><span class="line">(gdb) b 12 if i == 4</span><br><span class="line">Breakpoint 2 at 0x80483e6: file main.c, line 12.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:12</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1234</span></span><br></pre></td></tr></table></figure>
<p>现在<code>sum</code>是<code>1234</code>没错，根据运行结果是<code>123407</code>我们知道即将进行的这步计算肯定要出错，算出来应该是<code>12340</code>，那就是说<code>input[4]</code>肯定不是<code>'5'</code>了，事实证明这个推理是不严谨的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x04    0x00</span><br></pre></td></tr></table></figure>
<p><code>input[4]</code>的确是<code>0x35</code>，产生<code>123407</code>还有另外一种可能，就是在下一次循环中<code>123450</code>不是加上而是减去一个数得到<code>123407</code>。可现在不是到字符串末尾了吗？怎么会有下一次循环呢？注意到循环控制条件是<code>input[i] != '\0'</code>，而本来应该是<code>0x00</code>的位置现在莫名其妙地变成了<code>0x04</code>，因此循环不会结束。继续单步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 12345</span></span><br><span class="line">(gdb) n</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x05    0x00</span><br></pre></td></tr></table></figure>
<p>进入下一次循环，原来的<code>0x04</code>又莫名其妙地变成了<code>0x05</code>，这是怎么回事？这个暂时解释不了，但<code>123407</code>这个结果可以解释了，是<code>12345*10 + 0x05 - 0x30</code>得到的，虽然多循环了一次，但下次一定会退出循环了，因为<code>0x05</code>的后面是<code>'\0'</code>。</p>
<p><code>input[4]</code>后面那个字节到底是什么时候变的？可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。下面删除原来设的断点，从头执行程序，重复上次的输入，用<code>watch</code>命令设置观察点，跟踪<code>input[4]</code>后面那个字节（可以用<code>input[5]</code>表示，虽然这是访问越界）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) watch input[5]</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line">(gdb) i watchpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       hw watchpoint  keep y              input[5]</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 0 &#x27;\0&#x27;</span><br><span class="line">New value = 1 &#x27;\001&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 1 &#x27;\001&#x27;</span><br><span class="line">New value = 2 &#x27;\002&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 2 &#x27;\002&#x27;</span><br><span class="line">New value = 3 &#x27;\003&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br></pre></td></tr></table></figure>
<p>已经很明显了，每次都是回到<code>for</code>循环开头的时候改变了<code>input[5]</code>的值，而且是每次加<code>1</code>，而循环变量<code>i</code>正是在每次回到循环开头之前加<code>1</code>，原来<code>input[5]</code>就是变量<code>i</code>的存储单元，换句话说，<code>i</code>的存储单元是紧跟在<code>input</code>数组后面的。</p>
<p>修正这个Bug对初学者来说有一定难度。如果你发现了这个Bug却没想到数组访问越界这一点，也许一时想不出原因，就会先去处理另外一个更容易修正的Bug：如果输入的不是数字而是字母或别的符号也能算出结果来，这显然是不对的，可以在循环中加上判断条件检查非法字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123a</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">dead</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234578</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">23</span><br><span class="line">input=23</span><br></pre></td></tr></table></figure>
<p>似乎是两个Bug一起解决掉了，但这是治标不治本的解决方法。看起来输入超长的错误是不出现了，但只要没有找到根本原因就不可能真的解决掉，等到条件一变，它可能又冒出来了，在下一节你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入超长也会报错。最后总结一下本节用到的gdb命令：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch</td>
<td>设置观察点</td>
</tr>
<tr>
<td>info（或i） watchpoints</td>
<td>查看当前设置了哪些观察点</td>
</tr>
<tr>
<td>x</td>
<td>从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量</td>
</tr>
</tbody>
</table>
<h2 id="段错误">段错误</h2>
<p>如果程序运行时出现段错误，用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程序：</p>
<p>例 段错误调试实例一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> man = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, man);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0xb7e1404b <span class="keyword">in</span> _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0xb7e1dd2b <span class="keyword">in</span> scanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0804839f <span class="keyword">in</span> main () at main.c:6</span></span><br></pre></td></tr></table></figure>
<p>在gdb中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。gdb显示段错误出现在<code>_IO_vfscanf</code>函数中，用<code>bt</code>命令可以看到这个函数是被我们的<code>scanf</code>函数调用的，所以是<code>scanf</code>这一行代码引发的段错误。仔细观察程序发现是<code>man</code>前面少了个<code>&amp;</code>。</p>
<p>继续调试上一节的程序，上一节最后提出修正Bug的方法是在循环中加上判断条件，如果不是数字就报错退出，不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无论怎么运行都不出错了，但假如我们把<code>while (1)</code>循环去掉，每次执行程序只转换一个数：</p>
<p>例 段错误调试实例二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输入一个超长的字符串，看看会发生什么：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br></pre></td></tr></table></figure>
<p>看起来正常。再来一次，这次输个更长的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>又出段错误了。我们按同样的方法用gdb调试看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0804848e in main () at main.c:19</span><br><span class="line">19  &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">14          &#125;</span><br><span class="line">15          sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">16      &#125;</span><br><span class="line">17      printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">18      return 0;</span><br><span class="line">19  &#125;</span><br></pre></td></tr></table></figure>
<p>gdb指出，段错误发生在第<code>19</code>行。可是这一行什么都没有啊，只有表示<code>main</code>函数结束的<code>&#125;</code>括号。这可以算是一条规律，如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误。</p>
<p>想要写出Bug-free的程序是非常不容易的，即使<code>scanf</code>读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误，有些错误现象是我们暂时没法解释的：为什么变量<code>i</code>的存储单元紧跟在<code>input</code>数组后面？为什么同样是访问越界，有时出段错误有时不出段错误？为什么访问越界的段错误在函数返回时才出现？还有最基本的问题，为什么<code>scanf</code>输入整型变量就必须要加<code>&amp;</code>，否则就出段错误，而输入字符串就不要加<code>&amp;</code>？这些问题在后续章节中都会解释清楚。其实现在讲<code>scanf</code>这个函数为时过早，读者还不具备充足的基础知识。但还是有必要讲的，学完这一阶段之后读者应该能写出有用的程序了，然而一个只有输出而没有输入的程序算不上是有用的程序，另一方面也让读者认识到，学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个<code>scanf</code>函数都没办法用好，更没有办法保证写出正确的程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:计算机中数的表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:54:02" itemprop="dateModified" datetime="2025-08-08T19:54:02+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么计算机使用二进制数">为什么计算机使用二进制数</h2>
<p>人类的计数方式通常是“逢十进一”，称为十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字0~9是目前最广泛采用的。</p>
<p>计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所以对计算机来说二进制（Binary）是最自然的计数方式。根据“逢二进一”的原则，十进制的1、2、3、4分别对应二进制的1、10、11、100。二进制的一位数字称为一个位（Bit），三个bit能够表示的最大的二进制数是111，也就是十进制的7。不管用哪种计数方式，数的大小并没有变，十进制的1+1等于2，二进制的1+1等于10，二进制的10和十进制的2大小是相等的。</p>
<h2 id="不同进制之间的换算">不同进制之间的换算</h2>
<p>在十进制中，个位的1代表100=1，十位的1代表101=10，百位的1代表102=100，所以</p>
<p>123=1×102+2×101+3×100</p>
<p>同样道理，在二进制中，个位的1代表20=1，十位的1代表21=2，百位的1代表22=4，所以</p>
<p>(A3A2A1A0)2=A3×23+A2×22+A1×21+A0×20</p>
<p>如果二进制和十进制数出现在同一个等式中，为了区别我们用(A3A2A1A0)2这种形式表示A3A2A1A0是二进制数，每个数字只能是0或1，其它没有套括号加下标的数仍表示十进制数。对于(A3A2A1A0)2这样一个二进制数，最左边的A3位称为最高位（MSB，Most
Significant Bit），最右边的A0位称为最低位（LSB，Least Significant
Bit）。以后我们遵循这样的惯例：LSB称为第0位而不是第1位，所以如果一个数是32位的，则MSB是第31位。上式就是从二进制到十进制的换算公式。作为练习，请读者算一下(1011)2和(1111)2换算成十进制分别是多少。</p>
<p>下面来看十进制怎么换算成二进制。我们知道</p>
<p>13=1×23+1×22+0×21+1×20</p>
<p>所以13换算成二进制应该是(1101)2。问题是怎么把13分解成等号右边的形式呢？注意到等号右边可以写成</p>
<p>13=(((0×2+13)×2+12)×2+01)×2+10</p>
<p>我们将13反复除以2取余数就可以提取出上式中的1101四个数字，为了让读者更容易看清楚是哪个1和哪个0，上式和下式中对应的数字都加了下标：</p>
<p>13÷2=6…10 6÷2=3…01 3÷2=1…12 1÷2=0…13</p>
<p>把这四步得到的余数按相反的顺序排列就是13的二进制表示，因此这种方法称为除二反序取余法。</p>
<p>计算机用二进制表示数，程序员也必须习惯使用二进制，但二进制写起来太啰嗦了，所以通常将二进制数分成每三位一组或者每四位一组，每组用一个数字表示。比如把(10110010)2从最低位开始每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是(262)8，这样每一位数字的取值范围是0<sub>7，逢八进一，称为八进制（Octal）。类似地，把(10110010)2分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是2，高位已经大于9了，我们规定用字母A</sub>F表示10<sub>15，这个数可以写成(B2)16，每一位数字的取值范围是0</sub>F，逢十六进一，称为十六进制（Hexadecimal）。所以，八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样。</p>
<h2 id="整数的加减运算">整数的加减运算</h2>
<p>我们已经了解了计算机中正整数如何表示，加法如何计算，那么负数如何表示，减法又如何计算呢？本节讨论这些问题。为了书写方便，本节举的例子都用8个bit表示一个数，实际计算机做整数加减运算的操作数可以是8位、16位、32位甚至64位的。</p>
<h3 id="sign-and-magnitude表示法">Sign and Magnitude表示法</h3>
<p>要用8个bit表示正数和负数，一种简单的想法是把最高位规定为符号位（Sign
Bit），0表示正1表示负，剩下的7位表示绝对值的大小，这称为Sign and
Magnitude表示法。例如-1表示成10000001，+1表示成00000001。这样用8个bit表示整数的取值范围是-27-1<sub>27-1，即-127</sub>127。</p>
<p>采用这种表示法，计算机做加法运算需要处理以下逻辑：</p>
<p>如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出（Overflow）[24]，这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。</p>
<p>如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同。</p>
<p>那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算a-b，可以先把b变号然后和a相加，相当于计算a+(-b)。但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步减法计算仍然是免不了的。我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有第
1 节
“为什么计算机用二进制计数”提到的加法器电路之外，还要另外有一套减法器电路。</p>
<p>如果采用Sign and
Magnitude表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。还有一个缺点是0的表示不唯一，既可以表示成10000000也可以表示成00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。</p>
<h3 id="s-complement表示法">1’s Complement表示法</h3>
<p>本节介绍一种二进制补码表示法，为了便于理解，我们先看一个十进制的例子：</p>
<p>167-52=167+(-52)=167+(999-52)-1000+1=167+947-1000+1=1114-1000+1=114+1=115
167-52 → 减法转换成加法 167+(-52) → 负数取9的补码表示 167+947 → 114进1 →
高位进的1加到低位上去，结果为115</p>
<p>在这个例子中我们用三位十进制数字表示正数和负数，具体规定如下：</p>
<p>9’s Complement表示法</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>补码表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>-499</td>
<td>500</td>
</tr>
<tr>
<td>-498</td>
<td>501</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>998</td>
</tr>
<tr>
<td>0</td>
<td>999</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>498</td>
<td>498</td>
</tr>
<tr>
<td>499</td>
<td>499</td>
</tr>
</tbody>
</table>
<p>首先-52要用999-52表示，就是947，这称为取9的补码（9’s
Complement）；然后把167和947相加，得到114进1；再把高位进的1加到低位上去，得115，本来应该加1000，结果加了1，少加了999，正好把先前取9的补码多加的999抵消掉了。我们本来要做167-52的减法运算，结果变成做999-52的减法运算，后者显然要容易一些，因为没有借位。这种补码表示法的计算规则用一句话概括就是：负数用9的补码表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。要验证这条规则得考虑四种情况：</p>
<p>两个正数，相加得正</p>
<p>一正一负，相加得正</p>
<p>一正一负，相加得负</p>
<p>两个负数，相加得负</p>
<p>我们举的例子验证了第二种情况，另外三种情况请读者自己验证，暂时不考虑溢出的问题，稍后会讲到如何判定溢出。</p>
<p>上述规则也适用于二进制：负数用1的补码（1’s
Complement）表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。取1的补码更简单，连减法都不用做，因为1-1=0，1-0=1，取1的补码就是把每个bit取反，所以1的补码也称为反码。比如：</p>
<p>00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 →
00000011进1 → 高位进的1加到低位上去，结果为00000100</p>
<p>1’s Complement表示法相对于Sign and
Magnitude表示法的优势是非常明显的：不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，计算逻辑更简单，甚至连减法器电路都省了，只要有一套加法器电路，再有一套把每个bit取反的电路，就可以做加法和减法运算。如果8个bit采用1’s
Complement表示法，负数的取值范围是从10000000到11111111（-127<sub>0），正数是从00000000到01111111（0</sub>127），仍然可以根据最高位判断一个数是正是负。美中不足的是0的表示仍然不唯一，既可以表示成11111111也可以表示成00000000，为了解决这最后一个问题，我们引入2’s
Complement表示法。</p>
<h3 id="s-complement表示法-1">2’s Complement表示法</h3>
<p>2’s
Complement表示法规定：正数不变，负数先取反码再加1。如果8个bit采用2’s
Complement表示法，负数的取值范围是从10000000到11111111（-128<sub>-1），正数是从00000000到01111111（0</sub>127），也可以根据最高位判断一个数是正是负，并且0的表示是唯一的，目前绝大多数计算机都采用这种表示法。为什么称为“2的补码”呢？因为对一位二进制数b取补码就是1-b+1=10-b，相当于从2里面减去b。类似地，要表示-4需要对00000100取补码，11111111-00000100+1=100000000-00000100，相当于从28里面减去4。2’s
Complement表示法的计算规则有些不同：减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。请读者自己验证上一节提到的四种情况下这条规则都能算出正确结果。</p>
<p>8个bit采用2’s
Complement表示法的取值范围是-128~127，如果计算结果超出这个范围就会产生溢出，例如：</p>
<p>10000010(-126)+11111000(-8)=01111010(122)</p>
<p>如何判断产生了溢出呢？我们还是分四种情况讨论：如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。</p>
<h3 id="有符号数和无符号数">有符号数和无符号数</h3>
<p>前面几节我们用8个bit表示正数和负数，讲了三种表示法，每种表示法对应一种计算规则，这称为有符号数（Signed
Number）；如果8个bit全部表示正数则取值范围是0~255，这称为无符号数（Unsigned
Number）。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样，比如上面的例子也可以看作无符号数的加法：</p>
<p>10000010(130)+11111000(248)=01111010(122+256)</p>
<p>如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出；但如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的。计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时根据最高位和次高位产生的进位的异或设置溢出标志。至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。</p>
<h2 id="浮点数">浮点数</h2>
<p>浮点数在计算机中的表示是基于科学计数法（Scientific
Notation）的，我们知道32767这个数用科学计数法可以写成3.2767×104，3.2767称为尾数（Mantissa，或者叫Significand），4称为指数（Exponent）。浮点数在计算机中的表示与此类似，只不过基数（Radix）是2而不是10。下面我们用一个简单的模型来解释浮点数的基本概念。我们的模型由三部分组成：符号位、指数部分（表示2的多少次方）和尾数部分（小数点前面是0，尾数部分只表示小数点后的数字）。</p>
<p>一种浮点数格式</p>
<table>
<thead>
<tr>
<th>1 bit</th>
<th>5 bits</th>
<th>8 bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>sign bit</td>
<td>exponent</td>
<td>significand</td>
</tr>
</tbody>
</table>
<p>如果要表示17这个数，我们知道17=17.0×100=0.17×102，类似地，17=(10001)2×20=(0.10001)2×25，把尾数的有效数字全部移到小数点后，这样就可以表示为：</p>
<p>17的浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>00101</td>
<td>10001000</td>
</tr>
</tbody>
</table>
<p>如果我们要表示0.25就遇到新的困难了，因为0.25=1×2-2=(0.1)2×2-1，而我们的模型中指数部分没有规定如何表示负数。我们可以在指数部分规定一个符号位，然而更广泛采用的办法是使用偏移的指数（Biased
Exponent）。规定一个偏移值，比如16，实际的指数要加上这个偏移值再填写到指数部分，这样比16大的就表示正指数，比16小的就表示负指数。要表示0.25，指数部分应该填16-1=15：</p>
<p>0.25的偏移指数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>01111</td>
<td>10000000</td>
</tr>
</tbody>
</table>
<p>现在还有一个问题需要解决：每个浮点数的表示都不唯一，例如17=(0.10001)2×25=(0.010001)2×26，这样给计算机处理增加了复杂性。为了解决这个问题，我们规定尾数部分的最高位必须是1，也就是说尾数必须以0.1开头，对指数做相应的调整，这称为正规化（Normalize）。由于尾数部分的最高位必须是1，这个1就不必保存了，可以节省出一位来用于提高精度，我们说最高位的1是隐含的（Implied）。这样17就只有一种表示方法了，指数部分应该是16+5=21=(10101)2，尾数部分去掉最高位的1是0001：</p>
<p>17的正规化尾数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10101</td>
<td>00010000</td>
</tr>
</tbody>
</table>
<p>两个浮点数相加，首先把小数点对齐然后相加：</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10010</td>
<td>10010000</td>
<td>+</td>
</tr>
<tr>
<td>0</td>
<td>10000</td>
<td>00110110</td>
<td>=</td>
</tr>
<tr>
<td>0</td>
<td>10010</td>
<td>11011101</td>
<td></td>
</tr>
</tbody>
</table>
<p>11.0010000+0.100110110=11.101110110</p>
<p>由于浮点数表示的精度有限，计算结果末尾的10两位被舍去了。做浮点运算时要注意精度损失（Significance
Loss）问题，有时计算顺序不同也会导致不同的结果，比如11.0010000+0.00000001+0.00000001=11.0010000+0.00000001=11.0010000，后面加的两个很小的数全被舍去了，没有对计算结果产生任何影响，但如果调一下计算顺序它们就能影响到计算结果了，0.00000001+0.00000001+11.0010000=0.00000010+11.0010000=11.0010001。再比如128.25=(10000000.01)2，需要10个有效位，而我们的模型中尾数部分是8位，算上隐含的最高位1一共有9个有效位，那么128.25的浮点数表示只能舍去末尾的1，表示成(10000000.0)2，其实跟128相等了。在第
2 节
“if/else语句”讲过浮点数不能做精确比较，现在读者应该知道为什么不能精确比较了。</p>
<p>整数运算会产生溢出，浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，但和整数运算的定义不同。假设整数采用8位2’s
Complement表示法，取值范围是-128<sub>127，如果计算结果是-130则称为下溢，计算结果是130则称为上溢。假设按本节介绍的浮点数表示法，取值范围是-(0.111111111)2×215</sub>(0.111111111)2×215，如果计算结果超出这个范围则称为上溢；如果计算结果未超出这个范围但绝对值太小了，在-(0.1)2×2-16~(0.1)2×2-16之间，那么也同样无法表示，称为下溢。</p>
<p>浮点数是一个相当复杂的话题，不同平台的浮点数表示和浮点运算也有较大差异，本节只是通过这个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，目前业界广泛采用的符点数标准是由IEEE（Institute
of Electrical and Electronics Engineers）制定的IEEE 754。</p>
<p>最后讨论一个细节问题。我们知道，定义全局变量时如果没有Initializer就用0初始化，定义数组时如果Initializer中提供的元素不够那么剩下的元素也用0初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">double</span> a[<span class="number">10</span>] = &#123; <span class="number">1.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>“用<code>0</code>初始化”的意思是变量<code>i</code>、变量<code>d</code>和数组元素<code>a[1]~a[9]</code>的所有字节都用<code>0</code>填充，或者说所有bit都是0。无论是用Sign
and Magnitude表示法、1’s Complement表示法还是2’s
Complement表示法，一个整数的所有bit是0都表示0值，但一个浮点数的所有bit是0一定表示0值吗？严格来说不一定，某种平台可能会规定一个浮点数的所有bit是0并不表示0值，但[C99
Rationale]第6.7.8节的条款25提到：As far as the committee knows, all
machines treat all bits zero as a representation of floating-point zero.
But, all bits zero might not be the canonical representation of zero.
因此在绝大多数平台上，一个浮点数的所有bit是0就表示0值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:分支语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 18:33:21" itemprop="dateModified" datetime="2025-08-06T18:33:21+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="if语句">if语句</h2>
<p>目前我们写的简单函数中可以有多条语句，但这些语句总是从前到后顺序执行的。除了顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在C语言中可以用分支语句（Selection
Statement）实现，比如：</p>
<p>if (x != 0) { printf(“x is nonzero.”); } 其中x !=
0表示“x不等于0”的条件，这个表达式称为控制表达式（Controlling
Expression）如果条件成立，则{}中的语句被执行，否则{}中的语句不执行，直接跳到}后面。if和控制表达式改变了程序的控制流程（Control
Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支（Branch）。上例中的!=号表示“不等于”，像这样的运算符有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody>
</table>
<p>注意以下几点：</p>
<p>这里的<code>==</code>表示数学中的相等关系，相当于数学中的<code>=</code>号，初学者常犯的错误是在控制表达式中把<code>==</code>写成<code>=</code>，在C语言中<code>=</code>号是赋值运算符，两者的含义完全不同。</p>
<p>如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用<code>int</code>型的<code>1</code>和<code>0</code>表示。如果变量<code>x</code>的值是<code>-1</code>，那么<code>x&gt;0</code>这个表达式的值为<code>0</code>，<code>x&gt;-2</code>这个表达式的值为<code>1</code>。</p>
<p>在数学中<code>a&lt;b&lt;c</code>表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，但作为C语言表达式却不是这样。以上几种运算符都是左结合的，请读者想一下这个表达式应如何求值。</p>
<p>这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较，在第
1.5 节 “比较字符串”我们会介绍比较字符串的方法。</p>
<p><code>==</code>和<code>!=</code>称为相等性运算符（Equality
Operator），其余四个称为关系运算符（Relational
Operator），相等性运算符的优先级低于关系运算符。</p>
<p>总结一下，<code>if (x != 0) &#123; ... &#125;</code>这个语句的计算顺序是：首先求<code>x != 0</code>这个表达式的值，如果值为<code>0</code>，就跳过<code>&#123;&#125;</code>中的语句直接执行后面的语句，如果值为<code>1</code>，就先执行<code>&#123;&#125;</code>中的语句，然后再执行后面的语句。事实上控制表达式取任何非<code>0</code>值都表示真值，例如<code>if (x) &#123; ... &#125;</code>和<code>if (x != 0) &#123; ... &#125;</code>是等价的，如果<code>x</code>的值是<code>2</code>，则<code>x != 0</code>的值是<code>1</code>，但对于<code>if</code>来说不管是<code>2</code>还是<code>1</code>都表示真值。</p>
<p>和if语句相关的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 语句 → { 语句列表 } 语句 → ;</p>
<p>在C语言中，任何允许出现语句的地方既可以是由<code>;</code>号结尾的一条语句，也可以是由<code>&#123;&#125;</code>括起来的若干条语句或声明组成的语句块（Statement
Block），语句块和上一章介绍的函数体的语法相同。注意语句块的<code>&#125;</code>后面不需要加<code>;</code>号。如果<code>&#125;</code>后面加了<code>;</code>号，则这个<code>;</code>号本身又是一条新的语句了，在C语言中一个单独的<code>;</code>号表示一条空语句（Null
Statement）。上例的语句块中只有一条语句，其实没必要写成语句块，可以简单地写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is nonzero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>语句块中也可以定义局部变量，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d, j=%d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>, i); <span class="comment">/* cannot access j here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和函数的局部变量同样道理，每次进入语句块时为变量j分配存储空间，每次退出语句块时释放变量<code>j</code>的存储空间。语句块也构成一个作用域，和例
3.6
“作用域”的分析类似，如果整个源文件是一张大纸，<code>foo</code>函数是盖在上面的一张小纸，则函数中的语句块是盖在小纸上面的一张更小的纸。语句块中的变量<code>i</code>和函数的局部变量<code>i</code>是两个不同的变量，因此两次打印的<code>i</code>值是不同的；语句块中的变量<code>j</code>在退出语句块之后就没有了，因此最后一行的<code>printf</code>不能打印变量<code>j</code>，否则编译器会报错。语句块可以用在任何允许出现语句的地方，不一定非得用在<code>if</code>语句中，单独使用语句块通常是为了定义一些比函数的局部变量更“局部”的变量。</p>
<h2 id="ifelse语句">if/else语句</h2>
<p><code>if</code>语句还可以带一个<code>else</code>子句（Clause），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里的<code>%</code>是取模（Modulo）运算符，<code>x%2</code>表示<code>x</code>除以<code>2</code>所得的余数（Remainder），C语言规定<code>%</code>运算符的两个操作数必须是整型的。两个正数相除取余数很好理解，如果操作数中有负数，结果应该是正是负呢？C99规定，如果<code>a</code>和<code>b</code>是整型，<code>b</code>不等于<code>0</code>，则表达式<code>(a/b)*b+a%b</code>的值总是等于<code>a</code>，再结合第
5 节 “表达式”讲过的整数除法运算要Truncate Toward
Zero，可以得到一个结论：%运算符的结果总是与被除数同号（想一想为什么）。其它编程语言对取模运算的规定各不相同，也有规定结果和除数同号的，也有不做明确规定的。</p>
<p>取模运算在程序中是非常有用的，例如上面的例子判断<code>x</code>的奇偶性（Parity），看<code>x</code>除以<code>2</code>的余数是不是<code>0</code>，如果是<code>0</code>则打印<code>x is even.</code>，如果不是<code>0</code>则打印<code>x is odd.</code>，读者应该能看出<code>else</code>在这里的作用了，如果在上面的例子中去掉<code>else</code>，则不管<code>x</code>是奇是偶，<code>printf("x is odd.\n");</code>总是执行。为了让这条语句更有用，可以把它封装（Encapsulate）成一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_parity</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把语句封装成函数的基本步骤是：把语句放到函数体中，把变量改成函数的参数。这样，以后要检查一个数的奇偶性只需调用这个函数而不必重复写这条语句了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_parity(<span class="number">17</span>);</span><br><span class="line">print_parity(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><code>if/else</code>语句的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 else 语句</p>
<p>右边的“语句”既可以是一条语句，也可以是由<code>&#123;&#125;</code>括起来的语句块。一条<code>if</code>语句中包含一条子语句，一条<code>if/else</code>语句中包含两条子语句，子语句可以是任何语句或语句块，当然也可以是另外一条<code>if</code>或<code>if/else</code>语句。根据组合规则，<code>if</code>或<code>if/else</code>可以嵌套使用。例如可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一个问题，类似<code>if (A) if (B) C; else D;</code>形式的语句怎么理解呢？可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>也可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        D;</span><br></pre></td></tr></table></figure>
<p>在第 1 节 “继续Hello
World”讲过，C代码的缩进只是为了程序员看起来方便，实际上对编译器不起任何作用，你的代码不管写成上面哪一种缩进格式，在编译器看起来都是一样的。那么编译器到底按哪种方式理解呢？也就是说，<code>else</code>到底是和<code>if (A)</code>配对还是和<code>if (B)</code>配对？很多编程语言的语法都有这个问题，称为Dangling-else问题。C语言规定，<code>else</code>总是和它上面最近的一个<code>if</code>配对，因此应该理解成<code>else</code>和<code>if (B)</code>配对，也就是按第二种方式理解。如果你写成上面第一种缩进的格式就很危险了：你看到的是这样，而编译器理解的却是那样。如果你希望编译器按第一种方式理解，应该明确加上<code>&#123;&#125;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>顺便提一下，浮点型的精度有限，不适合用<code>==</code>运算符做精确比较。以下代码可以说明问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">20.0</span>;</span><br><span class="line"><span class="type">double</span> j = i / <span class="number">7.0</span>;</span><br><span class="line"><span class="keyword">if</span> (j * <span class="number">7.0</span> == i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Equal.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unequal.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不同平台的浮点数实现有很多不同之处，在我的平台上运行这段程序结果为<code>Unequal</code>，即使在你的平台上运行结果为<code>Equal</code>，你再把<code>i</code>改成其它值试试，总有些值会使得结果为<code>Unequal</code>。等学习了第
4 节 “浮点数”你就知道为什么浮点型不能做精确比较了。</p>
<h2 id="布尔代数">布尔代数</h2>
<p>在第 1 节
“if语句”讲过，<code>a&lt;b&lt;c</code>不表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，那么如果想表示这个含义该怎么写呢？可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以用逻辑与（Logical
AND）运算符表示这两个条件同时成立。逻辑与运算符在C语言中写成两个<code>&amp;</code>号（Ampersand），上面的语句可以改写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>a &lt; b &amp;&amp; b &lt; c</code>这个控制表达式，要求“<code>a &lt; b</code>的值非<code>0</code>”和“<code>b &lt; c</code>的值非<code>0</code>”这两个条件同时成立整个表达式的值才为<code>1</code>，否则整个表达式的值为<code>0</code>。也就是只有两个条件都为真，它们做逻辑与运算的结果才为真，有一个条件为假，则逻辑与运算的结果为假，如下表所示：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A AND B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>这种表称为真值表（Truth
Table）。注意逻辑与运算的操作数以非0表示真以0表示假，而运算结果以1表示真以0表示假（类型是int），我们忽略这些细微的差别，在表中全部以1表示真以0表示假。C语言还提供了逻辑或（Logical
OR）运算符，写成两个|线（Pipe Sign），逻辑非（Logical
NOT）运算符，写成一个!号（Exclamation Mark），它们的真值表如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A OR B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>表 4.4. NOT的真值表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>NOT A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑或表示两个条件只要有一个为真，它们做逻辑或运算的结果就为真，只有两个条件都为假，逻辑或运算的结果才为假。逻辑非的作用是对原来的逻辑值取反，原来是真的就是假，原来是假的就是真。逻辑非运算符只有一个操作数，称为单目运算符（Unary
Operator），以前讲过的加减乘除、赋值、相等性、关系、逻辑与、逻辑或运算符都有两个操作数，称为双目运算符（Binary
Operator）。</p>
<p>关于逻辑运算的数学体系称为布尔代数（Boolean
Algebra），以它的创始人布尔命名。在编程语言中表示真和假的数据类型叫做布尔类型，在C语言中通常用int型来表示，非0表示真，0表示假[6]。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。以下是一些布尔代数的基本定理，为了简洁易读，真和假用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有点像乘法和加法运算），NOT用¬表示，变量x、y、z的值可能是0也可能是1。</p>
<p>¬¬x=x</p>
<p>x*0=0 x+1=1</p>
<p>x*1=x x+0=x</p>
<p>x*x=x x+x=x</p>
<p>x*¬x=0 x+¬x=1</p>
<p>x<em>y=y</em>x x+y=y+x</p>
<p>x<em>(y</em>z)=(x<em>y)</em>z x+(y+z)=(x+y)+z</p>
<p>x<em>(y+z)=x</em>y+x<em>z x+y</em>z=(x+y)*(x+z)</p>
<p>x+x<em>y=x x</em>(x+y)=x</p>
<p>x<em>y+x</em>¬y=x (x+y)*(x+¬y)=x</p>
<p>¬(x<em>y)=¬x+¬y ¬(x+y)=¬x</em>¬y</p>
<p>x+¬x<em>y=x+y x</em>(¬x+y)=x*y</p>
<p>x<em>y+¬x</em>z+y<em>z=x</em>y+¬x<em>z
(x+y)</em>(¬x+z)<em>(y+z)=(x+y)</em>(¬x+z)</p>
<p>除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的<em>换成+、+换成</em>、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明，更多细节可参考有关数字逻辑的教材，例如[数字逻辑基础]。我们将在本节的练习题中强化训练对这些定理的理解。</p>
<p>目前为止介绍的这些运算符的优先级顺序是：!高于* / %，高于+ -，高于&gt;
&lt; &gt;= &lt;=，高于==
!=，高于&amp;&amp;，高于||，高于=。写一个控制表达式很可能同时用到这些运算符中的多个，如果记不清楚运算符的优先级一定要多套括号。我们将在第
4 节 “运算符总结”总结C语言所有运算符的优先级和结合性。</p>
<h2 id="switch语句">Switch语句</h2>
<p>switch语句可以产生具有多个分支的控制流程。它的格式是：</p>
<p>switch (控制表达式) { case 常量表达式： 语句列表 case 常量表达式：
语句列表 … default： 语句列表 }</p>
<p>例如以下程序根据传入的参数1<sub>7分别打印Monday</sub>Sunday：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_day</span><span class="params">(<span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        case1:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case2:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case3:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case4:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case5:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case6:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case7:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Illegal day number!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf_day(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的参数是<code>2</code>，则从<code>case 2</code>分支开始执行，先是打印相应的信息，然后遇到<code>break</code>语句，它的作用是跳出整个<code>switch</code>语句块。C语言规定各<code>case</code>分支的常量表达式必须互不相同，如果控制表达式不等于任何一个常量表达式，则从<code>default</code>分支开始执行，通常把<code>default</code>分支写在最后，但不是必须的。使用<code>switch</code>语句要注意几点：</p>
<p><code>case</code>后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。</p>
<p>第 2 节
“if/else语句”讲过浮点型不适合做精确比较，所以C语言规定<code>case</code>后面跟的必须是整型常量表达式。</p>
<p>进入<code>case</code>后如果没有遇到<code>break</code>语句就会一直往下执行，后面其它<code>case</code>或<code>default</code>分支的语句也会被执行到，直到遇到<code>break</code>，或者执行到整个<code>switch</code>语句块的末尾。通常每个<code>case</code>后面都要加上<code>break</code>语句，但有时会故意不加<code>break</code>来利用这个特性</p>
<p><code>switch</code>语句不是必不可缺的，显然可以用一组<code>if ... else if ... else if ... else ...</code>代替，但是一方面用<code>switch</code>语句会使代码更清晰，另一方面，有时候编译器会对<code>switch</code>语句进行整体优化，使它比等价的<code>if/else</code>语句所生成的指令效率更高。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/FPGA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/FPGA/" class="post-title-link" itemprop="url">第一章:Verilog HDL数字集成电路设计方法概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-22 14:31:58" itemprop="dateModified" datetime="2025-11-22T14:31:58+08:00">2025-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/FPGA/" itemprop="url" rel="index"><span itemprop="name">FPGA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="modelsim的安装">Modelsim的安装</h2>
<p>在网上找到Modelsim 2020.2及其许可证license的安装包, 先安装.</p>
<p>对于license的导入, 按照以下步骤进行:</p>
<ol type="1">
<li>点击下载附件modelsim_crack.zip，解压。</li>
<li>进入Modelsim的软件安装目录（我的电脑的安装目录是D:/modeltech64_10.4/win64）文件夹下找到mgls64.dll文件，去掉只读属性.</li>
<li>将解压后的文件MentorKG.exe和patch_dll.bat复制到Modelsim软件安装目录下的win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>运行patch_dll.bat，稍等一段时间后即可生成一个TXT文本</li>
<li>将生成的TXT文本另存为LICENSE.TXT，另存的路径选择Modelsim软件的安装路径win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>恢复mgls64.dll文件的只读属性</li>
<li>接下来设置环境变量，在电脑桌面上点击“我的电脑”或“计算机”，右键选择【属性】-&gt;【高级系统设置】-&gt;选择“高级”选项卡下的【环境变量】</li>
<li>Windows环境变量有用户变量和系统变量两个环境变量，这里设置用户变量即可；如果最后使用不了，再以同样的方式设置系统变量。
点击【新建(N)】，打开编辑用户变量对话框，变量名命名为MGLS_LICENSE_FILE，变量值为刚才生成的LICENSE.TXT的文件路径，即D:/modeltech64_10.4/win64/LICENSE.TXT，点击【确定】</li>
<li>环境变量设置完成之后，点击两次【确定】按钮，返回电脑桌面即可设置完成。此时双击桌面上的Modelsim软件，可以进入.
操作完成后打开Modelsim，如果仍然未检测到License，可以试下重启电脑</li>
</ol>
<p>上面的是网络上的方法, 我之前可以正常打开modelsim,
但是有时候打开时可能会显示检测不到licence,
或者打开之后会显示用户图形界面使用不了, 这说明了原来的license已经过期了.
我打开了<code>C:\modeltech64_2020.4\win64</code>目录下的<code>patch64_dll.bat</code>文件,
然后会弹出一个窗口, 等运行停止后, 按下回车键, 就可以生成一个新的licence,
把这个licence放到这个目录下, 替换掉原来的license, 然后设置环境变量,
在用户变量里面把MGLS_LICENSE_FILE指向<code>C:\modeltech64_2020.4\win64\LICENSE.TXT</code>,
然后在系统变量里面把LM_LICENSE_FILE指向<code>C:\modeltech64_2020.4\win64\LICENSE.TXT</code>,
但是MGLS_LICENSE_FILE的优先级要更高一些, 似乎只用设置它就行了.
保存之后就可以正常打开modelsim了.</p>
<h2 id="modelsim的使用">Modelsim的使用</h2>
<ol type="1">
<li>打开Modelsim软件,在左上角选中File-&gt;Change
Directory,在弹出的对话框中选择当前项目所在的文件夹(注意路径中不能包含中文).</li>
<li>接下来,选择File-&gt;New-&gt;Project.会弹出一个Create
Project的界面,只需要输入Project Name这一项,其他保持默认,点击OK.</li>
<li>点击OK后,会弹出Add items to the Project界面,选择Add Existing
File,选中我们已经写好的RTL代码和Testbench代码,然后点击OK.</li>
<li>添加完代码后,在Modelsim上面一栏中选择Compile-&gt;Compile
All,软件就会编译所有的代码,如果代码正确,就会显示绿色的勾.</li>
<li>编译完成后,在Modelsim上面一栏中选择Simulate-&gt;Start
Simulation,这时会弹出一个窗口,点击Optimization
Options,在Visibility页面中勾选Apply full visibility to all modules(full
debug mode),然后在Options页面的Optimization一栏中勾选Disable
Optimization(-o0),最后点击OK保存选项.</li>
<li>设置好Optimization
Options之后,点击work左边的加号”+“,选中Testbench代码,然后点击OK.</li>
<li>此时会出现一个界面,我们用右键点击Testbench下面的实例化模块(通常以u_…开头),选择Add
Wave选项,就可以打开示波(Wave)界面了.</li>
<li>在Wave界面的最上面一栏,可以设置仿真的时间,然后点击右边的按钮就可以进行仿真了.</li>
</ol>
<h2 id="vivado的安装">Vivado的安装</h2>
<p>在网上找到Vivado的及其许可证license的安装包, 直接安装即可.</p>
<h2 id="vivado的使用">Vivado的使用</h2>
<h3 id="基本操作">基本操作</h3>
<ol type="1">
<li>打开Vivado软件,在最上面的Quick Start一栏中点击”Create
Project”,然后在弹出的窗口中点击”Next”,然后填写Project
Name和工程路径,点击”Next”后,仅勾选”RTL
Project”,再点”Next”,会相继弹出”Add Sources”和”Add
Constraints”,我们直接跳过这两项,接下来选择开发板的芯片型号,我们在Search一栏里面输入”xc7z020clg400-2”,选中这个型号的芯片后点击”Next”,就可以进入工程主界面了.</li>
<li>在工程主界面中,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,里面有三个选项
<ol type="1">
<li>Add or create constraints:添加或者创建管脚约束文件</li>
<li>Add or create design sources:添加或者创建RTL文件</li>
<li>Add or create simulation source:添加或者创建Testbench文件</li>
</ol></li>
<li>我们勾选Add or create design sources,在弹出的界面中选择”Add
Files”,添加我们已经写好的RTL代码文件,然后点击”Finish”,再点击”OK”,然后是”Yes”.</li>
<li>这时,Sources窗口下”Design
Sources”目录下就会出现我们刚刚添加的RTL文件了,利用同样的方法可以在Sources窗口下”Constrains”和”Simulation
Sources”目录下分别添加管脚约束文件和Testbench文件.</li>
<li>事实上,在添加好RTL文件后,就可以进行分析(Elaborated)与综合(Synthesis)了.点击工程主界面左侧一栏”Flow
Navigator”中的”Open Elaborated
Design”,此时,Vivado会编译RTL源文件并且进行语法检查,分析完成后,会增加”Schematic(原理图)“和”Netlist(网表)“窗口.</li>
<li>然后,我们点击工程主界面左侧一栏”Flow Navigator”中的”Run
Synthesis”来对代码进行综合,在弹出的窗口中直接点击”OK”.综合完成后,会弹出一个窗口,我们直接关闭.</li>
<li>接下来进行管脚约束,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,勾选Add or create constrains,在弹出的界面中选择”Create
File”,在弹出的对话框中填写约束文件的名称,注意约束文件是后缀为”XDC”的文本文件,然后点击”OK”和”Finish”,这时,Sources窗口下”Constrains”目录下就会出现我们刚刚添加的约束文件了.</li>
<li>我们双击打开这个约束文件,写好约束代码,然后保存即可.</li>
<li>下面我们可以实现设计了,点击工程主界面左侧一栏”Flow
Navigator”中的”Run
Implementation”,在弹出的界面直接点击”OK”,实现完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>在下载程序之前,首先要生成用于下载到器件中的比特流文件,点击工程主界面左侧一栏”Flow
Navigator”中的”Generate
Bitstream”,在弹出的窗口中直接点击”OK”,生成比特流完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>最后我们下载比特流,点击工程主界面左侧一栏”Flow Navigator”中的”Open
Hardware Manager”,然后工程主界面的窗口布局就会发生变化.</li>
<li>这时,我们将Xilinx下载器一端连接到电脑,另一端连接到JTAG接口,然后连接开发板电源线,打开开发板上面的电源开关.</li>
<li>在工程主界面中”Hardware”子窗口中点击”Auto
Connect”按钮(就是长得像关节一样的那个),再点击”Program
device”,点击”Program”,此时就会下载比特流文件到板子上,并且可以在板子上看到现象.</li>
</ol>
<h3 id="ip核">IP核</h3>
<h4
id="集成逻辑分析器integrated-logic-analyzerila">集成逻辑分析器(Integrated
Logic Analyzer,ILA)</h4>
<p>传统的FPGA板级调试是由外接的逻辑分析仪连接到FPGA的控制管脚,然后将内部信号引出至引脚IO上,进行板级调试.在线逻辑分析仪利用FPGA中的逻辑资源,将这些功能植入到FPGA的设计中.</p>
<p>在线逻辑分析仪通过一个或者多个探针(Probe)来采集希望观察的信号,然后通过片内的JTAG硬核组件来将捕获到的数据传送给下载器,进而上传到Vivado
IDE以供用户查看.Vivado
IDE也可以按照上述的路径,向在线逻辑分析仪传输一些控制信息.</p>
<p>在Vivado中,在线逻辑分析仪的功能被称为”集成逻辑分析器(ILA)“,它以IP核的形式来加入到用户设计中.Vivado提供了三种具有不同集成层次的插入ILA方法,以满足不同Vivado用户的需求.</p>
<p>这里我们介绍第一种:</p>
<h5 id="hdl实例化调试探针流程">HDL实例化调试探针流程</h5>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”ILA”关键字,我们找到”Debug
&amp; Verification”下的”Debug”下的”ILA(Integrated Logic
Analyzer)“,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”ila_0”.</p>
<p>IP核的配置包含两个子界面,分别是”General
Options”和”Probe_Ports(0..0)”</p>
<p>在”General Options”界面中,“Number of
Probe”一栏用于设置所需的探针数量,一般来说,一个探针对应一个待测信号.”Sample
Data
Depth”用于设置采样深度,在每个时钟采样下,ILA都会将捕获到的探针信号的值送入RAM中,由于RAM存储空间是有限的,所以此选项就用于设置RAM最大存储多少个探针信号的值,我们一般保持默认1024,数值阅读,占用的RAM资源就越多.其他的选项保持默认.</p>
<p>在”Probe_Ports(0..0)“中,用于设置每个探针的参数,一般我们只需要设置每个探针的宽度”Probe
Width”即可,例如,“sys_rst_n”,“led”,“cnt”分别是1位,2位,26位,所以我们就设置探针1,探针2,探针3的宽度分别为1位,2位,26位.</p>
<p>设置完成后,点击”OK”,“Generate”即可生成IP核.</p>
<p>生成好后,在”Sources”窗口下的”IP
Sources”中,打开”ila_0.veo”文件,将其中的模板代码复制到用户设计的RTL代码中,然后修改代码,将IP核的时钟信号连接到”sys_clk”,“probe1”连接到”sys_rst_n”,“probe2”连接到”led”,“probe3”连接到”cnt”.</p>
<p>完成后,就可以保存,直接综合并且生成比特流.我们打开”Hardware
Manager”,连接到开发板,并且下载比特流.在弹出的窗口中,点击”Program”,Vivado就会自动弹出ILA调试窗口.</p>
<p>如果Waveform窗口缺少信号,可以点击上面一栏的加号”+(add
probes)“将所有探针信号加入到波形窗口中.然后,我们点击上面一栏的三角形符号”run
trigger for this ILA core”,就可以观察到此时信号的波形.</p>
<p>在调试完毕后,可以在顶层RTL代码中注释掉ILA IP核的实例化.</p>
<h4 id="clocking-wizard">Clocking Wizard</h4>
<p>首先创建一个新的工程,命名为”ip_clk_wiz”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP
Catalog”窗口后,在Search中搜索”clock”关键字,Vivado就会自动查找包含”clock”的IP核,我们找到”FPGA
Features and Design”下的”Clocking”下的”Clocking
Wizard”,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的时钟参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”clk_wiz_1”.</p>
<p>在第一个”Clocking
Options”选项卡中,“Primitive”一行可以选择使用MMCM模块还是PLL模块,我们选用功能比较多的MMCM模块.我们还需要修改”Input
Clock
Information”一栏,把”Primitive”的时钟输入频率修改为开发板核心板的晶振频率
<span class="math inline">\(50\rm{MHz}\)</span>,其他的设置保持默认.</p>
<p>接下来切换至”Output Clocks”选项卡,在”Output
Clock”一栏中,勾选前四个时钟(表明我们需要四个输出),并且在”Output
Freq(MHZ)“中分别设置为”<span
class="math inline">\(100,100,50,25\)</span>“,第二个<span
class="math inline">\(100\rm{MHZ}\)</span>时钟的相移”Phase(degrees)“一栏设置为”<span
class="math inline">\(180\)</span>“.</p>
<p>接下来切换至”Port
Renaming”,这个选项卡主要是对于一些控制信号的重命名.这里我们只用到锁定指示locked信号,其名称保持默认即可.</p>
<p>接下来切换至”MMCM
Setting”和”Summary”,这两个选项卡都保持默认,都点击OK.之后就会弹出”Generate
Output Products”窗口,我们直接点击”Generate”即可.</p>
<p>之后我们可以看到在”Design Run”窗口的”Out-of-Context Module
Runs”一栏中出现了该IP核对应的run”clk_wiz_0_synth_1”,其综合过程独立于顶层模块的综合.</p>
<h4 id="block-memory">Block Memory</h4>
<p>首先创建一个新的工程,命名为”ip_ram”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”Block
Memory”关键字,我们找到”Block Memory
Generator”(这里会出现两个相同名字的IP核,它们实际上是一样的),点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component Name”默认为”blk_mem_gen_0”,我们保持默认.</p>
<p>Interface
Type:RAM接口总线,这里保持默认的Native类型(标准RAM接口总线)</p>
<p>Memory Type:存储器类型.可以配置成Single Port RAM(单端口RAM),Simple
Dual Port RAM(伪双端口RAM),True Dual Port RAM(真双端口RAM),Single Port
ROM(单端口ROM),Dual Port ROM(双端口ROM).这里我们选择Single Port RAM.</p>
<p>ECC Options:即Error Correction
Capability,纠错能力选项,单端口RAM不支持ECC</p>
<p>Write
Enable:字节使能选项,选中后可以单独将数据的某个字节写入RAM中,这里不勾选.</p>
<p>Algorithm Options:算法选项.可选择Minimum Area(最小面积),Low
Power(低功耗),Fixed Primitives(固定原语),这里保持默认的Minimum Area.</p>
<p>“Port A Options”界面中,设置端口A的参数</p>
<p>Write Width:端口A写数据位宽,这里设置成8位</p>
<p>Read Width:端口A读数据位宽,这里设置成8位</p>
<p>Write
Width:端口A写数据深度,这里设置成32,即RAM所能访问的地址范围为0-31</p>
<p>Read Width:端口A读数据位宽,这里设置成32</p>
<p>Operating Mode:RAM读写模式.一共有三种模式</p>
<ol type="1">
<li>Write First:写优先模式,数据先写入RAM中,下一个时钟周期读出该数据</li>
<li>Read
First:读优先模式,数据先写入RAM中,同时输出RAM中同地址的上一次数据</li>
<li>No
Change:不变模式,读写分开操作,不能同时进行读写,我们选择这个选项</li>
</ol>
<p>Enable Port Type:使能端口类型.Use ENA Pin(添加使能端口A信号),Always
Enabled(取消使能信号,端口A一直处于使能状态),这里选择Use ENA Pin</p>
<p>Port A Optional Output
Register:端口A输出寄存器选项.其中我们取消勾选”Primitives Output
Register”</p>
<p>Port A Optional Reset
Options:RAM复位信号选项,这里不添加复位信号,保持默认.</p>
<p>接下来的”Other
Options”和”Summary”页面都不需要设置,点击”OK”,“Generate”选项后,就可以生成IP核了.</p>
<h4 id="fifo">FIFO</h4>
<p>首先创建一个新的工程,命名为”ip_fifo”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”fifo”关键字,我们找到”Memories
&amp; Storage Elements”下的”FIFOs”下的”FIFO
Generator”,点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component
Name”默认为”fifo_generator_0”,我们保持默认.</p>
<p>Interface
Type:用于选择FIFO接口的类型,这里保持默认的Native类型(标准FIFO接口)</p>
<p>FIFO
Implementation:选择实现同步FIFO或者异步FIFO,这里我们选择”Independent
Clocks Block RAM”,即使用块RAM来实现异步FIFO</p>
<p>“Native Ports”界面中</p>
<p>Read Mode:设置读FIFO时的读模式,这里选择默认的”Standard FIFO”</p>
<p>Data Port Parameters:设置读写端口的数据总线宽度以及FIFO的深度,“Write
Width”设置为8位,“Write Depth”设置为256位(注意FIFO
IP核实际实现的深度是255位),“Read Width”和”Read Depth”设置同上.</p>
<p>Reset Pin:这里我们只是观察FIFO的读写,我们取消勾选这个选项.</p>
<p>“Status Flags”界面</p>
<p>我们勾选”Almost Full Flag(即将写满)“和”Almost Empty
Flag(即将读空)“这两个选项,其他保持默认</p>
<p>“Data
Counts”选项卡用于设置FIFO内部数据计数的输出信号,此信号表示当前FIFO内存在多少个有效的数据,这里我们勾选”Write
Data Count(写数据计数)“和”Read Data
Count(读数据计数)“,且计数值总线的位宽”Write/Read Count
Width”设置成8位</p>
<p>“Summary”界面是总结,我们之间点击”OK”,“Generate”,就可以生成IP核了.</p>
<h3 id="uart串口通信">UART串口通信</h3>
<p>串行通信分为两种方式,同步串行通信和异步串行通信.同步串行通信需要双方在同一时钟控制下同步传输数据;异步串行通信是通信双方使用各自的时钟控制数据的发送和接收过程.</p>
<p>UART是一种采用异步串行通信方式的通用异步收发传输器(universal
asynchroonous
receiver-transmitter),它在发送数据时将并行数据转化成串行数据来传输,在接收数据时把接收到的串行数据再转化成并行数据.</p>
<p>UART串口通信需要两根信号线,一根用于串口发送,一根用于串口接收.UART在发送或者接收过程中的一帧数据由4部分组成:</p>
<ol type="1">
<li>起始位:标志着一帧数据的起始</li>
<li>停止位:标志着一帧数据的结束</li>
<li>数据位:一帧数据中的有效数据</li>
<li>奇偶检验位:分为奇校验和偶校验,用于检测数据在传输过程中是否出错</li>
</ol>
<p>UART通信过程中的数据格式和传输速率是可以设置的,为了正确的通信,收发双方应该约定好同样的设置.数据位可以选择5,6,7,8位,其中8位数据最常用.校验位可以选择奇校验,偶校验或者无校验位.停止位可以选择1位(默认),1.5位,2位.串口通信的速率用波特率表示,它表示每秒传输二进制数据的位数,单位是bps(位/秒),常用的波特率有9600,19200,38400,57600,115200等.</p>
<p>设置好数据格式和传输速率之后,UART负责完成串并数据的转换,而信号的传输则由外部驱动电路实现.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo+GitHub搭建博客教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-28 12:59:43" itemprop="dateModified" datetime="2026-02-28T12:59:43+08:00">2026-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E7%BD%91%E7%AB%99%E5%88%B6%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">网站制作</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装">安装</h2>
<h3 id="github的注册及创建域名">GitHub的注册及创建域名</h3>
<p>注册这一步就不说了. 注册完成后点击New创建一个新的repository,
在Owner填自己的<code>username</code>, 在Repository
name里面填<code>username.github.io</code> 这样就成功建立了一个域名.</p>
<h3 id="git的安装">Git的安装</h3>
<p>在搜索引擎中直接搜索Git进入官方网站, 点击Download for Windows,
在Standalone Installer下点击64-bit Git for Windows Setup,
下载好之后一直点击next(可以自己设置下载路径)就可以下载完成了.
最后可以按<code>win+R</code>输入cmd, 然后输入<code>git --version</code>,
如果出现git的版本, 说明安装完成.</p>
<p>在git的安装目录下打开git bash, 输入命令</p>
<p><code>ssh-keygen -t rsa -C "你自己的邮箱的地址"</code></p>
<p>然后回车, 遇到Enter file in which to save the
key时输入一个路径,生成的ssh文件就放在那里, 在遇到Enter
passphrase时回车两次(或者输入你自己的密码两次)即可.</p>
<p>打开GitHub网页,在Setting界面点开SSH and GPG keys, 点击New SSH,
title随便输一个名字, 然后打开刚刚生成的id_rsa.pub, 复制里面的内容,
粘贴到key这一栏下面, 然后点击Add SSH key即可.</p>
<h3 id="node.js的安装">Node.js的安装</h3>
<p>在搜索引擎中直接搜索Node js进入官方网站, 点击Recommended For Most
Users的下载按钮, 下载好之后打开, 一直点next 就可以下载完成了.
最后可以按<code>win+R</code>输入cmd,
然后输入<code>node --version</code>, 如果出现node的版本,
说明安装完成.</p>
<h3 id="hexo的安装">Hexo的安装</h3>
<p>在搜索引擎中直接搜索Hexo进入官方网站, 在网站上直接复制下面的代码</p>
<p><code>npm install hexo-cli -g</code></p>
<p>在C盘中创建一个新的文件夹blog,
在其中右键打开git的bash(这里需要安装git才能看见这个选项,
还需要安装node.js)窗口, 将代码粘贴进去回车, 等待下载, 下载好之后,
输入</p>
<p><code>hexo init Blog</code></p>
<p>然后就会发现blog文件夹下面有一个新的Blog文件夹,
在这个文件夹里面打开git bash, 输入</p>
<p><code>npm install</code></p>
<p>安装完成后输入</p>
<p><code>hexo s</code></p>
<p>就会出现一个localhost的网址, 复制之后在浏览器中打开,
就可以看见Hexo的默认界面了.</p>
<h2 id="主题的设置">主题的设置</h2>
<h3 id="next主题">Next主题</h3>
<h4 id="next主题的启用">Next主题的启用</h4>
<p>在C盘Blog文件夹下找到_config.yml文件, 用VScode打开,
在<code>theme</code>后面的东西改成<code>next</code>, Blog里面打开git
bash, 输入<code>hexo s</code>, 复制网站在浏览器打开,
就可以看见Next主题的默认界面了.</p>
<h4 id="语言的更改">语言的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>language</code>选项改成<code>zh-Hans</code>保存好之后,
输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会变成中文了.</p>
<h4 id="标签页和分类页">标签页和分类页</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>menu</code>下面的默认的<code>categories</code>和<code>tags</code>取消注释,
并保存, 输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会有标签页和分类页了,
但是点进去会出现空白页面.</p>
<p>在C盘Blog文件夹下找到source文件夹, 在Blog文件夹下面打开git bash,
输入<code>hexo n page tags</code>回车之后,
source文件里面就会多出来一个tags文件夹，
打开tags文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>标签</code>,
然后增加一行<code>type: "tags"</code>;
同样地输入<code>hexo n page categories</code>回车之后,
source文件里面就会多出来一个categories文件夹，
打开categories文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>分类</code>,
然后增加一行<code>type: "categories"</code>,
保存之后就可以看见标签和分类页了.</p>
<h4 id="主题样式的更改">主题样式的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件,
找到<code>scheme</code>, 把默认的<code>scheme: Muse</code>注释掉,
然后把<code>scheme: Pisces</code>取消注释, 保存即可.</p>
<p>下面来设置Pisces.</p>
<p>头像: 把<code>avatar: /images/avatar.gif</code>取消注释,
在Blog/themes/next/source/images文件夹下面删除默认的avatar.gif,
替换成你自己的femboy.jpg,
然后修改url为<code>url: /images/femboy.jpg</code>然后保存即可.</p>
<p>网站标题: 在C盘Blog文件夹下找到_config.yml文件,
作如下修改<code>title: SiyuanLei'blog</code>,
<code>author: SiyuanLei</code></p>
<p>侧边栏: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>social</code>一栏取消注释,
在对应的社交网站后面改成自己的社交平台链接即可.</p>
<p>友情链接: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>links</code>一栏取消注释, 然后加上一些连接, 比如Arxiv,
Libgen之类的.</p>
<h2 id="文章">文章</h2>
<p>我自己常用的方式是, 在C: _posts下面直接加入一个markdown文件,
但是文件开头一定要是下面的格式:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 第四章:Verilog HDL数字逻辑电路设计方法</span><br><span class="line">date: 2025-05-04</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> [EE,数字设计,Verilog]</span><br><span class="line">tags:</span><br><span class="line"><span class="section">- Verilog</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="博客的发布">博客的发布</h2>
<p>在<code>C:\blog\Blog</code>下打开终端, 然后依次输入以下指令即可:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="一些意外">一些意外</h2>
<h3
id="在博客根目录下的终端无法使用hexo命令">在博客根目录下的终端无法使用hexo命令</h3>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\blog\Blog&gt; hexo d</span><br><span class="line">hexo : 无法将“hexo”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确</span><br><span class="line">，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ hexo</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (hexo:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure>
<p>但是在命令行窗口输入<code>npm -v</code>, <code>node -v</code>都正常.
这说明环境变量出了问题.</p>
<p>首先需要配置环境变量,
在Windows上，通过npm全局安装的包（比如hexo），其可执行文件通常位于一个特定的目录。你需要确保这个目录被添加到了系统的PATH环境变量中。查找路径：全局安装的包默认在
C:。</p>
<p>修改环境变量：在Windows搜索框输入“环境变量”，选择“编辑系统环境变量”。在弹出窗口中，点击右下角的“环境变量”按钮。在“用户变量”或“系统变量”区域，找到名为
Path
的变量，双击它。点击“新建”，然后将上述的npm路径（例如C:）添加进去。逐一点击“确定”保存所有更改。重启终端：非常重要的一步！
完全关闭你当前的PowerShell或命令提示符窗口，然后重新打开，再尝试输入
hexo 命令。</p>
<p>然后出现了如下报错</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\blog\Blog&gt; hexo cl</span><br><span class="line">hexo : 无法加载文件 C:\Users\XQ\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/g</span><br><span class="line">o.microsoft.com/fwlink/?LinkID=<span class="number">135170</span> 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ hexo cl</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure>
<p>这个错误是因为Windows PowerShell的执行策略（Execution
Policy）限制了脚本运行。不过别担心，这个问题很常见，很容易解决。简单来说，Windows为了防止恶意脚本自动执行，默认禁止运行任何PowerShell脚本。你刚才配置好环境变量，系统找到了hexo.ps1脚本，但这个“安全门”却把它拦住了。</p>
<p>为了永久取消这个限制, 先右键点击“开始”菜单或按 Win + X，然后选择
“Windows PowerShell（管理员）”或
“终端（管理员）”。在打开的窗口中，输入<code>Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned</code>.
完成此操作后，关闭当前的PowerShell窗口（包括之前报错的那个），重新打开一个新的终端，再进入你的博客目录
C:，尝试执行<code>hexo cl, hexo g, hexo d</code>就可以正常工作了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">HSpice的安装及其基本使用方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-03 20:22:37" itemprop="dateModified" datetime="2025-12-03T20:22:37+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hspice的安装及破解">HSpice的安装及破解</h2>
<p>下载好安装包解压之后,
有两个文件夹<code>HSpice 2009.09</code>和<code>Testbench</code>(我把它改成<code>HSpiceTestbench</code>了).</p>
<p>以管理员身份运行<code>HSpice 2009.09</code>文件夹下的<code>hspice_vC-2009.09_Win_setup.exe</code>和<code>sx_C-2009_09_windows.exe</code>这两个文件,
一路next, 注意安装路径, 就可以完成安装, 接下来是破解方法.</p>
<ol type="1">
<li>产生 License 档桉 (Hspice and Spiceexplorer)到 “keygen”
的目录下执行LicGen.exe 1.1 按 “Open” 开启 “Synopsys.lpd”档桉 1.2
在”Select Host ID” 选择 “Any” 勾选 “Use Daemon”并在 “Select Daemon ID”
选择”Disk” 1.3 按 “Generate” 后会出现一个视窗 “Generated
License”，按Save，将档名储存为 “license.dat” 1.4 复製此 “license.dat”
到目录 “C:_C-2009.09" 下</li>
<li>复製 “lm” 到目录 “C:Files" 下，进入”lm” 目录执行 “lmtools.exe” 2.1
选 “Config Services” 在”Service Name” 输入 “SPICE_Explorer_Server”
在”Path to the lmgrd.exe file” 按 “Browse” 选择 “lm” 目录下的
“lmgrd.exe” 在”Path to the license file” 按 “Browse” 选择步骤 2.3
所产生的 license.dat (将档桉类型选为 “*.dat”才可以选择) 在”Path to the
debug log file” 按 “Browse” 输入 “debug” 后按开启 勾选 “Use Services” 和
“Start Server at Power Up” 然后按 “Save Service” 2.2 在 “Service/License
File” 勾选 “Configuration using Services” 并选择 SPICE_Explorer_Server
2.3 选 “Start/Stop/Reread” ， 按 “Stop Server” 再按 “Start Server”</li>
<li>环境变数设定 (Hspice and Spiceexplorer) 到桌面选”我的电脑”按右键
=&gt; 内容 =&gt; 进阶 =&gt; 环境变数 在”xxx的使用者变数” 按
“新增”，变数名称 = LM_LICENSE_FILE 变数值 =
27000@localhost;C:_C-2009.09.dat 若已经有 LM_LICENSE_FILE ，请以分号 “;”
隔开加入 27000@localhost 和 C:_C-2009.09.dat 到变数值</li>
<li>复製 “Meta.cfg” 和 “Hspice.ini” 到 “C:_C-2009.09" 目录下</li>
</ol>
<h2 id="hspice的基本使用方法">HSpice的基本使用方法</h2>
<p>在目录<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\HSPICE C-2009.09</code>下打开Hspui
C-2009.09, 出现界面, 点击open,
打开<code>HSpiceTestbench</code>下的任意一个网表文件(后缀是.sp),
这里以inv.sp为例, 以文本文件打开inv.sp, 可以看到其关联的工艺库,
这里把工艺库的路径改成<code>.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</code>,
这个工艺库可以在这个目录下的对应文件中找到细节.</p>
<p>然后点击最上面一栏的configuration-&gt;versions,
在cscope中关联波形观测器,
也就是把<code>C:\Program Files (x86)\Synopsys\CustomExplorer C-2009.09\sx.exe</code>复制到这一栏中,
然后点击OK. 然后在最上面一栏中的File-&gt;Save Configuration保存设置.</p>
<p>接下来进行仿真, 点击Simulate, 仿真完成后再点击Edit LL,
如果出现<code>***** job concluded 1****** HSPICE -- C-2009.09 32-BIT (Aug 24 2009) winnt ******</code>
的字样, 则说明仿真成功.
这时我们可以发现在HSpiceTestbench文件夹下面多出了几个文件,
其中一个就是inv.tr0, 这个就是波形文件.</p>
<p>下面查看仿真波形, 点击CScope, 打开波形观察窗口,
在上面第二栏中选择Import Waveform File, 选择刚刚生成的inv.tr0,
在左边一栏出现D0:inv.tr0, 点击这个东西左边的+号， 有一个toplevel,
点击就可以发现出现了三个选项, 分别是v(vdd), v(in), v(out),
分别点击这三个选项就可以在右边的窗口看见仿真波形了.</p>
<h2 id="hspice概览">HSpice概览</h2>
<h3 id="hspice的网表">HSpice的网表</h3>
<p>HSpice的网表文件后缀是.sp, 但是是纯文本文件,
可以用文本编辑器打开并进行编辑.</p>
<p>HSpice网表文件包含如下要素:</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>.title</code></td>
<td>标题语句</td>
</tr>
<tr>
<td>2</td>
<td><code>Sources(I or V)</code></td>
<td>输入激励和源, 为电路描述语句</td>
</tr>
<tr>
<td>3</td>
<td><code>circuit description</code></td>
<td>电路元件描述语句, 为电路描述语句</td>
</tr>
<tr>
<td>4</td>
<td><code>.lib</code></td>
<td>元件库引用, 为电路描述语句</td>
</tr>
<tr>
<td>5</td>
<td><code>.model libraries</code></td>
<td>元件模型描述, 为电路描述语句</td>
</tr>
<tr>
<td>6</td>
<td><code>.inc</code></td>
<td>文件包含语句, 电路描述语句</td>
</tr>
<tr>
<td>7</td>
<td><code>.options</code></td>
<td>选项设置, 为命令语句</td>
</tr>
<tr>
<td>8</td>
<td><code>Analysis statement</code></td>
<td>仿真类型描述, 为命令语句</td>
</tr>
<tr>
<td>9</td>
<td><code>.print/.plot/.graph/.probe</code></td>
<td>输出方式描述, 为命令语句</td>
</tr>
<tr>
<td>10</td>
<td><code>.end</code></td>
<td>结束语句</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A SIMPLE AC RUN</span><br><span class="line">VS 1 0 10 AC 1</span><br><span class="line">R1 1 2 1K</span><br><span class="line">R2 2 0 1K</span><br><span class="line">C1 2 0 1n</span><br><span class="line">.OPTIONS LIST NODE POST</span><br><span class="line">.OP</span><br><span class="line">.AC DEC 10 1K 1MEG</span><br><span class="line">.PRINT AC V(1) V(2) I(R2) I(C1)</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="电路描述语句总览">电路描述语句总览</h4>
<p>元件描述语句:</p>
<p>无源: 电阻<code>R</code>, 电容<code>C</code>, 电感<code>L</code>,
传输线 有源: 二极管<code>D</code>, 三极管<code>Q</code>,
JFET<code>J</code>, MOS<code>M</code></p>
<p>激励源描述语句:</p>
<p>独立源: 独立电压源<code>V</code>, 独立电流源<code>I</code> 源控源:
压控电压源<code>E</code>, 流控电流源<code>F</code>,
压控电流源<code>G</code>, 流控电压源<code>H</code></p>
<p>子电路描述语句<code>.SUBCKT</code>或<code>.MACRO</code></p>
<p>模型描述语句<code>.MODEL</code></p>
<p>库文件调用及定义语句<code>.LIB</code></p>
<h4 id="命令语句">命令语句</h4>
<p>电路性能仿真:</p>
<p>直流分析:</p>
<ol type="1">
<li>直流工作点分析<code>.OP</code></li>
<li>直流扫描分析<code>.DC</code></li>
<li>直流小信号传输函数<code>.TF</code></li>
<li>直流小信号灵敏度分析<code>.SENS</code></li>
</ol>
<p>交流分析:</p>
<ol type="1">
<li>交流小信号分析<code>.AC</code></li>
<li>零极点分析<code>.PZ</code></li>
<li>交流小信号失真分析<code>.DISTO</code></li>
<li>交流噪声分析<code>.NOISE</code></li>
</ol>
<p>瞬态分析<code>.TRAN</code></p>
<p>蒙特卡洛/最坏情况分析:</p>
<ol type="1">
<li>直流工作分析</li>
<li>直流扫描分析</li>
<li>交流扫描分析</li>
<li>瞬态扫描分析</li>
</ol>
<p>温度分析</p>
<p>输入控制: <code>.ALTER</code>, <code>.PARAM</code>,
<code>.DATA</code>, <code>.OPTIONS</code> 输出控制: <code>.PRINT</code>,
<code>.PLOT</code>, <code>.PROBE</code>, <code>.GRAPH</code>,
<code>.MEASURE</code></p>
<h4 id="hspice的输出">HSPice的输出</h4>
<p>输出文件也是一系列文本文件</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.ic</td>
<td>initial conditions for the circuit</td>
</tr>
<tr>
<td>*.lis</td>
<td>text simulation output listing</td>
</tr>
<tr>
<td>*.mt(0), *.mt(1), …</td>
<td>post-processor output for MEASURE statements</td>
</tr>
<tr>
<td>*.pa0</td>
<td>subscricuit path table</td>
</tr>
<tr>
<td>*.st0</td>
<td>run-time statistics</td>
</tr>
<tr>
<td>*.tr0,*.tr1…</td>
<td>post-processor output for transient analysis</td>
</tr>
<tr>
<td>*.ac0,*.ac1…</td>
<td>post-processor output for AC analysis</td>
</tr>
</tbody>
</table>
<p>Waveview or Cscope: 观察波形, 人机交互界面</p>
<h2 id="hspice基本语法">HSPice基本语法</h2>
<h3 id="文件名格式">文件名格式</h3>
<ol type="1">
<li>文件的后缀名必须是.sp, 可以用文本编辑器产生,
只需要修改后缀名即可.</li>
<li>文件名必须是英文.</li>
<li>网表文件第一行必须是标题行,
最后一个语句必须是<code>.END</code>.</li>
<li>标题语句和结束语句的中间语句没有任何先后次序.</li>
<li>续行用加号<code>+</code>表示.</li>
<li>不区分大小写</li>
<li>分隔符可以是<code>tab</code>, 空格, 逗号, 等号, 括号.</li>
<li>元素的属性由冒号分割, 例如<code>M1:beta</code>.</li>
<li>用句号表示隶属关系,
例如<code>X1.A1.V</code>表示电路<code>X1</code>的子电路<code>A1</code>的节点<code>V</code>.</li>
</ol>
<h3 id="节点">节点</h3>
<ol type="1">
<li>节点名可以由下列字符开头<code># _ ! %</code>.</li>
<li>节点可以由<code>.GLOBAL</code>语句声明为全局调用,
例如<code>.GLOBAL 1</code>声明节点1为全局调用.</li>
<li>节点<code>0, GND, GND!, GROUND</code>均指的是HSPice全局的地.</li>
<li>HSPice要求每个节点对地均要有直流通路. 当这个条件不满足时,
通常是接一个大电阻使得该悬浮节点具有直流通路.</li>
<li>每个节点至少应该连接两个元件, 不能有浮空节点存在.</li>
</ol>
<h3 id="数值及比例因子">数值及比例因子</h3>
<p>数字的表示:</p>
<ol type="1">
<li>整数, 如<code>12, -5</code>.</li>
<li>浮点数, 如<code>2.13, 3.14159</code></li>
<li>指数, 如<code>6E-14, 3.89E+13</code></li>
<li>在整数或浮点数后面跟比例因子, 如<code>10.18K</code>,
常用的比例因子有<code>T=1E+12, G=1E+9, MEG=1E+6, K=1E+3, M=1E-3, U=1E-6, N=1E-9, P=1E-12, F=1E-15, DB=20lg_&#123;10&#125;, MIL=25.4E-6</code>.</li>
</ol>
<h3 id="单位及关键字">单位及关键字</h3>
<p>单位: 电学单位可以省略,
例如<code>10</code>和<code>10V</code>表示相同电压.
<code>1000Hz, 1000, 1E+3, 1k, 1kHz</code>表示相同的频率. 同样,
<code>W, A</code>等标准单位在描述时均可省略.</p>
<p>元件关键字: 电压<code>V</code>, 电流<code>I</code>,
频率<code>F</code>, 电阻<code>R</code>, 电容<code>C</code>,
电感<code>L</code>.</p>
<h2 id="hspice的标题-结束及注释语句">HSpice的标题, 结束及注释语句</h2>
<h3 id="title语句">.TITLE语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TITLE &lt;string of up to 72 characters&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string of up to 72 characters&gt;</span><br></pre></td></tr></table></figure>
<h3 id="end语句">.END语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.END &lt;comment&gt;</span><br></pre></td></tr></table></figure>
<p><code>.END</code>后面的文本对仿真没有任何影响.</p>
<h3 id="注释语句">注释语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&lt;comment on a line by itself&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HSPICE statement&gt;$&lt;comment on the same line as and following HSPICE input&gt;</span><br></pre></td></tr></table></figure>
<p>注意<code>*</code>开头的注释放在每一行的开头,
<code>$</code>开头的注释紧跟在语句之后.</p>
<h2 id="电路描述语句">电路描述语句</h2>
<h3 id="元件描述语句">元件描述语句</h3>
<p>HSpice中元件的属性由器件名, 器件位置, 器件类型, 器件参数值等来定义.
格式为<code>名称 器件所连接的节点 器件类型 参数值</code>.</p>
<h4 id="无源器件">无源器件</h4>
<h5 id="电阻">电阻</h5>
<p>电阻的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RXXX n1 n2 Rvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电阻的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[R=R_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1 1 2 100k</span><br><span class="line">RC1 12 17 1k TC=0.001, 0</span><br></pre></td></tr></table></figure>
<h5 id="电容">电容</h5>
<p>电容的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXXX n1 n2 Cvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电容的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[C=C_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C1 1 2 10u</span><br><span class="line">CP 12 17 1p TC=0.001, 0</span><br></pre></td></tr></table></figure>
<h5 id="电感和互感">电感和互感</h5>
<p>电感的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LXXX n1 n2 Lvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电感的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[L=L_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1 1 2 10u</span><br><span class="line">LP 12 17 1u TC=0.001, 0</span><br></pre></td></tr></table></figure>
<p>另一种写法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LXXX n1 n2 POLY L0 L1 L2</span><br></pre></td></tr></table></figure>
<p>这里</p>
<p><span class="math display">\[L=L0+L1\times I+L2\times
I^2+\cdots\]</span></p>
<p>其中<span class="math inline">\(I\)</span>是流过电感的电流.</p>
<p>互感的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KXXX LYYY LZZZ Kvalue</span><br></pre></td></tr></table></figure>
<p>其中<code>LYYY, LZZZ</code>是两个耦合电感的名字,
<code>K</code>是耦合系数, <span class="math inline">\(0&lt;K\leq
1\)</span>.</p>
<h4 id="有源器件">有源器件</h4>
<h5 id="晶体二极管diode-d">晶体二极管(diode, D)</h5>
<p>一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DXXX nplus nminus mname </span><br><span class="line">+&lt;area=value, area&gt; &lt;PJ=value&gt; &lt;WP=value&gt;</span><br><span class="line">+&lt;LP=value&gt; &lt;WM=value&gt; &lt;LM=value&gt;</span><br><span class="line">+&lt;OFF&gt; &lt;IC=vd&gt; &lt;M=value&gt; &lt;DTEMP=value&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>上面的加号<code>+</code>表示续行.</li>
<li><code>DXXX</code>: 二极管元件名, 必须以<code>D</code>开头,
后面最多跟15个字符</li>
<li><code>nplus/nminus</code>: 二极管的正极和负极</li>
<li><code>mname</code>: 二极管模型名</li>
<li><code>area</code>: 二极管面积, 它定义了饱和电流, 电容与电阻值.
可以写为<code>area=xxx</code>, 也可以直接写为<code>xxx</code>,
缺省值为1.0, 若不定义<code>area</code>,
用定义<code>W</code>和<code>L</code>来代替也可以,
<code>area=W*L</code>.</li>
<li><code>PJ</code>: 二极管周长, <code>PJ=2(L+M)</code></li>
<li><code>WP/LP</code>: 寄生多晶电容的宽度和长度, 缺省值为0</li>
<li><code>WM/LM</code>: 寄生金属电容的宽度和长度, 缺省值为0</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件</li>
<li><code>M</code>: 多重二极管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBRIDGE 6 7 DIODE 1</span><br><span class="line">DCLMMMP 3 GND DMOD 3 IC=0.2</span><br></pre></td></tr></table></figure>
<h5 id="双极性晶体三极管">双极性晶体三极管</h5>
<p>一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QXXX nc nb ne &lt;ns&gt; mname</span><br><span class="line">+&lt;avalue; AREAA=value, AREAB=value, AREAC=value&gt;</span><br><span class="line">+&lt;OFF&gt; &lt;IC=vbevalue, vcevalue; VBE=value, VCE=value&gt;</span><br><span class="line">+&lt;M=value&gt;&lt;DTEMP=value&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>QXXX</code>: 三极管元件名, 必须以<code>Q</code>开头,
后面最多跟15个字符</li>
<li><code>nc/nb/ne/ns</code>: 集电极, 基极, 发射极, 基底节点</li>
<li><code>mname</code>: 三极管模型名</li>
<li><code>avalue</code>: 三极管面积,
也可以用<code>areaA=?, areaB=?, areaC=?</code>来定义.
其中<code>areaA, areaB, areaC</code>分别为发射区, 基区,
集电区的面积倍增因子, 缺省值为1.</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件两种表达方式</li>
<li><code>M</code>: 多重三极管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q11 CX BX EX QPNP AREAA=1.5 AREAB=2.5 AREAC=3.0</span><br><span class="line">Q22 10 18 12 QMOD IC=0.5, 5.0</span><br><span class="line">Q33 11 265 4 20 MOD</span><br></pre></td></tr></table></figure>
<h5 id="mos场效应管">MOS场效应管</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MXXX nd ng ns nb mname</span><br><span class="line">+&lt;L=value&gt;&lt;W=val&gt;&lt;AD=val&gt;&lt;AS=val&gt;&lt;PD=val&gt;&lt;PS=val&gt;</span><br><span class="line">+&lt;NRD=val&gt;&lt;NRS=val&gt;&lt;RDC=val&gt;&lt;RSC=val&gt;</span><br><span class="line">+&lt;OFF&gt;&lt;IC=vds,vgs,vbs&gt;&lt;M=val&gt;&lt;DTEMP=val&gt;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>MXXX</code>: 元件名, 必须以<code>M</code>开头,
后面最多跟15个字符</li>
<li><code>nd/ng/ns/nb</code>: 漏极, 栅极, 源极, 基底节点</li>
<li><code>mname</code>: 场效应管模型名</li>
<li><code>L/W</code>: 沟道长度和宽度</li>
<li><code>AD/AS</code>: 漏扩散区和源扩散区的面积</li>
<li><code>PD/PS</code>: 漏结和源结的周长</li>
<li><code>NRD/NRS</code>:
用以计算漏源级寄生串联电阻的漏扩散区等效方块数</li>
<li><code>RDC/RSC</code>: 漏极, 源极与连线的接触电阻</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件</li>
<li><code>M</code>: 多重MOS管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M11 D G S B MM1</span><br><span class="line">M22 10 18 12 1 MODM L=0.5 W=2U (0.5U 2U)</span><br><span class="line">M33 11 265 4 1 MOD OFF 10U 5U 2P 2P</span><br></pre></td></tr></table></figure>
<h3 id="激励源描述语句">激励源描述语句</h3>
<h4 id="独立电压源和独立电流源">独立电压源和独立电流源</h4>
<p>直流源一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- &lt;DC=value&gt;</span><br><span class="line">IXXX n+ n- &lt;DC=value&gt;</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V11 2 0 DC=5V</span><br><span class="line">V11 2 0 5V</span><br><span class="line">I11 3 0 DC 3mA</span><br><span class="line">I11 3 0 3mA</span><br></pre></td></tr></table></figure>
<p>交流源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- AC&lt;=&gt;&lt;acmag, &lt;acphase&gt;&gt;</span><br><span class="line">IXXX n+ n- AC&lt;=&gt;&lt;acmag, &lt;acphase&gt;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V11 2 0 AC=10V 90</span><br><span class="line">V11 2 0 AC 10V 90</span><br><span class="line">I11 3 0 AC=3mA 0</span><br><span class="line">I11 3 0 AC 3mA</span><br></pre></td></tr></table></figure>
<p>脉冲源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- PULSE(V0 Va td tr tf pw per)</span><br><span class="line">IXXX n+ n- PULSE(I0 Ia td tr tf pw per)</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>V0/I0, Va/Ia</code>分别代表信号的最小值和最大值</li>
<li><code>td</code>表示信号最小值持续的时间</li>
<li><code>tr</code>表示信号上升持续时间</li>
<li><code>tf</code>表示信号下降持续时间</li>
<li><code>pw</code>表示信号最大值持续时间</li>
<li><code>per</code>表示信号周期</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VIN 3 0 PULSE -1 1 2ns 2ns 2ns 50ns 100ns</span><br></pre></td></tr></table></figure>
<p>正弦源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- SIN V0 Va &lt;freq td theta phi&gt;</span><br><span class="line">IXXX n+ n- SIN I0 Ia &lt;freq td theta phi&gt;</span><br></pre></td></tr></table></figure>
<p>对应的表达式为</p>
<p><span class="math display">\[V0+Vae^{-\theta t}\sin(2\pi
f(t-td)+\varphi)\]</span></p>
<p>指数源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- EXP V0 Va &lt;td1 t1 td2 t2&gt;</span><br><span class="line">IXXX n+ n- EXP I0 Ia &lt;td1 t1 td2 t2&gt;</span><br></pre></td></tr></table></figure>
<p>对应的表达式为</p>
<p><span class="math display">\[\begin{cases}
\displaystyle
V0+(Va-V0)\cdot\left[1-\exp\left(-\frac{t-td1}{t1}\right)\right]~~~~td1&lt;t&lt;td2\\
\\
\displaystyle
V0+(Va-V0)\cdot\left[1-\exp\left(-\frac{td2-td1}{t1}\right)\right]\cdot\exp\left(-\frac{t-td2}{t2}\right)~~~~t&gt;td2\\
\end{cases}\]</span></p>
<p>分段线性源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- PWL t1 V1 &lt;t2 V2... R td&gt;</span><br><span class="line">IXXX n+ n- PWL t1 I1 &lt;t2 I2... R td&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>t1 V1 t2 V2 t3 V3...</code>:
在V-t平面上面依次连接<code>(t1, V1), (t2, V2), (t3, V3)...</code></li>
<li><code>R</code>: 是否周期重复</li>
<li><code>td</code>: 重复时延迟时间</li>
</ol>
<h3 id="子电路">子电路</h3>
<p>子电路一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.SUBCKT(.MACRO) SUBNAME N1 &lt;N2...&gt;</span><br><span class="line">具体描述</span><br><span class="line">.ENDS&lt;SUBNAME&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>子电路是以<code>.SUBCKT</code>或者<code>.MACRO</code>开头,
以<code>.END</code>结束的一组语句. 子电路可以嵌套其他子电路.</li>
<li><code>SUBNAME</code>: 子电路模型名</li>
<li><code>N1, N2, ...</code>: 子电路外部的节点名称</li>
<li><code>.END</code>: 结束语句,
只有二次以上嵌套时才后跟子电路模型名.</li>
</ol>
<p>子电路调用语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XNNN N1 &lt;N2...&gt; SUBNAME</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>子电路调用时, 可以将其看成是以<code>X</code>为关键字的器件.</li>
<li><code>XNNN</code>: 子电路名称</li>
<li><code>N1, N2, ...</code>: 子电路外部的节点名称</li>
<li><code>SUBNAME</code>: 子电路模型名</li>
</ol>
<h3 id="模型描述语句.model语句">模型描述语句(.MODEL语句)</h3>
<p>电路元件的描述语句为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D(Q,J,M) n1 n2 (n3) mname &lt;parameter&gt;</span><br></pre></td></tr></table></figure>
<p><code>mname</code>: 模型名称, 每一个模型名称对应于一类元件,
用户根据自己的需求定义其包含哪些内容, 即类的范围.
<code>parameter</code>: 模型之外的参数的定义</p>
<p>模型的定义: 一条以<code>.MODEL</code>引导的模型说明语句.
这一类元件中的共同点在模型说明语句中给出. 模型语句的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.MODEL mname type &lt;parameter1=value1 parameter2=value2 ...&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>mname</code>: 模型参考名,
与元件描述语句的<code>mname</code>相同</li>
<li><code>type</code>: 用来选择模型类型</li>
<li><code>parameter1,2...</code>: 此类模型所共有的参数值</li>
</ol>
<p>模型的类型如下:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>电阻模型</td>
</tr>
<tr>
<td>C</td>
<td>电容模型</td>
</tr>
<tr>
<td>CORE</td>
<td>磁芯模型</td>
</tr>
<tr>
<td>L</td>
<td>磁芯互感模型</td>
</tr>
<tr>
<td>D</td>
<td>二极管模型</td>
</tr>
<tr>
<td>NPN</td>
<td>NPN双极型晶体管模型</td>
</tr>
<tr>
<td>PNP</td>
<td>PNP双极型晶体管模型</td>
</tr>
<tr>
<td>NJF</td>
<td>N沟道JFET模型</td>
</tr>
<tr>
<td>PJF</td>
<td>P沟道JFET模型</td>
</tr>
<tr>
<td>NMOS</td>
<td>N沟道MOSFET模型</td>
</tr>
<tr>
<td>PMOS</td>
<td>P沟道MOSFET模型</td>
</tr>
<tr>
<td>AMP</td>
<td>运算放大器模型</td>
</tr>
<tr>
<td>OPT</td>
<td>优化模型</td>
</tr>
<tr>
<td>PLOT</td>
<td>针对<code>.GRAPH</code>语句的硬盘拷贝绘图模型</td>
</tr>
</tbody>
</table>
<p>MOSFET模型的描述方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.MODEL 模型名 PMOS &lt;LEVEL=val&gt; &lt;parameters&gt;</span><br><span class="line">.MODEL 模型名 NMOS &lt;LEVEL=val&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p>第一代元件模型: <code>LEVEL1, LEVEL2, LEVEL3</code> 第二代元件模型:
BSIM1模型<code>LEVEL13</code>, 修正的BSIM1模型<code>LEVEL28</code>,
BSIM2模型<code>LEVEL39</code> 第三代元件模型:
BSIM3模型<code>LEVEL49</code></p>
<h3 id="库文件的使用">库文件的使用</h3>
<p>库文件可包含</p>
<ol type="1">
<li>器件模型<code>.MODEL</code></li>
<li>子电路</li>
<li>有关注释语句</li>
<li>库文件调用语句<code>.LIB</code>等</li>
</ol>
<h4 id="库文件的创建">库文件的创建</h4>
<p>创建库文件的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.LIB entryname</span><br><span class="line">具体库文件的描述</span><br><span class="line">.ENDL entryname</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>.LIB entryname</code>:
定义入口名为<code>entryname</code>的库</li>
<li><code>.ENDL</code>: 结束库定义语句</li>
<li>不能包含<code>.END</code>语句·</li>
</ol>
<h4 id="库文件的调用">库文件的调用</h4>
<p>库文件调用的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.LIB &#x27;&lt;file path&gt; file name&#x27; entryname</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>file path</code>: 库文件所在的路径,
若<code>.lib</code>与所运行的网表在相同目录下, 则可以缺省.</li>
<li><code>filename</code>: 库文件名, 扩展名.lib不可缺少.
路径和文件名必须包含在双引号或者单引号里面.</li>
<li><code>entryname</code>: 将要包括的库文件段的入口名</li>
</ol>
<h4 id="库文件的嵌套">库文件的嵌套</h4>
<p>库文件嵌套的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.LIB entryname</span><br><span class="line">具体库文件模型的描述</span><br><span class="line">.LIB &#x27;&lt;file path&gt; file name&#x27; entryname1</span><br><span class="line">.ENDL entryname</span><br></pre></td></tr></table></figure>
<p>注意库文件定义中嵌套调用其他库文件的入口名不能与所要定义的名字相同,
可以无限嵌套.</p>
<h2 id="命令语句-1">命令语句</h2>
<h3 id="电路性能仿真">电路性能仿真</h3>
<h4 id="直流分析">直流分析</h4>
<p>直流工作点分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.OP</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流工作点分析是指所有独立源或者受控源都是直流形态, 所有电感短路,
电容开路</li>
<li>输出: 节点电压, 电源电流, 静态功耗, 半导体器件的电流, 阻抗和电容.
仿真结果储存在.dp0文件中</li>
<li>只能出现一次<code>.OP</code>语句</li>
</ol>
<p>直流扫描分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC variable start stop step</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>variable</code>: 要扫描的对象的变量名</li>
<li><code>start</code>: 扫描初始值</li>
<li><code>stop</code>: 扫描终值值</li>
<li><code>step</code>: 扫描步长</li>
</ol>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC VIN 0.25 5.0 0.25</span><br></pre></td></tr></table></figure>
<p>直流小信号传输函数的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TF variable1 variable2</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流传输函数就是在直流工作点附近对电路进行线性化处理,
然后对电路进行如下分析: 直流小信号传输函数(小信号增益,
即输出变量对于输入源的增益), 电路输入电阻, 电路输出电阻.</li>
<li>该语句特别适用于直流电路和直接耦合放大器(差动电路和运算放大器)的增益,
输入电阻, 输出电阻的计算.</li>
<li><code>variable1</code>: 传输函数中分子变量, 一般为输出变量</li>
<li><code>variable2</code>: 传输函数中分母变量, 一般为输入变量</li>
<li>每一个电路模拟中只能有一个<code>.TF</code>语句</li>
</ol>
<p>直流小信号灵敏度分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.SENS VO1 &lt;VO2...&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流小信号灵敏度是指在指定范围内,
各个指定的输出变量相对于某一电路参数(如主被动元件值,
独立电源等)的直流小信号灵敏度.</li>
<li>绝对灵敏度是指, 输入参数每改变一个单位值, 输出的变化量,
如输入电阻每改变1欧姆, 输出电压的变化量, 这里单位便为V/1欧.
绝对灵敏度用来测试输入大幅度变化情况下输出的变化情况, 用于粗调.
定义式为<span class="math inline">\(S_E=\partial V_o/\partial
P\)</span>.</li>
<li>相等灵敏度是指, 输入参数在原来的基础上每改变百分之一, 输出的变化量.
如输入电阻为10欧姆, 每改变百分之一, 也就是0.1欧时, 输出电压的变化量,
单位为V/%, 相对灵敏度用来估计最大可允许输入误差范围. 定义式为<span
class="math inline">\(S_N=\partial V_o/\partial P\cdot P
\%\)</span></li>
<li><code>VO</code>: 输出的支路电流或者节点电压</li>
<li>灵敏度分析可以帮助设计者了解电路中哪些元件和模型参数对直流偏置的影响最大,
据此可以判断哪些元件和参数的作用是关键的,
它们参数的变化都会对输出造成较大的影响,
从而对元件精密度的选择做出了要求.</li>
</ol>
<h4 id="交流分析">交流分析</h4>
<p>交流信号包含幅值, 相位, 频率等的信号.
交流分析就是分析输出参数随频率变化的规律, 也就是频率响应.</p>
<p>交流分析中的一些规定:</p>
<ul>
<li>电阻: 若包含交流电阻, 则使用交流电阻</li>
<li>电容: 阻抗为<span class="math inline">\(1/j\omega C\)</span></li>
<li>电感: 阻抗为<span class="math inline">\(j\omega L\)</span></li>
<li>有源元件, 非线性元件全部转化为小信号模型</li>
<li>直流源全部接地</li>
</ul>
<p>交流小信号分析的一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC type np fstart fstop</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>type</code>是扫描类型</li>
<li><code>np</code>是扫描点数</li>
<li><code>fstrat/fstop</code>是起始和终止频率</li>
<li>注意电路中至少含有一个交流源</li>
</ol>
<p>扫描类型<code>type</code>有如下的选项:</p>
<ol type="1">
<li><code>DEC</code>: 每十进制实现对<code>np</code>个点进行扫描,
对数坐标</li>
<li><code>OCT</code>: 每八进制实现对<code>np</code>个点进行扫描,
对数坐标</li>
<li><code>LIN</code>: 线性扫描,
在指定的<code>fstart/fstop</code>频率范围内进行线性扫描</li>
<li><code>POI</code>: 按照所列参数点表进行扫描</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC DEC 10 1k 100MEG</span><br></pre></td></tr></table></figure>
<p>Sweep from 1kHz to 100MEGHz, with 10 points per decade</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC LIN 100 1 100Hz</span><br></pre></td></tr></table></figure>
<p>A 100 points frequency from 1Hz to 100Hz</p>
<p>AC的通用形式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.AC type np fstart fstop </span><br><span class="line">+SWEEP variable start-value stop-value </span><br><span class="line">+increment(type np start-value stop-value)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC DEC 10 1 10k SWEEP Cload LIN 20 1pf 10pf</span><br></pre></td></tr></table></figure>
<p>对电容<code>Cload</code>的每个值进行AC分析, 扫描频率为1Hz到10kHZ,
每10进制扫描10个点,
其中<code>Cload</code>的值为从1pf到10pf等距离取20个点.</p>
<p>零极点分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PZ OUTPUT INPUT</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>OUTPUT</code>为输出变量, 可以是任一支路电流或者节点电压</li>
<li><code>INPUT</code>为输入变量, 可以是任一独立电压或电流源名称</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PZ V(10) VIN</span><br></pre></td></tr></table></figure>
<p>交流噪声分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.NOISE OVV srcnam inter</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>OVV</code>是指定节点总的噪声输出电压</li>
<li><code>srcnam</code>是作为噪声输入基准的独立电压源或者独立电流源</li>
<li><code>inter</code>是打印噪声分析结果的频率间隔</li>
</ol>
<h4 id="瞬态分析">瞬态分析</h4>
<p>瞬态分析也称为时域的暂态分析,
是指对所选定的电路节点的时域相应进行分析,
即观察该节点在整个显示周期中每一时刻的波形.</p>
<p>瞬态分析的条件:</p>
<ul>
<li>电路中含有储能元件, 如电容, 电感等</li>
<li>换路条件: 电源值的升高或降低, 接通或断开, 电路中元件参数的改变</li>
<li>换路定理1: 换路瞬间, 电容上的电压, 电感中的电流不能突变,
这就意味着瞬态分析需要设置初始条件.</li>
<li>换路定理2: 换路瞬间, 电感相当于理想恒流源,
电容相当于理想恒压源.</li>
</ul>
<p>瞬态分析的目的就是要分析电路的相应速度, 也就是时间常数<span
class="math inline">\(\tau\)</span>. 时间常数越大, 过渡过程,
即瞬态时间越长, 达到稳态所需的时间就越长.</p>
<p>瞬态分析不收敛的原因:</p>
<ol type="1">
<li>模型参数不连续</li>
<li>可选项设置不恰当</li>
<li>初始条件的设置不合适</li>
</ol>
<p>初始条件设定的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.IC var1=val1 &lt;var2=val2&gt; &lt;...&gt;</span><br><span class="line">.DCVOLT V(node1)/node1=val1 &lt;...&gt;</span><br></pre></td></tr></table></figure>
<p>注意<code>.IC</code>可以设置任意变量初始值,
<code>.DCVOLT</code>只能设置电压初始值.</p>
<p>节点电压语句的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.NODESET V(node1)=val1 &lt;V(node2)=val2&gt; &lt;...&gt;</span><br><span class="line">.NODESET node1=val1 node2=val2 ...</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.IC V(11)=5 V(4)=-5 V(2)=2.2</span><br><span class="line">.DCVOLT 11 5 4 -5 2 2.2</span><br><span class="line">.NODESET V(12)=4.5 V(4)=2.23</span><br><span class="line">.NODESET 12 4.5 4 2.23</span><br></pre></td></tr></table></figure>
<p>初始条件设置的三种形式:</p>
<p>一. 利用<code>IC=?</code>直接描述元件两端的初始电压, 例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C1 2 0 1uF IC=2V</span><br></pre></td></tr></table></figure>
<p>二. 初始条件语句<code>.IC</code></p>
<p>三. 节点电压语句<code>.NODESET/.DCVOLT</code></p>
<p>当这三种语句同时存在时,
优先级为<code>IC&gt;.IC&gt;.NODESET</code>.</p>
<p>瞬态分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN TSTEP TSTOP &lt;TSTART&gt; &lt;UIC&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>TSTEP</code>是瞬态分析的步长</li>
<li><code>TSTOP</code>是瞬态分析终止的时间,
瞬态分析一般是从0开始分析到稳态结束,
但是只打印<code>TSTART</code>到<code>TSTOP</code>时间段的结果</li>
<li><code>TSTART</code>是分析的起始时间, 若不写则默认为0</li>
<li><code>UIC</code>:
若<code>.TRAN</code>语句中规定了<code>UIC</code>参数,
HSPICE不去计算初始直流工作点,
而是用<code>.IC</code>语句规定的节点电压计算电路中的初始条件.
这时需要仔细检查各个节点的直流电压值.
若<code>.TRAN</code>语句未规定<code>UIC</code>参数时,
HSPICE在瞬态分析前先计算直流工作点. 这时如果有<code>.IC</code>语句,
则仅当作求解直流工作点时相应的节点初始值,
而瞬态分析忽略这些电压限制.</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 1NS 100NS UIC</span><br></pre></td></tr></table></figure>
<p>分析和打印瞬态分析结果, 从0~100ns, 每1ns打印一次. 忽略初始直流工作点,
以<code>.IC</code>规定的节点电压,
电流或者某个元件两端的初始电压值作为初始条件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN .1NS 25NS 1NS 40NS STRAT=10NS</span><br></pre></td></tr></table></figure>
<p>分析和打印10ns~25ns, 步长为0.1ns; 25ns~40ns, 步长为1ns</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 10NS 1US UIC SWEEP TEMP -55 75 10</span><br></pre></td></tr></table></figure>
<p>对温度-55, -45,…, 75进行瞬态扫描, 时间从0~1us, 步长为10ns,
初始条件为<code>IC</code>规定的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 10NS 1US SWEEP Cload POI 3 1pF 5pF 10pF</span><br></pre></td></tr></table></figure>
<p>对负载参数电容<code>Cload</code>为1pf, 5pf, 10pf分别进行瞬态扫描,
时间从0~1us, 步长为10ns, <code>POI</code>为要扫描的参数列表.</p>
<h4 id="蒙特卡洛分析">蒙特卡洛分析</h4>
<p>蒙特卡洛分析的含义: 在给定标准差资料的基础上,
使用随机数发生器按照元件值的概率分布来选择元件值,
然后对电路进行模拟分析.</p>
<p>目的:</p>
<ol type="1">
<li>计算一定的工艺误差允许范围内的元件值</li>
<li>计算一定元件值下所允许的工艺误差容忍值</li>
</ol>
<p>应用:</p>
<ol type="1">
<li>预测元件参数的变化对产品效能的影响</li>
<li>电路生产的成品率以及成本</li>
</ol>
<p>蒙特卡洛直流分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛直流扫描分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC vin 15 .25 SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛交流扫描分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC dec 10 100 10meg SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛瞬态扫描分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 1n 10n SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>注释: <code>val</code>是蒙特卡洛分析中迭代的次数.</p>
<p>蒙特卡洛分析的元件参数设定</p>
<p>均匀分布情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=UNIF(NOM_VALUE, REL_VARIATION &lt;,multiplier&gt;) * 相对变化</span><br><span class="line">.PARAM XX=UNIF(NOM_VALUE, ABS_VARIATION &lt;,multiplier&gt;) * 绝对变化</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>REL_VARIATION</code>为相对变化值R, 在[N-N*R,
N+N*R]之间均匀分布</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间均匀分布</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<p>高斯分布情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=GAUSS(NOM_VALUE, REL_VARIATION, +&lt;Sigm&gt;&lt;,multiplier&gt;) * 相对变化</span><br><span class="line">.PARAM XX=GAUSS(NOM_VALUE, ABS_VARIATION, +&lt;Sigm&gt;&lt;,multiplier&gt;) * 绝对变化</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>REL_VARIATION</code>为相对变化值R, 在[N-N*R,
N+N*R]之间高斯分布</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间高斯分布</li>
<li><code>Sigm</code>为标准差参数, 实际标准差=A/S</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<p>随机范围参数分布:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=LIMIT(NOM_VALUE, ABS_VARIATION&lt;,multiplier&gt;)</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间随机分布</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<h4 id="温度特性">温度特性</h4>
<p>电路温度由<code>.TEMP</code>语句设定:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TEMP T1 T2 T3...</span><br></pre></td></tr></table></figure>
<p>电路对每个设定温度都模拟一次, 若缺省,
则电路温度为<code>TNOM</code>(由<code>.option</code>设定, 如果未设定,
默认为25).</p>
<p>单个元件温度是用<code>DTEMP</code>参数的扩展功能,
指的是元件温度与电路温度的差值.</p>
<p>模型参考温度由<code>.MODEL</code>语句中的<code>TREF</code>参数决定.</p>
<h3 id="输入输出控制">输入输出控制</h3>
<h4 id="输入控制">输入控制</h4>
<h4 id="输出控制">输出控制</h4>
<h2 id="实验及作业">实验及作业</h2>
<h3 id="实验例程inv">实验例程inv</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.title inv by liang yuhua</span><br><span class="line">*******************************************************************************************************</span><br><span class="line">* 电路描述：这是一个基于TSMC 65nm工艺的反相器电路，用于蒙特卡洛仿真分析</span><br><span class="line">*******************************************************************************************************</span><br><span class="line"></span><br><span class="line">* 工艺库文件引用</span><br><span class="line">.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">* 可选的工艺角库文件：</span><br><span class="line">* tt_lib    - 典型工艺角</span><br><span class="line">* ff_lib    - 快-快工艺角  </span><br><span class="line">* ss_lib    - 慢-慢工艺角</span><br><span class="line">* sf_lib    - 慢-快工艺角</span><br><span class="line">* fs_lib    - 快-慢工艺角</span><br><span class="line">* mc_lib    - 蒙特卡洛分析库（当前使用）</span><br><span class="line">* mismatch_lib - 失配分析库</span><br><span class="line">* noise_best/noise_worst - 噪声分析库</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">* 仿真控制选项</span><br><span class="line">.OPTION POST        $ 生成后处理输出文件</span><br><span class="line">.option lis_new     $ 使用新的列表文件格式</span><br><span class="line">.TEMP 27            $ 设置仿真温度为27°C</span><br><span class="line">.option ingold      $ 使用Gold格式输出，便于数据处理</span><br><span class="line">.OPTION method=BDF  $ 使用后向差分公式积分方法，适合刚性电路</span><br><span class="line">.OPTION runlvl=6    $ 设置运行级别为6，提高仿真精度</span><br><span class="line">.OPTION CO=132      $ 设置输出行宽为132字符</span><br><span class="line">.option measform=3  $ 设置测量结果输出格式</span><br><span class="line">.option dcon=1      $ 启用直流收敛辅助</span><br><span class="line">.op                  $ 执行直流工作点分析</span><br><span class="line">.option probe       $ 启用探测功能</span><br><span class="line">.OPTION LIST NODE   $ 在列表文件中包含节点信息</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 全局参数定义</span><br><span class="line">.param vdd    =1.2                    $ 定义电源电压为1.2V</span><br><span class="line">.param mismatchflag_mos_rf=1          $ 启用RF MOS管的失配效应（蒙特卡洛分析）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 电源和信号源定义</span><br><span class="line">vdd vdd 0 pwl 0 0 5n 0 5.0001n &#x27;vdd&#x27;  $ 电源电压：0-5ns为0V，5ns后跳变到1.2V</span><br><span class="line">vss vss 0 0                           $ 地电位定义</span><br><span class="line">vin in  0 pwl 0 0 20n 0 20.00001n vdd 35n vdd 35.00001n 0 50n 0  </span><br><span class="line">* 输入信号vin：0-20ns为0V，20ns跳变到1.2V，35ns跳变回0V，持续到50ns</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 反相器电路核心器件</span><br><span class="line">* NMOS晶体管：RF NMOS，工作在饱和区</span><br><span class="line">XN1 out in vss vss   nmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* 器件说明：X开头表示子电路调用，N1为实例名</span><br><span class="line">* 端口连接：out-漏极, in-栅极, vss-源极, vss-体端（四端口器件）</span><br><span class="line">* 参数：lr=栅长60nm, wr=栅宽1μm, nr=栅指数为1（单指）</span><br><span class="line">*       mismatchflag=1启用失配, sigma=1标准差倍数</span><br><span class="line"></span><br><span class="line">* PMOS晶体管：RF PMOS，与NMOS构成互补结构  </span><br><span class="line">XP1 out in vdd vdd   pmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* 器件说明：P1为PMOS实例名</span><br><span class="line">* 端口连接：out-漏极, in-栅极, vdd-源极, vdd-体端</span><br><span class="line">* 参数与NMOS对称，形成标准CMOS反相器</span><br><span class="line"></span><br><span class="line">* 负载电容</span><br><span class="line">CL out 0 1p          $ 输出端接1pF负载电容，模拟实际负载条件</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 瞬态分析设置</span><br><span class="line">.tran 0.005n 50n $sweep monte=10    $ 瞬态分析：时间步长5ps，总时长50ns</span><br><span class="line">*                $ 蒙特卡洛分析：进行10次随机采样，分析工艺波动影响</span><br><span class="line"></span><br><span class="line">* 输出信号定义</span><br><span class="line">.print tran V(in) V(out) V(vdd)     $ 输出输入、输出和电源电压波形</span><br><span class="line"></span><br><span class="line">.end</span><br></pre></td></tr></table></figure>
<h3 id="实验例程二">实验例程二</h3>
<p>对TSMC65nm工艺下SVT型NMOS晶体管, 在VD=1.2V, VG=0.6V的条件下,
仿真M0的静态工作点.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A SIMPLE AC RUN $title</span><br><span class="line">.LIB .lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">VD D 0 1.2</span><br><span class="line">VG G 0 0.6</span><br><span class="line">XN1 D G 0 0 RF_NMOS lr=0.5u wr=1u nr=2</span><br><span class="line">.OPTIONS LIST NODE POST $control options</span><br><span class="line">.OP</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="作业一">作业一</h3>
<p>详细阐述噪声容限的概念, 图示说明. 然后使用HSpice进行仿真.</p>
<h4 id="噪声容限的概念">噪声容限的概念</h4>
<p>噪声容限是衡量数字电路抗干扰能力的重要指标<a
href="#ref1"><sup>[1]</sup></a>.</p>
<p>假设一个反相器门电路的输入为逻辑变量in, 产生输出变量out.
一个逻辑门的电路可以用它的电压传输特性(VTC,
有时称为DC传输特性)得到最佳描述, 它画出了输出电压与输入电压的关系 <span
class="math inline">\(V_{out}=f(V_{in})\)</span>.
额定高电压和额定低电压分别为 <span
class="math inline">\(V_{OH}=f(V_{OL})\)</span>, <span
class="math inline">\(V_{OL}=f(V_{OH})\)</span>.
门阈值电压或者开关阈值电压 <span
class="math inline">\(V_M=f(V_M)\)</span>, 如下图所示.</p>
<p><img src="/source/images/HSpice/invtransfer.jpg" /></p>
<p>可接受的高电压和低电压的区域分别由<span
class="math inline">\(V_{IH}\)</span>和<span
class="math inline">\(V_{IL}\)</span>来界定, 根据定义,
它们代表了VTC增益(<span
class="math inline">\(=\mathrm{d}V_{out}/\mathrm{d}V_{in}\)</span>)等于<span
class="math inline">\(-1\)</span>的点, 如下图所示. <span
class="math inline">\(V_{IH}\)</span>和<span
class="math inline">\(V_{IL}\)</span>之间的区域称为不确定区,
有时也称为过度宽度(Transition Width, TW), 为了电路正确工作,
稳态信号应该避开这个区域.</p>
<p><img src="/source/images/HSpice/voltage.jpg" /></p>
<p>为了使一个门的稳定性较好且对噪声干扰不敏感,
应当使得”0”和”1”的区间越大越好. 一个门对于噪声的灵敏度是由噪声容限<span
class="math inline">\(NM_L\)</span>(低电平噪声容限)和<span
class="math inline">\(NM_H\)</span>(高电平噪声容限)来度量的,
它们分别量化了合法的”0”和”1”的范围, 并且确定了噪声的最大固定阈值:</p>
<p><span class="math display">\[\begin{aligned}
   &amp; NM_L=V_{IL}-V_{OL}\\
   &amp; NM_H=V_{OH}-V_{IH}\\
\end{aligned}\]</span></p>
<p><img src="/source/images/HSpice/NM.jpg" /></p>
<h4 id="仿真">仿真</h4>
<p>为了得到<span class="math inline">\(V_{out}=f(V_{in})\)</span>的曲线,
我们对反相器进行直流扫描, 将原来的inv.sp文件修改如下,命名为invnm.sp:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">.title inv by liang yuhua</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">* 引用工艺库文件：TSMC 65nm工艺库，使用mc_lib（蒙特卡洛库）</span><br><span class="line">* 可选的库类型注释：</span><br><span class="line">* tt_lib - 典型工艺角</span><br><span class="line">* ff_lib - 快工艺角（fast-fast）</span><br><span class="line">* ss_lib - 慢工艺角（slow-slow）</span><br><span class="line">* sf_lib - PMOS快NMOS慢工艺角</span><br><span class="line">* fs_lib - PMOS慢NMOS快工艺角</span><br><span class="line">* mc_lib - 蒙特卡洛分析库</span><br><span class="line">* mismatch_lib - 失配分析库</span><br><span class="line">* noise_best - 最佳噪声特性</span><br><span class="line">* noise_worst - 最差噪声特性</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">.OPTION POST=2</span><br><span class="line">* 设置后处理选项：POST=2 生成二进制格式的输出文件，用于波形查看器如CScope</span><br><span class="line"></span><br><span class="line">.option lis_new</span><br><span class="line">* 使用新的列表文件格式</span><br><span class="line"></span><br><span class="line">.TEMP 27</span><br><span class="line">* 设置仿真温度：27摄氏度</span><br><span class="line"></span><br><span class="line">.option ingold=1</span><br><span class="line">* 使用Gold格式输出，与CScope兼容</span><br><span class="line"></span><br><span class="line">.OPTION method=BDF</span><br><span class="line">* 设置数值积分方法：BDF（Backward Differentiation Formula），适合刚性电路</span><br><span class="line"></span><br><span class="line">.OPTION runlvl=6</span><br><span class="line">* 设置仿真运行级别：6（较高的精度级别）</span><br><span class="line"></span><br><span class="line">.OPTION CO=132</span><br><span class="line">* 设置输出行宽度：132个字符</span><br><span class="line"></span><br><span class="line">.option measform=3</span><br><span class="line">* 设置测量结果输出格式：3（详细格式）</span><br><span class="line"></span><br><span class="line">.option dcon=1</span><br><span class="line">* 直流收敛辅助选项：开启直流收敛帮助</span><br><span class="line"></span><br><span class="line">.op</span><br><span class="line">* 要求输出直流工作点信息</span><br><span class="line"></span><br><span class="line">.option probe</span><br><span class="line">* 启用探测功能，生成波形数据</span><br><span class="line"></span><br><span class="line">.OPTION LIST NODE</span><br><span class="line">* 在列表文件中包含节点信息</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">.param vdd    =1.2</span><br><span class="line">* 定义参数：电源电压vdd = 1.2V</span><br><span class="line"></span><br><span class="line">.param mismatchflag_mos_rf=1</span><br><span class="line">* 定义参数：MOS管失配标志 = 1（启用失配效应）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">vdd vdd 0 dc &#x27;vdd&#x27;</span><br><span class="line">* 定义直流电压源：vdd节点到地（0），电压值为参数vdd的值（1.2V）</span><br><span class="line">* &#x27;vdd&#x27;表示使用之前定义的参数值</span><br><span class="line"></span><br><span class="line">vss vss 0 0</span><br><span class="line">* 定义地节点：vss节点连接到地，电压为0V</span><br><span class="line"></span><br><span class="line">vin in  0 dc 0</span><br><span class="line">* 定义输入直流电压源：in节点到地，初始电压为0V（将在直流扫描中变化）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 反相器电路结构：</span><br><span class="line">XN1 out in vss vss   nmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* NMOS晶体管XN1：</span><br><span class="line">*   - 漏极：out，栅极：in，源极：vss，体端：vss</span><br><span class="line">*   - 模型：nmos_rf（RF NMOS）</span><br><span class="line">*   - 参数：lr=0.06μm（栅长），wr=1.0μm（栅宽），nr=1（手指数）</span><br><span class="line">*   - mismatchflag=&#x27;mismatchflag_mos_rf&#x27;（使用失配标志参数）</span><br><span class="line">*   - sigma=1（标准差系数）</span><br><span class="line"></span><br><span class="line">XP1 out in vdd vdd   pmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* PMOS晶体管XP1：</span><br><span class="line">*   - 漏极：out，栅极：in，源极：vdd，体端：vdd</span><br><span class="line">*   - 模型：pmos_rf（RF PMOS）</span><br><span class="line">*   - 参数：lr=0.06μm（栅长），wr=1.0μm（栅宽），nr=1（手指数）</span><br><span class="line">*   - mismatchflag=&#x27;mismatchflag_mos_rf&#x27;（使用失配标志参数）</span><br><span class="line">*   - sigma=1（标准差系数）</span><br><span class="line"></span><br><span class="line">CL out 0 1p</span><br><span class="line">* 负载电容：out节点到地，电容值1pF</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 直流扫描分析</span><br><span class="line">.dc vin 0 vdd 0.01</span><br><span class="line">* 直流扫描分析命令：</span><br><span class="line">*   - 扫描变量：vin（输入电压源）</span><br><span class="line">*   - 扫描范围：从0V到vdd（1.2V）</span><br><span class="line">*   - 扫描步长：0.01V（10mV）</span><br><span class="line">*   这将生成反相器的电压传输特性曲线</span><br><span class="line"></span><br><span class="line">* 添加.probe语句来生成CScope可查看的波形</span><br><span class="line">.probe dc V(in) V(out)</span><br><span class="line">* 指定要保存的直流分析节点电压：</span><br><span class="line">*   - V(in)：输入电压</span><br><span class="line">*   - V(out)：输出电压</span><br><span class="line">*   这些数据将被保存到.tr0文件中，供CScope查看</span><br><span class="line"></span><br><span class="line">.end</span><br><span class="line">* 仿真结束</span><br></pre></td></tr></table></figure>
<p>用CScope打开生成的invnm.sw0, 可以得到波形图, 添加cursor, 在configure
cursor中设置为drivative, 即可得到<span
class="math inline">\(V_{out}\)</span>关于<span
class="math inline">\(V_{in}\)</span>的导数. 寻找导数约为<span
class="math inline">\(-1\)</span>的点对应的横坐标. 见下图</p>
<p><img src="/source/images/HSpice/invnm1.png" /></p>
<p><img src="/source/images/HSpice/invnm2.png" /></p>
<p>可得<span class="math inline">\(V_{IL}=450mV, V_{IH}=637mV\)</span>,
而<span class="math inline">\(V_{OH}\approx 1.2V, V_{OL}\approx
0V\)</span>, 所以噪声容限为:</p>
<p><span class="math display">\[\begin{aligned}
   &amp; NM_L=V_{IL}-V_{OL}=0.45-0=0.45V\\
   &amp; NM_H=V_{OH}-V_{IH}=1.2-0.637=0.563V\\
\end{aligned}\]</span></p>
<h4 id="参考文献">参考文献</h4>
<p><a id="ref1"></a> [1] Jan M. Rabaey, Anantha Chandrakasan, Borivoje
Nikolic. 数字集成电路——电路、系统与设计（第二版）[M]. 北京:
电子工业出版社, 2017.1: 13-15.</p>
<h3 id="作业二">作业二</h3>
<p>用HSpice仿真如下电路的噪声</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A simple noise run</span><br><span class="line">   R1 1 2 5</span><br><span class="line">   C1 2 0 500pf</span><br><span class="line">   V1 1 0 0 AC=10V, 37</span><br><span class="line">   .AC DEC 10 1 100MEG</span><br><span class="line">   .noise v(2) v1 20</span><br><span class="line">   .END</span><br></pre></td></tr></table></figure>
<p>我们把网表文件命名为<code>example2.sp</code>.</p>
<p>这个网表是一个<strong>基础的无源RC电路</strong>, 仅包含电阻和电容.
HSpice软件的内置模型已包含这些基础元件的噪声模型: *
电阻元件的<strong>热噪声（约翰逊噪声）</strong>
是HSpice内置的基础噪声源之一. 进行<code>.NOISE</code>分析时,
HSpice会自动计算此类噪声。 *
电容元件在HSpice中通常被视为<strong>无噪声元件</strong></p>
<p>由于电路中没有使用晶体管等有源半导体器件(这些器件的噪声模型,
如MOSFET的<strong>热噪声</strong>和<strong>1/f
噪声（闪烁噪声）</strong>, 通常需要专门的工艺库文件提供精确参数),
因此不包含工艺库文件不影响此电路的噪声仿真.</p>
<p>代码中与噪声分析相关的语句设置是合理的: *
<code>.AC DEC 10 1 100MEG</code>: 在1Hz到100MHz频率范围内,
以10倍频程进行扫描, 每个倍频计算10个点.
这是<code>.NOISE</code>分析的基础。 * <code>.noise v(2) v1 20</code>:
指定噪声分析. <code>v(2)</code>是输出节点,
<code>v1</code>是作为噪声输入参考的独立源,
<code>20</code>代表每隔20个频率点打印一次详细的噪声贡献.</p>
<p>仿真的结果保存在<code>example2.lis</code>,
用文本编辑器打开即可查看噪声仿真结果.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/LC-3%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/LC-3%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">LC-3处理器设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-17 18:47:50" itemprop="dateModified" datetime="2025-11-17T18:47:50+08:00">2025-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="顶层模块">顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lc3_processor (</span><br><span class="line">    <span class="comment">// 时钟和复位信号</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统主时钟，驱动所有同步逻辑</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，将处理器恢复到初始状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存接口信号</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 从内存读取的数据输入，16位宽度</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,       <span class="comment">// 要写入内存的数据输出，16位宽度</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] address,        <span class="comment">// 内存访问地址，16位可寻址64K内存空间</span></span><br><span class="line">    <span class="keyword">output</span> mem_read,              <span class="comment">// 内存读使能信号，高电平有效时执行读操作</span></span><br><span class="line">    <span class="keyword">output</span> mem_write,             <span class="comment">// 内存写使能信号，高电平有效时执行写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试和状态监控信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] pc,             <span class="comment">// 当前程序计数器值，用于调试和程序流跟踪</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] ir              <span class="comment">// 当前指令寄存器值，用于调试和指令分析</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部信号定义 - 数据通路相关</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] instruction;      <span class="comment">// 当前执行的指令，从指令寄存器直接输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] dr;                <span class="comment">// 目标寄存器地址，指令[11:9]，指定结果写入的寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr1;               <span class="comment">// 源寄存器1地址，指令[8:6]，ALU操作的第一操作数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr2;               <span class="comment">// 源寄存器2地址，指令[2:0]，ALU操作的第二操作数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] imm5;              <span class="comment">// 5位立即数，指令[4:0]，用于立即数指令的符号扩展</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] pc_offset9;        <span class="comment">// 9位PC偏移量，指令[8:0]，用于分支和跳转指令的地址计算</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] pc_offset11;      <span class="comment">// 11位PC偏移量，指令[10:0]，用于JSR指令的地址计算</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector;       <span class="comment">// 8位陷阱向量，指令[7:0]，用于TRAP指令的服务程序寻址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU和总线相关信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] alu_out;          <span class="comment">// ALU运算结果输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] bus_out;          <span class="comment">// 数据总线输出，连接寄存器文件写回端口</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] reg_out [<span class="number">0</span>:<span class="number">7</span>];    <span class="comment">// 寄存器文件输出数组，8个16位通用寄存器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件码寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] nzp;               <span class="comment">// 条件码标志位：N(负)、Z(零)、P(正)，用于条件分支判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 控制信号定义 - 来自控制单元</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载使能信号</span></span><br><span class="line">    <span class="keyword">wire</span> ld_ir;                   <span class="comment">// 指令寄存器加载使能，高电平有效时更新IR</span></span><br><span class="line">    <span class="keyword">wire</span> ld_reg;                  <span class="comment">// 寄存器文件写使能，控制寄存器写入时机</span></span><br><span class="line">    <span class="keyword">wire</span> ld_cc;                   <span class="comment">// 条件码寄存器加载使能，高电平有效时更新NZP标志</span></span><br><span class="line">    <span class="keyword">wire</span> ld_pc;                   <span class="comment">// 程序计数器加载使能，高电平有效时更新PC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control;       <span class="comment">// ALU操作选择：</span></span><br><span class="line">                                  <span class="comment">// 00 = ADD, 01 = ADD立即数, 10 = AND, 11 = AND立即数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多路选择器控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel;        <span class="comment">// PC多路选择器选择信号：</span></span><br><span class="line">                                  <span class="comment">// 00 = PC+1, 01 = PC+offset9, 10 = 寄存器值, 11 = 陷阱向量</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel;       <span class="comment">// 总线多路选择器选择信号：</span></span><br><span class="line">                                  <span class="comment">// 00 = 内存数据, 01 = ALU结果, 10 = PC值, 11 = LEA偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据流控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> reg_write;               <span class="comment">// 寄存器文件写使能，控制是否写入目标寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> mem_to_reg;              <span class="comment">// 内存到寄存器选择，选择总线数据来源（内存或ALU）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令类型标识信号（主要用于调试和控制逻辑）</span></span><br><span class="line">    <span class="keyword">wire</span> is_trap;                 <span class="comment">// TRAP指令标识，高电平表示当前为TRAP指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_jsr;                  <span class="comment">// JSR/JSRR指令标识，高电平表示子程序调用指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_br;                   <span class="comment">// BR指令标识，高电平表示条件分支指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_jmp;                  <span class="comment">// JMP/RET指令标识，高电平表示无条件跳转指令</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 主要组件实例化</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制单元 - 产生所有控制信号</span></span><br><span class="line">    <span class="comment">// 根据当前指令和处理器状态生成相应的控制信号序列</span></span><br><span class="line">    control_unit ctrl (</span><br><span class="line">        <span class="comment">// 输入接口</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),                        <span class="comment">// 时钟信号</span></span><br><span class="line">        <span class="variable">.reset</span>(reset),                    <span class="comment">// 复位信号</span></span><br><span class="line">        <span class="variable">.instruction</span>(instruction),        <span class="comment">// 当前指令输入</span></span><br><span class="line">        <span class="variable">.nzp</span>(nzp),                        <span class="comment">// 条件码标志输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寄存器控制输出</span></span><br><span class="line">        <span class="variable">.ld_ir</span>(ld_ir),                    <span class="comment">// IR加载使能</span></span><br><span class="line">        <span class="variable">.ld_reg</span>(ld_reg),                  <span class="comment">// 寄存器文件写使能</span></span><br><span class="line">        <span class="variable">.ld_cc</span>(ld_cc),                    <span class="comment">// 条件码加载使能</span></span><br><span class="line">        <span class="variable">.ld_pc</span>(ld_pc),                    <span class="comment">// PC加载使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ALU和控制逻辑输出</span></span><br><span class="line">        <span class="variable">.alu_control</span>(alu_control),        <span class="comment">// ALU操作选择</span></span><br><span class="line">        <span class="variable">.pc_mux_sel</span>(pc_mux_sel),          <span class="comment">// PC多路选择器控制</span></span><br><span class="line">        <span class="variable">.bus_mux_sel</span>(bus_mux_sel),        <span class="comment">// 总线多路选择器控制</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据流控制输出</span></span><br><span class="line">        <span class="variable">.reg_write</span>(reg_write),            <span class="comment">// 寄存器写使能</span></span><br><span class="line">        <span class="variable">.mem_to_reg</span>(mem_to_reg),          <span class="comment">// 内存到寄存器选择</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存接口控制输出</span></span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),              <span class="comment">// 内存读使能</span></span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),            <span class="comment">// 内存写使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指令类型标识输出（调试用）</span></span><br><span class="line">        <span class="variable">.is_trap</span>(is_trap),                <span class="comment">// TRAP指令标识</span></span><br><span class="line">        <span class="variable">.is_jsr</span>(is_jsr),                  <span class="comment">// JSR指令标识</span></span><br><span class="line">        <span class="variable">.is_br</span>(is_br),                    <span class="comment">// BR指令标识</span></span><br><span class="line">        <span class="variable">.is_jmp</span>(is_jmp)                   <span class="comment">// JMP指令标识</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据通路 - 执行所有算术逻辑运算和数据传输</span></span><br><span class="line">    <span class="comment">// 包含ALU、寄存器文件、PC、MAR、MDR等核心组件</span></span><br><span class="line">    datapath dp (</span><br><span class="line">        <span class="comment">// 系统信号输入</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),                        <span class="comment">// 系统时钟</span></span><br><span class="line">        <span class="variable">.reset</span>(reset),                    <span class="comment">// 系统复位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指令和数据输入</span></span><br><span class="line">        <span class="variable">.instruction</span>(instruction),        <span class="comment">// 当前执行指令</span></span><br><span class="line">        <span class="variable">.data_in</span>(data_in),                <span class="comment">// 内存数据输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 控制信号输入</span></span><br><span class="line">        <span class="variable">.alu_control</span>(alu_control),        <span class="comment">// ALU操作控制</span></span><br><span class="line">        <span class="variable">.pc_mux_sel</span>(pc_mux_sel),          <span class="comment">// PC多路选择控制</span></span><br><span class="line">        <span class="variable">.bus_mux_sel</span>(bus_mux_sel),        <span class="comment">// 总线多路选择控制</span></span><br><span class="line">        <span class="variable">.reg_write</span>(reg_write),            <span class="comment">// 寄存器写使能</span></span><br><span class="line">        <span class="variable">.mem_to_reg</span>(mem_to_reg),          <span class="comment">// 内存到寄存器选择</span></span><br><span class="line">        <span class="variable">.ld_ir</span>(ld_ir),                    <span class="comment">// IR加载使能</span></span><br><span class="line">        <span class="variable">.ld_reg</span>(ld_reg),                  <span class="comment">// 寄存器加载使能</span></span><br><span class="line">        <span class="variable">.ld_cc</span>(ld_cc),                    <span class="comment">// 条件码加载使能</span></span><br><span class="line">        <span class="variable">.ld_pc</span>(ld_pc),                    <span class="comment">// PC加载使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存接口输出</span></span><br><span class="line">        <span class="variable">.data_out</span>(data_out),              <span class="comment">// 内存写数据</span></span><br><span class="line">        <span class="variable">.address</span>(address),                <span class="comment">// 内存地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内部状态输出</span></span><br><span class="line">        <span class="variable">.alu_out</span>(alu_out),                <span class="comment">// ALU运算结果</span></span><br><span class="line">        <span class="variable">.bus_out</span>(bus_out),                <span class="comment">// 总线数据</span></span><br><span class="line">        <span class="variable">.nzp</span>(nzp),                        <span class="comment">// 条件码标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调试信号输出</span></span><br><span class="line">        <span class="variable">.pc</span>(pc),                          <span class="comment">// 当前PC值</span></span><br><span class="line">        <span class="variable">.ir</span>(ir)                           <span class="comment">// 当前IR值</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="控制单元">控制单元</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> control_unit (</span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 系统复位信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] instruction,     <span class="comment">// 当前执行的16位指令</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] nzp,              <span class="comment">// 条件码标志位：N(负)、Z(零)、P(正)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_ir,             <span class="comment">// 指令寄存器加载使能，控制IR更新</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_reg,            <span class="comment">// 寄存器文件加载使能，控制寄存器写入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_cc,             <span class="comment">// 条件码寄存器加载使能，控制NZP更新</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_pc,             <span class="comment">// 程序计数器加载使能，控制PC更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU和总线控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control, <span class="comment">// ALU操作选择控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel,  <span class="comment">// PC多路选择器选择信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel, <span class="comment">// 总线多路选择器选择信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据流控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> reg_write,         <span class="comment">// 寄存器写使能，控制寄存器文件写入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_to_reg,        <span class="comment">// 内存到寄存器选择，选择数据来源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存访问控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_read,          <span class="comment">// 内存读使能，控制内存读取操作</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_write,         <span class="comment">// 内存写使能，控制内存写入操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令类型标识信号（主要用于调试）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_trap,           <span class="comment">// TRAP指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_jsr,            <span class="comment">// JSR指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_br,             <span class="comment">// BR指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_jmp             <span class="comment">// JMP指令标识信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// LC-3指令操作码定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">3</span>:<span class="number">0</span>] </span><br><span class="line">        OP_ADD = <span class="number">4&#x27;b0001</span>,  <span class="comment">// 加法指令：寄存器+寄存器 或 寄存器+立即数</span></span><br><span class="line">        OP_AND = <span class="number">4&#x27;b0101</span>,  <span class="comment">// 逻辑与指令：寄存器&amp;寄存器 或 寄存器&amp;立即数</span></span><br><span class="line">        OP_BR  = <span class="number">4&#x27;b0000</span>,  <span class="comment">// 条件分支指令：根据条件码跳转到PC+offset9</span></span><br><span class="line">        OP_JMP = <span class="number">4&#x27;b1100</span>,  <span class="comment">// 跳转指令：跳转到寄存器指定的地址（包括RET）</span></span><br><span class="line">        OP_JSR = <span class="number">4&#x27;b0100</span>,  <span class="comment">// 跳转到子程序：保存返回地址到R7并跳转</span></span><br><span class="line">        OP_LD  = <span class="number">4&#x27;b0010</span>,  <span class="comment">// 加载指令：从内存地址PC+offset9加载数据到寄存器</span></span><br><span class="line">        OP_LDI = <span class="number">4&#x27;b1010</span>,  <span class="comment">// 间接加载指令：通过指针加载数据</span></span><br><span class="line">        OP_LDR = <span class="number">4&#x27;b0110</span>,  <span class="comment">// 基址偏移加载：从地址[基址寄存器+offset6]加载</span></span><br><span class="line">        OP_LEA = <span class="number">4&#x27;b1110</span>,  <span class="comment">// 加载有效地址：将PC+offset9的地址加载到寄存器</span></span><br><span class="line">        OP_NOT = <span class="number">4&#x27;b1001</span>,  <span class="comment">// 取反指令：对寄存器值按位取反</span></span><br><span class="line">        OP_ST  = <span class="number">4&#x27;b0011</span>,  <span class="comment">// 存储指令：将寄存器值存储到内存地址PC+offset9</span></span><br><span class="line">        OP_STI = <span class="number">4&#x27;b1011</span>,  <span class="comment">// 间接存储指令：通过指针存储数据</span></span><br><span class="line">        OP_STR = <span class="number">4&#x27;b0111</span>,  <span class="comment">// 基址偏移存储：存储到地址[基址寄存器+offset6]</span></span><br><span class="line">        OP_TRAP= <span class="number">4&#x27;b1111</span>;  <span class="comment">// 系统调用指令：执行指定的陷阱服务程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令字段提取</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] opcode = instruction[<span class="number">15</span>:<span class="number">12</span>];    <span class="comment">// 操作码字段</span></span><br><span class="line">    <span class="keyword">wire</span> imm_mode = instruction[<span class="number">5</span>];            <span class="comment">// 立即数模式标志：1=立即数模式，0=寄存器模式</span></span><br><span class="line">    <span class="keyword">wire</span> jsr_mode = instruction[<span class="number">11</span>];           <span class="comment">// JSR模式标志：1=JSRR(寄存器)，0=JSR(PC相对)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 组合逻辑：指令译码与控制信号生成</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 默认控制信号赋值 - 确保所有输出都有确定值</span></span><br><span class="line">        ld_ir = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认不加载IR（在case外统一设置）</span></span><br><span class="line">        ld_reg = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认不加载寄存器文件</span></span><br><span class="line">        ld_cc = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认不更新条件码</span></span><br><span class="line">        ld_pc = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认PC递增（PC+1）</span></span><br><span class="line">        alu_control = <span class="number">2&#x27;b00</span>;    <span class="comment">// 默认ALU执行加法</span></span><br><span class="line">        pc_mux_sel = <span class="number">2&#x27;b00</span>;     <span class="comment">// 默认PC选择PC+1</span></span><br><span class="line">        bus_mux_sel = <span class="number">2&#x27;b00</span>;    <span class="comment">// 默认总线选择内存数据</span></span><br><span class="line">        reg_write = <span class="number">1&#x27;b0</span>;       <span class="comment">// 默认不写入寄存器文件</span></span><br><span class="line">        mem_to_reg = <span class="number">1&#x27;b0</span>;      <span class="comment">// 默认总线数据来自ALU</span></span><br><span class="line">        mem_read = <span class="number">1&#x27;b0</span>;        <span class="comment">// 默认不读取内存</span></span><br><span class="line">        mem_write = <span class="number">1&#x27;b0</span>;       <span class="comment">// 默认不写入内存</span></span><br><span class="line">        is_trap = <span class="number">1&#x27;b0</span>;         <span class="comment">// 默认非TRAP指令</span></span><br><span class="line">        is_jsr = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认非JSR指令</span></span><br><span class="line">        is_br = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认非BR指令</span></span><br><span class="line">        is_jmp = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认非JMP指令</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据操作码生成相应的控制信号</span></span><br><span class="line">        <span class="keyword">case</span> (opcode)</span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// ADD指令：目标寄存器 ← 源寄存器1 + 源寄存器2/立即数</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_ADD: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：根据imm_mode选择寄存器相加或立即数相加</span></span><br><span class="line">                alu_control = (imm_mode) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b00</span>; </span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>; </span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// AND指令：目标寄存器 ← 源寄存器1 &amp; 源寄存器2/立即数</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_AND: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：根据imm_mode选择寄存器相与或立即数相与</span></span><br><span class="line">                alu_control = (imm_mode) ? <span class="number">2&#x27;b11</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// NOT指令：目标寄存器 ← ~源寄存器1（按位取反）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_NOT: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：NOT操作实际上使用AND逻辑的特殊处理</span></span><br><span class="line">                alu_control = <span class="number">2&#x27;b10</span>; </span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// BR指令：条件分支，如果条件码匹配则PC ← PC + 符号扩展(offset9)</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_BR: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置BR指令标识</span></span><br><span class="line">                is_br = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 检查条件码是否匹配：instruction[11:9]对应nzp[2:0]</span></span><br><span class="line">                <span class="comment">// instruction[11]=1且N=1，或instruction[10]=1且Z=1，或instruction[9]=1且P=1</span></span><br><span class="line">                <span class="keyword">if</span> ((instruction[<span class="number">11</span>] &amp; nzp[<span class="number">2</span>]) |   <span class="comment">// 负条件匹配</span></span><br><span class="line">                    (instruction[<span class="number">10</span>] &amp; nzp[<span class="number">1</span>]) |   <span class="comment">// 零条件匹配</span></span><br><span class="line">                    (instruction[<span class="number">9</span>] &amp; nzp[<span class="number">0</span>]))     <span class="comment">// 正条件匹配</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// 条件满足：选择PC+offset9作为下一条指令地址</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b01</span>; </span><br><span class="line">                    ld_pc = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// 如果不满足条件，PC保持默认的PC+1</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// JMP指令：无条件跳转，PC ← 寄存器值（RET是JMP R7的特殊情况）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_JMP: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置JMP指令标识</span></span><br><span class="line">                is_jmp = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// PC控制：选择寄存器值作为下一条指令地址</span></span><br><span class="line">                pc_mux_sel = <span class="number">2&#x27;b10</span>; </span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// JSR/JSRR指令：跳转到子程序</span></span><br><span class="line">            <span class="comment">// JSR: PC ← PC + 符号扩展(offset11), R7 ← 当前PC（返回地址）</span></span><br><span class="line">            <span class="comment">// JSRR: PC ← 寄存器值, R7 ← 当前PC（返回地址）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_JSR: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置JSR指令标识</span></span><br><span class="line">                is_jsr = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 保存返回地址到R7：将当前PC值通过总线写入R7</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b10</span>;     <span class="comment">// 选择PC值送到总线</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许写入寄存器</span></span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;           <span class="comment">// 加载寄存器文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据jsr_mode选择跳转方式</span></span><br><span class="line">                <span class="keyword">if</span> (jsr_mode) <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// JSRR模式：跳转到寄存器指定的地址</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b10</span>;  <span class="comment">// 选择寄存器值</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// JSR模式：跳转到PC+offset11</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b01</span>;  <span class="comment">// 选择PC+offset</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// TRAP指令：系统调用</span></span><br><span class="line">            <span class="comment">// R7 ← 当前PC（返回地址），PC ← 陷阱向量表[trapvect8]</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_TRAP: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置TRAP指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 保存返回地址到R7：将当前PC值通过总线写入R7</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b10</span>;     <span class="comment">// 选择PC值送到总线</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许写入寄存器</span></span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;           <span class="comment">// 加载寄存器文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 跳转到陷阱服务程序：通过陷阱向量表查找服务程序地址</span></span><br><span class="line">                pc_mux_sel = <span class="number">2&#x27;b11</span>;      <span class="comment">// 选择陷阱向量地址</span></span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 内存控制：可能需要读取陷阱向量表中的服务程序地址</span></span><br><span class="line">                mem_read = <span class="number">1&#x27;b1</span>;         <span class="comment">// 使能内存读取</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// LD指令：加载数据，目标寄存器 ← 内存[PC + 符号扩展(offset9)]</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_LD: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 内存控制：从PC+offset9地址读取数据</span></span><br><span class="line">                mem_read = <span class="number">1&#x27;b1</span>;         <span class="comment">// 使能内存读取</span></span><br><span class="line">                mem_to_reg = <span class="number">1&#x27;b1</span>;       <span class="comment">// 总线数据来自内存（而不是ALU）</span></span><br><span class="line">                <span class="comment">// 寄存器控制：将内存数据写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// ST指令：存储数据，内存[PC + 符号扩展(offset9)] ← 源寄存器</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_ST: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 内存控制：向PC+offset9地址写入寄存器数据</span></span><br><span class="line">                mem_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 使能内存写入</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 其他指令实现（LDI, LDR, LEA, STI, STR等）...</span></span><br><span class="line">            <span class="comment">// 这里可以继续添加其他指令的case分支</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 未定义操作码或未实现指令的默认处理</span></span><br><span class="line">                <span class="comment">// 所有信号保持默认值，确保系统稳定</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个时钟周期都取指：总是加载指令寄存器</span></span><br><span class="line">        <span class="comment">// 这确保了下一条指令能够及时进入流水线</span></span><br><span class="line">        ld_ir = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="数据通路单元">数据通路单元</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> datapath (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输入端口定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，驱动所有同步逻辑</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位所有寄存器</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] instruction,     <span class="comment">// 当前执行的16位指令字</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 从内存读取的16位数据输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制信号输入</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control,      <span class="comment">// ALU操作控制信号：00=ADD,01=ADD立即数,10=AND,11=AND立即数</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel,       <span class="comment">// PC多路选择器控制：00=PC+1,01=PC+offset,10=寄存器,11=陷阱向量</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel,      <span class="comment">// 总线多路选择器控制：00=内存,01=ALU,10=PC,11=LEA偏移量</span></span><br><span class="line">    <span class="keyword">input</span> reg_write,              <span class="comment">// 寄存器写使能信号，控制是否写入寄存器文件</span></span><br><span class="line">    <span class="keyword">input</span> mem_to_reg,             <span class="comment">// 内存到寄存器选择，选择写回数据来源（内存或ALU）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载控制信号</span></span><br><span class="line">    <span class="keyword">input</span> ld_ir,                  <span class="comment">// 指令寄存器加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_reg,                 <span class="comment">// 寄存器文件加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_cc,                  <span class="comment">// 条件码寄存器加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_pc,                  <span class="comment">// 程序计数器加载使能</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输出端口定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,   <span class="comment">// 要写入内存的16位数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] address,    <span class="comment">// 内存访问地址输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] alu_out,    <span class="comment">// ALU运算结果输出，用于调试和后续处理</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] bus_out,    <span class="comment">// 数据总线输出，连接寄存器写回端口</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] nzp,         <span class="comment">// 条件码标志位输出：N(负), Z(零), P(正)</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] pc,         <span class="comment">// 当前程序计数器值，用于调试</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] ir          <span class="comment">// 当前指令寄存器值，用于调试</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件定义 - 8个16位通用寄存器</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] reg_file [<span class="number">0</span>:<span class="number">7</span>];    <span class="comment">// R0-R7寄存器文件，支持同时读写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部信号定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器读取输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] sr1_out, sr2_out; <span class="comment">// 源寄存器1和源寄存器2的读取数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符号扩展立即数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] imm5_sext;        <span class="comment">// 5位立即数符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset9_sext;     <span class="comment">// 9位偏移量符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset11_sext;    <span class="comment">// 11位偏移量符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset6_sext;     <span class="comment">// 6位偏移量符号扩展结果（用于LDR/STR）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] trap_vector_addr; <span class="comment">// 陷阱向量地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PC控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] next_pc;          <span class="comment">// 下一条指令地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 指令解码 - 从指令字中提取各个字段</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] dr = instruction[<span class="number">11</span>:<span class="number">9</span>];    <span class="comment">// 目标寄存器地址（写入结果的寄存器）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr1 = instruction[<span class="number">8</span>:<span class="number">6</span>];    <span class="comment">// 源寄存器1地址（第一个操作数）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr2 = instruction[<span class="number">2</span>:<span class="number">0</span>];    <span class="comment">// 源寄存器2地址（第二个操作数）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] imm5 = instruction[<span class="number">4</span>:<span class="number">0</span>];   <span class="comment">// 5位立即数（用于ADD/AND立即数模式）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] offset9 = instruction[<span class="number">8</span>:<span class="number">0</span>]; <span class="comment">// 9位偏移量（用于LD/ST/BR/LEA等指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] offset11 = instruction[<span class="number">10</span>:<span class="number">0</span>]; <span class="comment">// 11位偏移量（用于JSR指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] offset6 = instruction[<span class="number">5</span>:<span class="number">0</span>]; <span class="comment">// 6位偏移量（用于LDR/STR指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector = instruction[<span class="number">7</span>:<span class="number">0</span>]; <span class="comment">// 8位陷阱向量（用于TRAP指令）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 符号扩展单元 - 将短位宽有符号数扩展为16位</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> imm5_sext = &#123;&#123;<span class="number">11</span>&#123;imm5[<span class="number">4</span>]&#125;&#125;, imm5&#125;;           <span class="comment">// 5位立即数符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset9_sext = &#123;&#123;<span class="number">7</span>&#123;offset9[<span class="number">8</span>]&#125;&#125;, offset9&#125;;   <span class="comment">// 9位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset11_sext = &#123;&#123;<span class="number">5</span>&#123;offset11[<span class="number">10</span>]&#125;&#125;, offset11&#125;; <span class="comment">// 11位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset6_sext = &#123;&#123;<span class="number">10</span>&#123;offset6[<span class="number">5</span>]&#125;&#125;, offset6&#125;;  <span class="comment">// 6位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> trap_vector_addr = &#123;<span class="number">8&#x27;b0</span>, trap_vector&#125;;      <span class="comment">// 陷阱向量零扩展为16位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件读取 - 组合逻辑读取，无时钟延迟</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> sr1_out = reg_file[sr1];  <span class="comment">// 从SR1指定寄存器读取数据</span></span><br><span class="line">    <span class="keyword">assign</span> sr2_out = reg_file[sr2];  <span class="comment">// 从SR2指定寄存器读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 算术逻辑单元(ALU) - 执行所有算术和逻辑运算</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 根据ALU控制信号执行相应的运算</span></span><br><span class="line">        <span class="keyword">case</span> (alu_control)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: alu_out = sr1_out + sr2_out;           <span class="comment">// 寄存器加法：SR1 + SR2</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: alu_out = sr1_out + imm5_sext;         <span class="comment">// 立即数加法：SR1 + 立即数</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: alu_out = sr1_out &amp; sr2_out;           <span class="comment">// 寄存器逻辑与：SR1 &amp; SR2</span></span><br><span class="line">            <span class="number">2&#x27;b11</span>: alu_out = sr1_out &amp; imm5_sext;         <span class="comment">// 立即数逻辑与：SR1 &amp; 立即数</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOT指令特殊处理：对源寄存器1按位取反</span></span><br><span class="line">        <span class="comment">// NOT指令的操作码是1001，它使用ALU的AND逻辑但需要特殊处理结果</span></span><br><span class="line">        <span class="keyword">if</span> (instruction[<span class="number">15</span>:<span class="number">12</span>] == <span class="number">4&#x27;b1001</span>) <span class="keyword">begin</span> <span class="comment">// NOT指令</span></span><br><span class="line">            alu_out = ~sr1_out;  <span class="comment">// 按位取反操作</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 总线多路选择器 - 选择写入寄存器文件的数据来源</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (bus_mux_sel)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: bus_out = data_in;     <span class="comment">// 选择内存数据（用于LD/LDI/LDR指令）</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: bus_out = alu_out;     <span class="comment">// 选择ALU运算结果（用于ADD/AND/NOT指令）</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: bus_out = pc;          <span class="comment">// 选择PC值（用于JSR/TRAP保存返回地址）</span></span><br><span class="line">            <span class="number">2&#x27;b11</span>: bus_out = offset9_sext; <span class="comment">// 选择LEA偏移量（用于LEA指令加载有效地址）</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// PC多路选择器 - 决定下一条指令的地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> next_pc = (pc_mux_sel == <span class="number">2&#x27;b00</span>) ? pc + <span class="number">16&#x27;b1</span> :           <span class="comment">// 顺序执行：PC + 1</span></span><br><span class="line">                    (pc_mux_sel == <span class="number">2&#x27;b01</span>) ? pc + offset9_sext :    <span class="comment">// 分支跳转：PC + 符号扩展offset9</span></span><br><span class="line">                    (pc_mux_sel == <span class="number">2&#x27;b10</span>) ? sr1_out :              <span class="comment">// 寄存器跳转：使用寄存器值作为目标地址</span></span><br><span class="line">                    &#123;<span class="number">8&#x27;b0</span>, trap_vector&#125;;                          <span class="comment">// 陷阱调用：使用陷阱向量作为目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 地址生成逻辑 - 计算内存访问地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (instruction[<span class="number">15</span>:<span class="number">12</span>])  <span class="comment">// 根据操作码选择地址生成方式</span></span><br><span class="line">            <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: address = pc + offset9_sext;  <span class="comment">// LD/ST：PC相对寻址</span></span><br><span class="line">            <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>: address = pc + offset9_sext;  <span class="comment">// LDI/STI：PC相对间接寻址</span></span><br><span class="line">            <span class="number">4&#x27;b0110</span>, <span class="number">4&#x27;b0111</span>: address = sr1_out + offset6_sext; <span class="comment">// LDR/STR：基址+偏移寻址</span></span><br><span class="line">            <span class="number">4&#x27;b1111</span>: address = trap_vector_addr;            <span class="comment">// TRAP：陷阱向量表地址</span></span><br><span class="line">            <span class="keyword">default</span>: address = pc;                          <span class="comment">// 默认使用PC作为地址</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 数据输出逻辑 - 准备要写入内存的数据</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 对于存储指令(ST/STI/STR)，将要存储的寄存器值送到data_out</span></span><br><span class="line">        data_out = sr1_out; <span class="comment">// 使用源寄存器1的值作为内存写入数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 条件码逻辑 - 跟踪最近写入结果的符号状态</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时初始化条件码为零标志</span></span><br><span class="line">            nzp &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 初始化为Z(零)标志</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_cc) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当条件码加载使能有效时，根据总线数据的符号更新条件码</span></span><br><span class="line">            <span class="keyword">if</span> (bus_out[<span class="number">15</span>] == <span class="number">1&#x27;b1</span>)        <span class="comment">// 检查最高位（符号位）</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b100</span>;              <span class="comment">// 负数：设置N标志</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bus_out == <span class="number">16&#x27;b0</span>)      <span class="comment">// 检查是否为零</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b010</span>;              <span class="comment">// 零：设置Z标志</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b001</span>;              <span class="comment">// 正数：设置P标志</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果ld_cc无效，条件码保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 程序计数器(PC) - 跟踪当前执行指令的地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时PC初始化为LC-3标准起始地址0x3000</span></span><br><span class="line">            pc &lt;= <span class="number">16&#x27;h3000</span>; </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_pc) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当PC加载使能有效时，更新为多路选择器选择的下一地址</span></span><br><span class="line">            pc &lt;= next_pc;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 默认情况下，PC每个周期递增1（顺序执行）</span></span><br><span class="line">            pc &lt;= pc + <span class="number">16&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 指令寄存器(IR) - 保存当前正在执行的指令</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时清除指令寄存器</span></span><br><span class="line">            ir &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_ir) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当IR加载使能有效时，锁存当前指令</span></span><br><span class="line">            ir &lt;= instruction;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果ld_ir无效，IR保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件写回逻辑 - 将数据写入目标寄存器</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">integer</span> i;  <span class="comment">// 循环变量，用于复位时初始化所有寄存器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时将所有8个寄存器清零</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>)</span><br><span class="line">                reg_file[i] &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (reg_write &amp;&amp; ld_reg) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当寄存器写使能和加载使能都有效时，执行写回操作</span></span><br><span class="line">            <span class="keyword">if</span> (ir[<span class="number">15</span>:<span class="number">12</span>] == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> </span><br><span class="line">                <span class="comment">// TRAP指令特殊处理：总是将返回地址写入R7</span></span><br><span class="line">                reg_file[<span class="number">3&#x27;b111</span>] &lt;= bus_out; <span class="comment">// R7 = 当前PC值（返回地址）</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 普通指令：根据mem_to_reg选择数据来源写入目标寄存器</span></span><br><span class="line">                reg_file[dr] &lt;= (mem_to_reg) ? data_in : bus_out;</span><br><span class="line">                <span class="comment">// mem_to_reg=1：从内存读取的数据(data_in)</span></span><br><span class="line">                <span class="comment">// mem_to_reg=0：从总线来的数据(bus_out，可能是ALU结果或PC值)</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果写使能无效，寄存器文件保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="trap处理模块">TRAP处理模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// TRAP处理模块 (Trap Handler)</span></span><br><span class="line"><span class="comment">// 功能：处理LC-3处理器的系统调用(TRAP)指令，实现陷阱向量到服务程序的地址转换</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="keyword">module</span> trap_handler (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输入端口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，用于同步陷阱处理操作</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位所有内部状态</span></span><br><span class="line">    <span class="keyword">input</span> trap_enable,            <span class="comment">// TRAP使能信号，高电平表示当前正在执行TRAP指令</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector,      <span class="comment">// 8位陷阱向量，来自TRAP指令的[7:0]字段，用于索引陷阱服务程序</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] current_pc,      <span class="comment">// 当前程序计数器值，用于保存为返回地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输出端口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] trap_address, <span class="comment">// 16位陷阱服务程序地址，输出到PC多路选择器</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> save_pc,           <span class="comment">// 保存PC使能信号，通知数据通路保存返回地址到R7</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] return_addr   <span class="comment">// 返回地址值，即TRAP指令执行时的PC值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部存储器：TRAP向量表</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 256x16位陷阱向量表，将8位陷阱向量映射到16位服务程序起始地址</span></span><br><span class="line">    <span class="comment">// 索引范围：0-255，对应TRAP指令的trapvect8字段的所有可能值</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] trap_vector_table [<span class="number">0</span>:<span class="number">255</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 向量表初始化 - 预定义标准LC-3陷阱服务程序地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 初始化所有向量表项为0（安全默认值）</span></span><br><span class="line">        <span class="comment">// 在实际实现中，可能需要更完整的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">integer</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            trap_vector_table[i] = <span class="number">16&#x27;h0000</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// LC-3标准陷阱向量定义</span></span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符输入陷阱服务</span></span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h20</span>] = <span class="number">16&#x27;h0430</span>; <span class="comment">// GETC - 从键盘读取单个字符到R0</span></span><br><span class="line">        <span class="comment">// 功能：等待键盘输入，将输入的ASCII字符存入R0[7:0]，R0[15:8]清零</span></span><br><span class="line">        <span class="comment">// 不回显字符到显示器</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h21</span>] = <span class="number">16&#x27;h0450</span>; <span class="comment">// OUT - 将R0[7:0]中的字符输出到显示器</span></span><br><span class="line">        <span class="comment">// 功能：将R0寄存器低8位的ASCII字符发送到显示器输出</span></span><br><span class="line">        <span class="comment">// 注意：字符必须位于R0[7:0]，高8位被忽略</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h22</span>] = <span class="number">16&#x27;h04A0</span>; <span class="comment">// PUTS - 输出以空字符结尾的字符串</span></span><br><span class="line">        <span class="comment">// 功能：从R0指定的内存地址开始，逐个输出字符直到遇到空字符(0x0000)</span></span><br><span class="line">        <span class="comment">// 输入：R0包含字符串起始地址</span></span><br><span class="line">        <span class="comment">// 输出：字符串内容显示在显示器上</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h23</span>] = <span class="number">16&#x27;h04E0</span>; <span class="comment">// IN - 输入字符并回显</span></span><br><span class="line">        <span class="comment">// 功能：等待键盘输入，将字符存入R0[7:0]并在显示器上回显该字符</span></span><br><span class="line">        <span class="comment">// 相当于GETC和OUT的组合，但作为原子操作</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h24</span>] = <span class="number">16&#x27;hFD70</span>; <span class="comment">// PUTSP - 输出打包的字节字符串</span></span><br><span class="line">        <span class="comment">// 功能：输出内存中的打包字符串（每个16位字包含2个ASCII字符）</span></span><br><span class="line">        <span class="comment">// 输入：R0包含字符串起始地址</span></span><br><span class="line">        <span class="comment">// 输出：解包后的字符串显示在显示器上</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h25</span>] = <span class="number">16&#x27;hFD00</span>; <span class="comment">// HALT - 停止程序执行</span></span><br><span class="line">        <span class="comment">// 功能：停止处理器执行，通常通过设置特定的状态位来实现</span></span><br><span class="line">        <span class="comment">// 在模拟器中会停止模拟，在实际硬件中可能进入低功耗状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// 可扩展的其他陷阱向量（根据需要添加）</span></span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// trap_vector_table[8&#x27;h26] = 16&#x27;hXXXX; // 预留用户自定义陷阱</span></span><br><span class="line">        <span class="comment">// trap_vector_table[8&#x27;h27] = 16&#x27;hXXXX; // 预留用户自定义陷阱</span></span><br><span class="line">        <span class="comment">// ... 可以继续添加其他陷阱服务程序地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// TRAP处理状态机 - 同步逻辑</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位处理：清除所有输出信号和状态</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            trap_address &lt;= <span class="number">16&#x27;b0</span>;    <span class="comment">// 复位陷阱地址输出</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b0</span>;          <span class="comment">// 复位保存PC使能信号</span></span><br><span class="line">            return_addr &lt;= <span class="number">16&#x27;b0</span>;     <span class="comment">// 复位返回地址寄存器</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TRAP指令使能处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (trap_enable) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 阶段1：保存返回地址</span></span><br><span class="line">            <span class="comment">// 将当前PC值（TRAP指令地址+1）保存到返回地址寄存器</span></span><br><span class="line">            return_addr &lt;= current_pc;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 产生保存PC使能信号，通知数据通路将返回地址写入R7寄存器</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 阶段2：查找陷阱服务程序地址</span></span><br><span class="line">            <span class="comment">// 使用8位陷阱向量作为索引，从陷阱向量表中查找对应的服务程序起始地址</span></span><br><span class="line">            <span class="comment">// trap_vector的范围是0-255，正好对应向量表的256个条目</span></span><br><span class="line">            trap_address &lt;= trap_vector_table[trap_vector];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：这里假设陷阱向量表已经正确初始化，包含了有效的服务程序地址</span></span><br><span class="line">            <span class="comment">// 如果访问未初始化的向量表项，将返回0，可能导致处理器执行地址0的指令</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非TRAP状态处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 清除保存PC使能信号，避免在其他指令执行时误保存PC</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：trap_address和return_addr保持它们之前的值</span></span><br><span class="line">            <span class="comment">// 这确保在TRAP处理期间输出稳定性</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 模块功能详细说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TRAP处理模块在LC-3系统中的作用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. TRAP指令执行流程：</span></span><br><span class="line"><span class="comment">   - 当处理器遇到TRAP指令时，控制单元产生trap_enable信号</span></span><br><span class="line"><span class="comment">   - TRAP处理模块接收trap_vector（来自指令低8位）和current_pc</span></span><br><span class="line"><span class="comment">   - 模块执行两个主要操作：</span></span><br><span class="line"><span class="comment">        a. 保存返回地址（current_pc）到return_addr，并产生save_pc信号</span></span><br><span class="line"><span class="comment">        b. 通过向量表查找对应的陷阱服务程序地址到trap_address</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 陷阱向量表机制：</span></span><br><span class="line"><span class="comment">   - 类似于现代操作系统中的中断向量表或系统调用表</span></span><br><span class="line"><span class="comment">   - 将用户可见的8位陷阱号映射到系统内部的服务程序入口地址</span></span><br><span class="line"><span class="comment">   - 提供硬件与操作系统服务之间的标准化接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 标准LC-3陷阱服务：</span></span><br><span class="line"><span class="comment">   - GETC (0x20): 输入单个字符，用于实现getchar()类似功能</span></span><br><span class="line"><span class="comment">   - OUT  (0x21): 输出单个字符，用于实现putchar()类似功能  </span></span><br><span class="line"><span class="comment">   - PUTS (0x22): 输出字符串，用于实现printf()类似功能</span></span><br><span class="line"><span class="comment">   - IN   (0x23): 输入并回显，用于实现交互式输入</span></span><br><span class="line"><span class="comment">   - PUTSP(0x24): 输出打包字符串，优化存储空间</span></span><br><span class="line"><span class="comment">   - HALT (0x25): 停止执行，用于程序正常退出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 关键时序：</span></span><br><span class="line"><span class="comment">   - 所有操作在时钟上升沿同步进行</span></span><br><span class="line"><span class="comment">   - trap_enable有效后，在下一个时钟周期即可获得服务程序地址</span></span><br><span class="line"><span class="comment">   - save_pc信号仅在一个时钟周期内有效，确保返回地址正确保存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 扩展性：</span></span><br><span class="line"><span class="comment">   - 可以通过添加更多向量表条目来支持自定义陷阱服务</span></span><br><span class="line"><span class="comment">   - 支持用户定义的操作系统服务调用</span></span><br><span class="line"><span class="comment">   - 为高级语言运行时库提供底层支持</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 在汇编程序中使用TRAP指令的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ; 输出字符串 &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment">        LEA R0, HELLO_STR  ; 将字符串地址加载到R0</span></span><br><span class="line"><span class="comment">        TRAP x22           ; 调用PUTS陷阱服务（陷阱向量0x22）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ; 停止程序执行</span></span><br><span class="line"><span class="comment">        TRAP x25           ; 调用HALT陷阱服务（陷阱向量0x25）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HELLO_STR .STRINGZ &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 对应的处理器操作：</span></span><br><span class="line"><span class="comment">// 1. 执行TRAP x22指令时，trap_vector = 8&#x27;h22</span></span><br><span class="line"><span class="comment">// 2. TRAP处理模块查找向量表，得到trap_address = 16&#x27;h04A0</span></span><br><span class="line"><span class="comment">// 3. PC跳转到0x04A0执行PUTS服务程序</span></span><br><span class="line"><span class="comment">// 4. 同时将返回地址（TRAP指令地址+1）保存到R7</span></span><br><span class="line"><span class="comment">// 5. 服务程序执行完成后，通过RET（JMP R7）返回主程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 注意事项</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 陷阱向量表必须在系统启动时正确初始化，否则可能导致未定义行为</span></span><br><span class="line"><span class="comment">2. 陷阱服务程序地址应该指向有效的可执行代码区域</span></span><br><span class="line"><span class="comment">3. 在真实的LC-3实现中，陷阱服务程序通常存储在系统ROM中</span></span><br><span class="line"><span class="comment">4. 该模块假设单周期TRAP处理，在实际多周期实现中可能需要更复杂的状态机</span></span><br><span class="line"><span class="comment">5. 复位时确保所有信号处于已知状态，避免系统启动时意外触发陷阱处理</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="内存接口模块">内存接口模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 内存接口模块 (Memory Interface)</span></span><br><span class="line"><span class="comment">// 功能：LC-3处理器的内存子系统，管理64Kx16位的内存空间</span></span><br><span class="line"><span class="comment">// 特性：同步读写操作，支持从文件加载程序，提供内存就绪状态信号</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="keyword">module</span> memory_interface (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 系统控制信号</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，同步所有内存操作</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位内存接口状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 处理器内存访问接口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] address,         <span class="comment">// 16位内存地址总线，可寻址64K字空间 (0x0000-0xFFFF)</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 16位内存写入数据总线，处理器要写入内存的数据</span></span><br><span class="line">    <span class="keyword">input</span> mem_read,               <span class="comment">// 内存读使能信号，高电平有效时执行读操作</span></span><br><span class="line">    <span class="keyword">input</span> mem_write,              <span class="comment">// 内存写使能信号，高电平有效时执行写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存响应信号</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,   <span class="comment">// 16位内存读取数据总线，从内存读取的数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_ready          <span class="comment">// 内存操作完成标志，高电平表示当前操作已完成</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存存储体定义 - 64Kx16位主内存</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 声明65536个16位存储单元，构成64K字的内存空间</span></span><br><span class="line">    <span class="comment">// 地址范围：0x0000 到 0xFFFF</span></span><br><span class="line">    <span class="comment">// 每个地址存储一个16位字，符合LC-3架构的字寻址特性</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] memory [<span class="number">0</span>:<span class="number">65535</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存初始化 - 从文件加载程序和数据</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 使用系统任务$readmemh从十六进制文件加载程序到内存</span></span><br><span class="line">        <span class="comment">// &quot;program.mem&quot;文件应包含LC-3机器码的十六进制表示</span></span><br><span class="line">        <span class="comment">// 文件格式：每行一个16位的十六进制值，从地址0开始顺序存储</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;program.mem&quot;</span>, memory); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：在真实的FPGA实现中，可能需要使用不同的内存初始化方法</span></span><br><span class="line">        <span class="comment">// 例如使用Block RAM的初始化文件或硬编码的初始值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存访问控制逻辑 - 同步时序逻辑</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位处理：清除所有输出信号</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">16&#x27;b0</span>;    <span class="comment">// 复位数据输出总线</span></span><br><span class="line">            mem_ready &lt;= <span class="number">1&#x27;b0</span>;    <span class="comment">// 复位内存就绪标志</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常操作处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 内存读操作处理</span></span><br><span class="line">            <span class="keyword">if</span> (mem_read) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 从指定地址读取数据并输出到data_out总线</span></span><br><span class="line">                <span class="comment">// 注意：这里假设内存读取在一个时钟周期内完成</span></span><br><span class="line">                <span class="comment">// 在实际系统中，可能需要考虑内存访问延迟</span></span><br><span class="line">                data_out &lt;= memory[address];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置内存就绪标志，表示读操作已完成</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 内存写操作处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mem_write) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 将数据写入指定内存地址</span></span><br><span class="line">                <span class="comment">// 注意：写操作在时钟上升沿生效</span></span><br><span class="line">                memory[address] &lt;= data_in;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置内存就绪标志，表示写操作已完成</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 无内存操作状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 清除内存就绪标志，表示当前没有进行中的内存操作</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 注意：data_out保持之前的值，直到下一次读操作</span></span><br><span class="line">                <span class="comment">// 这确保数据总线在非读操作期间保持稳定</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 模块功能详细说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存接口模块在LC-3系统中的作用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 内存组织特性：</span></span><br><span class="line"><span class="comment">   - 64K字（128K字节）地址空间，符合LC-3架构规范</span></span><br><span class="line"><span class="comment">   - 字寻址（16位为单位），而非字节寻址</span></span><br><span class="line"><span class="comment">   - 大端序或小端序取决于具体实现（LC-3通常为大端序）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 访问时序：</span></span><br><span class="line"><span class="comment">   - 同步设计：所有操作在时钟上升沿同步进行</span></span><br><span class="line"><span class="comment">   - 单周期访问：假设内存可以在一个时钟周期内完成读写</span></span><br><span class="line"><span class="comment">   - 就绪信号：mem_ready指示操作完成，便于处理器流水线控制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 内存映射区域：</span></span><br><span class="line"><span class="comment">   在标准LC-3中，特定地址区域有特殊功能：</span></span><br><span class="line"><span class="comment">   - 0x0000-0x2FFF: 用户程序区域</span></span><br><span class="line"><span class="comment">   - 0x3000-0xFDFF: 用户数据区域  </span></span><br><span class="line"><span class="comment">   - 0xFE00-0xFFFF: 设备寄存器区域（内存映射IO）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 文件加载机制：</span></span><br><span class="line"><span class="comment">   - 支持从program.mem文件加载初始程序</span></span><br><span class="line"><span class="comment">   - 文件格式：每行一个16位十六进制值</span></span><br><span class="line"><span class="comment">   - 典型用途：加载操作系统、用户程序或测试向量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 错误处理考虑：</span></span><br><span class="line"><span class="comment">   - 当前实现未包含地址越界检查</span></span><br><span class="line"><span class="comment">   - 在实际系统中可能需要添加访问权限检查</span></span><br><span class="line"><span class="comment">   - 对于不存在的内存区域应返回错误或默认值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 内存映射IO扩展示例</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 如果需要支持内存映射IO，可以扩展模块如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module memory_interface_with_io (</span></span><br><span class="line"><span class="comment">    input clk, reset,</span></span><br><span class="line"><span class="comment">    input [15:0] address, data_in,</span></span><br><span class="line"><span class="comment">    input mem_read, mem_write,</span></span><br><span class="line"><span class="comment">    output reg [15:0] data_out,</span></span><br><span class="line"><span class="comment">    output reg mem_ready,</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 设备接口</span></span><br><span class="line"><span class="comment">    input [15:0] kbsr_data,       // 键盘状态寄存器</span></span><br><span class="line"><span class="comment">    input [15:0] kbdr_data,       // 键盘数据寄存器  </span></span><br><span class="line"><span class="comment">    output reg [15:0] ddr_data,   // 显示数据寄存器</span></span><br><span class="line"><span class="comment">    output reg [15:0] dsr_data    // 显示状态寄存器</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    reg [15:0] memory [0:65535];</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    initial begin</span></span><br><span class="line"><span class="comment">        $readmemh(&quot;program.mem&quot;, memory);</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    always @(posedge clk or posedge reset) begin</span></span><br><span class="line"><span class="comment">        if (reset) begin</span></span><br><span class="line"><span class="comment">            data_out &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">            mem_ready &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">            ddr_data &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">            dsr_data &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">        end else begin</span></span><br><span class="line"><span class="comment">            if (mem_read) begin</span></span><br><span class="line"><span class="comment">                // 内存映射IO处理</span></span><br><span class="line"><span class="comment">                case (address)</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE00: data_out &lt;= kbsr_data;  // 键盘状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE02: data_out &lt;= kbdr_data;  // 键盘数据</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE04: data_out &lt;= dsr_data;   // 显示状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE06: data_out &lt;= ddr_data;   // 显示数据</span></span><br><span class="line"><span class="comment">                    default: data_out &lt;= memory[address];</span></span><br><span class="line"><span class="comment">                endcase</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b1;</span></span><br><span class="line"><span class="comment">            end else if (mem_write) begin</span></span><br><span class="line"><span class="comment">                // 内存映射IO处理</span></span><br><span class="line"><span class="comment">                case (address)</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE00: ; // KBSR只读</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE02: ; // KBDR只读</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE04: dsr_data &lt;= data_in;   // 写显示状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE06: ddr_data &lt;= data_in;   // 写显示数据</span></span><br><span class="line"><span class="comment">                    default: memory[address] &lt;= data_in;</span></span><br><span class="line"><span class="comment">                endcase</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b1;</span></span><br><span class="line"><span class="comment">            end else begin</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">            end</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">endmodule</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 使用示例和测试模式</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 测试内存接口的简单测试平台：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module test_memory_interface;</span></span><br><span class="line"><span class="comment">    reg clk, reset, mem_read, mem_write;</span></span><br><span class="line"><span class="comment">    reg [15:0] address, data_in;</span></span><br><span class="line"><span class="comment">    wire [15:0] data_out;</span></span><br><span class="line"><span class="comment">    wire mem_ready;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    memory_interface uut (</span></span><br><span class="line"><span class="comment">        .clk(clk), .reset(reset),</span></span><br><span class="line"><span class="comment">        .address(address), .data_in(data_in),</span></span><br><span class="line"><span class="comment">        .mem_read(mem_read), .mem_write(mem_write),</span></span><br><span class="line"><span class="comment">        .data_out(data_out), .mem_ready(mem_ready)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 时钟生成</span></span><br><span class="line"><span class="comment">    always #5 clk = ~clk;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    initial begin</span></span><br><span class="line"><span class="comment">        // 初始化</span></span><br><span class="line"><span class="comment">        clk = 0; reset = 1; </span></span><br><span class="line"><span class="comment">        mem_read = 0; mem_write = 0;</span></span><br><span class="line"><span class="comment">        address = 0; data_in = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 复位释放</span></span><br><span class="line"><span class="comment">        #10 reset = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 测试写操作</span></span><br><span class="line"><span class="comment">        #10 mem_write = 1; address = 16&#x27;h3000; data_in = 16&#x27;h1234;</span></span><br><span class="line"><span class="comment">        #10 mem_write = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 测试读操作  </span></span><br><span class="line"><span class="comment">        #10 mem_read = 1; address = 16&#x27;h3000;</span></span><br><span class="line"><span class="comment">        #10 mem_read = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 验证读取的数据应为0x1234</span></span><br><span class="line"><span class="comment">        if (data_out === 16&#x27;h1234)</span></span><br><span class="line"><span class="comment">            $display(&quot;Test PASSED: Write and read successful&quot;);</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            $display(&quot;Test FAILED: Expected 0x1234, got 0x%h&quot;, data_out);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        #10 $finish;</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">endmodule</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 性能优化考虑</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 访问延迟优化：</span></span><br><span class="line"><span class="comment">   - 当前设计假设单周期内存访问</span></span><br><span class="line"><span class="comment">   - 对于高速系统，可以考虑流水线内存访问</span></span><br><span class="line"><span class="comment">   - 对于大容量内存，可能需要多周期访问</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 资源优化：</span></span><br><span class="line"><span class="comment">   - 在FPGA中，可以使用Block RAM替代分布式RAM</span></span><br><span class="line"><span class="comment">   - 对于大内存，可以分块实现并按需激活</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 功耗优化：</span></span><br><span class="line"><span class="comment">   - 添加时钟门控，在不访问内存时关闭时钟</span></span><br><span class="line"><span class="comment">   - 实现内存分块，只激活被访问的内存区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 错误检测：</span></span><br><span class="line"><span class="comment">   - 添加奇偶校验或ECC错误检测校正</span></span><br><span class="line"><span class="comment">   - 实现地址范围检查，防止越界访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 文件格式说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">program.mem 文件格式示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// LC-3机器码的十六进制表示</span></span><br><span class="line"><span class="comment">// 地址 0x0000: 程序起始</span></span><br><span class="line"><span class="comment">3000    // 0x3000: 程序起始地址（通常）</span></span><br><span class="line"><span class="comment">1261    // ADD R1, R1, #1</span></span><br><span class="line"><span class="comment">14A1    // ADD R2, R1, R1</span></span><br><span class="line"><span class="comment">F025    // TRAP HALT (系统调用停止)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 注释以//开始，空行被忽略</span></span><br><span class="line"><span class="comment">// 每行一个16位十六进制值，从地址0开始顺序存储</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Matlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Matlab/" class="post-title-link" itemprop="url">MATLAB基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-21 17:07:44" itemprop="dateModified" datetime="2025-05-21T17:07:44+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/MATLAB/" itemprop="url" rel="index"><span itemprop="name">MATLAB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本指令">基本指令</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;b=<span class="number">2</span>;c=<span class="number">3</span>;                  <span class="comment">%%命令行</span></span><br><span class="line">sum=<span class="number">1</span>+<span class="number">1</span>/<span class="number">2</span>+<span class="number">1</span>/<span class="number">3</span>+<span class="number">1</span>/<span class="number">4</span>+<span class="number">1</span>/<span class="number">5</span>+<span class="number">1</span>/<span class="number">6</span>+...</span><br><span class="line">    <span class="number">1</span>/<span class="number">7</span>+<span class="number">1</span>/<span class="number">8</span>+<span class="number">1</span>/<span class="number">9</span>;              <span class="comment">%%...是续行符，可以写多行命令</span></span><br><span class="line">clc                           <span class="comment">%%清除命令</span></span><br><span class="line">clear                         <span class="comment">%%清除变量</span></span><br><span class="line">clear 变量名                  <span class="comment">%%清除某个变量</span></span><br><span class="line">format short\long\bank（保留小数点后两位）\shortE\longE\hex(<span class="number">16</span>进制)\<span class="built_in">rat</span>（分数）</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="字符和数字">字符和数字</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">abs</span>(s);                       <span class="comment">%%输出s对应字符的ASCII码</span></span><br><span class="line">char(<span class="number">65</span>);                     <span class="comment">%%输出ASCII码为65对应的字符</span></span><br><span class="line">num2str(<span class="number">65</span>);                  <span class="comment">%%输出字符‘65’</span></span><br><span class="line">str=<span class="string">&#x27;I love U&#x27;</span>;</span><br><span class="line"><span class="built_in">length</span>(str);                  <span class="comment">%%输出str的长度</span></span><br><span class="line">a=<span class="number">6</span>+<span class="number">5</span><span class="built_in">i</span>;b=<span class="number">6</span>+<span class="number">6</span><span class="built_in">j</span>                 <span class="comment">%%a，b都是复数</span></span><br><span class="line">x=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">complex</span>(<span class="number">2</span>,x)                  <span class="comment">%%生成实部为2，虚部为x的复数</span></span><br><span class="line"><span class="built_in">real</span>(a);                      <span class="comment">%%求复数的实部</span></span><br><span class="line"><span class="built_in">imag</span>(a);                      <span class="comment">%%求复数的虚部</span></span><br><span class="line"><span class="built_in">abs</span>(a);                       <span class="comment">%%求复数的模</span></span><br><span class="line"><span class="built_in">angle</span>(a);                     <span class="comment">%%求复数的辐角</span></span><br><span class="line"><span class="built_in">conj</span>(a);                      <span class="comment">%%求共轭复数</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<h4 id="矩阵基本运算">矩阵基本运算</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">B=A.&#x27;;                        <span class="comment">%%A的转置</span></span><br><span class="line">B=A&#x27;;                         <span class="comment">%%A的共轭转置</span></span><br><span class="line">C=A(:);                       <span class="comment">%%把A中的所有元素排成一列</span></span><br><span class="line">D=inv(A);                     <span class="comment">%%A的逆矩阵</span></span><br><span class="line">E=[A,A;A,A];                  <span class="comment">%%把矩阵A拼接</span></span><br><span class="line">F=<span class="built_in">rot90</span>(A,k);                 <span class="comment">%%将A矩阵逆时针旋转90°的k倍</span></span><br><span class="line">G=<span class="built_in">fliplr</span>(A);                  <span class="comment">%%左右翻转</span></span><br><span class="line">H=<span class="built_in">flipud</span>(A);                  <span class="comment">%%上下翻转</span></span><br><span class="line">A*D;                          <span class="comment">%%矩阵乘法</span></span><br><span class="line">A.*D;                         <span class="comment">%%矩阵对应元素相乘</span></span><br><span class="line">A/D;                          <span class="comment">%%相当于A*inv（D）</span></span><br><span class="line">A./D;                         <span class="comment">%%矩阵对应元素相除</span></span><br><span class="line">A+D;                          <span class="comment">%%矩阵对应元素相加</span></span><br><span class="line">A-D;                          <span class="comment">%%矩阵对应元素相减</span></span><br><span class="line">det(A);                       <span class="comment">%%计算A的行列式</span></span><br><span class="line">adj(A);                       <span class="comment">%%计算A的伴随矩阵</span></span><br><span class="line">cond(A);                      <span class="comment">%%计算A的条件数condition，数值越小越正常</span></span><br><span class="line">rank(A);                      <span class="comment">%%计算A的秩</span></span><br><span class="line">trace(A);                     <span class="comment">%%计算A的迹</span></span><br><span class="line">eig(A);                       <span class="comment">%%计算A的特征值</span></span><br><span class="line">A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br><span class="line">B=<span class="built_in">reshape</span>(A,<span class="number">3</span>,<span class="number">2</span>);             <span class="comment">%%把A按顺序变成三行两列的矩阵</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵生成">矩阵生成</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>);               <span class="comment">%%生成10行5列3层矩阵</span></span><br><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>);                 <span class="comment">%%生成10行5列矩阵</span></span><br><span class="line">E=<span class="built_in">rand</span>(<span class="number">2</span>,<span class="number">3</span>);                  <span class="comment">%%生成0~1之间的随机数</span></span><br><span class="line">E=<span class="built_in">randn</span>(<span class="number">3</span>,<span class="number">2</span>);                 <span class="comment">%%生成均值为0，方差为1的随机数</span></span><br><span class="line">E=randi([<span class="built_in">min</span>,<span class="built_in">max</span>],m,n);       <span class="comment">%%生成在开区间[min，max]之间随机整数的m行n列矩阵</span></span><br><span class="line">A=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>;                      <span class="comment">%%A=[1,3,5,7,9]</span></span><br><span class="line">str=<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>:<span class="string">&#x27;z&#x27;</span>;                <span class="comment">%%str=[a,b,...,z]</span></span><br><span class="line">B=<span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>);              <span class="comment">%%把A先竖着重复3次，再横着重复2次</span></span><br><span class="line">C=<span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">4</span>);                  <span class="comment">%%生成2行4列的元素全部为1的矩阵</span></span><br><span class="line">D=<span class="built_in">eye</span>(<span class="number">5</span>);                     <span class="comment">%%生成5阶单位阵</span></span><br><span class="line">E=<span class="built_in">magic</span>(<span class="number">3</span>);                   <span class="comment">%%生成3阶幻方（就是每行，每列，对角线元素之和相等的方阵）</span></span><br><span class="line">F=<span class="built_in">vander</span>([<span class="number">1</span>;<span class="number">3</span>;<span class="number">5</span>;<span class="number">8</span>]);          <span class="comment">%%生成范德蒙德矩阵，其中a1=1,a2=3,a3=5,a4=8</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵分析">矩阵分析</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">5</span>);</span><br><span class="line">B=A(<span class="number">2</span>,<span class="number">3</span>);                     <span class="comment">%%取A的第2行第3列的元素</span></span><br><span class="line">C=A(<span class="number">8</span>);                       <span class="comment">%%取A的第8个元素</span></span><br><span class="line">D=A([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);                 <span class="comment">%%取A的第1,3,5个元素作为一个行向量</span></span><br><span class="line">E=A([<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]);             <span class="comment">%%取A的第1,3行与第2,3列相交处的元素,相当于取子式！！！</span></span><br><span class="line">F=A([<span class="number">1</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>]);               <span class="comment">%%取A的第1,3个元素作为第一行，第2,3个元素作为第二行（与D类似）</span></span><br><span class="line">G=A(<span class="number">3</span>,:);G=A(:;<span class="number">2</span>:<span class="number">4</span>);G=A(<span class="number">2</span>:<span class="number">3</span>;<span class="number">1</span>:<span class="number">2</span>:<span class="number">5</span>)            <span class="comment">%%取A的第三行;取A的2,3,4列;取A的第2,3行和第1,2,5,列交叉处的元素</span></span><br><span class="line">A(<span class="number">3</span>,:)=[];A(:,[<span class="number">2</span>,<span class="number">4</span>])=[];      <span class="comment">%%删去A的第三行;删去A的第2,4列元素</span></span><br><span class="line">H=A(:,<span class="number">4</span>);                     <span class="comment">%%取A的第四列</span></span><br><span class="line">I=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>]);       <span class="comment">%%将A中的A(1,1),A(2,1);A(2,3),A(2,2)的序号组成一个2×2的矩阵</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">ind2sub</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);               <span class="comment">%%将矩阵A的第1,3,5个元素的下标输出</span></span><br><span class="line">J=A(<span class="keyword">end</span>,:)/J=A([<span class="number">1</span>,<span class="number">4</span>],<span class="number">3</span>:<span class="keyword">end</span>);                  <span class="comment">%%取A的最后一行的元素、取A的第1,4行与从第3~最后一列交叉处的元素</span></span><br><span class="line">K=<span class="built_in">diag</span>(A);                    <span class="comment">%%取A的主对角线上的元素</span></span><br><span class="line">L=<span class="built_in">diag</span>([<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">5</span>]);           <span class="comment">%%将1，-2,4,5排成对角阵</span></span><br><span class="line">[m,n]=<span class="built_in">find</span>(A&gt;<span class="number">20</span>);             <span class="comment">%%找出A中大于20的元素的行标（即m）和列标（即对应于m的n）</span></span><br><span class="line">I=<span class="built_in">find</span>(A==<span class="number">5</span>);                 <span class="comment">%%找出A中等于5的元素的序号</span></span><br><span class="line"><span class="built_in">max</span>(A);                       <span class="comment">%%找出A中每列的最大的元素</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">max</span>(A));                  <span class="comment">%%找出A中最大的元素，min同理</span></span><br><span class="line">sum(A);                       <span class="comment">%%求A每列元素之和</span></span><br><span class="line">sum(sum(A));                  <span class="comment">%%求A所有元素之和</span></span><br><span class="line"><span class="built_in">mean</span>(A);                      <span class="comment">%%求A每列元素的平均数</span></span><br><span class="line"><span class="built_in">mean</span>(<span class="built_in">mean</span>(A));                <span class="comment">%%求A所有元素的平均数</span></span><br><span class="line"><span class="built_in">sort</span>(A);                      <span class="comment">%%每列元素按照从小到大顺序排列</span></span><br><span class="line">sortrow(A);                   <span class="comment">%%按第一列元素从小到大排列</span></span><br><span class="line"><span class="built_in">size</span>(A);                      <span class="comment">%%输出A的行数和列数</span></span><br><span class="line"><span class="built_in">length</span>(A);                    <span class="comment">%%输出A的最长维的维数</span></span><br><span class="line"><span class="built_in">numel</span>(A);                     <span class="comment">%%输出A的元素的个数</span></span><br></pre></td></tr></table></figure>
<h2 id="数学运算">数学运算</h2>
<h3 id="一般函数">一般函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>/<span class="built_in">cos</span>/<span class="built_in">tan</span>/<span class="built_in">asin</span>/<span class="built_in">acos</span>/<span class="built_in">atan</span>/<span class="built_in">sinh</span>/<span class="built_in">cosh</span>/<span class="built_in">tanh</span>;    <span class="comment">%%三角函数</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">9</span>);                       <span class="comment">%%9的平方根</span></span><br><span class="line"><span class="built_in">log</span>()/<span class="built_in">log10</span>()/<span class="built_in">log2</span>;            <span class="comment">%%自然对数、常用对数、以2为底的对数函数</span></span><br><span class="line"><span class="built_in">exp</span>();                         <span class="comment">%%不解释</span></span><br><span class="line"><span class="built_in">pow2</span>;                          <span class="comment">%%2的幂,相当于平方</span></span><br><span class="line"><span class="built_in">abs</span>();                         <span class="comment">%%绝对值</span></span><br><span class="line"><span class="built_in">rem</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求模</span></span><br><span class="line"><span class="built_in">gcd</span>(<span class="number">150</span>,<span class="number">95</span>);                   <span class="comment">%%最大公约数</span></span><br><span class="line"><span class="built_in">lcm</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%最小公倍数</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);                  <span class="comment">%%5的阶乘</span></span><br><span class="line"><span class="built_in">isprime</span>(<span class="number">6</span>);                    <span class="comment">%%判断6是不是素数，如果是输出1，否则输出0</span></span><br><span class="line"><span class="built_in">primes</span>(<span class="number">9</span>);                     <span class="comment">%%生成1~9内所有的素数</span></span><br><span class="line"><span class="built_in">perms</span>(A);                      <span class="comment">%%生成A的所有的排列，A为行向量</span></span><br><span class="line">randperm(<span class="number">10</span>);                  <span class="comment">%%生成1~10的随机排列</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵函数">矩阵函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrtm(A);                     <span class="comment">%%对矩阵中所有元素开方</span></span><br><span class="line">logm(A);                      <span class="comment">%%对矩阵中所有元素取自然对数</span></span><br><span class="line">expm(A);                      <span class="comment">%%对矩阵中所有元素取指数</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算">逻辑运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;/&lt;=;                         <span class="comment">%%小于、小于等于</span></span><br><span class="line">&gt;/&gt;=;                         <span class="comment">%%大于、大于等于</span></span><br><span class="line">==/~=;                        <span class="comment">%%等于、不等于</span></span><br><span class="line">eq(a,b);                      <span class="comment">%%判断a、b是否相等，相等输出1，不相等输出0</span></span><br><span class="line">a&amp;b/and(a,b);                 <span class="comment">%%“与”，a、b全部非0时，输出1；a、b只要有一个为0，输出0</span></span><br><span class="line">a|b;or(a,b);                  <span class="comment">%%a、b只要有一个不为0，输出1；a、b全为0时，输出0</span></span><br><span class="line">~a/not(a);                    <span class="comment">%%a是0时，输出1；a不为0时，输出0</span></span><br><span class="line">xor(a,b);                     <span class="comment">%%a、b值不同时，输出1；a、b值相同时，输出0</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串运算">字符串运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;Xidian University&#x27;</span>;</span><br><span class="line">str=<span class="string">&#x27;I&#x27;&#x27;m a student&#x27;</span>;             <span class="comment">%%当字符串中含有&#x27;时，打两个&#x27;&#x27;</span></span><br><span class="line">ch=[<span class="string">&#x27;abcdef&#x27;</span>;<span class="string">&#x27;123456&#x27;</span>];           <span class="comment">%%字符串矩阵</span></span><br><span class="line">ch=<span class="string">&#x27;ABc123d4e56Fg9&#x27;</span>;</span><br><span class="line">str=ch(<span class="number">1</span>:<span class="number">5</span>);                      <span class="comment">%%取ch的前5个元素</span></span><br><span class="line">str=ch(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);                 <span class="comment">%%将ch倒着排列</span></span><br><span class="line">place=<span class="built_in">find</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>);      <span class="comment">%%找到小写字母的位置</span></span><br><span class="line">ch(place)=ch(place)-<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;A&#x27;</span>;      <span class="comment">%%将小写字母换成大写字母</span></span><br><span class="line"><span class="built_in">length</span>(place);                    <span class="comment">%%计算小写字母的数量</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&#x27;MATLAB&#x27;</span>;</span><br><span class="line">a=<span class="built_in">abs</span>(str);                       <span class="comment">%%将str里面的字符转化成ASCII码</span></span><br><span class="line">b=char(a+<span class="number">32</span>);                     <span class="comment">%%将ASCII码加32后再转化成对应的字符</span></span><br><span class="line"></span><br><span class="line">ch=[str1,str2,str3];</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;www0&#x27;</span>&gt;=<span class="string">&#x27;w123&#x27;</span>;                   <span class="comment">%%比较这两个字符串中各个元素的大小，输出1110</span></span><br><span class="line">strcmp(str1,str2);                <span class="comment">%%比较两个字符串是否相等，相等输出1，否则输出0</span></span><br><span class="line">strncmp(str1,str2,n);             <span class="comment">%%比较两个字符串的前n个元素是否相等</span></span><br><span class="line">strcmpi(str1,str2);               <span class="comment">%%忽略大小写，比较两个字符串是否相等</span></span><br><span class="line">strncmpi(str1,str2,n);            <span class="comment">%%忽略大小写,比较两个字符串的前n个元素是否相等</span></span><br><span class="line"></span><br><span class="line">findstr(str1,str2);               <span class="comment">%%输出str2在str1中开始的位置</span></span><br><span class="line">strrep(str1,str2,str3);           <span class="comment">%%将str1中的str2替换为str3</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">A=cell(<span class="number">1</span>,<span class="number">6</span>);                      <span class="comment">%%生成A=[][][][][][]</span></span><br><span class="line">A&#123;<span class="number">2</span>&#125;=<span class="built_in">eye</span>(<span class="number">3</span>);                      <span class="comment">%%A=[][eye(3)][][][][]</span></span><br><span class="line">A&#123;<span class="number">6</span>&#125;=<span class="built_in">magic</span>(<span class="number">5</span>);                    <span class="comment">%%A=[][eye(3)][][][][magic(5)]</span></span><br><span class="line">B=A&#123;<span class="number">6</span>&#125;;                           <span class="comment">%%取出A中第六个元素，即magic（5）</span></span><br><span class="line">   </span><br><span class="line">A=cell(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=&#123;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>;<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>;<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=&#123;<span class="string">&#x27;Fourier&#x27;</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=&#123;<span class="number">3</span>+<span class="number">7</span><span class="built_in">i</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=&#123;<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>&#125;;</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;                           <span class="comment">%%输出[1,4,3;0,5,8;7,2,9]</span></span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;(<span class="number">2</span>,<span class="number">3</span>);                      <span class="comment">%%取出A&#123;1,1&#125;矩阵中的第二行第三列的元素</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>);                           <span class="comment">%%输出[3x3double]</span></span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;                           <span class="comment">%%输出[1,3,5,7,9]</span></span><br><span class="line"></span><br><span class="line">books=struct(<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;fourier&#x27;</span>,<span class="string">&#x27;laplace&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span>,<span class="number">40</span>]);</span><br><span class="line">books.name(<span class="number">1</span>);                    <span class="comment">%%输出‘fourier’</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;;                    <span class="comment">%%输出fourier</span></span><br><span class="line"></span><br><span class="line">A=struct(<span class="string">&#x27;data&#x27;</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>;<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="string">&#x27;nest&#x27;</span>,struct(<span class="string">&#x27;testnum&#x27;</span>,<span class="string">&#x27;test1&#x27;</span>,<span class="string">&#x27;xdata&#x27;</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>],<span class="string">&#x27;ydata&#x27;</span>,[<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>]));</span><br><span class="line">A(<span class="number">2</span>).data=[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.testnum=<span class="string">&#x27;test2&#x27;</span>;</span><br><span class="line">A(<span class="number">2</span>).nest.xdata=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.ydata=[<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>];</span><br><span class="line">A.nest;</span><br><span class="line">A(<span class="number">1</span>).nest.testnum;</span><br><span class="line">A(<span class="number">1</span>).nest.xdata;</span><br><span class="line">A(<span class="number">2</span>).nest.ydata;</span><br></pre></td></tr></table></figure>
<h2 id="程序设计">程序设计</h2>
<h3 id="顺序结构">顺序结构</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A=input(<span class="string">&#x27;请输入A矩阵：&#x27;</span>);</span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>);            <span class="comment">%%输入字符的时候要加上&#x27;&#x27;</span></span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);        <span class="comment">%%输入字符的时候不用加&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A=<span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="built_in">disp</span>(A);                                  <span class="comment">%%输出项只能是字符串或者是矩阵，如果要输出数字的话要用num2str()将数字转化成数字字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%例题：解方程a*x^2+b*x+c=0</span></span><br><span class="line">a=input(<span class="string">&#x27;请输入a的值&#x27;</span>);</span><br><span class="line">b=input(<span class="string">&#x27;请输入b的值&#x27;</span>);</span><br><span class="line">c=input(<span class="string">&#x27;请输入c的值&#x27;</span>);</span><br><span class="line">delta=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x=[(-b+<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;x1=&#x27;</span>,num2str(x(<span class="number">1</span>)),<span class="string">&#x27;，x2=&#x27;</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure>
<h3 id="选择结构">选择结构</h3>
<h4 id="if语句">if语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x=input(<span class="string">&#x27;请输入x的值&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">10</span></span><br><span class="line">    y=<span class="built_in">cos</span>(x+<span class="number">1</span>)+<span class="built_in">sqrt</span>(x*x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y=x*<span class="built_in">sqrt</span>(x+<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=input(<span class="string">&#x27;请输入一个字符&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(lower(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(upper(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(str2num(c)^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="switch语句">switch语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">price=input(<span class="string">&#x27;请输入商品价格&#x27;</span>);</span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">fix</span>(price/<span class="number">100</span>)             <span class="comment">%%fix函数是将数字向0的方向取整</span></span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">          rate=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">          rate=<span class="number">3</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">5</span>:<span class="number">9</span>)            <span class="comment">%%num2cell函数是将数值矩阵转化成单元矩阵&#123;5,6,7,8,9&#125;</span></span><br><span class="line">          rate=<span class="number">5</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">10</span>:<span class="number">24</span>)</span><br><span class="line">          rate=<span class="number">8</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">24</span>:<span class="number">49</span>)</span><br><span class="line">          rate=<span class="number">10</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">otherwise</span></span><br><span class="line">          rate=<span class="number">14</span>/<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  price=price*(<span class="number">1</span>-rate)</span><br></pre></td></tr></table></figure>
<h3 id="循环结构">循环结构</h3>
<h4 id="for语句">for语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flower=[];                      <span class="comment">%%判断水仙花数，这是开一个空矩阵</span></span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">100</span>:<span class="number">999</span>;</span><br><span class="line">        m1=<span class="built_in">fix</span>(m/<span class="number">100</span>);          <span class="comment">%%取百位</span></span><br><span class="line">        m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);   <span class="comment">%%取十位</span></span><br><span class="line">        m3=<span class="built_in">rem</span>(m,<span class="number">10</span>);           <span class="comment">%%取个位</span></span><br><span class="line">        <span class="keyword">if</span> m==m1^<span class="number">3</span>+m2^<span class="number">3</span>+m3^<span class="number">3</span></span><br><span class="line">            flower=[flower,m];  <span class="comment">%%这个语句的意思是将m添加到flower中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(flower)</span><br><span class="line">  </span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="number">1</span>/(<span class="built_in">i</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="while语句">while语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span></span><br><span class="line">    sum=sum+x;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> n&gt;<span class="number">0</span></span><br><span class="line">    sum</span><br><span class="line">    <span class="built_in">mean</span>=sum/n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="break和continue语句">break和continue语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n=<span class="number">100</span>:<span class="number">200</span><span class="comment">%%求100~200之间第一个能被21整除的数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rem</span>(n,<span class="number">21</span>)~=<span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="循环的嵌套">循环的嵌套</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=初值:步长:终值</span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> 表达式(数值或字符串)</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">1</span></span><br><span class="line">        语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">2</span></span><br><span class="line">        语句<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串n</span><br><span class="line">        语句n</span><br><span class="line">    <span class="keyword">otherwise</span>(可省略)</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=input(<span class="string">&#x27;请输入n的值&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="built_in">factor</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;1到&#x27;</span>,num2str(n),<span class="string">&#x27;的阶乘的和为&#x27;</span>,num2str(sum)]);</span><br></pre></td></tr></table></figure>
<h2 id="绘图">绘图</h2>
<h3 id="二维图像">二维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);<span class="comment">%%2是标量，exp和sin是矩阵，所以2和exp是数量乘法，exp和sin是点乘</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=-<span class="built_in">pi</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="built_in">pi</span>;</span><br><span class="line">x=t.*<span class="built_in">cos</span>(<span class="number">3</span>*t);</span><br><span class="line">y=t.*<span class="built_in">sin</span>(t).*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%参数方程</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);<span class="comment">%%生成0~2*pi，元素个数为100的行向量</span></span><br><span class="line">y=[<span class="built_in">sin</span>(x);<span class="built_in">cos</span>(x)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t]&#x27;;</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t];</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%这是个什么玩意儿？？？</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">sin</span>(x),x,<span class="number">2</span>*<span class="built_in">sin</span>(x),x,<span class="number">3</span>*<span class="built_in">sin</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y1=<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">y3=<span class="number">3</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">x=[x;x;x]&#x27;;<span class="comment">%%注意变成行向量</span></span><br><span class="line">y=[y1;y2;y3]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y,x,<span class="built_in">cos</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">200</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1=<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line">y2=<span class="built_in">sin</span>(x);</span><br><span class="line">plotyy(x,y1,x,y2);<span class="comment">%%双纵坐标，左边是y1，右边是y2</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>);<span class="comment">%%产生自变量向量x</span></span><br><span class="line">y=[];<span class="comment">%%y的初始值为空</span></span><br><span class="line"><span class="keyword">for</span> x0=x<span class="comment">%%将函数值追加到y中</span></span><br><span class="line">    <span class="keyword">if</span> x0&gt;=<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">6</span>&amp;&amp;x0&lt;<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">5</span>-x0/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">4</span>&amp;&amp;x0&lt;<span class="number">6</span></span><br><span class="line">        y=[y,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">0</span>&amp;&amp;x0&lt;<span class="number">4</span></span><br><span class="line">        y=[y,<span class="built_in">sqrt</span>(x0)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2.5</span>]);<span class="comment">%%设置坐标轴，x坐标轴是[0，10]，y坐标轴是[0,2.5]</span></span><br><span class="line">title(<span class="string">&#x27;分段函数曲线&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Variable X&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Variable Y&#x27;</span>);</span><br><span class="line">text(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;y=x^&#123;1/2&#125;&#x27;</span>);<span class="comment">%%在指定位置处添加图形说明</span></span><br><span class="line">text(<span class="number">4.5</span>,<span class="number">1.9</span>,<span class="string">&#x27;y=2&#x27;</span>);</span><br><span class="line">text(<span class="number">7.3</span>,<span class="number">1.5</span>,<span class="string">&#x27;y=5-x/2&#x27;</span>);</span><br><span class="line">text(<span class="number">8.5</span>,<span class="number">0.9</span>,<span class="string">&#x27;y=1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">60</span>);</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">z=<span class="built_in">cos</span>(x);</span><br><span class="line">t=<span class="built_in">tan</span>(x);</span><br><span class="line">ct=<span class="built_in">cot</span>(x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">%%将当前图形窗口分割成2×2，并选中1号区</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;sinx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,z);</span><br><span class="line">title(<span class="string">&#x27;cosx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,t);</span><br><span class="line">title(<span class="string">&#x27;tanx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,ct);</span><br><span class="line">title(<span class="string">&#x27;cotx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="number">10</span>*x.*x;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y);title(<span class="string">&#x27;直角坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">semilogx(x,y);title(<span class="string">&#x27;x半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">semilogy(x,y);title(<span class="string">&#x27;y半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">loglog(x,y);title(<span class="string">&#x27;全对数坐标曲线&#x27;</span>);grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span>;<span class="comment">%%建立一个幕布，可以不写</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);<span class="comment">%%右端对齐</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on<span class="comment">%%图形保持</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">cos</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">sin</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;b:&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-2</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1=<span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,H1,H2]=plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">1</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;slow decay&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">2</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;fast decay&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(\musec)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;multiple decay rates&#x27;</span>);</span><br><span class="line">set(H1,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">set(H2,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;k:&#x27;</span>,x,y2,<span class="string">&#x27;b--&#x27;</span>);<span class="comment">%%控制图像的颜色和线形</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.5</span>:<span class="number">4</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);h=<span class="built_in">cos</span>(x);w=<span class="number">1.</span>/(<span class="number">1</span>+<span class="built_in">exp</span>(-x));</span><br><span class="line">g=(<span class="number">1.</span>/<span class="number">2</span>*(<span class="number">2</span>*<span class="built_in">pi</span>)^<span class="number">0.5</span>).*<span class="built_in">exp</span>((<span class="number">-1.</span>*(x<span class="number">-2</span>*<span class="built_in">pi</span>).^<span class="number">2</span>)./<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;bd-&#x27;</span>,x,h,<span class="string">&#x27;gp:&#x27;</span>,x,w,<span class="string">&#x27;rp-&#x27;</span>,x,g,<span class="string">&#x27;c^-&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin(x)&#x27;</span>,<span class="string">&#x27;cos(x)&#x27;</span>,<span class="string">&#x27;sigmoid&#x27;</span>,<span class="string">&#x27;gauss function&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">20</span>*<span class="built_in">pi</span>;</span><br><span class="line">r1=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*t)+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;</span><br><span class="line">r2=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t-<span class="built_in">pi</span>/<span class="number">2</span>))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*(t-<span class="built_in">pi</span>/<span class="number">2</span>))+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;<span class="comment">%%旋转90°</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">polar(t,r1);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">polar(t,r2);</span><br></pre></td></tr></table></figure>
<h3 id="三维图像">三维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="number">8</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">y=<span class="number">4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line">z=<span class="number">-4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;line in 3D space&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;origin&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>);ylabel(<span class="string">&#x27;Y&#x27;</span>);zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">7</span>:<span class="number">29</span>;y=<span class="number">16</span>:<span class="number">35</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);<span class="comment">%%在[7,29]×[16,35]区域内生成网格坐标</span></span><br><span class="line">z=<span class="number">2</span>*x+<span class="number">5</span>*y;</span><br><span class="line">k=<span class="built_in">find</span>(z==<span class="number">126</span>);<span class="comment">%%找到z=126的位置，就是求不定方程的解</span></span><br><span class="line">x(k)&#x27;,y(k)&#x27;;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">mesh(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维网格图&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">surf(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维曲面图&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="高级应用">高级应用</h2>
<h3 id="多项式计算">多项式计算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%多项式加减</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line">b=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">-1</span>];</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="comment">%%多项式乘除</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-10</span>];</span><br><span class="line">b=[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>];</span><br><span class="line">c=conv(a,b);            <span class="comment">%%多项式乘法</span></span><br><span class="line">d=deconv(a,b);          <span class="comment">%%多项式除法</span></span><br><span class="line"><span class="comment">%%多项式求导</span></span><br><span class="line">p=polyder(P);           <span class="comment">%%对P求导</span></span><br><span class="line">p=polyder(P,Q);         <span class="comment">%%对P,Q求导</span></span><br><span class="line">[p,q]=polyder(P,Q);     <span class="comment">%%对P/Q求导，分子储存在p，分母储存在q</span></span><br><span class="line"><span class="comment">%%多项式求值</span></span><br><span class="line">Y=polyval(A,x);         <span class="comment">%%A是多项式，x可以是数字，向量，矩阵</span></span><br><span class="line"><span class="comment">%%多项式求根</span></span><br><span class="line">roots(P);               <span class="comment">%%求多项式的根</span></span><br></pre></td></tr></table></figure>
<h3 id="数值微分">数值微分</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DX=diff(X);             <span class="comment">%%计算X的向前差分，即DX(i)=X(i+1)-X(i)</span></span><br><span class="line">DX=diff(X);             <span class="comment">%%计算X的n阶向前差分，即DX(i)=X(i+n)-X(i)</span></span><br></pre></td></tr></table></figure>
<h3 id="插值">插值</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">4</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">xq=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">16</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line"> x=<span class="number">1</span>:<span class="number">100</span>;</span><br><span class="line">y=<span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">xq=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">100</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);                  <span class="comment">%%这种方法噪音太大了</span></span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">y=[<span class="number">12</span>,<span class="number">16</span>,<span class="number">31</span>,<span class="number">10</span>,<span class="number">6</span>];</span><br><span class="line">xq=[<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1.5</span>,<span class="number">5.5</span>,<span class="number">6</span>];</span><br><span class="line">yq1=interp1(x,y,xq,<span class="string">&#x27;pchip&#x27;</span>);           <span class="comment">%%高阶外插</span></span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;liner&#x27;</span>,<span class="string">&#x27;extrap&#x27;</span>);  <span class="comment">%%低阶线性外插（数据少）</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq1,xq,yq2);</span><br></pre></td></tr></table></figure>
<h3 id="拟合">拟合</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">-1</span>,<span class="number">-0.75</span>,<span class="number">-0.50</span>,<span class="number">-0.25</span>,<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0.50</span>,<span class="number">0.75</span>,<span class="number">1.00</span>];</span><br><span class="line">X2=[<span class="number">-1</span>:<span class="number">0.01</span>:<span class="number">1</span>];</span><br><span class="line">Y=[<span class="number">-0.2209</span>,<span class="number">0.3295</span>,<span class="number">0.8826</span>,<span class="number">1.4392</span>,<span class="number">2.0003</span>,<span class="number">2.5645</span>,<span class="number">3.1334</span>,<span class="number">3.7061</span>,<span class="number">4.2836</span>];</span><br><span class="line">P1=polyfit(X,Y,<span class="number">1</span>);</span><br><span class="line">P2=polyfit(X,Y,<span class="number">2</span>);</span><br><span class="line">Y1=polyval(P1,X2);</span><br><span class="line">Y2=polyval(P2,X2);</span><br><span class="line"><span class="built_in">plot</span>(X,Y,<span class="string">&#x27;bx&#x27;</span>,X2,Y1,<span class="string">&#x27;r&#x27;</span>,X2,Y2,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-1.2</span>,<span class="number">1.2</span>]);</span><br><span class="line">ylim([<span class="number">-0.5</span>,<span class="number">4.5</span>]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;数据点&#x27;</span>,<span class="string">&#x27;一次拟合多项式&#x27;</span>,<span class="string">&#x27;二次拟合多项式&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> xdata=[<span class="number">0.9</span>,<span class="number">1.5</span>,<span class="number">13.8</span>,<span class="number">19.8</span>,<span class="number">24.1</span>,<span class="number">28.2</span>,<span class="number">35.2</span>,<span class="number">60.3</span>,<span class="number">74.6</span>,<span class="number">81.3</span>];</span><br><span class="line"> ydata=[<span class="number">455.2</span>,<span class="number">428.6</span>,<span class="number">124.1</span>,<span class="number">67.3</span>,<span class="number">43.2</span>,<span class="number">28.1</span>,<span class="number">13.1</span>,<span class="number">-0.4</span>,<span class="number">-1.3</span>,<span class="number">-1.5</span>];</span><br><span class="line"> fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line"> x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line"> options=optimoptions(<span class="string">&#x27;lsqcurvefit&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;trust-region-reflective&#x27;</span>);</span><br><span class="line"> lb=[<span class="number">-500</span>,<span class="number">-500</span>];</span><br><span class="line"> ub=[<span class="number">500</span>,<span class="number">500</span>];</span><br><span class="line"> x=lsqcurvefit(fun,x0,xdata,ydata,lb,ub,options);</span><br><span class="line"> times=<span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"> <span class="built_in">plot</span>(xdata.ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line"> <span class="built_in">legend</span>(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;fitted exponential&#x27;</span>);?????</span><br><span class="line"> </span><br><span class="line">xdata=[<span class="number">0.9</span> <span class="number">1.5</span> <span class="number">13.8</span> <span class="number">19.8</span> <span class="number">24.1</span> <span class="number">28.2</span> <span class="number">35.2</span> <span class="number">60.3</span> <span class="number">74.6</span> <span class="number">81.3</span>];</span><br><span class="line">ydata=[<span class="number">455.2</span> <span class="number">428.6</span> <span class="number">124.1</span> <span class="number">67.3</span> <span class="number">43.2</span> <span class="number">28.1</span> <span class="number">13.1</span> <span class="number">-0.4</span> <span class="number">-1.3</span> <span class="number">-1.5</span>];</span><br><span class="line">fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line">x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line">x=lsqcurvefit(fun,x0,xdata,ydata);</span><br><span class="line">times = <span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"><span class="built_in">plot</span>(xdata,ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Data&#x27;</span>,<span class="string">&#x27;Fitted exponential&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Data and Fitted Curve&#x27;</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
