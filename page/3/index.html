<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:58" itemprop="dateModified" datetime="2025-08-08T19:53:58+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="位运算">位运算</h2>
<p>整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如第
2 节
“Unicode和UTF-8”介绍的UTF-8编码就是如此，学完本节之后你应该能自己写出UTF-8的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。</p>
<h3 id="按位与或异或取反运算">按位与、或、异或、取反运算</h3>
<p>在第 3 节
“布尔代数”讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C语言提供了按位与（Bitwise
AND）运算符<code>&amp;</code>、按位或（Bitwise
OR）运算符<code>|</code>和按位取反（Bitwise
NOT）运算符<code>~</code>，此外还有按位异或（Bitwise
XOR）运算符<code>^</code>，我们在第 1 节
“为什么计算机用二进制计数”讲过异或运算。</p>
<p>注意，<code>&amp;</code>、<code>|</code>、<code>^</code>运算符都是要做Usual
Arithmetic Conversion的（其中有一步是Integer
Promotion），<code>~</code>运算符也要做Integer
Promotion，所以在C语言中其实并不存在8位整数的位运算，操作数在做位运算之前都至少被提升为<code>int</code>型了.</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0xfc</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = ~c;</span><br></pre></td></tr></table></figure>
<p>计算过程是这样的：常量<code>0xfc</code>是<code>int</code>型的，赋给c要转成<code>unsigned char</code>，值不变；c的十六进制表示是<code>fc</code>，计算<code>~c</code>时先提升为整型<code>000000fc</code>然后取反，最后结果是<code>ffffff03</code>。注意，如果把<code>~c</code>看成是8位整数的取反，最后结果就得3了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。</p>
<h3 id="移位运算">移位运算</h3>
<p>移位运算符（Bitwise
Shift）包括左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。左移将一个整数的各二进制位全部左移若干位.</p>
<p>最高两位的11被移出去了，最低两位又补了两个0，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是<code>unsigned int</code>型，如果左移的位数大于等于32位，则结果是Undefined。移位运算符不同于<code>+ - * / ==</code>等运算符，两边操作数的类型不要求一致，但两边操作数都要做Integer
Promotion，整个表达式的类型和左操作数提升后的类型相同。</p>
<p>复习一下第 2 节
“不同进制之间的换算”讲过的知识可以得出结论，在一定的取值范围内，将一个整数左移1位相当于乘以2。比如二进制11（十进制3）左移一位变成110，就是6，再左移一位变成1100，就是12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以2了，所以我加了个前提“在一定的取值范围内”。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有<code>i * 8</code>，可以编译成移位指令而不是乘法指令。</p>
<p>当操作数是无符号数时，右移运算的规则和左移类似，</p>
<p>比如最低两位的11被移出去了，最高两位又补了两个0，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是Undefined。在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。</p>
<p>当操作数是有符号数时，右移运算的规则比较复杂：</p>
<p>如果是正数，那么高位移入0</p>
<p>如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“右移1位相当于除以2”的性质。</p>
<p>综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，建议只对无符号数做位运算，以减少出错的可能。</p>
<h3 id="掩码">掩码</h3>
<p>如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）来表示。比如掩码0x0000ff00表示对一个32位整数的8~15位进行操作，举例如下。</p>
<p>1、取出8~15位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = (a &amp; mask) &gt;&gt; <span class="number">8</span>; <span class="comment">/* 0x00000056 */</span></span><br></pre></td></tr></table></figure>
<p>这样也可以达到同样的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = (a &gt;&gt; <span class="number">8</span>) &amp; ~(~<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>2、将8~15位清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a &amp; ~mask; <span class="comment">/* 0x12340078 */</span></span><br></pre></td></tr></table></figure>
<p>3、将8~15位置1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a | mask; <span class="comment">/* 0x1234ff78 */</span></span><br></pre></td></tr></table></figure>
<h3 id="异或运算的一些特性">异或运算的一些特性</h3>
<p>1、一个数和自己做异或的结果是0。如果需要一个常数0，x86平台的编译器可能会生成这样的指令：<code>xorl %eax, %eax</code>。不管<code>eax</code>寄存器里的值原来是多少，做异或运算都能得到0，这条指令比同样效果的<code>movl $0, %eax</code>指令快，因为前者只需要在CPU内部计算，而后者需要访问内存，在下一章第
5 节 “Memory Hierarchy”详细介绍。</p>
<p>2、从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">1U</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a ^ mask; <span class="comment">/* flip the 6th bit */</span></span><br></pre></td></tr></table></figure>
<p>3、如果<code>a1 ^ a2 ^ a3 ^ ... ^ an</code>的结果是1，则表示<code>a1、a2、a3...an</code>之中1的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity
Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。</p>
<p>4、<code>x ^ x ^ y == y</code>，因为<code>x ^ x == 0</code>，<code>0 ^ y == y</code>。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用<code>temp = a; a = b; b = temp;</code>的办法了。利用位运算可以这样做交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>分析一下这个过程。为了避免混淆，把<code>a</code>和<code>b</code>的初值分别记为<code>a0</code>和<code>b0</code>。第一行，<code>a = a0 ^ b0；</code>第二行，把<code>a</code>的新值代入，得到<code>b = b0 ^ a0 ^ b0</code>，等号右边的<code>b0</code>相当于上面公式中的<code>x</code>，<code>a0</code>相当于<code>y</code>，所以结果为<code>a0</code>；第三行，把<code>a</code>和<code>b</code>的新值代入，得到<code>a = a0 ^ b0 ^ a0</code>，结果为<code>b0</code>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量<code>temp</code>则可以交换。</p>
<h2 id="其他运算符">其他运算符</h2>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<p>复合赋值运算符（Compound Assignment
Operator）包括<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>，一边做运算一边赋值。例如<code>a += 1</code>相当于<code>a = a + 1</code>。但有一点细微的差别，前者对表达式<code>a</code>只求值一次，而后者求值两次，如果<code>a</code>是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如<code>a[i+j] += 1</code>和<code>a[i+j] = a[i+j] + 1</code>。那么仅仅是效率上的差别吗？对于没有Side
Effect的表达式，求值一次和求值两次的结果是一样的，但对于有Side
Effect的表达式则不一定，例如<code>a[foo()] += 1</code>和<code>a[foo()] = a[foo()] + 1</code>，如果<code>foo()</code>函数调用有Side
Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。</p>
<p>在第 3 节
“for语句”讲自增、自减运算符时说<code>++i</code>相当于<code>i = i + 1</code>，其实更准确地说应该是等价于<code>i += 1</code>，表达式<code>i</code>只求值一次，而<code>--i</code>等价于<code>i -= 1</code>。</p>
<h3 id="条件运算符">条件运算符</h3>
<p>条件运算符（Conditional
Operator）是C语言中唯一一个三目运算符（Ternary
Operator），带三个操作数，它的形式是<code>表达式1 ? 表达式2 : 表达式3</code>，这个运算符所组成的整个表达式的值等于<code>表达式2</code>或<code>表达式3</code>的值，取决于<code>表达式1</code>的值是否为真，可以把它想像成这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><code>表达式1</code>相当于<code>if</code>语句的控制表达式，因此它的值必须是标量类型，而表达式2和3相当于同一个函数在不同情况下的返回值，因此它们的类型要求一致，也要做Usual
Arithmetic Conversion。</p>
<p>下面举个例子，定义一个函数求两个参数中较大的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逗号运算符">逗号运算符</h3>
<p>逗号运算符（Comma
Operator）也是一种双目运算符，它的形式是<code>表达式1, 表达式2</code>，两个表达式不要求类型一致，左边的表达式1先求值，求完了直接把值丢掉，再求右边表达式2的值作为整个表达式的值。逗号运算符是左结合的，类似于<code>+ - * /</code>运算符，根据组合规则可以写出<code>表达式1, 表达式2, 表达式3, ..., 表达式n</code>这种形式，<code>表达式1</code>,
<code>表达式2</code>可以看作一个子表达式，先求<code>表达式1</code>的值，然后求<code>表达式2</code>的值作为这个子表达式的值，然后这个值再和<code>表达式3</code>组成一个更大的表达式，求<code>表达式3</code>的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一个表达式的值成为整个表达式的值。</p>
<p>注意，函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样使用逗号运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a, (t=<span class="number">3</span>, t+<span class="number">2</span>), c)</span><br></pre></td></tr></table></figure>
<p>传给函数<code>f</code>的参数有三个，其中第二个参数的值是表达式<code>t+2</code>的值。</p>
<h3
id="sizeof运算符与typedef类型声明">sizeof运算符与typedef类型声明</h3>
<p><code>sizeof</code>是一个很特殊的运算符，它有两种形式：“<code>sizeof 表达式</code>”和“<code>sizeof(类型名)</code>”。这个运算符很特殊，“<code>sizeof 表达式</code>”中的子表达式并不求值，而只是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成“<code>sizeof(表达式)</code>”的形式也可以，这里的括号和<code>return(1);</code>的括号一样，不起任何作用。但另外一种形式“<code>sizeof(类型名)</code>”的括号则是必须写的，整个表达式的值也是这种类型所占的字节数。</p>
<p>比如用<code>sizeof</code>运算符求一个数组的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span> a/<span class="keyword">sizeof</span> a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，由于<code>sizeof</code>
表达式中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道<code>sizeof a</code>的值是48，<code>sizeof a[0]</code>的值是4，所以在编译时就已经把<code>sizeof a/sizeof a[0]</code>替换成常量12了，这是一个常量表达式。</p>
<p><code>sizeof</code>运算符的结果是<code>size_t</code>类型的，这个类型定义在<code>stddef.h</code>头文件中，不过你的代码中只要不出现<code>size_t</code>这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C标准规定<code>size_t</code>是一种无符号整型，编译器可以用<code>typedef</code>做一个类型声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<p>那么<code>size_t</code>就代表<code>unsigned long</code>型。不同平台的编译器可能会根据自己平台的具体情况定义<code>size_t</code>所代表的类型，比如有的平台定义为<code>unsigned long</code>型，有的平台定义为<code>unsigned long long</code>型，C标准规定<code>size_t</code>这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把<code>size_t</code>类型和它所代表的真实类型混用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">size_t</span> y;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>
<p>如果在一种ILP32平台上定义<code>size_t</code>代表<code>unsigned long long</code>型，这段代码把<code>y</code>赋给<code>x</code>时就把高位截掉了，结果可能是错的。</p>
<p><code>typedef</code>这个关键字用于给某种类型起个新名字，比如上面的<code>typedef</code>声明可以这么看：去掉<code>typedef</code>就成了一个变量声明<code>unsigned long size_t;</code>，<code>size_t</code>是一个变量名，类型是<code>unsigned long</code>，那么加上<code>typedef</code>之后，<code>size_t</code>就是一个类型名，就代表<code>unsigned long</code>类型。再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">array_t</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">array_t</span> a;</span><br></pre></td></tr></table></figure>
<p>这相当于声明<code>char a[10];</code>。类型名也遵循标识符的命名规则，并且通常加个<code>_t</code>后缀表示Type。</p>
<h2 id="side-effect和sequence-point">Side Effect和Sequence Point</h2>
<p>如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了Short-circuit比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">a = (++a)+(++a)+(++a)+(++a);</span><br></pre></td></tr></table></figure>
<p>据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是Undefined。</p>
<p>我们知道，调用一个函数可能产生Side
Effect，使用某些运算符（<code>++ -- =</code> 复合赋值）也会产生Side
Effect，如果一个表达式中隐含着多个Side
Effect，究竟哪个先发生哪个后发生呢？C标准规定代码中的某些点是Sequence
Point，当执行到一个Sequence Point时，在此之前的Side
Effect必须全部作用完毕，在此之后的Side
Effect必须一个都没发生。至于两个Sequence Point之间的多个Side
Effect哪个先发生哪个后发生则没有规定，编译器可以任意选择各Side
Effect的作用顺序。下面详细解释各种Sequence Point。</p>
<p>1、调用一个函数时，在所有准备工作做完之后、函数调用开始之前是Sequence
Point。比如调用<code>foo(f(), g())</code>时，<code>foo</code>、<code>f()</code>、<code>g()</code>这三个表达式哪个先求值哪个后求值是Unspecified，但是必须都求值完了才能做最后的函数调用，所以<code>f()</code>和<code>g()</code>的Side
Effect按什么顺序发生不一定，但必定在这些Side
Effect全部作用完之后才开始调用<code>foo</code>函数。</p>
<p>2、条件运算符<code>?:</code>、逗号运算符、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>的第一个操作数求值之后是Sequence
Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据表达式1的值是否为真决定下一步求表达式2还是表达式3的值，如果决定求表达式2的值，表达式3就不会被求值了，反之也一样，逗号运算符也是这样，表达式1求值结束才继续求表达式2的值。</p>
<p>逻辑与和逻辑或早在第 3 节
“布尔代数”就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如例
8.5 “剪刀石头布”这个程序中的这几句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以写得更简单（类似于[K&amp;R]的简洁风格）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man) != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个控制表达式的求值顺序是：先求<code>scanf("%d", &amp;man) = 1</code>的值，如果<code>scanf</code>调用失败，则返回值不等于1成立，<code>||</code>运算有一个操作数为真则整个表达式为真，这时直接执行下一句<code>printf</code>，根本不会再去求<code>man &lt; 0</code>或<code>man &gt; 2</code>的值；如果<code>scanf</code>调用成功，则读入的数保存在变量<code>man</code>中，并且返回值等于1，那么说它不等于1就不成立了，第一个<code>||</code>运算的左操作数为假，就会去求右操作数<code>man &lt; 0</code>的值作为整个表达式的值，这时变量<code>man</code>的值正是<code>scanf</code>读上来的值，我们判断它是否在[0,
2]之间，如果<code>man &lt; 0</code>不成立，则整个表达式<code>scanf("%d", &amp;man) != 1 || man &lt; 0</code>
的值为假，也就是第二个<code>||</code>运算的左操作数为假，所以最后求右操作数<code>man &gt; 2</code>的值作为整个表达式的值。</p>
<p><code>&amp;&amp;</code>运算与此类似，<code>a &amp;&amp; b</code>的计算过程是：首先求表达式a的值，如果a的值是假则整个表达式的值是假，不会再去求b的值；如果a的值是真，则下一步求b的值作为整个表达式的值。所以，<code>a &amp;&amp; b</code>相当于“<code>if a then b</code>”，而<code>a || b</code>相当于“<code>if not a then b</code>”。这种特性称为Short-circuit，很多人喜欢利用Short-circuit特性简化代码。</p>
<p>3、在一个完整的声明末尾是Sequence
Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明<code>int a[10], b[20];</code>，在<code>a[10]</code>末尾是Sequence
Point，在<code>b[20]</code>末尾也是。</p>
<p>4、在一个完整的表达式末尾是Sequence
Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有<code>f(); g();</code>这样两条语句，<code>f()</code>和<code>g()</code>是两个完整的表达式，<code>f()</code>的Side
Effect必定在<code>g()</code>之前发生。</p>
<p>5、在库函数即将返回时是Sequence
Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（第
2.1 节 “函数式宏定义”），并不是真正的函数，所以才需要有这条规则。</p>
<p>还有两种Sequence
Point和某些C标准库函数的执行过程相关，此处从略，有兴趣的读者可参考[C99]的Annex
C。</p>
<p>现在可以分析一下本节开头的例子了。<code>a = (++a)+(++a)+(++a)+(++a);</code>的结果之所以是Undefined，因为在这个表达式中有五个Side
Effect都在改变<code>a</code>的值，这些Side
Effect按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个<code>++a</code>的值，这时第一个、第三个、第四个<code>++a</code>的Side
Effect发生了没有，<code>a</code>的值被加过几次了，这些都不确定，所以第二个<code>++a</code>的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。</p>
<p>写表达式应遵循的原则一：在两个Sequence
Point之间，同一个变量的值只允许被改变一次。仅有这一条原则还不够，例如<code>a[i++] = i;</code>的变量<code>i</code>只改变了一次，但结果仍是Undefined，因为等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么<code>i = i + 1;</code>就没有歧义呢？虽然也是等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，但你不读出<code>i</code>的值就没法计算<code>i + 1</code>，那拿什么去改<code>i</code>的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：如果在两个Sequence
Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写。</p>
<h2 id="运算符小结">运算符小结</h2>
<p>到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。</p>
<p>运算符<code>+ - * / % &gt; &lt; &gt;= &lt;= == != &amp; | ^</code>以及各种复合赋值运算符要求两边的操作数类型一致，条件运算符<code>?:</code>要求后两个操作数类型一致，这些运算符在计算之前都需要做Usual
Arithmetic Conversion。</p>
<p>下面按优先级从高到低的顺序总结一下C语言的运算符，每一条所列的各运算符具有相同的优先级，对于同一优先级的多个运算符按什么顺序计算也有说明，双目运算符就简单地用“左结合”或“右结合”来说明了。和指针有关的运算符<code>* &amp; -&gt;</code>也在这里列出来了，到第
23 章 指针再详细解释。</p>
<p>1、标识符、常量、字符串和用<code>()</code>括号套起来的表达式是组成表达式的最基本单元，在运算中做操作数，优先级最高。</p>
<p>2、后缀运算符，包括数组取下标<code>[]</code>、函数调用<code>()</code>、结构体取成员<code>“.”</code>、指向结构体的指针取成员<code>-&gt;</code>、后缀自增<code>++</code>、后缀自减<code>--</code>。如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）依次计算，比如<code>a.name++</code>，先算<code>a.name</code>，再<code>++</code>，这里的<code>.name</code>应该看成<code>a</code>的一个后缀，而不是把<code>.</code>看成双目运算符。</p>
<p>3、单目运算符，包括前缀自增<code>++</code>、前缀自减<code>--</code>、<code>sizeof</code>、类型转换<code>()</code>、取地址运算<code>&amp;</code>、指针间接寻址<code>*</code>、正号<code>+</code>、负号<code>-</code>、按位取反<code>~</code>、逻辑非<code>!</code>。如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）依次计算，比如<code>!~a</code>，先算<code>~a</code>，再求<code>!</code>。</p>
<p>4、乘<code>*</code>、除<code>/</code>、模<code>%</code>运算符。这三个运算符是左结合的。</p>
<p>5、加<code>+</code>、减<code>-</code>运算符。左结合。</p>
<p>6、移位运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。左结合。</p>
<p>7、关系运算符<code>&lt; &gt; &lt;= &gt;=</code>。左结合。</p>
<p>8、相等性运算符<code>==</code>和<code>!=</code>。左结合。</p>
<p>9、按位与<code>&amp;</code>。左结合。</p>
<p>10、按位异或<code>^</code>。左结合。</p>
<p>11、按位或<code>|</code>。左结合。</p>
<p>12、逻辑与<code>&amp;&amp;</code>。左结合。</p>
<p>13、逻辑或<code>||</code>。左结合。</p>
<p>14、条件运算符<code>:?</code>。在第 2 节
“if/else语句”讲过Dangling-else问题，条件运算符也有类似的问题。例如<code>a ? b : c ? d : e</code>是看成<code>(a ? b : c) ? d : e</code>还是<code>a ? b : (c ? d : e)</code>呢？C语言规定是后者。</p>
<p>15、赋值<code>=</code>和各种复合赋值（<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>）。在双目运算符中只有赋值和复合赋值是右结合的。</p>
<p>16、逗号运算符。左结合。</p>
<p>[K&amp;R]第2章也有这样一个列表，但是对于结合性解释得不够清楚。左结合和右结合这两个概念只对双目运算符有意义，对于前缀、后缀和三目运算符我单独做了说明。C语言表达式的详细语法规则可以参考[C99]的Annex
A.2，其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些细节用优先级和结合性是表达不了的，只有看C99才能了解完整的语法规则。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:计算机中数的表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:54:02" itemprop="dateModified" datetime="2025-08-08T19:54:02+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么计算机使用二进制数">为什么计算机使用二进制数</h2>
<p>人类的计数方式通常是“逢十进一”，称为十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字0~9是目前最广泛采用的。</p>
<p>计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所以对计算机来说二进制（Binary）是最自然的计数方式。根据“逢二进一”的原则，十进制的1、2、3、4分别对应二进制的1、10、11、100。二进制的一位数字称为一个位（Bit），三个bit能够表示的最大的二进制数是111，也就是十进制的7。不管用哪种计数方式，数的大小并没有变，十进制的1+1等于2，二进制的1+1等于10，二进制的10和十进制的2大小是相等的。</p>
<h2 id="不同进制之间的换算">不同进制之间的换算</h2>
<p>在十进制中，个位的1代表100=1，十位的1代表101=10，百位的1代表102=100，所以</p>
<p>123=1×102+2×101+3×100</p>
<p>同样道理，在二进制中，个位的1代表20=1，十位的1代表21=2，百位的1代表22=4，所以</p>
<p>(A3A2A1A0)2=A3×23+A2×22+A1×21+A0×20</p>
<p>如果二进制和十进制数出现在同一个等式中，为了区别我们用(A3A2A1A0)2这种形式表示A3A2A1A0是二进制数，每个数字只能是0或1，其它没有套括号加下标的数仍表示十进制数。对于(A3A2A1A0)2这样一个二进制数，最左边的A3位称为最高位（MSB，Most
Significant Bit），最右边的A0位称为最低位（LSB，Least Significant
Bit）。以后我们遵循这样的惯例：LSB称为第0位而不是第1位，所以如果一个数是32位的，则MSB是第31位。上式就是从二进制到十进制的换算公式。作为练习，请读者算一下(1011)2和(1111)2换算成十进制分别是多少。</p>
<p>下面来看十进制怎么换算成二进制。我们知道</p>
<p>13=1×23+1×22+0×21+1×20</p>
<p>所以13换算成二进制应该是(1101)2。问题是怎么把13分解成等号右边的形式呢？注意到等号右边可以写成</p>
<p>13=(((0×2+13)×2+12)×2+01)×2+10</p>
<p>我们将13反复除以2取余数就可以提取出上式中的1101四个数字，为了让读者更容易看清楚是哪个1和哪个0，上式和下式中对应的数字都加了下标：</p>
<p>13÷2=6…10 6÷2=3…01 3÷2=1…12 1÷2=0…13</p>
<p>把这四步得到的余数按相反的顺序排列就是13的二进制表示，因此这种方法称为除二反序取余法。</p>
<p>计算机用二进制表示数，程序员也必须习惯使用二进制，但二进制写起来太啰嗦了，所以通常将二进制数分成每三位一组或者每四位一组，每组用一个数字表示。比如把(10110010)2从最低位开始每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是(262)8，这样每一位数字的取值范围是0<sub>7，逢八进一，称为八进制（Octal）。类似地，把(10110010)2分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是2，高位已经大于9了，我们规定用字母A</sub>F表示10<sub>15，这个数可以写成(B2)16，每一位数字的取值范围是0</sub>F，逢十六进一，称为十六进制（Hexadecimal）。所以，八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样。</p>
<h2 id="整数的加减运算">整数的加减运算</h2>
<p>我们已经了解了计算机中正整数如何表示，加法如何计算，那么负数如何表示，减法又如何计算呢？本节讨论这些问题。为了书写方便，本节举的例子都用8个bit表示一个数，实际计算机做整数加减运算的操作数可以是8位、16位、32位甚至64位的。</p>
<h3 id="sign-and-magnitude表示法">Sign and Magnitude表示法</h3>
<p>要用8个bit表示正数和负数，一种简单的想法是把最高位规定为符号位（Sign
Bit），0表示正1表示负，剩下的7位表示绝对值的大小，这称为Sign and
Magnitude表示法。例如-1表示成10000001，+1表示成00000001。这样用8个bit表示整数的取值范围是-27-1<sub>27-1，即-127</sub>127。</p>
<p>采用这种表示法，计算机做加法运算需要处理以下逻辑：</p>
<p>如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出（Overflow）[24]，这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。</p>
<p>如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同。</p>
<p>那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算a-b，可以先把b变号然后和a相加，相当于计算a+(-b)。但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步减法计算仍然是免不了的。我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有第
1 节
“为什么计算机用二进制计数”提到的加法器电路之外，还要另外有一套减法器电路。</p>
<p>如果采用Sign and
Magnitude表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。还有一个缺点是0的表示不唯一，既可以表示成10000000也可以表示成00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。</p>
<h3 id="s-complement表示法">1’s Complement表示法</h3>
<p>本节介绍一种二进制补码表示法，为了便于理解，我们先看一个十进制的例子：</p>
<p>167-52=167+(-52)=167+(999-52)-1000+1=167+947-1000+1=1114-1000+1=114+1=115
167-52 → 减法转换成加法 167+(-52) → 负数取9的补码表示 167+947 → 114进1 →
高位进的1加到低位上去，结果为115</p>
<p>在这个例子中我们用三位十进制数字表示正数和负数，具体规定如下：</p>
<p>9’s Complement表示法</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>补码表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>-499</td>
<td>500</td>
</tr>
<tr>
<td>-498</td>
<td>501</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>998</td>
</tr>
<tr>
<td>0</td>
<td>999</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>498</td>
<td>498</td>
</tr>
<tr>
<td>499</td>
<td>499</td>
</tr>
</tbody>
</table>
<p>首先-52要用999-52表示，就是947，这称为取9的补码（9’s
Complement）；然后把167和947相加，得到114进1；再把高位进的1加到低位上去，得115，本来应该加1000，结果加了1，少加了999，正好把先前取9的补码多加的999抵消掉了。我们本来要做167-52的减法运算，结果变成做999-52的减法运算，后者显然要容易一些，因为没有借位。这种补码表示法的计算规则用一句话概括就是：负数用9的补码表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。要验证这条规则得考虑四种情况：</p>
<p>两个正数，相加得正</p>
<p>一正一负，相加得正</p>
<p>一正一负，相加得负</p>
<p>两个负数，相加得负</p>
<p>我们举的例子验证了第二种情况，另外三种情况请读者自己验证，暂时不考虑溢出的问题，稍后会讲到如何判定溢出。</p>
<p>上述规则也适用于二进制：负数用1的补码（1’s
Complement）表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。取1的补码更简单，连减法都不用做，因为1-1=0，1-0=1，取1的补码就是把每个bit取反，所以1的补码也称为反码。比如：</p>
<p>00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 →
00000011进1 → 高位进的1加到低位上去，结果为00000100</p>
<p>1’s Complement表示法相对于Sign and
Magnitude表示法的优势是非常明显的：不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，计算逻辑更简单，甚至连减法器电路都省了，只要有一套加法器电路，再有一套把每个bit取反的电路，就可以做加法和减法运算。如果8个bit采用1’s
Complement表示法，负数的取值范围是从10000000到11111111（-127<sub>0），正数是从00000000到01111111（0</sub>127），仍然可以根据最高位判断一个数是正是负。美中不足的是0的表示仍然不唯一，既可以表示成11111111也可以表示成00000000，为了解决这最后一个问题，我们引入2’s
Complement表示法。</p>
<h3 id="s-complement表示法-1">2’s Complement表示法</h3>
<p>2’s
Complement表示法规定：正数不变，负数先取反码再加1。如果8个bit采用2’s
Complement表示法，负数的取值范围是从10000000到11111111（-128<sub>-1），正数是从00000000到01111111（0</sub>127），也可以根据最高位判断一个数是正是负，并且0的表示是唯一的，目前绝大多数计算机都采用这种表示法。为什么称为“2的补码”呢？因为对一位二进制数b取补码就是1-b+1=10-b，相当于从2里面减去b。类似地，要表示-4需要对00000100取补码，11111111-00000100+1=100000000-00000100，相当于从28里面减去4。2’s
Complement表示法的计算规则有些不同：减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。请读者自己验证上一节提到的四种情况下这条规则都能算出正确结果。</p>
<p>8个bit采用2’s
Complement表示法的取值范围是-128~127，如果计算结果超出这个范围就会产生溢出，例如：</p>
<p>10000010(-126)+11111000(-8)=01111010(122)</p>
<p>如何判断产生了溢出呢？我们还是分四种情况讨论：如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。</p>
<h3 id="有符号数和无符号数">有符号数和无符号数</h3>
<p>前面几节我们用8个bit表示正数和负数，讲了三种表示法，每种表示法对应一种计算规则，这称为有符号数（Signed
Number）；如果8个bit全部表示正数则取值范围是0~255，这称为无符号数（Unsigned
Number）。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样，比如上面的例子也可以看作无符号数的加法：</p>
<p>10000010(130)+11111000(248)=01111010(122+256)</p>
<p>如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出；但如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的。计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时根据最高位和次高位产生的进位的异或设置溢出标志。至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。</p>
<h2 id="浮点数">浮点数</h2>
<p>浮点数在计算机中的表示是基于科学计数法（Scientific
Notation）的，我们知道32767这个数用科学计数法可以写成3.2767×104，3.2767称为尾数（Mantissa，或者叫Significand），4称为指数（Exponent）。浮点数在计算机中的表示与此类似，只不过基数（Radix）是2而不是10。下面我们用一个简单的模型来解释浮点数的基本概念。我们的模型由三部分组成：符号位、指数部分（表示2的多少次方）和尾数部分（小数点前面是0，尾数部分只表示小数点后的数字）。</p>
<p>一种浮点数格式</p>
<table>
<thead>
<tr>
<th>1 bit</th>
<th>5 bits</th>
<th>8 bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>sign bit</td>
<td>exponent</td>
<td>significand</td>
</tr>
</tbody>
</table>
<p>如果要表示17这个数，我们知道17=17.0×100=0.17×102，类似地，17=(10001)2×20=(0.10001)2×25，把尾数的有效数字全部移到小数点后，这样就可以表示为：</p>
<p>17的浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>00101</td>
<td>10001000</td>
</tr>
</tbody>
</table>
<p>如果我们要表示0.25就遇到新的困难了，因为0.25=1×2-2=(0.1)2×2-1，而我们的模型中指数部分没有规定如何表示负数。我们可以在指数部分规定一个符号位，然而更广泛采用的办法是使用偏移的指数（Biased
Exponent）。规定一个偏移值，比如16，实际的指数要加上这个偏移值再填写到指数部分，这样比16大的就表示正指数，比16小的就表示负指数。要表示0.25，指数部分应该填16-1=15：</p>
<p>0.25的偏移指数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>01111</td>
<td>10000000</td>
</tr>
</tbody>
</table>
<p>现在还有一个问题需要解决：每个浮点数的表示都不唯一，例如17=(0.10001)2×25=(0.010001)2×26，这样给计算机处理增加了复杂性。为了解决这个问题，我们规定尾数部分的最高位必须是1，也就是说尾数必须以0.1开头，对指数做相应的调整，这称为正规化（Normalize）。由于尾数部分的最高位必须是1，这个1就不必保存了，可以节省出一位来用于提高精度，我们说最高位的1是隐含的（Implied）。这样17就只有一种表示方法了，指数部分应该是16+5=21=(10101)2，尾数部分去掉最高位的1是0001：</p>
<p>17的正规化尾数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10101</td>
<td>00010000</td>
</tr>
</tbody>
</table>
<p>两个浮点数相加，首先把小数点对齐然后相加：</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10010</td>
<td>10010000</td>
<td>+</td>
</tr>
<tr>
<td>0</td>
<td>10000</td>
<td>00110110</td>
<td>=</td>
</tr>
<tr>
<td>0</td>
<td>10010</td>
<td>11011101</td>
<td></td>
</tr>
</tbody>
</table>
<p>11.0010000+0.100110110=11.101110110</p>
<p>由于浮点数表示的精度有限，计算结果末尾的10两位被舍去了。做浮点运算时要注意精度损失（Significance
Loss）问题，有时计算顺序不同也会导致不同的结果，比如11.0010000+0.00000001+0.00000001=11.0010000+0.00000001=11.0010000，后面加的两个很小的数全被舍去了，没有对计算结果产生任何影响，但如果调一下计算顺序它们就能影响到计算结果了，0.00000001+0.00000001+11.0010000=0.00000010+11.0010000=11.0010001。再比如128.25=(10000000.01)2，需要10个有效位，而我们的模型中尾数部分是8位，算上隐含的最高位1一共有9个有效位，那么128.25的浮点数表示只能舍去末尾的1，表示成(10000000.0)2，其实跟128相等了。在第
2 节
“if/else语句”讲过浮点数不能做精确比较，现在读者应该知道为什么不能精确比较了。</p>
<p>整数运算会产生溢出，浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，但和整数运算的定义不同。假设整数采用8位2’s
Complement表示法，取值范围是-128<sub>127，如果计算结果是-130则称为下溢，计算结果是130则称为上溢。假设按本节介绍的浮点数表示法，取值范围是-(0.111111111)2×215</sub>(0.111111111)2×215，如果计算结果超出这个范围则称为上溢；如果计算结果未超出这个范围但绝对值太小了，在-(0.1)2×2-16~(0.1)2×2-16之间，那么也同样无法表示，称为下溢。</p>
<p>浮点数是一个相当复杂的话题，不同平台的浮点数表示和浮点运算也有较大差异，本节只是通过这个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，目前业界广泛采用的符点数标准是由IEEE（Institute
of Electrical and Electronics Engineers）制定的IEEE 754。</p>
<p>最后讨论一个细节问题。我们知道，定义全局变量时如果没有Initializer就用0初始化，定义数组时如果Initializer中提供的元素不够那么剩下的元素也用0初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">double</span> a[<span class="number">10</span>] = &#123; <span class="number">1.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>“用<code>0</code>初始化”的意思是变量<code>i</code>、变量<code>d</code>和数组元素<code>a[1]~a[9]</code>的所有字节都用<code>0</code>填充，或者说所有bit都是0。无论是用Sign
and Magnitude表示法、1’s Complement表示法还是2’s
Complement表示法，一个整数的所有bit是0都表示0值，但一个浮点数的所有bit是0一定表示0值吗？严格来说不一定，某种平台可能会规定一个浮点数的所有bit是0并不表示0值，但[C99
Rationale]第6.7.8节的条款25提到：As far as the committee knows, all
machines treat all bits zero as a representation of floating-point zero.
But, all bits zero might not be the canonical representation of zero.
因此在绝大多数平台上，一个浮点数的所有bit是0就表示0值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:分支语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 18:33:21" itemprop="dateModified" datetime="2025-08-06T18:33:21+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="if语句">if语句</h2>
<p>目前我们写的简单函数中可以有多条语句，但这些语句总是从前到后顺序执行的。除了顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在C语言中可以用分支语句（Selection
Statement）实现，比如：</p>
<p>if (x != 0) { printf(“x is nonzero.”); } 其中x !=
0表示“x不等于0”的条件，这个表达式称为控制表达式（Controlling
Expression）如果条件成立，则{}中的语句被执行，否则{}中的语句不执行，直接跳到}后面。if和控制表达式改变了程序的控制流程（Control
Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支（Branch）。上例中的!=号表示“不等于”，像这样的运算符有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody>
</table>
<p>注意以下几点：</p>
<p>这里的<code>==</code>表示数学中的相等关系，相当于数学中的<code>=</code>号，初学者常犯的错误是在控制表达式中把<code>==</code>写成<code>=</code>，在C语言中<code>=</code>号是赋值运算符，两者的含义完全不同。</p>
<p>如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用<code>int</code>型的<code>1</code>和<code>0</code>表示。如果变量<code>x</code>的值是<code>-1</code>，那么<code>x&gt;0</code>这个表达式的值为<code>0</code>，<code>x&gt;-2</code>这个表达式的值为<code>1</code>。</p>
<p>在数学中<code>a&lt;b&lt;c</code>表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，但作为C语言表达式却不是这样。以上几种运算符都是左结合的，请读者想一下这个表达式应如何求值。</p>
<p>这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较，在第
1.5 节 “比较字符串”我们会介绍比较字符串的方法。</p>
<p><code>==</code>和<code>!=</code>称为相等性运算符（Equality
Operator），其余四个称为关系运算符（Relational
Operator），相等性运算符的优先级低于关系运算符。</p>
<p>总结一下，<code>if (x != 0) &#123; ... &#125;</code>这个语句的计算顺序是：首先求<code>x != 0</code>这个表达式的值，如果值为<code>0</code>，就跳过<code>&#123;&#125;</code>中的语句直接执行后面的语句，如果值为<code>1</code>，就先执行<code>&#123;&#125;</code>中的语句，然后再执行后面的语句。事实上控制表达式取任何非<code>0</code>值都表示真值，例如<code>if (x) &#123; ... &#125;</code>和<code>if (x != 0) &#123; ... &#125;</code>是等价的，如果<code>x</code>的值是<code>2</code>，则<code>x != 0</code>的值是<code>1</code>，但对于<code>if</code>来说不管是<code>2</code>还是<code>1</code>都表示真值。</p>
<p>和if语句相关的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 语句 → { 语句列表 } 语句 → ;</p>
<p>在C语言中，任何允许出现语句的地方既可以是由<code>;</code>号结尾的一条语句，也可以是由<code>&#123;&#125;</code>括起来的若干条语句或声明组成的语句块（Statement
Block），语句块和上一章介绍的函数体的语法相同。注意语句块的<code>&#125;</code>后面不需要加<code>;</code>号。如果<code>&#125;</code>后面加了<code>;</code>号，则这个<code>;</code>号本身又是一条新的语句了，在C语言中一个单独的<code>;</code>号表示一条空语句（Null
Statement）。上例的语句块中只有一条语句，其实没必要写成语句块，可以简单地写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is nonzero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>语句块中也可以定义局部变量，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d, j=%d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>, i); <span class="comment">/* cannot access j here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和函数的局部变量同样道理，每次进入语句块时为变量j分配存储空间，每次退出语句块时释放变量<code>j</code>的存储空间。语句块也构成一个作用域，和例
3.6
“作用域”的分析类似，如果整个源文件是一张大纸，<code>foo</code>函数是盖在上面的一张小纸，则函数中的语句块是盖在小纸上面的一张更小的纸。语句块中的变量<code>i</code>和函数的局部变量<code>i</code>是两个不同的变量，因此两次打印的<code>i</code>值是不同的；语句块中的变量<code>j</code>在退出语句块之后就没有了，因此最后一行的<code>printf</code>不能打印变量<code>j</code>，否则编译器会报错。语句块可以用在任何允许出现语句的地方，不一定非得用在<code>if</code>语句中，单独使用语句块通常是为了定义一些比函数的局部变量更“局部”的变量。</p>
<h2 id="ifelse语句">if/else语句</h2>
<p><code>if</code>语句还可以带一个<code>else</code>子句（Clause），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里的<code>%</code>是取模（Modulo）运算符，<code>x%2</code>表示<code>x</code>除以<code>2</code>所得的余数（Remainder），C语言规定<code>%</code>运算符的两个操作数必须是整型的。两个正数相除取余数很好理解，如果操作数中有负数，结果应该是正是负呢？C99规定，如果<code>a</code>和<code>b</code>是整型，<code>b</code>不等于<code>0</code>，则表达式<code>(a/b)*b+a%b</code>的值总是等于<code>a</code>，再结合第
5 节 “表达式”讲过的整数除法运算要Truncate Toward
Zero，可以得到一个结论：%运算符的结果总是与被除数同号（想一想为什么）。其它编程语言对取模运算的规定各不相同，也有规定结果和除数同号的，也有不做明确规定的。</p>
<p>取模运算在程序中是非常有用的，例如上面的例子判断<code>x</code>的奇偶性（Parity），看<code>x</code>除以<code>2</code>的余数是不是<code>0</code>，如果是<code>0</code>则打印<code>x is even.</code>，如果不是<code>0</code>则打印<code>x is odd.</code>，读者应该能看出<code>else</code>在这里的作用了，如果在上面的例子中去掉<code>else</code>，则不管<code>x</code>是奇是偶，<code>printf("x is odd.\n");</code>总是执行。为了让这条语句更有用，可以把它封装（Encapsulate）成一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_parity</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把语句封装成函数的基本步骤是：把语句放到函数体中，把变量改成函数的参数。这样，以后要检查一个数的奇偶性只需调用这个函数而不必重复写这条语句了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_parity(<span class="number">17</span>);</span><br><span class="line">print_parity(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><code>if/else</code>语句的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 else 语句</p>
<p>右边的“语句”既可以是一条语句，也可以是由<code>&#123;&#125;</code>括起来的语句块。一条<code>if</code>语句中包含一条子语句，一条<code>if/else</code>语句中包含两条子语句，子语句可以是任何语句或语句块，当然也可以是另外一条<code>if</code>或<code>if/else</code>语句。根据组合规则，<code>if</code>或<code>if/else</code>可以嵌套使用。例如可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一个问题，类似<code>if (A) if (B) C; else D;</code>形式的语句怎么理解呢？可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>也可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        D;</span><br></pre></td></tr></table></figure>
<p>在第 1 节 “继续Hello
World”讲过，C代码的缩进只是为了程序员看起来方便，实际上对编译器不起任何作用，你的代码不管写成上面哪一种缩进格式，在编译器看起来都是一样的。那么编译器到底按哪种方式理解呢？也就是说，<code>else</code>到底是和<code>if (A)</code>配对还是和<code>if (B)</code>配对？很多编程语言的语法都有这个问题，称为Dangling-else问题。C语言规定，<code>else</code>总是和它上面最近的一个<code>if</code>配对，因此应该理解成<code>else</code>和<code>if (B)</code>配对，也就是按第二种方式理解。如果你写成上面第一种缩进的格式就很危险了：你看到的是这样，而编译器理解的却是那样。如果你希望编译器按第一种方式理解，应该明确加上<code>&#123;&#125;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>顺便提一下，浮点型的精度有限，不适合用<code>==</code>运算符做精确比较。以下代码可以说明问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">20.0</span>;</span><br><span class="line"><span class="type">double</span> j = i / <span class="number">7.0</span>;</span><br><span class="line"><span class="keyword">if</span> (j * <span class="number">7.0</span> == i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Equal.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unequal.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不同平台的浮点数实现有很多不同之处，在我的平台上运行这段程序结果为<code>Unequal</code>，即使在你的平台上运行结果为<code>Equal</code>，你再把<code>i</code>改成其它值试试，总有些值会使得结果为<code>Unequal</code>。等学习了第
4 节 “浮点数”你就知道为什么浮点型不能做精确比较了。</p>
<h2 id="布尔代数">布尔代数</h2>
<p>在第 1 节
“if语句”讲过，<code>a&lt;b&lt;c</code>不表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，那么如果想表示这个含义该怎么写呢？可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以用逻辑与（Logical
AND）运算符表示这两个条件同时成立。逻辑与运算符在C语言中写成两个<code>&amp;</code>号（Ampersand），上面的语句可以改写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>a &lt; b &amp;&amp; b &lt; c</code>这个控制表达式，要求“<code>a &lt; b</code>的值非<code>0</code>”和“<code>b &lt; c</code>的值非<code>0</code>”这两个条件同时成立整个表达式的值才为<code>1</code>，否则整个表达式的值为<code>0</code>。也就是只有两个条件都为真，它们做逻辑与运算的结果才为真，有一个条件为假，则逻辑与运算的结果为假，如下表所示：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A AND B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>这种表称为真值表（Truth
Table）。注意逻辑与运算的操作数以非0表示真以0表示假，而运算结果以1表示真以0表示假（类型是int），我们忽略这些细微的差别，在表中全部以1表示真以0表示假。C语言还提供了逻辑或（Logical
OR）运算符，写成两个|线（Pipe Sign），逻辑非（Logical
NOT）运算符，写成一个!号（Exclamation Mark），它们的真值表如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A OR B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>表 4.4. NOT的真值表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>NOT A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑或表示两个条件只要有一个为真，它们做逻辑或运算的结果就为真，只有两个条件都为假，逻辑或运算的结果才为假。逻辑非的作用是对原来的逻辑值取反，原来是真的就是假，原来是假的就是真。逻辑非运算符只有一个操作数，称为单目运算符（Unary
Operator），以前讲过的加减乘除、赋值、相等性、关系、逻辑与、逻辑或运算符都有两个操作数，称为双目运算符（Binary
Operator）。</p>
<p>关于逻辑运算的数学体系称为布尔代数（Boolean
Algebra），以它的创始人布尔命名。在编程语言中表示真和假的数据类型叫做布尔类型，在C语言中通常用int型来表示，非0表示真，0表示假[6]。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。以下是一些布尔代数的基本定理，为了简洁易读，真和假用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有点像乘法和加法运算），NOT用¬表示，变量x、y、z的值可能是0也可能是1。</p>
<p>¬¬x=x</p>
<p>x*0=0 x+1=1</p>
<p>x*1=x x+0=x</p>
<p>x*x=x x+x=x</p>
<p>x*¬x=0 x+¬x=1</p>
<p>x<em>y=y</em>x x+y=y+x</p>
<p>x<em>(y</em>z)=(x<em>y)</em>z x+(y+z)=(x+y)+z</p>
<p>x<em>(y+z)=x</em>y+x<em>z x+y</em>z=(x+y)*(x+z)</p>
<p>x+x<em>y=x x</em>(x+y)=x</p>
<p>x<em>y+x</em>¬y=x (x+y)*(x+¬y)=x</p>
<p>¬(x<em>y)=¬x+¬y ¬(x+y)=¬x</em>¬y</p>
<p>x+¬x<em>y=x+y x</em>(¬x+y)=x*y</p>
<p>x<em>y+¬x</em>z+y<em>z=x</em>y+¬x<em>z
(x+y)</em>(¬x+z)<em>(y+z)=(x+y)</em>(¬x+z)</p>
<p>除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的<em>换成+、+换成</em>、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明，更多细节可参考有关数字逻辑的教材，例如[数字逻辑基础]。我们将在本节的练习题中强化训练对这些定理的理解。</p>
<p>目前为止介绍的这些运算符的优先级顺序是：!高于* / %，高于+ -，高于&gt;
&lt; &gt;= &lt;=，高于==
!=，高于&amp;&amp;，高于||，高于=。写一个控制表达式很可能同时用到这些运算符中的多个，如果记不清楚运算符的优先级一定要多套括号。我们将在第
4 节 “运算符总结”总结C语言所有运算符的优先级和结合性。</p>
<h2 id="switch语句">Switch语句</h2>
<p>switch语句可以产生具有多个分支的控制流程。它的格式是：</p>
<p>switch (控制表达式) { case 常量表达式： 语句列表 case 常量表达式：
语句列表 … default： 语句列表 }</p>
<p>例如以下程序根据传入的参数1<sub>7分别打印Monday</sub>Sunday：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_day</span><span class="params">(<span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        case1:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case2:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case3:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case4:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case5:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case6:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case7:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Illegal day number!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf_day(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的参数是<code>2</code>，则从<code>case 2</code>分支开始执行，先是打印相应的信息，然后遇到<code>break</code>语句，它的作用是跳出整个<code>switch</code>语句块。C语言规定各<code>case</code>分支的常量表达式必须互不相同，如果控制表达式不等于任何一个常量表达式，则从<code>default</code>分支开始执行，通常把<code>default</code>分支写在最后，但不是必须的。使用<code>switch</code>语句要注意几点：</p>
<p><code>case</code>后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。</p>
<p>第 2 节
“if/else语句”讲过浮点型不适合做精确比较，所以C语言规定<code>case</code>后面跟的必须是整型常量表达式。</p>
<p>进入<code>case</code>后如果没有遇到<code>break</code>语句就会一直往下执行，后面其它<code>case</code>或<code>default</code>分支的语句也会被执行到，直到遇到<code>break</code>，或者执行到整个<code>switch</code>语句块的末尾。通常每个<code>case</code>后面都要加上<code>break</code>语句，但有时会故意不加<code>break</code>来利用这个特性</p>
<p><code>switch</code>语句不是必不可缺的，显然可以用一组<code>if ... else if ... else if ... else ...</code>代替，但是一方面用<code>switch</code>语句会使代码更清晰，另一方面，有时候编译器会对<code>switch</code>语句进行整体优化，使它比等价的<code>if/else</code>语句所生成的指令效率更高。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/FPGA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/FPGA/" class="post-title-link" itemprop="url">第一章:Verilog HDL数字集成电路设计方法概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-28 19:35:27" itemprop="dateModified" datetime="2025-10-28T19:35:27+08:00">2025-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/FPGA/" itemprop="url" rel="index"><span itemprop="name">FPGA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="modelsim的安装">Modelsim的安装</h2>
<p>在网上找到Modelsim 2020.2及其许可证license的安装包, 先安装.</p>
<p>对于license的导入, 按照以下步骤进行:</p>
<ol type="1">
<li>点击下载附件modelsim_crack.zip，解压。</li>
<li>进入Modelsim的软件安装目录（我的电脑的安装目录是D:/modeltech64_10.4/win64）文件夹下找到mgls64.dll文件，去掉只读属性.</li>
<li>将解压后的文件MentorKG.exe和patch_dll.bat复制到Modelsim软件安装目录下的win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>运行patch_dll.bat，稍等一段时间后即可生成一个TXT文本</li>
<li>将生成的TXT文本另存为LICENSE.TXT，另存的路径选择Modelsim软件的安装路径win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>恢复mgls64.dll文件的只读属性</li>
<li>接下来设置环境变量，在电脑桌面上点击“我的电脑”或“计算机”，右键选择【属性】-&gt;【高级系统设置】-&gt;选择“高级”选项卡下的【环境变量】</li>
<li>Windows环境变量有用户变量和系统变量两个环境变量，这里设置用户变量即可；如果最后使用不了，再以同样的方式设置系统变量。
点击【新建(N)】，打开编辑用户变量对话框，变量名命名为MGLS_LICENSE_FILE，变量值为刚才生成的LICENSE.TXT的文件路径，即D:/modeltech64_10.4/win64/LICENSE.TXT，点击【确定】</li>
<li>环境变量设置完成之后，点击两次【确定】按钮，返回电脑桌面即可设置完成。此时双击桌面上的Modelsim软件，可以进入.
操作完成后打开Modelsim，如果仍然未检测到License，可以试下重启电脑</li>
</ol>
<h2 id="modelsim的使用">Modelsim的使用</h2>
<ol type="1">
<li>打开Modelsim软件,在左上角选中File-&gt;Change
Directory,在弹出的对话框中选择当前项目所在的文件夹(注意路径中不能包含中文).</li>
<li>接下来,选择File-&gt;New-&gt;Project.会弹出一个Create
Project的界面,只需要输入Project Name这一项,其他保持默认,点击OK.</li>
<li>点击OK后,会弹出Add items to the Project界面,选择Add Existing
File,选中我们已经写好的RTL代码和Testbench代码,然后点击OK.</li>
<li>添加完代码后,在Modelsim上面一栏中选择Compile-&gt;Compile
All,软件就会编译所有的代码,如果代码正确,就会显示绿色的勾.</li>
<li>编译完成后,在Modelsim上面一栏中选择Simulate-&gt;Start
Simulation,这时会弹出一个窗口,点击Optimization
Options,在Visibility页面中勾选Apply full visibility to all modules(full
debug mode),然后在Options页面的Optimization一栏中勾选Disable
Optimization(-o0),最后点击OK保存选项.</li>
<li>设置好Optimization
Options之后,点击work左边的加号”+“,选中Testbench代码,然后点击OK.</li>
<li>此时会出现一个界面,我们用右键点击Testbench下面的实例化模块(通常以u_…开头),选择Add
Wave选项,就可以打开示波(Wave)界面了.</li>
<li>在Wave界面的最上面一栏,可以设置仿真的时间,然后点击右边的按钮就可以进行仿真了.</li>
</ol>
<h2 id="vivado的安装">Vivado的安装</h2>
<p>在网上找到Vivado的及其许可证license的安装包, 直接安装即可.</p>
<h2 id="vivado的使用">Vivado的使用</h2>
<h3 id="基本操作">基本操作</h3>
<ol type="1">
<li>打开Vivado软件,在最上面的Quick Start一栏中点击”Create
Project”,然后在弹出的窗口中点击”Next”,然后填写Project
Name和工程路径,点击”Next”后,仅勾选”RTL
Project”,再点”Next”,会相继弹出”Add Sources”和”Add
Constraints”,我们直接跳过这两项,接下来选择开发板的芯片型号,我们在Search一栏里面输入”xc7z020clg400-2”,选中这个型号的芯片后点击”Next”,就可以进入工程主界面了.</li>
<li>在工程主界面中,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,里面有三个选项
<ol type="1">
<li>Add or create constraints:添加或者创建管脚约束文件</li>
<li>Add or create design sources:添加或者创建RTL文件</li>
<li>Add or create simulation source:添加或者创建Testbench文件</li>
</ol></li>
<li>我们勾选Add or create design sources,在弹出的界面中选择”Add
Files”,添加我们已经写好的RTL代码文件,然后点击”Finish”,再点击”OK”,然后是”Yes”.</li>
<li>这时,Sources窗口下”Design
Sources”目录下就会出现我们刚刚添加的RTL文件了,利用同样的方法可以在Sources窗口下”Constrains”和”Simulation
Sources”目录下分别添加管脚约束文件和Testbench文件.</li>
<li>事实上,在添加好RTL文件后,就可以进行分析(Elaborated)与综合(Synthesis)了.点击工程主界面左侧一栏”Flow
Navigator”中的”Open Elaborated
Design”,此时,Vivado会编译RTL源文件并且进行语法检查,分析完成后,会增加”Schematic(原理图)“和”Netlist(网表)“窗口.</li>
<li>然后,我们点击工程主界面左侧一栏”Flow Navigator”中的”Run
Synthesis”来对代码进行综合,在弹出的窗口中直接点击”OK”.综合完成后,会弹出一个窗口,我们直接关闭.</li>
<li>接下来进行管脚约束,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,勾选Add or create constrains,在弹出的界面中选择”Create
File”,在弹出的对话框中填写约束文件的名称,注意约束文件是后缀为”XDC”的文本文件,然后点击”OK”和”Finish”,这时,Sources窗口下”Constrains”目录下就会出现我们刚刚添加的约束文件了.</li>
<li>我们双击打开这个约束文件,写好约束代码,然后保存即可.</li>
<li>下面我们可以实现设计了,点击工程主界面左侧一栏”Flow
Navigator”中的”Run
Implementation”,在弹出的界面直接点击”OK”,实现完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>在下载程序之前,首先要生成用于下载到器件中的比特流文件,点击工程主界面左侧一栏”Flow
Navigator”中的”Generate
Bitstream”,在弹出的窗口中直接点击”OK”,生成比特流完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>最后我们下载比特流,点击工程主界面左侧一栏”Flow Navigator”中的”Open
Hardware Manager”,然后工程主界面的窗口布局就会发生变化.</li>
<li>这时,我们将Xilinx下载器一端连接到电脑,另一端连接到JTAG接口,然后连接开发板电源线,打开开发板上面的电源开关.</li>
<li>在工程主界面中”Hardware”子窗口中点击”Auto
Connect”按钮(就是长得像关节一样的那个),再点击”Program
device”,点击”Program”,此时就会下载比特流文件到板子上,并且可以在板子上看到现象.</li>
</ol>
<h3 id="ip核">IP核</h3>
<h4
id="集成逻辑分析器integrated-logic-analyzerila">集成逻辑分析器(Integrated
Logic Analyzer,ILA)</h4>
<p>传统的FPGA板级调试是由外接的逻辑分析仪连接到FPGA的控制管脚,然后将内部信号引出至引脚IO上,进行板级调试.在线逻辑分析仪利用FPGA中的逻辑资源,将这些功能植入到FPGA的设计中.</p>
<p>在线逻辑分析仪通过一个或者多个探针(Probe)来采集希望观察的信号,然后通过片内的JTAG硬核组件来将捕获到的数据传送给下载器,进而上传到Vivado
IDE以供用户查看.Vivado
IDE也可以按照上述的路径,向在线逻辑分析仪传输一些控制信息.</p>
<p>在Vivado中,在线逻辑分析仪的功能被称为”集成逻辑分析器(ILA)“,它以IP核的形式来加入到用户设计中.Vivado提供了三种具有不同集成层次的插入ILA方法,以满足不同Vivado用户的需求.</p>
<p>这里我们介绍第一种:</p>
<h5 id="hdl实例化调试探针流程">HDL实例化调试探针流程</h5>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”ILA”关键字,我们找到”Debug
&amp; Verification”下的”Debug”下的”ILA(Integrated Logic
Analyzer)“,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”ila_0”.</p>
<p>IP核的配置包含两个子界面,分别是”General
Options”和”Probe_Ports(0..0)”</p>
<p>在”General Options”界面中,“Number of
Probe”一栏用于设置所需的探针数量,一般来说,一个探针对应一个待测信号.”Sample
Data
Depth”用于设置采样深度,在每个时钟采样下,ILA都会将捕获到的探针信号的值送入RAM中,由于RAM存储空间是有限的,所以此选项就用于设置RAM最大存储多少个探针信号的值,我们一般保持默认1024,数值阅读,占用的RAM资源就越多.其他的选项保持默认.</p>
<p>在”Probe_Ports(0..0)“中,用于设置每个探针的参数,一般我们只需要设置每个探针的宽度”Probe
Width”即可,例如,“sys_rst_n”,“led”,“cnt”分别是1位,2位,26位,所以我们就设置探针1,探针2,探针3的宽度分别为1位,2位,26位.</p>
<p>设置完成后,点击”OK”,“Generate”即可生成IP核.</p>
<p>生成好后,在”Sources”窗口下的”IP
Sources”中,打开”ila_0.veo”文件,将其中的模板代码复制到用户设计的RTL代码中,然后修改代码,将IP核的时钟信号连接到”sys_clk”,“probe1”连接到”sys_rst_n”,“probe2”连接到”led”,“probe3”连接到”cnt”.</p>
<p>完成后,就可以保存,直接综合并且生成比特流.我们打开”Hardware
Manager”,连接到开发板,并且下载比特流.在弹出的窗口中,点击”Program”,Vivado就会自动弹出ILA调试窗口.</p>
<p>如果Waveform窗口缺少信号,可以点击上面一栏的加号”+(add
probes)“将所有探针信号加入到波形窗口中.然后,我们点击上面一栏的三角形符号”run
trigger for this ILA core”,就可以观察到此时信号的波形.</p>
<p>在调试完毕后,可以在顶层RTL代码中注释掉ILA IP核的实例化.</p>
<h4 id="clocking-wizard">Clocking Wizard</h4>
<p>首先创建一个新的工程,命名为”ip_clk_wiz”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP
Catalog”窗口后,在Search中搜索”clock”关键字,Vivado就会自动查找包含”clock”的IP核,我们找到”FPGA
Features and Design”下的”Clocking”下的”Clocking
Wizard”,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的时钟参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”clk_wiz_1”.</p>
<p>在第一个”Clocking
Options”选项卡中,“Primitive”一行可以选择使用MMCM模块还是PLL模块,我们选用功能比较多的MMCM模块.我们还需要修改”Input
Clock
Information”一栏,把”Primitive”的时钟输入频率修改为开发板核心板的晶振频率
<span class="math inline">\(50\rm{MHz}\)</span>,其他的设置保持默认.</p>
<p>接下来切换至”Output Clocks”选项卡,在”Output
Clock”一栏中,勾选前四个时钟(表明我们需要四个输出),并且在”Output
Freq(MHZ)“中分别设置为”<span
class="math inline">\(100,100,50,25\)</span>“,第二个<span
class="math inline">\(100\rm{MHZ}\)</span>时钟的相移”Phase(degrees)“一栏设置为”<span
class="math inline">\(180\)</span>“.</p>
<p>接下来切换至”Port
Renaming”,这个选项卡主要是对于一些控制信号的重命名.这里我们只用到锁定指示locked信号,其名称保持默认即可.</p>
<p>接下来切换至”MMCM
Setting”和”Summary”,这两个选项卡都保持默认,都点击OK.之后就会弹出”Generate
Output Products”窗口,我们直接点击”Generate”即可.</p>
<p>之后我们可以看到在”Design Run”窗口的”Out-of-Context Module
Runs”一栏中出现了该IP核对应的run”clk_wiz_0_synth_1”,其综合过程独立于顶层模块的综合.</p>
<h4 id="block-memory">Block Memory</h4>
<p>首先创建一个新的工程,命名为”ip_ram”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”Block
Memory”关键字,我们找到”Block Memory
Generator”(这里会出现两个相同名字的IP核,它们实际上是一样的),点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component Name”默认为”blk_mem_gen_0”,我们保持默认.</p>
<p>Interface
Type:RAM接口总线,这里保持默认的Native类型(标准RAM接口总线)</p>
<p>Memory Type:存储器类型.可以配置成Single Port RAM(单端口RAM),Simple
Dual Port RAM(伪双端口RAM),True Dual Port RAM(真双端口RAM),Single Port
ROM(单端口ROM),Dual Port ROM(双端口ROM).这里我们选择Single Port RAM.</p>
<p>ECC Options:即Error Correction
Capability,纠错能力选项,单端口RAM不支持ECC</p>
<p>Write
Enable:字节使能选项,选中后可以单独将数据的某个字节写入RAM中,这里不勾选.</p>
<p>Algorithm Options:算法选项.可选择Minimum Area(最小面积),Low
Power(低功耗),Fixed Primitives(固定原语),这里保持默认的Minimum Area.</p>
<p>“Port A Options”界面中,设置端口A的参数</p>
<p>Write Width:端口A写数据位宽,这里设置成8位</p>
<p>Read Width:端口A读数据位宽,这里设置成8位</p>
<p>Write
Width:端口A写数据深度,这里设置成32,即RAM所能访问的地址范围为0-31</p>
<p>Read Width:端口A读数据位宽,这里设置成32</p>
<p>Operating Mode:RAM读写模式.一共有三种模式</p>
<ol type="1">
<li>Write First:写优先模式,数据先写入RAM中,下一个时钟周期读出该数据</li>
<li>Read
First:读优先模式,数据先写入RAM中,同时输出RAM中同地址的上一次数据</li>
<li>No
Change:不变模式,读写分开操作,不能同时进行读写,我们选择这个选项</li>
</ol>
<p>Enable Port Type:使能端口类型.Use ENA Pin(添加使能端口A信号),Always
Enabled(取消使能信号,端口A一直处于使能状态),这里选择Use ENA Pin</p>
<p>Port A Optional Output
Register:端口A输出寄存器选项.其中我们取消勾选”Primitives Output
Register”</p>
<p>Port A Optional Reset
Options:RAM复位信号选项,这里不添加复位信号,保持默认.</p>
<p>接下来的”Other
Options”和”Summary”页面都不需要设置,点击”OK”,“Generate”选项后,就可以生成IP核了.</p>
<h4 id="fifo">FIFO</h4>
<p>首先创建一个新的工程,命名为”ip_fifo”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”fifo”关键字,我们找到”Memories
&amp; Storage Elements”下的”FIFOs”下的”FIFO
Generator”,点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component
Name”默认为”fifo_generator_0”,我们保持默认.</p>
<p>Interface
Type:用于选择FIFO接口的类型,这里保持默认的Native类型(标准FIFO接口)</p>
<p>FIFO
Implementation:选择实现同步FIFO或者异步FIFO,这里我们选择”Independent
Clocks Block RAM”,即使用块RAM来实现异步FIFO</p>
<p>“Native Ports”界面中</p>
<p>Read Mode:设置读FIFO时的读模式,这里选择默认的”Standard FIFO”</p>
<p>Data Port Parameters:设置读写端口的数据总线宽度以及FIFO的深度,“Write
Width”设置为8位,“Write Depth”设置为256位(注意FIFO
IP核实际实现的深度是255位),“Read Width”和”Read Depth”设置同上.</p>
<p>Reset Pin:这里我们只是观察FIFO的读写,我们取消勾选这个选项.</p>
<p>“Status Flags”界面</p>
<p>我们勾选”Almost Full Flag(即将写满)“和”Almost Empty
Flag(即将读空)“这两个选项,其他保持默认</p>
<p>“Data
Counts”选项卡用于设置FIFO内部数据计数的输出信号,此信号表示当前FIFO内存在多少个有效的数据,这里我们勾选”Write
Data Count(写数据计数)“和”Read Data
Count(读数据计数)“,且计数值总线的位宽”Write/Read Count
Width”设置成8位</p>
<p>“Summary”界面是总结,我们之间点击”OK”,“Generate”,就可以生成IP核了.</p>
<h3 id="uart串口通信">UART串口通信</h3>
<p>串行通信分为两种方式,同步串行通信和异步串行通信.同步串行通信需要双方在同一时钟控制下同步传输数据;异步串行通信是通信双方使用各自的时钟控制数据的发送和接收过程.</p>
<p>UART是一种采用异步串行通信方式的通用异步收发传输器(universal
asynchroonous
receiver-transmitter),它在发送数据时将并行数据转化成串行数据来传输,在接收数据时把接收到的串行数据再转化成并行数据.</p>
<p>UART串口通信需要两根信号线,一根用于串口发送,一根用于串口接收.UART在发送或者接收过程中的一帧数据由4部分组成:</p>
<ol type="1">
<li>起始位:标志着一帧数据的起始</li>
<li>停止位:标志着一帧数据的结束</li>
<li>数据位:一帧数据中的有效数据</li>
<li>奇偶检验位:分为奇校验和偶校验,用于检测数据在传输过程中是否出错</li>
</ol>
<p>UART通信过程中的数据格式和传输速率是可以设置的,为了正确的通信,收发双方应该约定好同样的设置.数据位可以选择5,6,7,8位,其中8位数据最常用.校验位可以选择奇校验,偶校验或者无校验位.停止位可以选择1位(默认),1.5位,2位.串口通信的速率用波特率表示,它表示每秒传输二进制数据的位数,单位是bps(位/秒),常用的波特率有9600,19200,38400,57600,115200等.</p>
<p>设置好数据格式和传输速率之后,UART负责完成串并数据的转换,而信号的传输则由外部驱动电路实现.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:gdb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 17:49:37" itemprop="dateModified" datetime="2025-08-07T17:49:37+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入<code>printf</code>，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的代码行等。掌握了gdb的用法之后，调试手段就更加丰富了。但要注意，即使调试手段丰富了，调试的基本思想仍然是“分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设”这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用而忽略了分析过程，往往会治标不治本地修正Bug，导致一个错误现象消失了但Bug仍然存在，甚至是把程序越改越错。本章通过初学者易犯的几个错误实例来讲解如何使用gdb调试程序，在每个实例后面总结一部分常用的gdb命令。</p>
<h2 id="单步执行和跟踪函数调用">单步执行和跟踪函数调用</h2>
<p>看下面的程序：</p>
<p>例 函数调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">    result[<span class="number">0</span>] = add_range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    result[<span class="number">1</span>] = add_range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>, result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_range</code>函数从<code>low</code>加到<code>high</code>，在<code>main</code>函数中首先从<code>1</code>加到<code>10</code>，把结果保存下来，然后从<code>1</code>加到<code>100</code>，再把结果保存下来，最后打印的两个结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br></pre></td></tr></table></figure>
<p>第一个结果正确[20]，第二个结果显然不正确，在小学我们就听说过高斯小时候的故事，从1加到100应该是5050。一段代码，第一次运行结果是对的，第二次运行却不对，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。在动手调试之前，读者先试试只看代码能不能看出错误原因，只要前面几章学得扎实就应该能看出来。</p>
<p>在编译时要加上<code>-g</code>选项，生成的可执行文件才能用gdb进行源码级调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g main.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">GNU gdb 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入<code>help</code>可以查看命令的类别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure>
<p>也可以进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help files</span><br><span class="line">Specifying and examining files.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">add-shared-symbol-files -- Load the symbols from shared objects in the dynamic linker&#x27;s link map</span><br><span class="line">add-symbol-file -- Load symbols from FILE</span><br><span class="line">add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file</span><br><span class="line">cd -- Set working directory to DIR for debugger and program being debugged</span><br><span class="line">core-file -- Use FILE as core dump for examining memory and registers</span><br><span class="line">directory -- Add directory DIR to beginning of search path for source files</span><br><span class="line">edit -- Edit specified file or function</span><br><span class="line">exec-file -- Use FILE as program for getting contents of pure memory</span><br><span class="line">file -- Use FILE as program to be debugged</span><br><span class="line">forward-search -- Search for regular expression (see regex(3)) from last line listed</span><br><span class="line">generate-core-file -- Save a core file with the current state of the debugged process</span><br><span class="line">list -- List specified function or line</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在试试用<code>list</code>命令从第一行开始列出源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 1</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>一次只列10行，如果要从第11行开始继续列源代码可以输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure>
<p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) （直接回车）</span><br><span class="line">11  int main(void)</span><br><span class="line">12  &#123;</span><br><span class="line">13      int result[100];</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">17      return 0;</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>gdb的很多常用命令有简写形式，例如<code>list</code>命令可以写成<code>l</code>，要列一个函数的源代码也可以用函数名做参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l add_range</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>现在退出gdb的环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>我们做一个实验，把源代码改名或移到别处再用gdb调试，这样就列不出源代码了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> main.c mian.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) l</span><br><span class="line">5	main.c: No such file or directory.</span><br><span class="line">	in main.c</span><br></pre></td></tr></table></figure>
<p>可见gcc的<code>-g</code>选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用<code>start</code>命令开始执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14		result[0] = add_range(1, 10);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb停在<code>main</code>函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句。我们可以用<code>next</code>命令（简写为<code>n</code>）控制这些语句一条一条地执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">15		result[1] = add_range(1, 100);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">16		printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br><span class="line">17		return 0;</span><br></pre></td></tr></table></figure>
<p>用<code>n</code>命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在<code>return</code>语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在<code>main</code>函数中而在<code>add_range</code>函数中，现在用<code>start</code>命令重新来过，这次用<code>step</code>命令（简写为<code>s</code>）钻进<code>add_range</code>函数中去跟踪执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line"></span><br><span class="line">Breakpoint 2 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=10) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br></pre></td></tr></table></figure>
<p>这次停在了<code>add_range</code>函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，<code>backtrace</code>命令（简写为<code>bt</code>）可以查看函数调用的栈帧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=10) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br></pre></td></tr></table></figure>
<p>可见当前的<code>add_range</code>函数是被<code>main</code>函数调用的，<code>main</code>传进来的参数是<code>low=1</code>,
<code>high=10</code>。<code>main</code>函数的栈帧编号为<code>1</code>，<code>add_range</code>的栈帧编号为<code>0</code>。现在可以用<code>info</code>命令（简写为<code>i</code>）查看<code>add_range</code>函数局部变量的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i locals</span><br><span class="line">i = 0</span><br><span class="line">sum = 0</span><br></pre></td></tr></table></figure>
<p>如果想查看<code>main</code>函数当前局部变量的值也可以做到，先用<code>frame</code>命令（简写为<code>f</code>）选择<code>1</code>号栈帧然后再查看局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br><span class="line">14	    result[0] = add_range(1, 10);</span><br><span class="line">(gdb) i locals </span><br><span class="line">result = &#123;0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>result</code>数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用<code>s</code>或<code>n</code>往下走几步，然后用<code>print</code>命令（简写为<code>p</code>）打印出变量<code>sum</code>的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 3</span></span><br></pre></td></tr></table></figure>
<p>第一次循环<code>i</code>是<code>1</code>，第二次循环<code>i</code>是<code>2</code>，加起来是<code>3</code>，没错。这里的<code>$1</code>表示gdb保存着这些中间结果，<code>$</code>后面的编号会自动增长，在命令中可以用<code>$1</code>、<code>$2</code>、<code>$3</code>等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用<code>finish</code>命令让程序一直运行到从当前函数返回为止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=10) at main.c:6</span><br><span class="line">0x080483c1 in main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">Value returned is $2 = 55</span><br></pre></td></tr></table></figure>
<p>返回值是55，当前正准备执行赋值操作，用<code>s</code>命令赋值，然后查看<code>result</code>数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480,</span> </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值55确实赋给了<code>result</code>数组的第<code>0</code>个元素。下面用<code>s</code>命令进入第二次<code>add_range</code>调用，进入之后首先查看参数和局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=100) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=100) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483db <span class="keyword">in</span> main () at main.c:15</span></span><br><span class="line">(gdb) i locals </span><br><span class="line">i = 11</span><br><span class="line">sum = 55</span><br></pre></td></tr></table></figure>
<p>由于局部变量<code>i</code>和<code>sum</code>没初始化，所以具有不确定的值，又由于两次调用是挨着的，<code>i</code>和<code>sum</code>正好取了上次调用时的值，原来这跟例
3.7
“验证局部变量存储空间的分配和释放”是一样的道理，只不过我这次举的例子设法让局部变量<code>sum</code>在第一次调用时初值为<code>0</code>了。<code>i</code>的初值不是<code>0</code>倒没关系，在<code>for</code>循环中会赋值为<code>0</code>的，但<code>sum</code>如果初值不是<code>0</code>，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出gdb修改源代码了。如果我们不想浪费这次调试机会，可以在gdb中马上把<code>sum</code>的初值改为<code>0</code>继续运行，看看这一处改了之后还有没有别的Bug：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var sum=0</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=100) at main.c:6</span><br><span class="line">0x080483db in main () at main.c:15</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">Value returned is $4 = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5050</span><br><span class="line">17      return 0;</span><br></pre></td></tr></table></figure>
<p>这样结果就对了。修改变量的值除了用<code>set</code>命令之外也可以用<code>print</code>命令，因为<code>print</code>命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用<code>print</code>命令修改变量的值或者调用函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 33</span></span><br><span class="line">(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])</span><br><span class="line">result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 13</span></span><br></pre></td></tr></table></figure>
<p>我们讲过，<code>printf</code>的返回值表示实际打印的字符数，所以<code>$6</code>的结果是<code>13</code>。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>backtrace（或bt）</td>
<td>查看各级函数调用及参数</td>
</tr>
<tr>
<td>finish</td>
<td>连续运行到当前函数返回为止，然后停下来等待命令</td>
</tr>
<tr>
<td>frame（或f） 帧编号</td>
<td>选择栈帧</td>
</tr>
<tr>
<td>info（或i） locals</td>
<td>查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td>list（或l）</td>
<td>列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td>list 行号</td>
<td>列出从第几行开始的源代码</td>
</tr>
<tr>
<td>list 函数名</td>
<td>列出某个函数的源代码</td>
</tr>
<tr>
<td>next（或n）</td>
<td>执行下一行语句</td>
</tr>
<tr>
<td>print（或p）</td>
<td>打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td>quit（或q）</td>
<td>退出gdb调试环境</td>
</tr>
<tr>
<td>set var</td>
<td>修改变量的值</td>
</tr>
<tr>
<td>start</td>
<td>开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td>step（或s）</td>
<td>执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
</tbody>
</table>
<h2 id="断点">断点</h2>
<p>看以下程序：</p>
<p>例 断点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用是：首先从键盘读入一串数字存到字符数组<code>input</code>中，然后转换成整型存到<code>sum</code>中，然后打印出来，一直这样循环下去。<code>scanf("%s", input);</code>这个调用的功能是等待用户输入一个字符串并回车，<code>scanf</code>把其中第一段非空白（非空格、<code>Tab</code>、换行）的字符串保存到<code>input</code>数组中，并自动在末尾添加<code>'\0'</code>。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是<code>"2345"</code>，则循环累加的过程是<code>(((0*10+2)*10+3)*10+4)*10+5=2345</code>。注意字符型的<code>'2'</code>要减去<code>'0'</code>的ASCII码才能转换成整数值<code>2</code>。下面编译运行程序看看有什么问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">234</span><br><span class="line">input=123234</span><br><span class="line">（Ctrl-C退出程序）</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅<code>sum</code>赋了初值，连不必赋初值的<code>i</code>都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br></pre></td></tr></table></figure>
<p>有了上一次的经验，<code>sum</code>被列为重点怀疑对象，我们可以用<code>display</code>命令使得每次停下来的时候都显示当前<code>sum</code>的值，然后继续往下走：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display sum</span><br><span class="line">1: sum = -1208103488</span><br><span class="line">(gdb) n</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 0</span><br><span class="line">(gdb) </span><br><span class="line">123</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 0</span><br></pre></td></tr></table></figure>
<p><code>undisplay</code>命令可以取消跟踪显示，变量<code>sum</code>的编号是<code>1</code>，可以用<code>undisplay 1</code>命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用<code>break</code>命令（简写为<code>b</code>）在第9行设一个断点（Breakpoint）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">5       int sum = 0, i;</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">11              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">12          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">13      &#125;</span><br><span class="line">14      return 0;</span><br><span class="line">(gdb) b 9</span><br><span class="line">Breakpoint 2 at 0x80483bc: file main.c, line 9.</span><br></pre></td></tr></table></figure>
<p><code>break</code>命令的参数也可以是函数名，表示在某个函数开头设断点。现在用<code>continue</code>命令（简写为<code>c</code>）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>然后输入新的字符串准备转换：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">234</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>问题暴露出来了，新的转换应该再次从<code>0</code>开始累加，而<code>sum</code>现在已经是<code>123</code>了，原因在于新的循环没有把<code>sum</code>归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，“断点加单步”是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用<code>printf</code>打印中间结果时也要分析应该在哪里插入<code>printf</code>，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用<code>info</code>命令可以查看已经设置的断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 3 at 0x8048411: file main.c, line 12.</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>每个断点都有一个编号，可以用编号指定删除某个断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints 2</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoints 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep n   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) enable 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>
<p>gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当<code>sum</code>不等于<code>0</code>时才中断，然后用<code>run</code>命令（简写为<code>r</code>）重新从程序开头连续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 9 if sum != 0</span><br><span class="line">Breakpoint 5 at 0x80483c3: file main.c, line 9.</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">5       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    stop only if sum != 0</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 5, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>结果是第一次执行<code>scanf</code>之前没有中断，第二次却中断了。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break（或b） 行号</td>
<td>在某一行设置断点</td>
</tr>
<tr>
<td>break 函数名</td>
<td>在某个函数开头设置断点</td>
</tr>
<tr>
<td>break … if …</td>
<td>设置条件断点</td>
</tr>
<tr>
<td>continue（或c）</td>
<td>从当前位置开始连续运行程序</td>
</tr>
<tr>
<td>delete breakpoints 断点号</td>
<td>删除断点</td>
</tr>
<tr>
<td>display 变量名</td>
<td>跟踪查看某个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td>disable breakpoints 断点号</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable 断点号</td>
<td>启用断点</td>
</tr>
<tr>
<td>info（或i） breakpoints</td>
<td>查看当前设置了哪些断点</td>
</tr>
<tr>
<td>run（或r）</td>
<td>从头开始连续运行程序</td>
</tr>
<tr>
<td>undisplay 跟踪显示号</td>
<td>取消跟踪显示</td>
</tr>
</tbody>
</table>
<h2 id="观察点">观察点</h2>
<p>接着上一节的步骤，经过调试我们知道，虽然<code>sum</code>已经赋了初值<code>0</code>，但仍需要在<code>while (1)</code>循环的开头加上<code>sum = 0;</code>：</p>
<p>例 观察点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>scanf</code>函数是非常凶险的，即使修正了这个Bug也还存在很多问题。如果输入的字符串超长了会怎么样？我们知道数组访问越界是不会检查的，所以<code>scanf</code>会写出界。现象是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">67</span><br><span class="line">input=67</span><br><span class="line">12345</span><br><span class="line">input=123407</span><br></pre></td></tr></table></figure>
<p>下面用调试器看看最后这个诡异的结果是怎么出来的[21]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p input</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;12345&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>input</code>数组只有<code>5</code>个元素，写出界的是<code>scanf</code>自动添的<code>'\0'</code>，用<code>x</code>命令看会更清楚一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x00    0x00</span><br></pre></td></tr></table></figure>
<p><code>x</code>命令打印指定存储单元的内容。<code>7b</code>是打印格式，<code>b</code>表示每个字节一组，<code>7</code>表示打印<code>7</code>组[22]，从<code>input</code>数组的第一个字节开始连续打印<code>7</code>个字节。前<code>5</code>个字节是<code>input</code>数组的存储单元，打印的正是十六进制ASCII码的<code>'1'</code>到<code>'5'</code>，第<code>6</code>个字节是写出界的<code>'\0'</code>。根据运行结果，前4个字符转成数字都没错，第5个错了，也就是<code>i</code>从0到3的循环都没错，我们设一个条件断点从<code>i</code>等于4开始单步调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           sum = 0;</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">13          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">14      &#125;</span><br><span class="line">15      return 0;</span><br><span class="line">(gdb) b 12 if i == 4</span><br><span class="line">Breakpoint 2 at 0x80483e6: file main.c, line 12.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:12</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1234</span></span><br></pre></td></tr></table></figure>
<p>现在<code>sum</code>是<code>1234</code>没错，根据运行结果是<code>123407</code>我们知道即将进行的这步计算肯定要出错，算出来应该是<code>12340</code>，那就是说<code>input[4]</code>肯定不是<code>'5'</code>了，事实证明这个推理是不严谨的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x04    0x00</span><br></pre></td></tr></table></figure>
<p><code>input[4]</code>的确是<code>0x35</code>，产生<code>123407</code>还有另外一种可能，就是在下一次循环中<code>123450</code>不是加上而是减去一个数得到<code>123407</code>。可现在不是到字符串末尾了吗？怎么会有下一次循环呢？注意到循环控制条件是<code>input[i] != '\0'</code>，而本来应该是<code>0x00</code>的位置现在莫名其妙地变成了<code>0x04</code>，因此循环不会结束。继续单步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 12345</span></span><br><span class="line">(gdb) n</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x05    0x00</span><br></pre></td></tr></table></figure>
<p>进入下一次循环，原来的<code>0x04</code>又莫名其妙地变成了<code>0x05</code>，这是怎么回事？这个暂时解释不了，但<code>123407</code>这个结果可以解释了，是<code>12345*10 + 0x05 - 0x30</code>得到的，虽然多循环了一次，但下次一定会退出循环了，因为<code>0x05</code>的后面是<code>'\0'</code>。</p>
<p><code>input[4]</code>后面那个字节到底是什么时候变的？可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。下面删除原来设的断点，从头执行程序，重复上次的输入，用<code>watch</code>命令设置观察点，跟踪<code>input[4]</code>后面那个字节（可以用<code>input[5]</code>表示，虽然这是访问越界）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) watch input[5]</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line">(gdb) i watchpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       hw watchpoint  keep y              input[5]</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 0 &#x27;\0&#x27;</span><br><span class="line">New value = 1 &#x27;\001&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 1 &#x27;\001&#x27;</span><br><span class="line">New value = 2 &#x27;\002&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 2 &#x27;\002&#x27;</span><br><span class="line">New value = 3 &#x27;\003&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br></pre></td></tr></table></figure>
<p>已经很明显了，每次都是回到<code>for</code>循环开头的时候改变了<code>input[5]</code>的值，而且是每次加<code>1</code>，而循环变量<code>i</code>正是在每次回到循环开头之前加<code>1</code>，原来<code>input[5]</code>就是变量<code>i</code>的存储单元，换句话说，<code>i</code>的存储单元是紧跟在<code>input</code>数组后面的。</p>
<p>修正这个Bug对初学者来说有一定难度。如果你发现了这个Bug却没想到数组访问越界这一点，也许一时想不出原因，就会先去处理另外一个更容易修正的Bug：如果输入的不是数字而是字母或别的符号也能算出结果来，这显然是不对的，可以在循环中加上判断条件检查非法字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123a</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">dead</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234578</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">23</span><br><span class="line">input=23</span><br></pre></td></tr></table></figure>
<p>似乎是两个Bug一起解决掉了，但这是治标不治本的解决方法。看起来输入超长的错误是不出现了，但只要没有找到根本原因就不可能真的解决掉，等到条件一变，它可能又冒出来了，在下一节你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入超长也会报错。最后总结一下本节用到的gdb命令：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch</td>
<td>设置观察点</td>
</tr>
<tr>
<td>info（或i） watchpoints</td>
<td>查看当前设置了哪些观察点</td>
</tr>
<tr>
<td>x</td>
<td>从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量</td>
</tr>
</tbody>
</table>
<h2 id="段错误">段错误</h2>
<p>如果程序运行时出现段错误，用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程序：</p>
<p>例 段错误调试实例一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> man = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, man);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0xb7e1404b <span class="keyword">in</span> _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0xb7e1dd2b <span class="keyword">in</span> scanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0804839f <span class="keyword">in</span> main () at main.c:6</span></span><br></pre></td></tr></table></figure>
<p>在gdb中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。gdb显示段错误出现在<code>_IO_vfscanf</code>函数中，用<code>bt</code>命令可以看到这个函数是被我们的<code>scanf</code>函数调用的，所以是<code>scanf</code>这一行代码引发的段错误。仔细观察程序发现是<code>man</code>前面少了个<code>&amp;</code>。</p>
<p>继续调试上一节的程序，上一节最后提出修正Bug的方法是在循环中加上判断条件，如果不是数字就报错退出，不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无论怎么运行都不出错了，但假如我们把<code>while (1)</code>循环去掉，每次执行程序只转换一个数：</p>
<p>例 段错误调试实例二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输入一个超长的字符串，看看会发生什么：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br></pre></td></tr></table></figure>
<p>看起来正常。再来一次，这次输个更长的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>又出段错误了。我们按同样的方法用gdb调试看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0804848e in main () at main.c:19</span><br><span class="line">19  &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">14          &#125;</span><br><span class="line">15          sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">16      &#125;</span><br><span class="line">17      printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">18      return 0;</span><br><span class="line">19  &#125;</span><br></pre></td></tr></table></figure>
<p>gdb指出，段错误发生在第<code>19</code>行。可是这一行什么都没有啊，只有表示<code>main</code>函数结束的<code>&#125;</code>括号。这可以算是一条规律，如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误。</p>
<p>想要写出Bug-free的程序是非常不容易的，即使<code>scanf</code>读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误，有些错误现象是我们暂时没法解释的：为什么变量<code>i</code>的存储单元紧跟在<code>input</code>数组后面？为什么同样是访问越界，有时出段错误有时不出段错误？为什么访问越界的段错误在函数返回时才出现？还有最基本的问题，为什么<code>scanf</code>输入整型变量就必须要加<code>&amp;</code>，否则就出段错误，而输入字符串就不要加<code>&amp;</code>？这些问题在后续章节中都会解释清楚。其实现在讲<code>scanf</code>这个函数为时过早，读者还不具备充足的基础知识。但还是有必要讲的，学完这一阶段之后读者应该能写出有用的程序了，然而一个只有输出而没有输入的程序算不上是有用的程序，另一方面也让读者认识到，学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个<code>scanf</code>函数都没办法用好，更没有办法保证写出正确的程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo+GitHub搭建博客教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-29 20:28:50" itemprop="dateModified" datetime="2025-10-29T20:28:50+08:00">2025-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E7%BD%91%E7%AB%99%E5%88%B6%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">网站制作</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装">安装</h2>
<h3 id="github的注册及创建域名">GitHub的注册及创建域名</h3>
<p>注册这一步就不说了. 注册完成后点击New创建一个新的repository,
在Owner填自己的<code>username</code>, 在Repository
name里面填<code>username.github.io</code> 这样就成功建立了一个域名.</p>
<h3 id="git的安装">Git的安装</h3>
<p>在搜索引擎中直接搜索Git进入官方网站, 点击Download for Windows,
在Standalone Installer下点击64-bit Git for Windows Setup,
下载好之后一直点击next(可以自己设置下载路径)就可以下载完成了.
最后可以按<code>win+R</code>输入cmd, 然后输入<code>git --version</code>,
如果出现git的版本, 说明安装完成.</p>
<p>在git的安装目录下打开git bash, 输入命令</p>
<p><code>ssh-keygen -t rsa -C "你自己的邮箱的地址"</code></p>
<p>然后回车, 遇到Enter file in which to save the
key时输入一个路径,生成的ssh文件就放在那里, 在遇到Enter
passphrase时回车两次(或者输入你自己的密码两次)即可.</p>
<p>打开GitHub网页,在Setting界面点开SSH and GPG keys, 点击New SSH,
title随便输一个名字, 然后打开刚刚生成的id_rsa.pub, 复制里面的内容,
粘贴到key这一栏下面, 然后点击Add SSH key即可.</p>
<h3 id="node.js的安装">Node.js的安装</h3>
<p>在搜索引擎中直接搜索Node js进入官方网站, 点击Recommended For Most
Users的下载按钮, 下载好之后打开, 一直点next 就可以下载完成了.
最后可以按<code>win+R</code>输入cmd,
然后输入<code>node --version</code>, 如果出现node的版本,
说明安装完成.</p>
<h3 id="hexo的安装">Hexo的安装</h3>
<p>在搜索引擎中直接搜索Hexo进入官方网站, 在网站上直接复制下面的代码</p>
<p><code>npm install hexo-cli -g</code></p>
<p>在C盘中创建一个新的文件夹blog,
在其中右键打开git的bash(这里需要安装git才能看见这个选项,
还需要安装node.js)窗口, 将代码粘贴进去回车, 等待下载, 下载好之后,
输入</p>
<p><code>hexo init Blog</code></p>
<p>然后就会发现blog文件夹下面有一个新的Blog文件夹,
在这个文件夹里面打开git bash, 输入</p>
<p><code>npm install</code></p>
<p>安装完成后输入</p>
<p><code>hexo s</code></p>
<p>就会出现一个localhost的网址, 复制之后在浏览器中打开,
就可以看见Hexo的默认界面了.</p>
<h2 id="主题的设置">主题的设置</h2>
<h3 id="next主题">Next主题</h3>
<h4 id="next主题的启用">Next主题的启用</h4>
<p>在C盘Blog文件夹下找到_config.yml文件, 用VScode打开,
在<code>theme</code>后面的东西改成<code>next</code>, Blog里面打开git
bash, 输入<code>hexo s</code>, 复制网站在浏览器打开,
就可以看见Next主题的默认界面了.</p>
<h4 id="语言的更改">语言的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>language</code>选项改成<code>zh-Hans</code>保存好之后,
输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会变成中文了.</p>
<h4 id="标签页和分类页">标签页和分类页</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>menu</code>下面的默认的<code>categories</code>和<code>tags</code>取消注释,
并保存, 输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会有标签页和分类页了,
但是点进去会出现空白页面.</p>
<p>在C盘Blog文件夹下找到source文件夹, 在Blog文件夹下面打开git bash,
输入<code>hexo n page tags</code>回车之后,
source文件里面就会多出来一个tags文件夹，
打开tags文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>标签</code>,
然后增加一行<code>type: "tags"</code>;
同样地输入<code>hexo n page categories</code>回车之后,
source文件里面就会多出来一个categories文件夹，
打开categories文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>分类</code>,
然后增加一行<code>type: "categories"</code>,
保存之后就可以看见标签和分类页了.</p>
<h4 id="主题样式的更改">主题样式的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件,
找到<code>scheme</code>, 把默认的<code>scheme: Muse</code>注释掉,
然后把<code>scheme: Pisces</code>取消注释, 保存即可.</p>
<p>下面来设置Pisces.</p>
<p>头像: 把<code>avatar: /images/avatar.gif</code>取消注释,
在Blog/themes/next/source/images文件夹下面删除默认的avatar.gif,
替换成你自己的femboy.jpg,
然后修改url为<code>url: /images/femboy.jpg</code>然后保存即可.</p>
<p>网站标题: 在C盘Blog文件夹下找到_config.yml文件,
作如下修改<code>title: SiyuanLei'blog</code>,
<code>author: SiyuanLei</code></p>
<p>侧边栏: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>social</code>一栏取消注释,
在对应的社交网站后面改成自己的社交平台链接即可.</p>
<p>友情链接: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>links</code>一栏取消注释, 然后加上一些连接, 比如Arxiv,
Libgen之类的.</p>
<h2 id="文章">文章</h2>
<p>我自己常用的方式是, 在C: _posts下面直接加入一个markdown文件,
但是文件开头一定要是下面的格式:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 第四章:Verilog HDL数字逻辑电路设计方法</span><br><span class="line">date: 2025-05-04</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> [EE,数字设计,Verilog]</span><br><span class="line">tags:</span><br><span class="line"><span class="section">- Verilog</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="博客的发布">博客的发布</h2>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">HSpice的安装及其基本使用方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-29 10:44:52" itemprop="dateModified" datetime="2025-10-29T10:44:52+08:00">2025-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hspice的安装及破解">HSpice的安装及破解</h2>
<p>下载好安装包解压之后,
有两个文件夹<code>HSpice 2009.09</code>和<code>Testbench</code>(我把它改成<code>HSpiceTestbench</code>了).</p>
<p>以管理员身份运行<code>HSpice 2009.09</code>文件夹下的<code>hspice_vC-2009.09_Win_setup.exe</code>和<code>sx_C-2009_09_windows.exe</code>这两个文件,
一路next, 注意安装路径, 就可以完成安装, 接下来是破解方法.</p>
<ol type="1">
<li>产生 License 档桉 (Hspice and Spiceexplorer)到 “keygen”
的目录下执行LicGen.exe 1.1 按 “Open” 开启 “Synopsys.lpd”档桉 1.2
在”Select Host ID” 选择 “Any” 勾选 “Use Daemon”并在 “Select Daemon ID”
选择”Disk” 1.3 按 “Generate” 后会出现一个视窗 “Generated
License”，按Save，将档名储存为 “license.dat” 1.4 复製此 “license.dat”
到目录 “C:_C-2009.09" 下</li>
<li>复製 “lm” 到目录 “C:Files" 下，进入”lm” 目录执行 “lmtools.exe” 2.1
选 “Config Services” 在”Service Name” 输入 “SPICE_Explorer_Server”
在”Path to the lmgrd.exe file” 按 “Browse” 选择 “lm” 目录下的
“lmgrd.exe” 在”Path to the license file” 按 “Browse” 选择步骤 2.3
所产生的 license.dat (将档桉类型选为 “*.dat”才可以选择) 在”Path to the
debug log file” 按 “Browse” 输入 “debug” 后按开启 勾选 “Use Services” 和
“Start Server at Power Up” 然后按 “Save Service” 2.2 在 “Service/License
File” 勾选 “Configuration using Services” 并选择 SPICE_Explorer_Server
2.3 选 “Start/Stop/Reread” ， 按 “Stop Server” 再按 “Start Server”</li>
<li>环境变数设定 (Hspice and Spiceexplorer) 到桌面选”我的电脑”按右键
=&gt; 内容 =&gt; 进阶 =&gt; 环境变数 在”xxx的使用者变数” 按
“新增”，变数名称 = LM_LICENSE_FILE 变数值 =
27000@localhost;C:_C-2009.09.dat 若已经有 LM_LICENSE_FILE ，请以分号 “;”
隔开加入 27000@localhost 和 C:_C-2009.09.dat 到变数值</li>
<li>复製 “Meta.cfg” 和 “Hspice.ini” 到 “C:_C-2009.09" 目录下</li>
</ol>
<h2 id="hspice的基本使用方法">HSpice的基本使用方法</h2>
<p>在目录<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\HSPICE C-2009.09</code>下打开Hspui
C-2009.09, 出现界面, 点击open,
打开<code>HSpiceTestbench</code>下的任意一个网表文件(后缀是.sp),
这里以inv.sp为例, 以文本文件打开inv.sp, 可以看到其关联的工艺库,
这里把工艺库的路径改成<code>.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</code>,
这个工艺库可以在这个目录下的对应文件中找到细节.</p>
<p>然后点击最上面一栏的configuration-&gt;versions,
在cscope中关联波形观测器,
也就是把<code>C:\Program Files (x86)\Synopsys\CustomExplorer C-2009.09\sx.exe</code>复制到这一栏中,
然后点击OK. 然后在最上面一栏中的File-&gt;Save Configuration保存设置.</p>
<p>接下来进行仿真, 点击Simulate, 仿真完成后再点击Edit LL,
如果出现<code>***** job concluded 1****** HSPICE -- C-2009.09 32-BIT (Aug 24 2009) winnt ******</code>
的字样, 则说明仿真成功.
这时我们可以发现在HSpiceTestbench文件夹下面多出了几个文件,
其中一个就是inv.tr0, 这个就是波形文件.</p>
<p>下面查看仿真波形, 点击CScope, 打开波形观察窗口,
在上面第二栏中选择Import Waveform File, 选择刚刚生成的inv.tr0,
在左边一栏出现D0:inv.tr0, 点击这个东西左边的+号， 有一个toplevel,
点击就可以发现出现了三个选项, 分别是v(vdd), v(in), v(out),
分别点击这三个选项就可以在右边的窗口看见仿真波形了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Python%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Python%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Python基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-19 20:09:20" itemprop="dateModified" datetime="2025-08-19T20:09:20+08:00">2025-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="matplotlib">Matplotlib</h2>
<h3 id="安装">安装</h3>
<p>安装:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure>
<p>导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(matplotlib._version_)</span><br></pre></td></tr></table></figure>
<h3 id="基本操作">基本操作</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Matlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Matlab/" class="post-title-link" itemprop="url">MATLAB基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-21 17:07:44" itemprop="dateModified" datetime="2025-05-21T17:07:44+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/MATLAB/" itemprop="url" rel="index"><span itemprop="name">MATLAB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本指令">基本指令</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;b=<span class="number">2</span>;c=<span class="number">3</span>;                  <span class="comment">%%命令行</span></span><br><span class="line">sum=<span class="number">1</span>+<span class="number">1</span>/<span class="number">2</span>+<span class="number">1</span>/<span class="number">3</span>+<span class="number">1</span>/<span class="number">4</span>+<span class="number">1</span>/<span class="number">5</span>+<span class="number">1</span>/<span class="number">6</span>+...</span><br><span class="line">    <span class="number">1</span>/<span class="number">7</span>+<span class="number">1</span>/<span class="number">8</span>+<span class="number">1</span>/<span class="number">9</span>;              <span class="comment">%%...是续行符，可以写多行命令</span></span><br><span class="line">clc                           <span class="comment">%%清除命令</span></span><br><span class="line">clear                         <span class="comment">%%清除变量</span></span><br><span class="line">clear 变量名                  <span class="comment">%%清除某个变量</span></span><br><span class="line">format short\long\bank（保留小数点后两位）\shortE\longE\hex(<span class="number">16</span>进制)\<span class="built_in">rat</span>（分数）</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="字符和数字">字符和数字</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">abs</span>(s);                       <span class="comment">%%输出s对应字符的ASCII码</span></span><br><span class="line">char(<span class="number">65</span>);                     <span class="comment">%%输出ASCII码为65对应的字符</span></span><br><span class="line">num2str(<span class="number">65</span>);                  <span class="comment">%%输出字符‘65’</span></span><br><span class="line">str=<span class="string">&#x27;I love U&#x27;</span>;</span><br><span class="line"><span class="built_in">length</span>(str);                  <span class="comment">%%输出str的长度</span></span><br><span class="line">a=<span class="number">6</span>+<span class="number">5</span><span class="built_in">i</span>;b=<span class="number">6</span>+<span class="number">6</span><span class="built_in">j</span>                 <span class="comment">%%a，b都是复数</span></span><br><span class="line">x=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">complex</span>(<span class="number">2</span>,x)                  <span class="comment">%%生成实部为2，虚部为x的复数</span></span><br><span class="line"><span class="built_in">real</span>(a);                      <span class="comment">%%求复数的实部</span></span><br><span class="line"><span class="built_in">imag</span>(a);                      <span class="comment">%%求复数的虚部</span></span><br><span class="line"><span class="built_in">abs</span>(a);                       <span class="comment">%%求复数的模</span></span><br><span class="line"><span class="built_in">angle</span>(a);                     <span class="comment">%%求复数的辐角</span></span><br><span class="line"><span class="built_in">conj</span>(a);                      <span class="comment">%%求共轭复数</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<h4 id="矩阵基本运算">矩阵基本运算</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">B=A.&#x27;;                        <span class="comment">%%A的转置</span></span><br><span class="line">B=A&#x27;;                         <span class="comment">%%A的共轭转置</span></span><br><span class="line">C=A(:);                       <span class="comment">%%把A中的所有元素排成一列</span></span><br><span class="line">D=inv(A);                     <span class="comment">%%A的逆矩阵</span></span><br><span class="line">E=[A,A;A,A];                  <span class="comment">%%把矩阵A拼接</span></span><br><span class="line">F=<span class="built_in">rot90</span>(A,k);                 <span class="comment">%%将A矩阵逆时针旋转90°的k倍</span></span><br><span class="line">G=<span class="built_in">fliplr</span>(A);                  <span class="comment">%%左右翻转</span></span><br><span class="line">H=<span class="built_in">flipud</span>(A);                  <span class="comment">%%上下翻转</span></span><br><span class="line">A*D;                          <span class="comment">%%矩阵乘法</span></span><br><span class="line">A.*D;                         <span class="comment">%%矩阵对应元素相乘</span></span><br><span class="line">A/D;                          <span class="comment">%%相当于A*inv（D）</span></span><br><span class="line">A./D;                         <span class="comment">%%矩阵对应元素相除</span></span><br><span class="line">A+D;                          <span class="comment">%%矩阵对应元素相加</span></span><br><span class="line">A-D;                          <span class="comment">%%矩阵对应元素相减</span></span><br><span class="line">det(A);                       <span class="comment">%%计算A的行列式</span></span><br><span class="line">adj(A);                       <span class="comment">%%计算A的伴随矩阵</span></span><br><span class="line">cond(A);                      <span class="comment">%%计算A的条件数condition，数值越小越正常</span></span><br><span class="line">rank(A);                      <span class="comment">%%计算A的秩</span></span><br><span class="line">trace(A);                     <span class="comment">%%计算A的迹</span></span><br><span class="line">eig(A);                       <span class="comment">%%计算A的特征值</span></span><br><span class="line">A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br><span class="line">B=<span class="built_in">reshape</span>(A,<span class="number">3</span>,<span class="number">2</span>);             <span class="comment">%%把A按顺序变成三行两列的矩阵</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵生成">矩阵生成</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>);               <span class="comment">%%生成10行5列3层矩阵</span></span><br><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>);                 <span class="comment">%%生成10行5列矩阵</span></span><br><span class="line">E=<span class="built_in">rand</span>(<span class="number">2</span>,<span class="number">3</span>);                  <span class="comment">%%生成0~1之间的随机数</span></span><br><span class="line">E=<span class="built_in">randn</span>(<span class="number">3</span>,<span class="number">2</span>);                 <span class="comment">%%生成均值为0，方差为1的随机数</span></span><br><span class="line">E=randi([<span class="built_in">min</span>,<span class="built_in">max</span>],m,n);       <span class="comment">%%生成在开区间[min，max]之间随机整数的m行n列矩阵</span></span><br><span class="line">A=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>;                      <span class="comment">%%A=[1,3,5,7,9]</span></span><br><span class="line">str=<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>:<span class="string">&#x27;z&#x27;</span>;                <span class="comment">%%str=[a,b,...,z]</span></span><br><span class="line">B=<span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>);              <span class="comment">%%把A先竖着重复3次，再横着重复2次</span></span><br><span class="line">C=<span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">4</span>);                  <span class="comment">%%生成2行4列的元素全部为1的矩阵</span></span><br><span class="line">D=<span class="built_in">eye</span>(<span class="number">5</span>);                     <span class="comment">%%生成5阶单位阵</span></span><br><span class="line">E=<span class="built_in">magic</span>(<span class="number">3</span>);                   <span class="comment">%%生成3阶幻方（就是每行，每列，对角线元素之和相等的方阵）</span></span><br><span class="line">F=<span class="built_in">vander</span>([<span class="number">1</span>;<span class="number">3</span>;<span class="number">5</span>;<span class="number">8</span>]);          <span class="comment">%%生成范德蒙德矩阵，其中a1=1,a2=3,a3=5,a4=8</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵分析">矩阵分析</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">5</span>);</span><br><span class="line">B=A(<span class="number">2</span>,<span class="number">3</span>);                     <span class="comment">%%取A的第2行第3列的元素</span></span><br><span class="line">C=A(<span class="number">8</span>);                       <span class="comment">%%取A的第8个元素</span></span><br><span class="line">D=A([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);                 <span class="comment">%%取A的第1,3,5个元素作为一个行向量</span></span><br><span class="line">E=A([<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]);             <span class="comment">%%取A的第1,3行与第2,3列相交处的元素,相当于取子式！！！</span></span><br><span class="line">F=A([<span class="number">1</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>]);               <span class="comment">%%取A的第1,3个元素作为第一行，第2,3个元素作为第二行（与D类似）</span></span><br><span class="line">G=A(<span class="number">3</span>,:);G=A(:;<span class="number">2</span>:<span class="number">4</span>);G=A(<span class="number">2</span>:<span class="number">3</span>;<span class="number">1</span>:<span class="number">2</span>:<span class="number">5</span>)            <span class="comment">%%取A的第三行;取A的2,3,4列;取A的第2,3行和第1,2,5,列交叉处的元素</span></span><br><span class="line">A(<span class="number">3</span>,:)=[];A(:,[<span class="number">2</span>,<span class="number">4</span>])=[];      <span class="comment">%%删去A的第三行;删去A的第2,4列元素</span></span><br><span class="line">H=A(:,<span class="number">4</span>);                     <span class="comment">%%取A的第四列</span></span><br><span class="line">I=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>]);       <span class="comment">%%将A中的A(1,1),A(2,1);A(2,3),A(2,2)的序号组成一个2×2的矩阵</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">ind2sub</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);               <span class="comment">%%将矩阵A的第1,3,5个元素的下标输出</span></span><br><span class="line">J=A(<span class="keyword">end</span>,:)/J=A([<span class="number">1</span>,<span class="number">4</span>],<span class="number">3</span>:<span class="keyword">end</span>);                  <span class="comment">%%取A的最后一行的元素、取A的第1,4行与从第3~最后一列交叉处的元素</span></span><br><span class="line">K=<span class="built_in">diag</span>(A);                    <span class="comment">%%取A的主对角线上的元素</span></span><br><span class="line">L=<span class="built_in">diag</span>([<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">5</span>]);           <span class="comment">%%将1，-2,4,5排成对角阵</span></span><br><span class="line">[m,n]=<span class="built_in">find</span>(A&gt;<span class="number">20</span>);             <span class="comment">%%找出A中大于20的元素的行标（即m）和列标（即对应于m的n）</span></span><br><span class="line">I=<span class="built_in">find</span>(A==<span class="number">5</span>);                 <span class="comment">%%找出A中等于5的元素的序号</span></span><br><span class="line"><span class="built_in">max</span>(A);                       <span class="comment">%%找出A中每列的最大的元素</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">max</span>(A));                  <span class="comment">%%找出A中最大的元素，min同理</span></span><br><span class="line">sum(A);                       <span class="comment">%%求A每列元素之和</span></span><br><span class="line">sum(sum(A));                  <span class="comment">%%求A所有元素之和</span></span><br><span class="line"><span class="built_in">mean</span>(A);                      <span class="comment">%%求A每列元素的平均数</span></span><br><span class="line"><span class="built_in">mean</span>(<span class="built_in">mean</span>(A));                <span class="comment">%%求A所有元素的平均数</span></span><br><span class="line"><span class="built_in">sort</span>(A);                      <span class="comment">%%每列元素按照从小到大顺序排列</span></span><br><span class="line">sortrow(A);                   <span class="comment">%%按第一列元素从小到大排列</span></span><br><span class="line"><span class="built_in">size</span>(A);                      <span class="comment">%%输出A的行数和列数</span></span><br><span class="line"><span class="built_in">length</span>(A);                    <span class="comment">%%输出A的最长维的维数</span></span><br><span class="line"><span class="built_in">numel</span>(A);                     <span class="comment">%%输出A的元素的个数</span></span><br></pre></td></tr></table></figure>
<h2 id="数学运算">数学运算</h2>
<h3 id="一般函数">一般函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>/<span class="built_in">cos</span>/<span class="built_in">tan</span>/<span class="built_in">asin</span>/<span class="built_in">acos</span>/<span class="built_in">atan</span>/<span class="built_in">sinh</span>/<span class="built_in">cosh</span>/<span class="built_in">tanh</span>;    <span class="comment">%%三角函数</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">9</span>);                       <span class="comment">%%9的平方根</span></span><br><span class="line"><span class="built_in">log</span>()/<span class="built_in">log10</span>()/<span class="built_in">log2</span>;            <span class="comment">%%自然对数、常用对数、以2为底的对数函数</span></span><br><span class="line"><span class="built_in">exp</span>();                         <span class="comment">%%不解释</span></span><br><span class="line"><span class="built_in">pow2</span>;                          <span class="comment">%%2的幂,相当于平方</span></span><br><span class="line"><span class="built_in">abs</span>();                         <span class="comment">%%绝对值</span></span><br><span class="line"><span class="built_in">rem</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求模</span></span><br><span class="line"><span class="built_in">gcd</span>(<span class="number">150</span>,<span class="number">95</span>);                   <span class="comment">%%最大公约数</span></span><br><span class="line"><span class="built_in">lcm</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%最小公倍数</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);                  <span class="comment">%%5的阶乘</span></span><br><span class="line"><span class="built_in">isprime</span>(<span class="number">6</span>);                    <span class="comment">%%判断6是不是素数，如果是输出1，否则输出0</span></span><br><span class="line"><span class="built_in">primes</span>(<span class="number">9</span>);                     <span class="comment">%%生成1~9内所有的素数</span></span><br><span class="line"><span class="built_in">perms</span>(A);                      <span class="comment">%%生成A的所有的排列，A为行向量</span></span><br><span class="line">randperm(<span class="number">10</span>);                  <span class="comment">%%生成1~10的随机排列</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵函数">矩阵函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrtm(A);                     <span class="comment">%%对矩阵中所有元素开方</span></span><br><span class="line">logm(A);                      <span class="comment">%%对矩阵中所有元素取自然对数</span></span><br><span class="line">expm(A);                      <span class="comment">%%对矩阵中所有元素取指数</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算">逻辑运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;/&lt;=;                         <span class="comment">%%小于、小于等于</span></span><br><span class="line">&gt;/&gt;=;                         <span class="comment">%%大于、大于等于</span></span><br><span class="line">==/~=;                        <span class="comment">%%等于、不等于</span></span><br><span class="line">eq(a,b);                      <span class="comment">%%判断a、b是否相等，相等输出1，不相等输出0</span></span><br><span class="line">a&amp;b/and(a,b);                 <span class="comment">%%“与”，a、b全部非0时，输出1；a、b只要有一个为0，输出0</span></span><br><span class="line">a|b;or(a,b);                  <span class="comment">%%a、b只要有一个不为0，输出1；a、b全为0时，输出0</span></span><br><span class="line">~a/not(a);                    <span class="comment">%%a是0时，输出1；a不为0时，输出0</span></span><br><span class="line">xor(a,b);                     <span class="comment">%%a、b值不同时，输出1；a、b值相同时，输出0</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串运算">字符串运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;Xidian University&#x27;</span>;</span><br><span class="line">str=<span class="string">&#x27;I&#x27;&#x27;m a student&#x27;</span>;             <span class="comment">%%当字符串中含有&#x27;时，打两个&#x27;&#x27;</span></span><br><span class="line">ch=[<span class="string">&#x27;abcdef&#x27;</span>;<span class="string">&#x27;123456&#x27;</span>];           <span class="comment">%%字符串矩阵</span></span><br><span class="line">ch=<span class="string">&#x27;ABc123d4e56Fg9&#x27;</span>;</span><br><span class="line">str=ch(<span class="number">1</span>:<span class="number">5</span>);                      <span class="comment">%%取ch的前5个元素</span></span><br><span class="line">str=ch(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);                 <span class="comment">%%将ch倒着排列</span></span><br><span class="line">place=<span class="built_in">find</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>);      <span class="comment">%%找到小写字母的位置</span></span><br><span class="line">ch(place)=ch(place)-<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;A&#x27;</span>;      <span class="comment">%%将小写字母换成大写字母</span></span><br><span class="line"><span class="built_in">length</span>(place);                    <span class="comment">%%计算小写字母的数量</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&#x27;MATLAB&#x27;</span>;</span><br><span class="line">a=<span class="built_in">abs</span>(str);                       <span class="comment">%%将str里面的字符转化成ASCII码</span></span><br><span class="line">b=char(a+<span class="number">32</span>);                     <span class="comment">%%将ASCII码加32后再转化成对应的字符</span></span><br><span class="line"></span><br><span class="line">ch=[str1,str2,str3];</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;www0&#x27;</span>&gt;=<span class="string">&#x27;w123&#x27;</span>;                   <span class="comment">%%比较这两个字符串中各个元素的大小，输出1110</span></span><br><span class="line">strcmp(str1,str2);                <span class="comment">%%比较两个字符串是否相等，相等输出1，否则输出0</span></span><br><span class="line">strncmp(str1,str2,n);             <span class="comment">%%比较两个字符串的前n个元素是否相等</span></span><br><span class="line">strcmpi(str1,str2);               <span class="comment">%%忽略大小写，比较两个字符串是否相等</span></span><br><span class="line">strncmpi(str1,str2,n);            <span class="comment">%%忽略大小写,比较两个字符串的前n个元素是否相等</span></span><br><span class="line"></span><br><span class="line">findstr(str1,str2);               <span class="comment">%%输出str2在str1中开始的位置</span></span><br><span class="line">strrep(str1,str2,str3);           <span class="comment">%%将str1中的str2替换为str3</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">A=cell(<span class="number">1</span>,<span class="number">6</span>);                      <span class="comment">%%生成A=[][][][][][]</span></span><br><span class="line">A&#123;<span class="number">2</span>&#125;=<span class="built_in">eye</span>(<span class="number">3</span>);                      <span class="comment">%%A=[][eye(3)][][][][]</span></span><br><span class="line">A&#123;<span class="number">6</span>&#125;=<span class="built_in">magic</span>(<span class="number">5</span>);                    <span class="comment">%%A=[][eye(3)][][][][magic(5)]</span></span><br><span class="line">B=A&#123;<span class="number">6</span>&#125;;                           <span class="comment">%%取出A中第六个元素，即magic（5）</span></span><br><span class="line">   </span><br><span class="line">A=cell(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=&#123;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>;<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>;<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=&#123;<span class="string">&#x27;Fourier&#x27;</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=&#123;<span class="number">3</span>+<span class="number">7</span><span class="built_in">i</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=&#123;<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>&#125;;</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;                           <span class="comment">%%输出[1,4,3;0,5,8;7,2,9]</span></span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;(<span class="number">2</span>,<span class="number">3</span>);                      <span class="comment">%%取出A&#123;1,1&#125;矩阵中的第二行第三列的元素</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>);                           <span class="comment">%%输出[3x3double]</span></span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;                           <span class="comment">%%输出[1,3,5,7,9]</span></span><br><span class="line"></span><br><span class="line">books=struct(<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;fourier&#x27;</span>,<span class="string">&#x27;laplace&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span>,<span class="number">40</span>]);</span><br><span class="line">books.name(<span class="number">1</span>);                    <span class="comment">%%输出‘fourier’</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;;                    <span class="comment">%%输出fourier</span></span><br><span class="line"></span><br><span class="line">A=struct(<span class="string">&#x27;data&#x27;</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>;<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="string">&#x27;nest&#x27;</span>,struct(<span class="string">&#x27;testnum&#x27;</span>,<span class="string">&#x27;test1&#x27;</span>,<span class="string">&#x27;xdata&#x27;</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>],<span class="string">&#x27;ydata&#x27;</span>,[<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>]));</span><br><span class="line">A(<span class="number">2</span>).data=[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.testnum=<span class="string">&#x27;test2&#x27;</span>;</span><br><span class="line">A(<span class="number">2</span>).nest.xdata=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.ydata=[<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>];</span><br><span class="line">A.nest;</span><br><span class="line">A(<span class="number">1</span>).nest.testnum;</span><br><span class="line">A(<span class="number">1</span>).nest.xdata;</span><br><span class="line">A(<span class="number">2</span>).nest.ydata;</span><br></pre></td></tr></table></figure>
<h2 id="程序设计">程序设计</h2>
<h3 id="顺序结构">顺序结构</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A=input(<span class="string">&#x27;请输入A矩阵：&#x27;</span>);</span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>);            <span class="comment">%%输入字符的时候要加上&#x27;&#x27;</span></span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);        <span class="comment">%%输入字符的时候不用加&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A=<span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="built_in">disp</span>(A);                                  <span class="comment">%%输出项只能是字符串或者是矩阵，如果要输出数字的话要用num2str()将数字转化成数字字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%例题：解方程a*x^2+b*x+c=0</span></span><br><span class="line">a=input(<span class="string">&#x27;请输入a的值&#x27;</span>);</span><br><span class="line">b=input(<span class="string">&#x27;请输入b的值&#x27;</span>);</span><br><span class="line">c=input(<span class="string">&#x27;请输入c的值&#x27;</span>);</span><br><span class="line">delta=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x=[(-b+<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;x1=&#x27;</span>,num2str(x(<span class="number">1</span>)),<span class="string">&#x27;，x2=&#x27;</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure>
<h3 id="选择结构">选择结构</h3>
<h4 id="if语句">if语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x=input(<span class="string">&#x27;请输入x的值&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">10</span></span><br><span class="line">    y=<span class="built_in">cos</span>(x+<span class="number">1</span>)+<span class="built_in">sqrt</span>(x*x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y=x*<span class="built_in">sqrt</span>(x+<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=input(<span class="string">&#x27;请输入一个字符&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(lower(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(upper(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(str2num(c)^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="switch语句">switch语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">price=input(<span class="string">&#x27;请输入商品价格&#x27;</span>);</span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">fix</span>(price/<span class="number">100</span>)             <span class="comment">%%fix函数是将数字向0的方向取整</span></span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">          rate=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">          rate=<span class="number">3</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">5</span>:<span class="number">9</span>)            <span class="comment">%%num2cell函数是将数值矩阵转化成单元矩阵&#123;5,6,7,8,9&#125;</span></span><br><span class="line">          rate=<span class="number">5</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">10</span>:<span class="number">24</span>)</span><br><span class="line">          rate=<span class="number">8</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">24</span>:<span class="number">49</span>)</span><br><span class="line">          rate=<span class="number">10</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">otherwise</span></span><br><span class="line">          rate=<span class="number">14</span>/<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  price=price*(<span class="number">1</span>-rate)</span><br></pre></td></tr></table></figure>
<h3 id="循环结构">循环结构</h3>
<h4 id="for语句">for语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flower=[];                      <span class="comment">%%判断水仙花数，这是开一个空矩阵</span></span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">100</span>:<span class="number">999</span>;</span><br><span class="line">        m1=<span class="built_in">fix</span>(m/<span class="number">100</span>);          <span class="comment">%%取百位</span></span><br><span class="line">        m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);   <span class="comment">%%取十位</span></span><br><span class="line">        m3=<span class="built_in">rem</span>(m,<span class="number">10</span>);           <span class="comment">%%取个位</span></span><br><span class="line">        <span class="keyword">if</span> m==m1^<span class="number">3</span>+m2^<span class="number">3</span>+m3^<span class="number">3</span></span><br><span class="line">            flower=[flower,m];  <span class="comment">%%这个语句的意思是将m添加到flower中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(flower)</span><br><span class="line">  </span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="number">1</span>/(<span class="built_in">i</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="while语句">while语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span></span><br><span class="line">    sum=sum+x;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> n&gt;<span class="number">0</span></span><br><span class="line">    sum</span><br><span class="line">    <span class="built_in">mean</span>=sum/n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="break和continue语句">break和continue语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n=<span class="number">100</span>:<span class="number">200</span><span class="comment">%%求100~200之间第一个能被21整除的数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rem</span>(n,<span class="number">21</span>)~=<span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="循环的嵌套">循环的嵌套</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=初值:步长:终值</span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> 表达式(数值或字符串)</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">1</span></span><br><span class="line">        语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">2</span></span><br><span class="line">        语句<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串n</span><br><span class="line">        语句n</span><br><span class="line">    <span class="keyword">otherwise</span>(可省略)</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=input(<span class="string">&#x27;请输入n的值&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="built_in">factor</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;1到&#x27;</span>,num2str(n),<span class="string">&#x27;的阶乘的和为&#x27;</span>,num2str(sum)]);</span><br></pre></td></tr></table></figure>
<h2 id="绘图">绘图</h2>
<h3 id="二维图像">二维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);<span class="comment">%%2是标量，exp和sin是矩阵，所以2和exp是数量乘法，exp和sin是点乘</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=-<span class="built_in">pi</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="built_in">pi</span>;</span><br><span class="line">x=t.*<span class="built_in">cos</span>(<span class="number">3</span>*t);</span><br><span class="line">y=t.*<span class="built_in">sin</span>(t).*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%参数方程</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);<span class="comment">%%生成0~2*pi，元素个数为100的行向量</span></span><br><span class="line">y=[<span class="built_in">sin</span>(x);<span class="built_in">cos</span>(x)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t]&#x27;;</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t];</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%这是个什么玩意儿？？？</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">sin</span>(x),x,<span class="number">2</span>*<span class="built_in">sin</span>(x),x,<span class="number">3</span>*<span class="built_in">sin</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y1=<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">y3=<span class="number">3</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">x=[x;x;x]&#x27;;<span class="comment">%%注意变成行向量</span></span><br><span class="line">y=[y1;y2;y3]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y,x,<span class="built_in">cos</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">200</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1=<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line">y2=<span class="built_in">sin</span>(x);</span><br><span class="line">plotyy(x,y1,x,y2);<span class="comment">%%双纵坐标，左边是y1，右边是y2</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>);<span class="comment">%%产生自变量向量x</span></span><br><span class="line">y=[];<span class="comment">%%y的初始值为空</span></span><br><span class="line"><span class="keyword">for</span> x0=x<span class="comment">%%将函数值追加到y中</span></span><br><span class="line">    <span class="keyword">if</span> x0&gt;=<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">6</span>&amp;&amp;x0&lt;<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">5</span>-x0/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">4</span>&amp;&amp;x0&lt;<span class="number">6</span></span><br><span class="line">        y=[y,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">0</span>&amp;&amp;x0&lt;<span class="number">4</span></span><br><span class="line">        y=[y,<span class="built_in">sqrt</span>(x0)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2.5</span>]);<span class="comment">%%设置坐标轴，x坐标轴是[0，10]，y坐标轴是[0,2.5]</span></span><br><span class="line">title(<span class="string">&#x27;分段函数曲线&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Variable X&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Variable Y&#x27;</span>);</span><br><span class="line">text(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;y=x^&#123;1/2&#125;&#x27;</span>);<span class="comment">%%在指定位置处添加图形说明</span></span><br><span class="line">text(<span class="number">4.5</span>,<span class="number">1.9</span>,<span class="string">&#x27;y=2&#x27;</span>);</span><br><span class="line">text(<span class="number">7.3</span>,<span class="number">1.5</span>,<span class="string">&#x27;y=5-x/2&#x27;</span>);</span><br><span class="line">text(<span class="number">8.5</span>,<span class="number">0.9</span>,<span class="string">&#x27;y=1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">60</span>);</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">z=<span class="built_in">cos</span>(x);</span><br><span class="line">t=<span class="built_in">tan</span>(x);</span><br><span class="line">ct=<span class="built_in">cot</span>(x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">%%将当前图形窗口分割成2×2，并选中1号区</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;sinx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,z);</span><br><span class="line">title(<span class="string">&#x27;cosx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,t);</span><br><span class="line">title(<span class="string">&#x27;tanx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,ct);</span><br><span class="line">title(<span class="string">&#x27;cotx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="number">10</span>*x.*x;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y);title(<span class="string">&#x27;直角坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">semilogx(x,y);title(<span class="string">&#x27;x半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">semilogy(x,y);title(<span class="string">&#x27;y半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">loglog(x,y);title(<span class="string">&#x27;全对数坐标曲线&#x27;</span>);grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span>;<span class="comment">%%建立一个幕布，可以不写</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);<span class="comment">%%右端对齐</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on<span class="comment">%%图形保持</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">cos</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">sin</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;b:&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-2</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1=<span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,H1,H2]=plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">1</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;slow decay&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">2</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;fast decay&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(\musec)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;multiple decay rates&#x27;</span>);</span><br><span class="line">set(H1,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">set(H2,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;k:&#x27;</span>,x,y2,<span class="string">&#x27;b--&#x27;</span>);<span class="comment">%%控制图像的颜色和线形</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.5</span>:<span class="number">4</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);h=<span class="built_in">cos</span>(x);w=<span class="number">1.</span>/(<span class="number">1</span>+<span class="built_in">exp</span>(-x));</span><br><span class="line">g=(<span class="number">1.</span>/<span class="number">2</span>*(<span class="number">2</span>*<span class="built_in">pi</span>)^<span class="number">0.5</span>).*<span class="built_in">exp</span>((<span class="number">-1.</span>*(x<span class="number">-2</span>*<span class="built_in">pi</span>).^<span class="number">2</span>)./<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;bd-&#x27;</span>,x,h,<span class="string">&#x27;gp:&#x27;</span>,x,w,<span class="string">&#x27;rp-&#x27;</span>,x,g,<span class="string">&#x27;c^-&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin(x)&#x27;</span>,<span class="string">&#x27;cos(x)&#x27;</span>,<span class="string">&#x27;sigmoid&#x27;</span>,<span class="string">&#x27;gauss function&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">20</span>*<span class="built_in">pi</span>;</span><br><span class="line">r1=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*t)+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;</span><br><span class="line">r2=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t-<span class="built_in">pi</span>/<span class="number">2</span>))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*(t-<span class="built_in">pi</span>/<span class="number">2</span>))+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;<span class="comment">%%旋转90°</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">polar(t,r1);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">polar(t,r2);</span><br></pre></td></tr></table></figure>
<h3 id="三维图像">三维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="number">8</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">y=<span class="number">4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line">z=<span class="number">-4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;line in 3D space&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;origin&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>);ylabel(<span class="string">&#x27;Y&#x27;</span>);zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">7</span>:<span class="number">29</span>;y=<span class="number">16</span>:<span class="number">35</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);<span class="comment">%%在[7,29]×[16,35]区域内生成网格坐标</span></span><br><span class="line">z=<span class="number">2</span>*x+<span class="number">5</span>*y;</span><br><span class="line">k=<span class="built_in">find</span>(z==<span class="number">126</span>);<span class="comment">%%找到z=126的位置，就是求不定方程的解</span></span><br><span class="line">x(k)&#x27;,y(k)&#x27;;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">mesh(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维网格图&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">surf(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维曲面图&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="高级应用">高级应用</h2>
<h3 id="多项式计算">多项式计算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%多项式加减</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line">b=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">-1</span>];</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="comment">%%多项式乘除</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-10</span>];</span><br><span class="line">b=[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>];</span><br><span class="line">c=conv(a,b);            <span class="comment">%%多项式乘法</span></span><br><span class="line">d=deconv(a,b);          <span class="comment">%%多项式除法</span></span><br><span class="line"><span class="comment">%%多项式求导</span></span><br><span class="line">p=polyder(P);           <span class="comment">%%对P求导</span></span><br><span class="line">p=polyder(P,Q);         <span class="comment">%%对P,Q求导</span></span><br><span class="line">[p,q]=polyder(P,Q);     <span class="comment">%%对P/Q求导，分子储存在p，分母储存在q</span></span><br><span class="line"><span class="comment">%%多项式求值</span></span><br><span class="line">Y=polyval(A,x);         <span class="comment">%%A是多项式，x可以是数字，向量，矩阵</span></span><br><span class="line"><span class="comment">%%多项式求根</span></span><br><span class="line">roots(P);               <span class="comment">%%求多项式的根</span></span><br></pre></td></tr></table></figure>
<h3 id="数值微分">数值微分</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DX=diff(X);             <span class="comment">%%计算X的向前差分，即DX(i)=X(i+1)-X(i)</span></span><br><span class="line">DX=diff(X);             <span class="comment">%%计算X的n阶向前差分，即DX(i)=X(i+n)-X(i)</span></span><br></pre></td></tr></table></figure>
<h3 id="插值">插值</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">4</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">xq=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">16</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line"> x=<span class="number">1</span>:<span class="number">100</span>;</span><br><span class="line">y=<span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">xq=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">100</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);                  <span class="comment">%%这种方法噪音太大了</span></span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">y=[<span class="number">12</span>,<span class="number">16</span>,<span class="number">31</span>,<span class="number">10</span>,<span class="number">6</span>];</span><br><span class="line">xq=[<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1.5</span>,<span class="number">5.5</span>,<span class="number">6</span>];</span><br><span class="line">yq1=interp1(x,y,xq,<span class="string">&#x27;pchip&#x27;</span>);           <span class="comment">%%高阶外插</span></span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;liner&#x27;</span>,<span class="string">&#x27;extrap&#x27;</span>);  <span class="comment">%%低阶线性外插（数据少）</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq1,xq,yq2);</span><br></pre></td></tr></table></figure>
<h3 id="拟合">拟合</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">-1</span>,<span class="number">-0.75</span>,<span class="number">-0.50</span>,<span class="number">-0.25</span>,<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0.50</span>,<span class="number">0.75</span>,<span class="number">1.00</span>];</span><br><span class="line">X2=[<span class="number">-1</span>:<span class="number">0.01</span>:<span class="number">1</span>];</span><br><span class="line">Y=[<span class="number">-0.2209</span>,<span class="number">0.3295</span>,<span class="number">0.8826</span>,<span class="number">1.4392</span>,<span class="number">2.0003</span>,<span class="number">2.5645</span>,<span class="number">3.1334</span>,<span class="number">3.7061</span>,<span class="number">4.2836</span>];</span><br><span class="line">P1=polyfit(X,Y,<span class="number">1</span>);</span><br><span class="line">P2=polyfit(X,Y,<span class="number">2</span>);</span><br><span class="line">Y1=polyval(P1,X2);</span><br><span class="line">Y2=polyval(P2,X2);</span><br><span class="line"><span class="built_in">plot</span>(X,Y,<span class="string">&#x27;bx&#x27;</span>,X2,Y1,<span class="string">&#x27;r&#x27;</span>,X2,Y2,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-1.2</span>,<span class="number">1.2</span>]);</span><br><span class="line">ylim([<span class="number">-0.5</span>,<span class="number">4.5</span>]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;数据点&#x27;</span>,<span class="string">&#x27;一次拟合多项式&#x27;</span>,<span class="string">&#x27;二次拟合多项式&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> xdata=[<span class="number">0.9</span>,<span class="number">1.5</span>,<span class="number">13.8</span>,<span class="number">19.8</span>,<span class="number">24.1</span>,<span class="number">28.2</span>,<span class="number">35.2</span>,<span class="number">60.3</span>,<span class="number">74.6</span>,<span class="number">81.3</span>];</span><br><span class="line"> ydata=[<span class="number">455.2</span>,<span class="number">428.6</span>,<span class="number">124.1</span>,<span class="number">67.3</span>,<span class="number">43.2</span>,<span class="number">28.1</span>,<span class="number">13.1</span>,<span class="number">-0.4</span>,<span class="number">-1.3</span>,<span class="number">-1.5</span>];</span><br><span class="line"> fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line"> x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line"> options=optimoptions(<span class="string">&#x27;lsqcurvefit&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;trust-region-reflective&#x27;</span>);</span><br><span class="line"> lb=[<span class="number">-500</span>,<span class="number">-500</span>];</span><br><span class="line"> ub=[<span class="number">500</span>,<span class="number">500</span>];</span><br><span class="line"> x=lsqcurvefit(fun,x0,xdata,ydata,lb,ub,options);</span><br><span class="line"> times=<span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"> <span class="built_in">plot</span>(xdata.ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line"> <span class="built_in">legend</span>(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;fitted exponential&#x27;</span>);?????</span><br><span class="line"> </span><br><span class="line">xdata=[<span class="number">0.9</span> <span class="number">1.5</span> <span class="number">13.8</span> <span class="number">19.8</span> <span class="number">24.1</span> <span class="number">28.2</span> <span class="number">35.2</span> <span class="number">60.3</span> <span class="number">74.6</span> <span class="number">81.3</span>];</span><br><span class="line">ydata=[<span class="number">455.2</span> <span class="number">428.6</span> <span class="number">124.1</span> <span class="number">67.3</span> <span class="number">43.2</span> <span class="number">28.1</span> <span class="number">13.1</span> <span class="number">-0.4</span> <span class="number">-1.3</span> <span class="number">-1.5</span>];</span><br><span class="line">fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line">x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line">x=lsqcurvefit(fun,x0,xdata,ydata);</span><br><span class="line">times = <span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"><span class="built_in">plot</span>(xdata,ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Data&#x27;</span>,<span class="string">&#x27;Fitted exponential&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Data and Fitted Curve&#x27;</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">RISC-V体系结构编程与实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 13:16:24" itemprop="dateModified" datetime="2025-08-08T13:16:24+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/RISC-V/" itemprop="url" rel="index"><span itemprop="name">RISC-V</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="实验环境搭建">实验环境搭建</h2>
<p>在VMware中安装完Ubuntu Linux 20.04
系统后,打开终端,可以通过如下命令安装需要的软件包:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt update -y</span></span><br><span class="line"></span><br><span class="line">[sudo] siyuanlei 的密码： 123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt install net-tools libncurses5-dev libssl-dev build-essential openssl qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu git bison flex bc vim universal-ctags cscope gdb-multiarch libsdl2-dev libreadline-dev</span></span><br></pre></td></tr></table></figure>
<p>我们再克隆GitHub上的<code>runninglinuxkernel/riscv_ programming_ practice</code>仓库到当前目录下,在Linux系统中,使用<code>git clone</code>命令克隆的GitHub仓库默认会保存在当前工作目录下具体位置取决于你执行命令时所在的目录:</p>
<ol type="1">
<li>默认存储位置:如果你没有切换目录就直接执行<code>git clone</code>,仓库会保存在当前用户的主目录(/home/你的用户名/),例如：/home/ubuntu/riscv_programming_practice/</li>
<li>如果你先切换了目录再执行克隆,仓库会保存在你切换后的目录,例如:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp  # 先切换到 /tmp 目录</span><br><span class="line">git clone https://github.com/xxx/yyy.git  # 仓库会保存在 /tmp/yyy/</span><br></pre></td></tr></table></figure>
<p>下面我们进行克隆</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Git</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install git -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆仓库</span></span><br><span class="line">git clone https://github.com/runninglinuxkernel/riscv_programming_practice.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 chapter2</span></span><br><span class="line">cd riscv_programming_practice/chapter2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录内容（验证）</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h3 id="实验2-1输出welcome-to-risc-v">实验2-1:输出”Welcome to
RISC-V!”</h3>
<p>在Linux主机中安装相关工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt-get install qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu build-essential git bison flex libssl-dev</span></span><br></pre></td></tr></table></figure>
<p>下面我们在QEMU上运行BenOS</p>
<p>我们首先在Linux主机上使用make命令编译BenOS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">export</span> board=qemu</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
<p>想要编译可以在QEMU模拟器上运行的可执行二进制文件,需要先设置<code>board=qemu</code>.</p>
<p>直接输入<code>make run</code>命令并运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlk@master:benos$ make run</span><br></pre></td></tr></table></figure>
<p>我们可以看到QEMU输出”Welcome
RISC-V!“.要关闭QEMU,可以按下<code>Ctrl+A</code>键,松开后再快速按下<code>X</code>键.</p>
<h3 id="实验2-2单步调试benos和mysbi">实验2-2:单步调试BenOS和MySBI</h3>
<p>使用<code>make debug</code>命令在终端启动QEMU虚拟机的gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make debug</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用如下命令启动gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-riscv64 -nographic -machine virt -m 128M -bios mysbi.bin -kernel benos.elf -S -s</span></span><br></pre></td></tr></table></figure>
<p>在另一个终端使用如下命令启动GDB工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gdb-multiarch --tui benos.elf</span></span><br></pre></td></tr></table></figure>
<p>在GDB命令行中执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
