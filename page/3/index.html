<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:58" itemprop="dateModified" datetime="2025-08-08T19:53:58+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="位运算">位运算</h2>
<p>整数在计算机中用二进制的位来表示，C语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如第
2 节
“Unicode和UTF-8”介绍的UTF-8编码就是如此，学完本节之后你应该能自己写出UTF-8的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。</p>
<h3 id="按位与或异或取反运算">按位与、或、异或、取反运算</h3>
<p>在第 3 节
“布尔代数”讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C语言提供了按位与（Bitwise
AND）运算符<code>&amp;</code>、按位或（Bitwise
OR）运算符<code>|</code>和按位取反（Bitwise
NOT）运算符<code>~</code>，此外还有按位异或（Bitwise
XOR）运算符<code>^</code>，我们在第 1 节
“为什么计算机用二进制计数”讲过异或运算。</p>
<p>注意，<code>&amp;</code>、<code>|</code>、<code>^</code>运算符都是要做Usual
Arithmetic Conversion的（其中有一步是Integer
Promotion），<code>~</code>运算符也要做Integer
Promotion，所以在C语言中其实并不存在8位整数的位运算，操作数在做位运算之前都至少被提升为<code>int</code>型了.</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0xfc</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = ~c;</span><br></pre></td></tr></table></figure>
<p>计算过程是这样的：常量<code>0xfc</code>是<code>int</code>型的，赋给c要转成<code>unsigned char</code>，值不变；c的十六进制表示是<code>fc</code>，计算<code>~c</code>时先提升为整型<code>000000fc</code>然后取反，最后结果是<code>ffffff03</code>。注意，如果把<code>~c</code>看成是8位整数的取反，最后结果就得3了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。</p>
<h3 id="移位运算">移位运算</h3>
<p>移位运算符（Bitwise
Shift）包括左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。左移将一个整数的各二进制位全部左移若干位.</p>
<p>最高两位的11被移出去了，最低两位又补了两个0，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是<code>unsigned int</code>型，如果左移的位数大于等于32位，则结果是Undefined。移位运算符不同于<code>+ - * / ==</code>等运算符，两边操作数的类型不要求一致，但两边操作数都要做Integer
Promotion，整个表达式的类型和左操作数提升后的类型相同。</p>
<p>复习一下第 2 节
“不同进制之间的换算”讲过的知识可以得出结论，在一定的取值范围内，将一个整数左移1位相当于乘以2。比如二进制11（十进制3）左移一位变成110，就是6，再左移一位变成1100，就是12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以2了，所以我加了个前提“在一定的取值范围内”。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有<code>i * 8</code>，可以编译成移位指令而不是乘法指令。</p>
<p>当操作数是无符号数时，右移运算的规则和左移类似，</p>
<p>比如最低两位的11被移出去了，最高两位又补了两个0，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是Undefined。在一定的取值范围内，将一个整数右移1位相当于除以2，小数部分截掉。</p>
<p>当操作数是有符号数时，右移运算的规则比较复杂：</p>
<p>如果是正数，那么高位移入0</p>
<p>如果是负数，那么高位移入1还是0不一定，这是Implementation-defined的。对于x86平台的gcc编译器，最高位移入1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了“右移1位相当于除以2”的性质。</p>
<p>综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，建议只对无符号数做位运算，以减少出错的可能。</p>
<h3 id="掩码">掩码</h3>
<p>如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）来表示。比如掩码0x0000ff00表示对一个32位整数的8~15位进行操作，举例如下。</p>
<p>1、取出8~15位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = (a &amp; mask) &gt;&gt; <span class="number">8</span>; <span class="comment">/* 0x00000056 */</span></span><br></pre></td></tr></table></figure>
<p>这样也可以达到同样的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = (a &gt;&gt; <span class="number">8</span>) &amp; ~(~<span class="number">0U</span> &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>2、将8~15位清0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a &amp; ~mask; <span class="comment">/* 0x12340078 */</span></span><br></pre></td></tr></table></figure>
<p>3、将8~15位置1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">0x0000ff00</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a | mask; <span class="comment">/* 0x1234ff78 */</span></span><br></pre></td></tr></table></figure>
<h3 id="异或运算的一些特性">异或运算的一些特性</h3>
<p>1、一个数和自己做异或的结果是0。如果需要一个常数0，x86平台的编译器可能会生成这样的指令：<code>xorl %eax, %eax</code>。不管<code>eax</code>寄存器里的值原来是多少，做异或运算都能得到0，这条指令比同样效果的<code>movl $0, %eax</code>指令快，因为前者只需要在CPU内部计算，而后者需要访问内存，在下一章第
5 节 “Memory Hierarchy”详细介绍。</p>
<p>2、从异或的真值表可以看出，不管是0还是1，和0做异或保持原值不变，和1做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a, b, mask = <span class="number">1U</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line">a = <span class="number">0x12345678</span>;</span><br><span class="line">b = a ^ mask; <span class="comment">/* flip the 6th bit */</span></span><br></pre></td></tr></table></figure>
<p>3、如果<code>a1 ^ a2 ^ a3 ^ ... ^ an</code>的结果是1，则表示<code>a1、a2、a3...an</code>之中1的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity
Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。</p>
<p>4、<code>x ^ x ^ y == y</code>，因为<code>x ^ x == 0</code>，<code>0 ^ y == y</code>。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用<code>temp = a; a = b; b = temp;</code>的办法了。利用位运算可以这样做交换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>分析一下这个过程。为了避免混淆，把<code>a</code>和<code>b</code>的初值分别记为<code>a0</code>和<code>b0</code>。第一行，<code>a = a0 ^ b0；</code>第二行，把<code>a</code>的新值代入，得到<code>b = b0 ^ a0 ^ b0</code>，等号右边的<code>b0</code>相当于上面公式中的<code>x</code>，<code>a0</code>相当于<code>y</code>，所以结果为<code>a0</code>；第三行，把<code>a</code>和<code>b</code>的新值代入，得到<code>a = a0 ^ b0 ^ a0</code>，结果为<code>b0</code>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量<code>temp</code>则可以交换。</p>
<h2 id="其他运算符">其他运算符</h2>
<h3 id="复合赋值运算符">复合赋值运算符</h3>
<p>复合赋值运算符（Compound Assignment
Operator）包括<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>，一边做运算一边赋值。例如<code>a += 1</code>相当于<code>a = a + 1</code>。但有一点细微的差别，前者对表达式<code>a</code>只求值一次，而后者求值两次，如果<code>a</code>是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如<code>a[i+j] += 1</code>和<code>a[i+j] = a[i+j] + 1</code>。那么仅仅是效率上的差别吗？对于没有Side
Effect的表达式，求值一次和求值两次的结果是一样的，但对于有Side
Effect的表达式则不一定，例如<code>a[foo()] += 1</code>和<code>a[foo()] = a[foo()] + 1</code>，如果<code>foo()</code>函数调用有Side
Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。</p>
<p>在第 3 节
“for语句”讲自增、自减运算符时说<code>++i</code>相当于<code>i = i + 1</code>，其实更准确地说应该是等价于<code>i += 1</code>，表达式<code>i</code>只求值一次，而<code>--i</code>等价于<code>i -= 1</code>。</p>
<h3 id="条件运算符">条件运算符</h3>
<p>条件运算符（Conditional
Operator）是C语言中唯一一个三目运算符（Ternary
Operator），带三个操作数，它的形式是<code>表达式1 ? 表达式2 : 表达式3</code>，这个运算符所组成的整个表达式的值等于<code>表达式2</code>或<code>表达式3</code>的值，取决于<code>表达式1</code>的值是否为真，可以把它想像成这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><code>表达式1</code>相当于<code>if</code>语句的控制表达式，因此它的值必须是标量类型，而表达式2和3相当于同一个函数在不同情况下的返回值，因此它们的类型要求一致，也要做Usual
Arithmetic Conversion。</p>
<p>下面举个例子，定义一个函数求两个参数中较大的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逗号运算符">逗号运算符</h3>
<p>逗号运算符（Comma
Operator）也是一种双目运算符，它的形式是<code>表达式1, 表达式2</code>，两个表达式不要求类型一致，左边的表达式1先求值，求完了直接把值丢掉，再求右边表达式2的值作为整个表达式的值。逗号运算符是左结合的，类似于<code>+ - * /</code>运算符，根据组合规则可以写出<code>表达式1, 表达式2, 表达式3, ..., 表达式n</code>这种形式，<code>表达式1</code>,
<code>表达式2</code>可以看作一个子表达式，先求<code>表达式1</code>的值，然后求<code>表达式2</code>的值作为这个子表达式的值，然后这个值再和<code>表达式3</code>组成一个更大的表达式，求<code>表达式3</code>的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一个表达式的值成为整个表达式的值。</p>
<p>注意，函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样使用逗号运算符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a, (t=<span class="number">3</span>, t+<span class="number">2</span>), c)</span><br></pre></td></tr></table></figure>
<p>传给函数<code>f</code>的参数有三个，其中第二个参数的值是表达式<code>t+2</code>的值。</p>
<h3
id="sizeof运算符与typedef类型声明">sizeof运算符与typedef类型声明</h3>
<p><code>sizeof</code>是一个很特殊的运算符，它有两种形式：“<code>sizeof 表达式</code>”和“<code>sizeof(类型名)</code>”。这个运算符很特殊，“<code>sizeof 表达式</code>”中的子表达式并不求值，而只是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成“<code>sizeof(表达式)</code>”的形式也可以，这里的括号和<code>return(1);</code>的括号一样，不起任何作用。但另外一种形式“<code>sizeof(类型名)</code>”的括号则是必须写的，整个表达式的值也是这种类型所占的字节数。</p>
<p>比如用<code>sizeof</code>运算符求一个数组的长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span> a/<span class="keyword">sizeof</span> a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，由于<code>sizeof</code>
表达式中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道<code>sizeof a</code>的值是48，<code>sizeof a[0]</code>的值是4，所以在编译时就已经把<code>sizeof a/sizeof a[0]</code>替换成常量12了，这是一个常量表达式。</p>
<p><code>sizeof</code>运算符的结果是<code>size_t</code>类型的，这个类型定义在<code>stddef.h</code>头文件中，不过你的代码中只要不出现<code>size_t</code>这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C标准规定<code>size_t</code>是一种无符号整型，编译器可以用<code>typedef</code>做一个类型声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<p>那么<code>size_t</code>就代表<code>unsigned long</code>型。不同平台的编译器可能会根据自己平台的具体情况定义<code>size_t</code>所代表的类型，比如有的平台定义为<code>unsigned long</code>型，有的平台定义为<code>unsigned long long</code>型，C标准规定<code>size_t</code>这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把<code>size_t</code>类型和它所代表的真实类型混用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">size_t</span> y;</span><br><span class="line">x = y;</span><br></pre></td></tr></table></figure>
<p>如果在一种ILP32平台上定义<code>size_t</code>代表<code>unsigned long long</code>型，这段代码把<code>y</code>赋给<code>x</code>时就把高位截掉了，结果可能是错的。</p>
<p><code>typedef</code>这个关键字用于给某种类型起个新名字，比如上面的<code>typedef</code>声明可以这么看：去掉<code>typedef</code>就成了一个变量声明<code>unsigned long size_t;</code>，<code>size_t</code>是一个变量名，类型是<code>unsigned long</code>，那么加上<code>typedef</code>之后，<code>size_t</code>就是一个类型名，就代表<code>unsigned long</code>类型。再举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> <span class="type">array_t</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">array_t</span> a;</span><br></pre></td></tr></table></figure>
<p>这相当于声明<code>char a[10];</code>。类型名也遵循标识符的命名规则，并且通常加个<code>_t</code>后缀表示Type。</p>
<h2 id="side-effect和sequence-point">Side Effect和Sequence Point</h2>
<p>如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了Short-circuit比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">a = (++a)+(++a)+(++a)+(++a);</span><br></pre></td></tr></table></figure>
<p>据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是Undefined。</p>
<p>我们知道，调用一个函数可能产生Side
Effect，使用某些运算符（<code>++ -- =</code> 复合赋值）也会产生Side
Effect，如果一个表达式中隐含着多个Side
Effect，究竟哪个先发生哪个后发生呢？C标准规定代码中的某些点是Sequence
Point，当执行到一个Sequence Point时，在此之前的Side
Effect必须全部作用完毕，在此之后的Side
Effect必须一个都没发生。至于两个Sequence Point之间的多个Side
Effect哪个先发生哪个后发生则没有规定，编译器可以任意选择各Side
Effect的作用顺序。下面详细解释各种Sequence Point。</p>
<p>1、调用一个函数时，在所有准备工作做完之后、函数调用开始之前是Sequence
Point。比如调用<code>foo(f(), g())</code>时，<code>foo</code>、<code>f()</code>、<code>g()</code>这三个表达式哪个先求值哪个后求值是Unspecified，但是必须都求值完了才能做最后的函数调用，所以<code>f()</code>和<code>g()</code>的Side
Effect按什么顺序发生不一定，但必定在这些Side
Effect全部作用完之后才开始调用<code>foo</code>函数。</p>
<p>2、条件运算符<code>?:</code>、逗号运算符、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>的第一个操作数求值之后是Sequence
Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据表达式1的值是否为真决定下一步求表达式2还是表达式3的值，如果决定求表达式2的值，表达式3就不会被求值了，反之也一样，逗号运算符也是这样，表达式1求值结束才继续求表达式2的值。</p>
<p>逻辑与和逻辑或早在第 3 节
“布尔代数”就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如例
8.5 “剪刀石头布”这个程序中的这几句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以写得更简单（类似于[K&amp;R]的简洁风格）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man) != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个控制表达式的求值顺序是：先求<code>scanf("%d", &amp;man) = 1</code>的值，如果<code>scanf</code>调用失败，则返回值不等于1成立，<code>||</code>运算有一个操作数为真则整个表达式为真，这时直接执行下一句<code>printf</code>，根本不会再去求<code>man &lt; 0</code>或<code>man &gt; 2</code>的值；如果<code>scanf</code>调用成功，则读入的数保存在变量<code>man</code>中，并且返回值等于1，那么说它不等于1就不成立了，第一个<code>||</code>运算的左操作数为假，就会去求右操作数<code>man &lt; 0</code>的值作为整个表达式的值，这时变量<code>man</code>的值正是<code>scanf</code>读上来的值，我们判断它是否在[0,
2]之间，如果<code>man &lt; 0</code>不成立，则整个表达式<code>scanf("%d", &amp;man) != 1 || man &lt; 0</code>
的值为假，也就是第二个<code>||</code>运算的左操作数为假，所以最后求右操作数<code>man &gt; 2</code>的值作为整个表达式的值。</p>
<p><code>&amp;&amp;</code>运算与此类似，<code>a &amp;&amp; b</code>的计算过程是：首先求表达式a的值，如果a的值是假则整个表达式的值是假，不会再去求b的值；如果a的值是真，则下一步求b的值作为整个表达式的值。所以，<code>a &amp;&amp; b</code>相当于“<code>if a then b</code>”，而<code>a || b</code>相当于“<code>if not a then b</code>”。这种特性称为Short-circuit，很多人喜欢利用Short-circuit特性简化代码。</p>
<p>3、在一个完整的声明末尾是Sequence
Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明<code>int a[10], b[20];</code>，在<code>a[10]</code>末尾是Sequence
Point，在<code>b[20]</code>末尾也是。</p>
<p>4、在一个完整的表达式末尾是Sequence
Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有<code>f(); g();</code>这样两条语句，<code>f()</code>和<code>g()</code>是两个完整的表达式，<code>f()</code>的Side
Effect必定在<code>g()</code>之前发生。</p>
<p>5、在库函数即将返回时是Sequence
Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（第
2.1 节 “函数式宏定义”），并不是真正的函数，所以才需要有这条规则。</p>
<p>还有两种Sequence
Point和某些C标准库函数的执行过程相关，此处从略，有兴趣的读者可参考[C99]的Annex
C。</p>
<p>现在可以分析一下本节开头的例子了。<code>a = (++a)+(++a)+(++a)+(++a);</code>的结果之所以是Undefined，因为在这个表达式中有五个Side
Effect都在改变<code>a</code>的值，这些Side
Effect按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个<code>++a</code>的值，这时第一个、第三个、第四个<code>++a</code>的Side
Effect发生了没有，<code>a</code>的值被加过几次了，这些都不确定，所以第二个<code>++a</code>的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。</p>
<p>写表达式应遵循的原则一：在两个Sequence
Point之间，同一个变量的值只允许被改变一次。仅有这一条原则还不够，例如<code>a[i++] = i;</code>的变量<code>i</code>只改变了一次，但结果仍是Undefined，因为等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么<code>i = i + 1;</code>就没有歧义呢？虽然也是等号左边改<code>i</code>的值，等号右边读<code>i</code>的值，但你不读出<code>i</code>的值就没法计算<code>i + 1</code>，那拿什么去改<code>i</code>的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：如果在两个Sequence
Point之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写。</p>
<h2 id="运算符小结">运算符小结</h2>
<p>到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。</p>
<p>运算符<code>+ - * / % &gt; &lt; &gt;= &lt;= == != &amp; | ^</code>以及各种复合赋值运算符要求两边的操作数类型一致，条件运算符<code>?:</code>要求后两个操作数类型一致，这些运算符在计算之前都需要做Usual
Arithmetic Conversion。</p>
<p>下面按优先级从高到低的顺序总结一下C语言的运算符，每一条所列的各运算符具有相同的优先级，对于同一优先级的多个运算符按什么顺序计算也有说明，双目运算符就简单地用“左结合”或“右结合”来说明了。和指针有关的运算符<code>* &amp; -&gt;</code>也在这里列出来了，到第
23 章 指针再详细解释。</p>
<p>1、标识符、常量、字符串和用<code>()</code>括号套起来的表达式是组成表达式的最基本单元，在运算中做操作数，优先级最高。</p>
<p>2、后缀运算符，包括数组取下标<code>[]</code>、函数调用<code>()</code>、结构体取成员<code>“.”</code>、指向结构体的指针取成员<code>-&gt;</code>、后缀自增<code>++</code>、后缀自减<code>--</code>。如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）依次计算，比如<code>a.name++</code>，先算<code>a.name</code>，再<code>++</code>，这里的<code>.name</code>应该看成<code>a</code>的一个后缀，而不是把<code>.</code>看成双目运算符。</p>
<p>3、单目运算符，包括前缀自增<code>++</code>、前缀自减<code>--</code>、<code>sizeof</code>、类型转换<code>()</code>、取地址运算<code>&amp;</code>、指针间接寻址<code>*</code>、正号<code>+</code>、负号<code>-</code>、按位取反<code>~</code>、逻辑非<code>!</code>。如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）依次计算，比如<code>!~a</code>，先算<code>~a</code>，再求<code>!</code>。</p>
<p>4、乘<code>*</code>、除<code>/</code>、模<code>%</code>运算符。这三个运算符是左结合的。</p>
<p>5、加<code>+</code>、减<code>-</code>运算符。左结合。</p>
<p>6、移位运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>。左结合。</p>
<p>7、关系运算符<code>&lt; &gt; &lt;= &gt;=</code>。左结合。</p>
<p>8、相等性运算符<code>==</code>和<code>!=</code>。左结合。</p>
<p>9、按位与<code>&amp;</code>。左结合。</p>
<p>10、按位异或<code>^</code>。左结合。</p>
<p>11、按位或<code>|</code>。左结合。</p>
<p>12、逻辑与<code>&amp;&amp;</code>。左结合。</p>
<p>13、逻辑或<code>||</code>。左结合。</p>
<p>14、条件运算符<code>:?</code>。在第 2 节
“if/else语句”讲过Dangling-else问题，条件运算符也有类似的问题。例如<code>a ? b : c ? d : e</code>是看成<code>(a ? b : c) ? d : e</code>还是<code>a ? b : (c ? d : e)</code>呢？C语言规定是后者。</p>
<p>15、赋值<code>=</code>和各种复合赋值（<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</code>）。在双目运算符中只有赋值和复合赋值是右结合的。</p>
<p>16、逗号运算符。左结合。</p>
<p>[K&amp;R]第2章也有这样一个列表，但是对于结合性解释得不够清楚。左结合和右结合这两个概念只对双目运算符有意义，对于前缀、后缀和三目运算符我单独做了说明。C语言表达式的详细语法规则可以参考[C99]的Annex
A.2，其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些细节用优先级和结合性是表达不了的，只有看C99才能了解完整的语法规则。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:栈与队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 20:02:04" itemprop="dateModified" datetime="2025-08-07T20:02:04+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据结构的概念">数据结构的概念</h2>
<p>数据结构（Data
Structure）是数据的组织方式。程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。以前学过的复合类型也可以看作数据的组织方式，把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。数据的组织方式包含了存储方式和访问方式这两层意思，二者是紧密联系的。例如，数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式，结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访问，而不能按下标访问。</p>
<p>本章主要介绍栈和队列这两种数据结构以及它们的应用。从本章的应用实例可以看出，一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。所以Pascal语言的设计者Niklaus
Wirth提出：算法+数据结构=程序（详见[算法+数据结构=程序]）。</p>
<h2 id="堆栈">堆栈</h2>
<p>在第 3 节
“递归”中我们已经对堆栈这种数据结构有了初步认识。堆栈是一组元素的集合，类似于数组，不同之处在于，数组可以按下标随机访问，这次访问a[5]下次可以访问a[1]，但是堆栈的访问规则被限制为Push和Pop两种操作，Push（入栈或压栈）向栈顶添加元素，Pop（出栈或弹出）则取出当前栈顶的元素，也就是说，只能访问栈顶元素而不能访问栈中其它元素。如果所有元素的类型相同，堆栈的存储也可以用数组来实现，访问操作可以通过函数接口提供。看以下的示例程序。</p>
<p>例 用堆栈实现倒序打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    push(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    push(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    push(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!is_empty())</span><br><span class="line">        <span class="built_in">putchar</span>(pop());</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是<code>cba</code>。运行过程图示如下：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.stack.png"
alt="用堆栈实现倒序打印" />
<figcaption aria-hidden="true">用堆栈实现倒序打印</figcaption>
</figure>
<p>数组<code>stack</code>是堆栈的存储空间，变量<code>top</code>总是保存数组中栈顶的下一个元素的下标，我们说“<code>top</code>总是指向栈顶的下一个元素”，或者把<code>top</code>叫做栈顶指针（Pointer）。在第
2 节 “插入排序”中介绍了Loop
Invariant的概念，可以用它检验循环的正确性，这里的“<code>top</code>总是指向栈顶的下一个元素”其实也是一种Invariant，Push和Pop操作总是维持这个条件不变，这种Invariant描述的对象是一个数据结构而不是一个循环，在DbC中称为Class
Invariant。Pop操作的语义是取出栈顶元素，但上例的实现其实并没有清除原来的栈顶元素，只是把<code>top</code>指针移动了一下，原来的栈顶元素仍然存在那里，这就足够了，因为此后通过Push和Pop操作不可能再访问到已经取出的元素，下次Push操作就会覆盖它。<code>putchar</code>函数的作用是把一个字符打印到屏幕上，和<code>printf</code>的<code>%c</code>作用相同。布尔函数<code>is_empty</code>的作用是防止Pop操作访问越界。这里我们预留了足够大的栈空间（512个元素），其实严格来说Push操作之前也应该检查栈是否满了。</p>
<p>在<code>main</code>函数中，入栈的顺序是<code>'a'</code>、<code>'b'</code>、<code>'c'</code>，而出栈打印的顺序却是<code>'c'</code>、<code>'b'</code>、<code>'a'</code>，最后入栈的<code>'c'</code>最早出来，因此堆栈这种数据结构的特点可以概括为LIFO（Last
In First
Out，后进先出）。我们也可以写一个递归函数做倒序打印，利用函数调用的栈帧实现后进先出：</p>
<p>例 用递归实现倒序打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[LEN]=&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_backward</span><span class="params">(<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(pos == LEN)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">     print_backward(pos+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">putchar</span>(buf[pos]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     print_backward(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你会说，又是堆栈又是递归的，倒序打印一个数组犯得着这么大动干戈吗？写一个简单的循环不就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = LEN<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">putchar</span>(buf[i]);</span><br></pre></td></tr></table></figure>
<p>对于数组来说确实没必要搞这么复杂，因为数组既可以从前向后访问也可以从后向前访问，甚至可以随机访问，但有些数据结构的访问并没有这么自由，下一节你就会看到这样的数据结构。</p>
<h2 id="深度优先搜索">深度优先搜索</h2>
<p>现在我们用堆栈解决一个有意思的问题，定义一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maze[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。程序如下：</p>
<p>例 用深度优先搜索解迷宫问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col; &#125; <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">predecessor</span>[<span class="title">MAX_ROW</span>][<span class="title">MAX_COL</span>] =</span> &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="keyword">struct</span> point pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    predecessor[row][col] = pre;</span><br><span class="line">    push(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    push(p);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = pop();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col, p);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col, p);</span><br><span class="line">        print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (predecessor[p.row][p.col].row != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = predecessor[p.row][p.col];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">(4, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(2, 4)</span><br><span class="line">(1, 4)</span><br><span class="line">(0, 4)</span><br><span class="line">(0, 3)</span><br><span class="line">(0, 2)</span><br><span class="line">(1, 2)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(0, 0)</span><br></pre></td></tr></table></figure>
<p>这次堆栈里的元素是结构体类型的，用来表示迷宫中一个点的x和y座标。我们用一个新的数据结构保存走迷宫的路线，每个走过的点都有一个前趋（Predecessor）点，表示是从哪儿走到当前点的，比如<code>predecessor[4][4]</code>是座标为(3,
4)的点，就表示从(3, 4)走到了(4,
4)，一开始<code>predecessor</code>的各元素初始化为无效座标(-1,
-1)。在迷宫中探索路线的同时就把路线保存在<code>predecessor</code>数组中，已经走过的点在<code>maze</code>数组中记为2防止重复走，最后找到终点时就根据<code>predecessor</code>数组保存的路线从终点打印到起点。为了帮助理解，我把这个算法改写成伪代码（Pseudocode）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将起点标记为已走过并压栈;</span><br><span class="line"><span class="keyword">while</span> (栈非空) &#123;</span><br><span class="line">    从栈顶弹出一个点p;</span><br><span class="line">    <span class="keyword">if</span> (p这个点是终点)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    否则沿右、下、左、上四个方向探索相邻的点</span><br><span class="line">    <span class="keyword">if</span> (和p相邻的点有路可走，并且还没走过)</span><br><span class="line">        将相邻的点标记为已走过并压栈，它的前趋就是p点;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p点是终点) &#123;</span><br><span class="line">    打印p点的座标;</span><br><span class="line">    <span class="keyword">while</span> (p点有前趋) &#123;</span><br><span class="line">        p点 = p点的前趋;</span><br><span class="line">        打印p点的座标;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    没有路线可以到达终点;</span><br></pre></td></tr></table></figure>
<p>我在<code>while</code>循环的末尾插了打印语句，每探索一步都打印出当前迷宫的状态（标记了哪些点），从打印结果可以看出这种搜索算法的特点是：每次探索完各个方向相邻的点之后，取其中一个相邻的点走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。这称为深度优先搜索（DFS，Depth
First Search）。探索迷宫和堆栈变化的过程如下图所示。</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.dfs.png"
alt="深度优先搜索" />
<figcaption aria-hidden="true">深度优先搜索</figcaption>
</figure>
<p>图中各点的编号表示探索顺序，堆栈中保存的应该是座标，我在画图时为了直观就把各点的编号写在堆栈里了。可见正是堆栈后进先出的性质使这个算法具有了深度优先的特点。如果在探索问题的解时走进了死胡同，则需要退回来从另一条路继续探索，这种思想称为回溯（Backtrack），一个典型的例子是很多编程书上都会讲的八皇后问题。</p>
<p>最后我们打印终点的座标并通过<code>predecessor</code>数据结构找到它的前趋，这样顺藤摸瓜一直打印到起点。那么能不能从起点到终点正向打印路线呢？在上一节我们看到，数组支持随机访问也支持顺序访问，如果在一个循环里打印数组，既可以正向打印也可以反向打印。但<code>predecessor</code>这种数据结构却有很多限制：</p>
<p>不能随机访问一条路线上的任意点，只能通过一个点找到另一个点，通过另一个点再找第三个点，因此只能顺序访问。</p>
<p>每个点只知道它的前趋是谁，而不知道它的后继（Successor）是谁，所以只能反向顺序访问。</p>
<p>可见，有什么样的数据结构就决定了可以用什么样的算法。那为什么不再建一个<code>successor</code>数组来保存每个点的后继呢？从DFS算法的过程可以看出，虽然每个点的前趋只有一个，后继却不止一个，如果我们为每个点只保存一个后继，则无法保证这个后继指向正确的路线。由此可见，有什么样的算法就决定了可以用什么样的数据结构。设计算法和设计数据结构这两件工作是紧密联系的。</p>
<h2 id="队列与广度优先搜索">队列与广度优先搜索</h2>
<p>队列也是一组元素的集合，也提供两种基本操作：Enqueue（入队）将元素添加到队尾，Dequeue（出队）从队头取出元素并返回。就像排队买票一样，先来先服务，先入队的人也是先出队的，这种方式称为FIFO（First
In First Out，先进先出），有时候队列本身也被称为FIFO。</p>
<p>下面我们用队列解决迷宫问题。程序如下：</p>
<p>例 用广度优先搜索解迷宫问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col, predecessor; &#125; <span class="built_in">queue</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>[tail++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point <span class="title function_">dequeue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>[head++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> head == tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col, head<span class="number">-1</span> &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    enqueue(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    enqueue(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = dequeue();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col);</span><br><span class="line">            print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (p.predecessor != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = <span class="built_in">queue</span>[p.predecessor];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">(4, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(2, 4)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(0, 0)</span><br></pre></td></tr></table></figure>
<p>其实仍然可以像例 12.3
“用深度优先搜索解迷宫问题”一样用predecessor数组表示每个点的前趋，但我想换一种更方便的数据结构，直接在每个点的结构体中加一个成员表示前趋：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col, predecessor; &#125; <span class="built_in">queue</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>变量<code>head</code>和<code>tail</code>是队头和队尾指针，<code>head</code>总是指向队头，<code>tail</code>总是指向队尾的下一个元素。每个点的<code>predecessor</code>成员也是一个指针，指向它的前趋在<code>queue</code>数组中的位置。如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.bfsqueue.png"
alt="广度优先搜索的队列数据结构" />
<figcaption aria-hidden="true">广度优先搜索的队列数据结构</figcaption>
</figure>
<p>为了帮助理解，我把这个算法改写成伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将起点标记为已走过并入队;</span><br><span class="line"><span class="keyword">while</span> (队列非空) &#123;</span><br><span class="line">    出队一个点p;</span><br><span class="line">    <span class="keyword">if</span> (p这个点是终点)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    否则沿右、下、左、上四个方向探索相邻的点</span><br><span class="line">    <span class="keyword">if</span> (和p相邻的点有路可走，并且还没走过)</span><br><span class="line">        将相邻的点标记为已走过并入队，它的前趋就是刚出队的p点;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p点是终点) &#123;</span><br><span class="line">    打印p点的座标;</span><br><span class="line">    <span class="keyword">while</span> (p点有前趋) &#123;</span><br><span class="line">        p点 = p点的前趋;</span><br><span class="line">        打印p点的座标;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    没有路线可以到达终点;</span><br></pre></td></tr></table></figure>
<p>从打印的搜索过程可以看出，这个算法的特点是沿各个方向同时展开搜索，每个可以走通的方向轮流往前走一步，这称为广度优先搜索（BFS，Breadth
First Search）。探索迷宫和队列变化的过程如下图所示。</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.bfs.png"
alt="广度优先搜索" />
<figcaption aria-hidden="true">广度优先搜索</figcaption>
</figure>
<p>广度优先是一种步步为营的策略，每次都从各个方向探索一步，将前线推进一步，图中的虚线就表示这个前线，队列中的元素总是由前线的点组成的，可见正是队列先进先出的性质使这个算法具有了广度优先的特点。广度优先搜索还有一个特点是可以找到从起点到终点的最短路径，而深度优先搜索找到的不一定是最短路径，比较本节和上一节程序的运行结果可以看出这一点，想一想为什么。</p>
<h2 id="环形队列">环形队列</h2>
<p>比较例 12.3 “用深度优先搜索解迷宫问题”的栈操作和例 12.4
“用广度优先搜索解迷宫问题”的队列操作可以发现，栈操作的<code>top</code>指针在Push时增大而在Pop时减小，栈空间是可以重复利用的，而队列的<code>head</code>、<code>tail</code>指针都在一直增大，虽然前面的元素已经出队了，但它所占的存储空间却不能重复利用。在例
12.4
“用广度优先搜索解迷宫问题”的解法中，出队的元素仍然有用，保存着走过的路径和每个点的前趋，但大多数程序并不是这样使用队列的，一般情况下出队的元素就不再有保存价值了，这些元素的存储空间应该回收利用，由此想到把队列改造成环形队列（Circular
Queue）：把<code>queue</code>数组想像成一个圈，<code>head</code>和<code>tail</code>指针仍然是一直增大的，当指到数组末尾时就自动回到数组开头，就像两个人围着操场赛跑，沿着它们跑的方向看，从<code>head</code>到<code>tail</code>之间是队列的有效元素，从<code>tail</code>到<code>head</code>之间是空的存储位置，如果<code>head</code>追上<code>tail</code>就表示队列空了，如果<code>tail</code>追上<code>head</code>就表示队列的存储空间满了。如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.circular.png"
alt="环形队列" />
<figcaption aria-hidden="true">环形队列</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:计算机中数的表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:54:02" itemprop="dateModified" datetime="2025-08-08T19:54:02+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么计算机使用二进制数">为什么计算机使用二进制数</h2>
<p>人类的计数方式通常是“逢十进一”，称为十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字0~9是目前最广泛采用的。</p>
<p>计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所以对计算机来说二进制（Binary）是最自然的计数方式。根据“逢二进一”的原则，十进制的1、2、3、4分别对应二进制的1、10、11、100。二进制的一位数字称为一个位（Bit），三个bit能够表示的最大的二进制数是111，也就是十进制的7。不管用哪种计数方式，数的大小并没有变，十进制的1+1等于2，二进制的1+1等于10，二进制的10和十进制的2大小是相等的。</p>
<h2 id="不同进制之间的换算">不同进制之间的换算</h2>
<p>在十进制中，个位的1代表100=1，十位的1代表101=10，百位的1代表102=100，所以</p>
<p>123=1×102+2×101+3×100</p>
<p>同样道理，在二进制中，个位的1代表20=1，十位的1代表21=2，百位的1代表22=4，所以</p>
<p>(A3A2A1A0)2=A3×23+A2×22+A1×21+A0×20</p>
<p>如果二进制和十进制数出现在同一个等式中，为了区别我们用(A3A2A1A0)2这种形式表示A3A2A1A0是二进制数，每个数字只能是0或1，其它没有套括号加下标的数仍表示十进制数。对于(A3A2A1A0)2这样一个二进制数，最左边的A3位称为最高位（MSB，Most
Significant Bit），最右边的A0位称为最低位（LSB，Least Significant
Bit）。以后我们遵循这样的惯例：LSB称为第0位而不是第1位，所以如果一个数是32位的，则MSB是第31位。上式就是从二进制到十进制的换算公式。作为练习，请读者算一下(1011)2和(1111)2换算成十进制分别是多少。</p>
<p>下面来看十进制怎么换算成二进制。我们知道</p>
<p>13=1×23+1×22+0×21+1×20</p>
<p>所以13换算成二进制应该是(1101)2。问题是怎么把13分解成等号右边的形式呢？注意到等号右边可以写成</p>
<p>13=(((0×2+13)×2+12)×2+01)×2+10</p>
<p>我们将13反复除以2取余数就可以提取出上式中的1101四个数字，为了让读者更容易看清楚是哪个1和哪个0，上式和下式中对应的数字都加了下标：</p>
<p>13÷2=6…10 6÷2=3…01 3÷2=1…12 1÷2=0…13</p>
<p>把这四步得到的余数按相反的顺序排列就是13的二进制表示，因此这种方法称为除二反序取余法。</p>
<p>计算机用二进制表示数，程序员也必须习惯使用二进制，但二进制写起来太啰嗦了，所以通常将二进制数分成每三位一组或者每四位一组，每组用一个数字表示。比如把(10110010)2从最低位开始每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是(262)8，这样每一位数字的取值范围是0<sub>7，逢八进一，称为八进制（Octal）。类似地，把(10110010)2分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是2，高位已经大于9了，我们规定用字母A</sub>F表示10<sub>15，这个数可以写成(B2)16，每一位数字的取值范围是0</sub>F，逢十六进一，称为十六进制（Hexadecimal）。所以，八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样。</p>
<h2 id="整数的加减运算">整数的加减运算</h2>
<p>我们已经了解了计算机中正整数如何表示，加法如何计算，那么负数如何表示，减法又如何计算呢？本节讨论这些问题。为了书写方便，本节举的例子都用8个bit表示一个数，实际计算机做整数加减运算的操作数可以是8位、16位、32位甚至64位的。</p>
<h3 id="sign-and-magnitude表示法">Sign and Magnitude表示法</h3>
<p>要用8个bit表示正数和负数，一种简单的想法是把最高位规定为符号位（Sign
Bit），0表示正1表示负，剩下的7位表示绝对值的大小，这称为Sign and
Magnitude表示法。例如-1表示成10000001，+1表示成00000001。这样用8个bit表示整数的取值范围是-27-1<sub>27-1，即-127</sub>127。</p>
<p>采用这种表示法，计算机做加法运算需要处理以下逻辑：</p>
<p>如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出（Overflow）[24]，这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。</p>
<p>如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同。</p>
<p>那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算a-b，可以先把b变号然后和a相加，相当于计算a+(-b)。但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步减法计算仍然是免不了的。我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有第
1 节
“为什么计算机用二进制计数”提到的加法器电路之外，还要另外有一套减法器电路。</p>
<p>如果采用Sign and
Magnitude表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。还有一个缺点是0的表示不唯一，既可以表示成10000000也可以表示成00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。</p>
<h3 id="s-complement表示法">1’s Complement表示法</h3>
<p>本节介绍一种二进制补码表示法，为了便于理解，我们先看一个十进制的例子：</p>
<p>167-52=167+(-52)=167+(999-52)-1000+1=167+947-1000+1=1114-1000+1=114+1=115
167-52 → 减法转换成加法 167+(-52) → 负数取9的补码表示 167+947 → 114进1 →
高位进的1加到低位上去，结果为115</p>
<p>在这个例子中我们用三位十进制数字表示正数和负数，具体规定如下：</p>
<p>9’s Complement表示法</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>补码表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>-499</td>
<td>500</td>
</tr>
<tr>
<td>-498</td>
<td>501</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>-1</td>
<td>998</td>
</tr>
<tr>
<td>0</td>
<td>999</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>498</td>
<td>498</td>
</tr>
<tr>
<td>499</td>
<td>499</td>
</tr>
</tbody>
</table>
<p>首先-52要用999-52表示，就是947，这称为取9的补码（9’s
Complement）；然后把167和947相加，得到114进1；再把高位进的1加到低位上去，得115，本来应该加1000，结果加了1，少加了999，正好把先前取9的补码多加的999抵消掉了。我们本来要做167-52的减法运算，结果变成做999-52的减法运算，后者显然要容易一些，因为没有借位。这种补码表示法的计算规则用一句话概括就是：负数用9的补码表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。要验证这条规则得考虑四种情况：</p>
<p>两个正数，相加得正</p>
<p>一正一负，相加得正</p>
<p>一正一负，相加得负</p>
<p>两个负数，相加得负</p>
<p>我们举的例子验证了第二种情况，另外三种情况请读者自己验证，暂时不考虑溢出的问题，稍后会讲到如何判定溢出。</p>
<p>上述规则也适用于二进制：负数用1的补码（1’s
Complement）表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去。取1的补码更简单，连减法都不用做，因为1-1=0，1-0=1，取1的补码就是把每个bit取反，所以1的补码也称为反码。比如：</p>
<p>00001000-00000100 → 00001000+(-00000100) → 00001000+11111011 →
00000011进1 → 高位进的1加到低位上去，结果为00000100</p>
<p>1’s Complement表示法相对于Sign and
Magnitude表示法的优势是非常明显的：不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，计算逻辑更简单，甚至连减法器电路都省了，只要有一套加法器电路，再有一套把每个bit取反的电路，就可以做加法和减法运算。如果8个bit采用1’s
Complement表示法，负数的取值范围是从10000000到11111111（-127<sub>0），正数是从00000000到01111111（0</sub>127），仍然可以根据最高位判断一个数是正是负。美中不足的是0的表示仍然不唯一，既可以表示成11111111也可以表示成00000000，为了解决这最后一个问题，我们引入2’s
Complement表示法。</p>
<h3 id="s-complement表示法-1">2’s Complement表示法</h3>
<p>2’s
Complement表示法规定：正数不变，负数先取反码再加1。如果8个bit采用2’s
Complement表示法，负数的取值范围是从10000000到11111111（-128<sub>-1），正数是从00000000到01111111（0</sub>127），也可以根据最高位判断一个数是正是负，并且0的表示是唯一的，目前绝大多数计算机都采用这种表示法。为什么称为“2的补码”呢？因为对一位二进制数b取补码就是1-b+1=10-b，相当于从2里面减去b。类似地，要表示-4需要对00000100取补码，11111111-00000100+1=100000000-00000100，相当于从28里面减去4。2’s
Complement表示法的计算规则有些不同：减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。请读者自己验证上一节提到的四种情况下这条规则都能算出正确结果。</p>
<p>8个bit采用2’s
Complement表示法的取值范围是-128~127，如果计算结果超出这个范围就会产生溢出，例如：</p>
<p>10000010(-126)+11111000(-8)=01111010(122)</p>
<p>如何判断产生了溢出呢？我们还是分四种情况讨论：如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。</p>
<h3 id="有符号数和无符号数">有符号数和无符号数</h3>
<p>前面几节我们用8个bit表示正数和负数，讲了三种表示法，每种表示法对应一种计算规则，这称为有符号数（Signed
Number）；如果8个bit全部表示正数则取值范围是0~255，这称为无符号数（Unsigned
Number）。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样，比如上面的例子也可以看作无符号数的加法：</p>
<p>10000010(130)+11111000(248)=01111010(122+256)</p>
<p>如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出；但如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的。计算机的加法器在做完计算之后，根据最高位产生的进位设置进位标志，同时根据最高位和次高位产生的进位的异或设置溢出标志。至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。</p>
<h2 id="浮点数">浮点数</h2>
<p>浮点数在计算机中的表示是基于科学计数法（Scientific
Notation）的，我们知道32767这个数用科学计数法可以写成3.2767×104，3.2767称为尾数（Mantissa，或者叫Significand），4称为指数（Exponent）。浮点数在计算机中的表示与此类似，只不过基数（Radix）是2而不是10。下面我们用一个简单的模型来解释浮点数的基本概念。我们的模型由三部分组成：符号位、指数部分（表示2的多少次方）和尾数部分（小数点前面是0，尾数部分只表示小数点后的数字）。</p>
<p>一种浮点数格式</p>
<table>
<thead>
<tr>
<th>1 bit</th>
<th>5 bits</th>
<th>8 bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>sign bit</td>
<td>exponent</td>
<td>significand</td>
</tr>
</tbody>
</table>
<p>如果要表示17这个数，我们知道17=17.0×100=0.17×102，类似地，17=(10001)2×20=(0.10001)2×25，把尾数的有效数字全部移到小数点后，这样就可以表示为：</p>
<p>17的浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>00101</td>
<td>10001000</td>
</tr>
</tbody>
</table>
<p>如果我们要表示0.25就遇到新的困难了，因为0.25=1×2-2=(0.1)2×2-1，而我们的模型中指数部分没有规定如何表示负数。我们可以在指数部分规定一个符号位，然而更广泛采用的办法是使用偏移的指数（Biased
Exponent）。规定一个偏移值，比如16，实际的指数要加上这个偏移值再填写到指数部分，这样比16大的就表示正指数，比16小的就表示负指数。要表示0.25，指数部分应该填16-1=15：</p>
<p>0.25的偏移指数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>01111</td>
<td>10000000</td>
</tr>
</tbody>
</table>
<p>现在还有一个问题需要解决：每个浮点数的表示都不唯一，例如17=(0.10001)2×25=(0.010001)2×26，这样给计算机处理增加了复杂性。为了解决这个问题，我们规定尾数部分的最高位必须是1，也就是说尾数必须以0.1开头，对指数做相应的调整，这称为正规化（Normalize）。由于尾数部分的最高位必须是1，这个1就不必保存了，可以节省出一位来用于提高精度，我们说最高位的1是隐含的（Implied）。这样17就只有一种表示方法了，指数部分应该是16+5=21=(10101)2，尾数部分去掉最高位的1是0001：</p>
<p>17的正规化尾数浮点数表示</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10101</td>
<td>00010000</td>
</tr>
</tbody>
</table>
<p>两个浮点数相加，首先把小数点对齐然后相加：</p>
<table>
<thead>
<tr>
<th>sign bit</th>
<th>biased exponent</th>
<th>normalized significand</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10010</td>
<td>10010000</td>
<td>+</td>
</tr>
<tr>
<td>0</td>
<td>10000</td>
<td>00110110</td>
<td>=</td>
</tr>
<tr>
<td>0</td>
<td>10010</td>
<td>11011101</td>
<td></td>
</tr>
</tbody>
</table>
<p>11.0010000+0.100110110=11.101110110</p>
<p>由于浮点数表示的精度有限，计算结果末尾的10两位被舍去了。做浮点运算时要注意精度损失（Significance
Loss）问题，有时计算顺序不同也会导致不同的结果，比如11.0010000+0.00000001+0.00000001=11.0010000+0.00000001=11.0010000，后面加的两个很小的数全被舍去了，没有对计算结果产生任何影响，但如果调一下计算顺序它们就能影响到计算结果了，0.00000001+0.00000001+11.0010000=0.00000010+11.0010000=11.0010001。再比如128.25=(10000000.01)2，需要10个有效位，而我们的模型中尾数部分是8位，算上隐含的最高位1一共有9个有效位，那么128.25的浮点数表示只能舍去末尾的1，表示成(10000000.0)2，其实跟128相等了。在第
2 节
“if/else语句”讲过浮点数不能做精确比较，现在读者应该知道为什么不能精确比较了。</p>
<p>整数运算会产生溢出，浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，但和整数运算的定义不同。假设整数采用8位2’s
Complement表示法，取值范围是-128<sub>127，如果计算结果是-130则称为下溢，计算结果是130则称为上溢。假设按本节介绍的浮点数表示法，取值范围是-(0.111111111)2×215</sub>(0.111111111)2×215，如果计算结果超出这个范围则称为上溢；如果计算结果未超出这个范围但绝对值太小了，在-(0.1)2×2-16~(0.1)2×2-16之间，那么也同样无法表示，称为下溢。</p>
<p>浮点数是一个相当复杂的话题，不同平台的浮点数表示和浮点运算也有较大差异，本节只是通过这个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，目前业界广泛采用的符点数标准是由IEEE（Institute
of Electrical and Electronics Engineers）制定的IEEE 754。</p>
<p>最后讨论一个细节问题。我们知道，定义全局变量时如果没有Initializer就用0初始化，定义数组时如果Initializer中提供的元素不够那么剩下的元素也用0初始化。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">double</span> a[<span class="number">10</span>] = &#123; <span class="number">1.0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>“用<code>0</code>初始化”的意思是变量<code>i</code>、变量<code>d</code>和数组元素<code>a[1]~a[9]</code>的所有字节都用<code>0</code>填充，或者说所有bit都是0。无论是用Sign
and Magnitude表示法、1’s Complement表示法还是2’s
Complement表示法，一个整数的所有bit是0都表示0值，但一个浮点数的所有bit是0一定表示0值吗？严格来说不一定，某种平台可能会规定一个浮点数的所有bit是0并不表示0值，但[C99
Rationale]第6.7.8节的条款25提到：As far as the committee knows, all
machines treat all bits zero as a representation of floating-point zero.
But, all bits zero might not be the canonical representation of zero.
因此在绝大多数平台上，一个浮点数的所有bit是0就表示0值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:gdb</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 17:49:37" itemprop="dateModified" datetime="2025-08-07T17:49:37+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序中除了一目了然的Bug之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入<code>printf</code>，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正Bug了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具gdb，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的代码行等。掌握了gdb的用法之后，调试手段就更加丰富了。但要注意，即使调试手段丰富了，调试的基本思想仍然是“分析现象-&gt;假设错误原因-&gt;产生新的现象去验证假设”这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用而忽略了分析过程，往往会治标不治本地修正Bug，导致一个错误现象消失了但Bug仍然存在，甚至是把程序越改越错。本章通过初学者易犯的几个错误实例来讲解如何使用gdb调试程序，在每个实例后面总结一部分常用的gdb命令。</p>
<h2 id="单步执行和跟踪函数调用">单步执行和跟踪函数调用</h2>
<p>看下面的程序：</p>
<p>例 函数调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_range</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, sum;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result[<span class="number">100</span>];</span><br><span class="line">    result[<span class="number">0</span>] = add_range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    result[<span class="number">1</span>] = add_range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[0]=%d\nresult[1]=%d\n&quot;</span>, result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_range</code>函数从<code>low</code>加到<code>high</code>，在<code>main</code>函数中首先从<code>1</code>加到<code>10</code>，把结果保存下来，然后从<code>1</code>加到<code>100</code>，再把结果保存下来，最后打印的两个结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br></pre></td></tr></table></figure>
<p>第一个结果正确[20]，第二个结果显然不正确，在小学我们就听说过高斯小时候的故事，从1加到100应该是5050。一段代码，第一次运行结果是对的，第二次运行却不对，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。在动手调试之前，读者先试试只看代码能不能看出错误原因，只要前面几章学得扎实就应该能看出来。</p>
<p>在编译时要加上<code>-g</code>选项，生成的可执行文件才能用gdb进行源码级调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g main.c -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">GNU gdb 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p><code>-g</code>选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入<code>help</code>可以查看命令的类别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure>
<p>也可以进一步查看某一类别中有哪些命令，例如查看files类别下有哪些命令可用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help files</span><br><span class="line">Specifying and examining files.</span><br><span class="line"></span><br><span class="line">List of commands:</span><br><span class="line"></span><br><span class="line">add-shared-symbol-files -- Load the symbols from shared objects in the dynamic linker&#x27;s link map</span><br><span class="line">add-symbol-file -- Load symbols from FILE</span><br><span class="line">add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file</span><br><span class="line">cd -- Set working directory to DIR for debugger and program being debugged</span><br><span class="line">core-file -- Use FILE as core dump for examining memory and registers</span><br><span class="line">directory -- Add directory DIR to beginning of search path for source files</span><br><span class="line">edit -- Edit specified file or function</span><br><span class="line">exec-file -- Use FILE as program for getting contents of pure memory</span><br><span class="line">file -- Use FILE as program to be debugged</span><br><span class="line">forward-search -- Search for regular expression (see regex(3)) from last line listed</span><br><span class="line">generate-core-file -- Save a core file with the current state of the debugged process</span><br><span class="line">list -- List specified function or line</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在试试用<code>list</code>命令从第一行开始列出源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 1</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>一次只列10行，如果要从第11行开始继续列源代码可以输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list</span><br></pre></td></tr></table></figure>
<p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) （直接回车）</span><br><span class="line">11  int main(void)</span><br><span class="line">12  &#123;</span><br><span class="line">13      int result[100];</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">17      return 0;</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p>gdb的很多常用命令有简写形式，例如<code>list</code>命令可以写成<code>l</code>，要列一个函数的源代码也可以用函数名做参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l add_range</span><br><span class="line">1   #include &lt;stdio.h&gt;</span><br><span class="line">2   </span><br><span class="line">3   int add_range(int low, int high)</span><br><span class="line">4   &#123;</span><br><span class="line">5       int i, sum;</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">8       return sum;</span><br><span class="line">9   &#125;</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>现在退出gdb的环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>
<p>我们做一个实验，把源代码改名或移到别处再用gdb调试，这样就列不出源代码了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> main.c mian.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) l</span><br><span class="line">5	main.c: No such file or directory.</span><br><span class="line">	in main.c</span><br></pre></td></tr></table></figure>
<p>可见gcc的<code>-g</code>选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用<code>start</code>命令开始执行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14		result[0] = add_range(1, 10);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>gdb停在<code>main</code>函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句。我们可以用<code>next</code>命令（简写为<code>n</code>）控制这些语句一条一条地执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">15		result[1] = add_range(1, 100);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">16		printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5105</span><br><span class="line">17		return 0;</span><br></pre></td></tr></table></figure>
<p>用<code>n</code>命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在<code>return</code>语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在<code>main</code>函数中而在<code>add_range</code>函数中，现在用<code>start</code>命令重新来过，这次用<code>step</code>命令（简写为<code>s</code>）钻进<code>add_range</code>函数中去跟踪执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line"></span><br><span class="line">Breakpoint 2 at 0x80483ad: file main.c, line 14.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=10) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br></pre></td></tr></table></figure>
<p>这次停在了<code>add_range</code>函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，<code>backtrace</code>命令（简写为<code>bt</code>）可以查看函数调用的栈帧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=10) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br></pre></td></tr></table></figure>
<p>可见当前的<code>add_range</code>函数是被<code>main</code>函数调用的，<code>main</code>传进来的参数是<code>low=1</code>,
<code>high=10</code>。<code>main</code>函数的栈帧编号为<code>1</code>，<code>add_range</code>的栈帧编号为<code>0</code>。现在可以用<code>info</code>命令（简写为<code>i</code>）查看<code>add_range</code>函数局部变量的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i locals</span><br><span class="line">i = 0</span><br><span class="line">sum = 0</span><br></pre></td></tr></table></figure>
<p>如果想查看<code>main</code>函数当前局部变量的值也可以做到，先用<code>frame</code>命令（简写为<code>f</code>）选择<code>1</code>号栈帧然后再查看局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483c1 <span class="keyword">in</span> main () at main.c:14</span></span><br><span class="line">14	    result[0] = add_range(1, 10);</span><br><span class="line">(gdb) i locals </span><br><span class="line">result = &#123;0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>注意到<code>result</code>数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用<code>s</code>或<code>n</code>往下走几步，然后用<code>print</code>命令（简写为<code>p</code>）打印出变量<code>sum</code>的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">7           sum = sum + i;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 3</span></span><br></pre></td></tr></table></figure>
<p>第一次循环<code>i</code>是<code>1</code>，第二次循环<code>i</code>是<code>2</code>，加起来是<code>3</code>，没错。这里的<code>$1</code>表示gdb保存着这些中间结果，<code>$</code>后面的编号会自动增长，在命令中可以用<code>$1</code>、<code>$2</code>、<code>$3</code>等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用<code>finish</code>命令让程序一直运行到从当前函数返回为止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=10) at main.c:6</span><br><span class="line">0x080483c1 in main () at main.c:14</span><br><span class="line">14      result[0] = add_range(1, 10);</span><br><span class="line">Value returned is $2 = 55</span><br></pre></td></tr></table></figure>
<p>返回值是55，当前正准备执行赋值操作，用<code>s</code>命令赋值，然后查看<code>result</code>数组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480,</span> </span><br><span class="line">...</span><br><span class="line">  -1208623680&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值55确实赋给了<code>result</code>数组的第<code>0</code>个元素。下面用<code>s</code>命令进入第二次<code>add_range</code>调用，进入之后首先查看参数和局部变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">add_range (low=1, high=100) at main.c:6</span><br><span class="line">6       for (i = low; i &lt;= high; i++)</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  add_range (low=1, high=100) at main.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x080483db <span class="keyword">in</span> main () at main.c:15</span></span><br><span class="line">(gdb) i locals </span><br><span class="line">i = 11</span><br><span class="line">sum = 55</span><br></pre></td></tr></table></figure>
<p>由于局部变量<code>i</code>和<code>sum</code>没初始化，所以具有不确定的值，又由于两次调用是挨着的，<code>i</code>和<code>sum</code>正好取了上次调用时的值，原来这跟例
3.7
“验证局部变量存储空间的分配和释放”是一样的道理，只不过我这次举的例子设法让局部变量<code>sum</code>在第一次调用时初值为<code>0</code>了。<code>i</code>的初值不是<code>0</code>倒没关系，在<code>for</code>循环中会赋值为<code>0</code>的，但<code>sum</code>如果初值不是<code>0</code>，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出gdb修改源代码了。如果我们不想浪费这次调试机会，可以在gdb中马上把<code>sum</code>的初值改为<code>0</code>继续运行，看看这一处改了之后还有没有别的Bug：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var sum=0</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  add_range (low=1, high=100) at main.c:6</span><br><span class="line">0x080483db in main () at main.c:15</span><br><span class="line">15      result[1] = add_range(1, 100);</span><br><span class="line">Value returned is $4 = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">16      printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">result[0]=55</span><br><span class="line">result[1]=5050</span><br><span class="line">17      return 0;</span><br></pre></td></tr></table></figure>
<p>这样结果就对了。修改变量的值除了用<code>set</code>命令之外也可以用<code>print</code>命令，因为<code>print</code>命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用<code>print</code>命令修改变量的值或者调用函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 33</span></span><br><span class="line">(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])</span><br><span class="line">result[2]=33</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 13</span></span><br></pre></td></tr></table></figure>
<p>我们讲过，<code>printf</code>的返回值表示实际打印的字符数，所以<code>$6</code>的结果是<code>13</code>。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>backtrace（或bt）</td>
<td>查看各级函数调用及参数</td>
</tr>
<tr>
<td>finish</td>
<td>连续运行到当前函数返回为止，然后停下来等待命令</td>
</tr>
<tr>
<td>frame（或f） 帧编号</td>
<td>选择栈帧</td>
</tr>
<tr>
<td>info（或i） locals</td>
<td>查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td>list（或l）</td>
<td>列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td>list 行号</td>
<td>列出从第几行开始的源代码</td>
</tr>
<tr>
<td>list 函数名</td>
<td>列出某个函数的源代码</td>
</tr>
<tr>
<td>next（或n）</td>
<td>执行下一行语句</td>
</tr>
<tr>
<td>print（或p）</td>
<td>打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td>quit（或q）</td>
<td>退出gdb调试环境</td>
</tr>
<tr>
<td>set var</td>
<td>修改变量的值</td>
</tr>
<tr>
<td>start</td>
<td>开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td>step（或s）</td>
<td>执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
</tbody>
</table>
<h2 id="断点">断点</h2>
<p>看以下程序：</p>
<p>例 断点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用是：首先从键盘读入一串数字存到字符数组<code>input</code>中，然后转换成整型存到<code>sum</code>中，然后打印出来，一直这样循环下去。<code>scanf("%s", input);</code>这个调用的功能是等待用户输入一个字符串并回车，<code>scanf</code>把其中第一段非空白（非空格、<code>Tab</code>、换行）的字符串保存到<code>input</code>数组中，并自动在末尾添加<code>'\0'</code>。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是<code>"2345"</code>，则循环累加的过程是<code>(((0*10+2)*10+3)*10+4)*10+5=2345</code>。注意字符型的<code>'2'</code>要减去<code>'0'</code>的ASCII码才能转换成整数值<code>2</code>。下面编译运行程序看看有什么问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -g -o main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">234</span><br><span class="line">input=123234</span><br><span class="line">（Ctrl-C退出程序）</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>
<p>又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅<code>sum</code>赋了初值，连不必赋初值的<code>i</code>都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br></pre></td></tr></table></figure>
<p>有了上一次的经验，<code>sum</code>被列为重点怀疑对象，我们可以用<code>display</code>命令使得每次停下来的时候都显示当前<code>sum</code>的值，然后继续往下走：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display sum</span><br><span class="line">1: sum = -1208103488</span><br><span class="line">(gdb) n</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 0</span><br><span class="line">(gdb) </span><br><span class="line">123</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 0</span><br></pre></td></tr></table></figure>
<p><code>undisplay</code>命令可以取消跟踪显示，变量<code>sum</code>的编号是<code>1</code>，可以用<code>undisplay 1</code>命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用<code>break</code>命令（简写为<code>b</code>）在第9行设一个断点（Breakpoint）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">5       int sum = 0, i;</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">11              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">12          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">13      &#125;</span><br><span class="line">14      return 0;</span><br><span class="line">(gdb) b 9</span><br><span class="line">Breakpoint 2 at 0x80483bc: file main.c, line 9.</span><br></pre></td></tr></table></figure>
<p><code>break</code>命令的参数也可以是函数名，表示在某个函数开头设断点。现在用<code>continue</code>命令（简写为<code>c</code>）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>然后输入新的字符串准备转换：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">234</span><br><span class="line">10          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>问题暴露出来了，新的转换应该再次从<code>0</code>开始累加，而<code>sum</code>现在已经是<code>123</code>了，原因在于新的循环没有把<code>sum</code>归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，“断点加单步”是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用<code>printf</code>打印中间结果时也要分析应该在哪里插入<code>printf</code>，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用<code>info</code>命令可以查看已经设置的断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 12</span><br><span class="line">Breakpoint 3 at 0x8048411: file main.c, line 12.</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    breakpoint already hit 1 time</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>每个断点都有一个编号，可以用编号指定删除某个断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints 2</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br></pre></td></tr></table></figure>
<p>有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable breakpoints 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep n   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) enable 3</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">3       breakpoint     keep y   0x08048411 in main at main.c:12</span><br><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) i breakpoints</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>
<p>gdb的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当<code>sum</code>不等于<code>0</code>时才中断，然后用<code>run</code>命令（简写为<code>r</code>）重新从程序开头连续运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 9 if sum != 0</span><br><span class="line">Breakpoint 5 at 0x80483c3: file main.c, line 9.</span><br><span class="line">(gdb) i breakpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">5       breakpoint     keep y   0x080483c3 in main at main.c:9</span><br><span class="line">    stop only if sum != 0</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line"></span><br><span class="line">Breakpoint 5, main () at main.c:9</span><br><span class="line">9           scanf(&quot;%s&quot;, input);</span><br><span class="line">1: sum = 123</span><br></pre></td></tr></table></figure>
<p>结果是第一次执行<code>scanf</code>之前没有中断，第二次却中断了。总结一下本节用到的gdb命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break（或b） 行号</td>
<td>在某一行设置断点</td>
</tr>
<tr>
<td>break 函数名</td>
<td>在某个函数开头设置断点</td>
</tr>
<tr>
<td>break … if …</td>
<td>设置条件断点</td>
</tr>
<tr>
<td>continue（或c）</td>
<td>从当前位置开始连续运行程序</td>
</tr>
<tr>
<td>delete breakpoints 断点号</td>
<td>删除断点</td>
</tr>
<tr>
<td>display 变量名</td>
<td>跟踪查看某个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td>disable breakpoints 断点号</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable 断点号</td>
<td>启用断点</td>
</tr>
<tr>
<td>info（或i） breakpoints</td>
<td>查看当前设置了哪些断点</td>
</tr>
<tr>
<td>run（或r）</td>
<td>从头开始连续运行程序</td>
</tr>
<tr>
<td>undisplay 跟踪显示号</td>
<td>取消跟踪显示</td>
</tr>
</tbody>
</table>
<h2 id="观察点">观察点</h2>
<p>接着上一节的步骤，经过调试我们知道，虽然<code>sum</code>已经赋了初值<code>0</code>，但仍需要在<code>while (1)</code>循环的开头加上<code>sum = 0;</code>：</p>
<p>例 观察点调试实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">            sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>scanf</code>函数是非常凶险的，即使修正了这个Bug也还存在很多问题。如果输入的字符串超长了会怎么样？我们知道数组访问越界是不会检查的，所以<code>scanf</code>会写出界。现象是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123</span><br><span class="line">input=123</span><br><span class="line">67</span><br><span class="line">input=67</span><br><span class="line">12345</span><br><span class="line">input=123407</span><br></pre></td></tr></table></figure>
<p>下面用调试器看看最后这个诡异的结果是怎么出来的[21]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p input</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = <span class="string">&quot;12345&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>input</code>数组只有<code>5</code>个元素，写出界的是<code>scanf</code>自动添的<code>'\0'</code>，用<code>x</code>命令看会更清楚一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x00    0x00</span><br></pre></td></tr></table></figure>
<p><code>x</code>命令打印指定存储单元的内容。<code>7b</code>是打印格式，<code>b</code>表示每个字节一组，<code>7</code>表示打印<code>7</code>组[22]，从<code>input</code>数组的第一个字节开始连续打印<code>7</code>个字节。前<code>5</code>个字节是<code>input</code>数组的存储单元，打印的正是十六进制ASCII码的<code>'1'</code>到<code>'5'</code>，第<code>6</code>个字节是写出界的<code>'\0'</code>。根据运行结果，前4个字符转成数字都没错，第5个错了，也就是<code>i</code>从0到3的循环都没错，我们设一个条件断点从<code>i</code>等于4开始单步调试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">6       char input[5];</span><br><span class="line">7   </span><br><span class="line">8       while (1) &#123;</span><br><span class="line">9           sum = 0;</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">13          printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">14      &#125;</span><br><span class="line">15      return 0;</span><br><span class="line">(gdb) b 12 if i == 4</span><br><span class="line">Breakpoint 2 at 0x80483e6: file main.c, line 12.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:12</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1234</span></span><br></pre></td></tr></table></figure>
<p>现在<code>sum</code>是<code>1234</code>没错，根据运行结果是<code>123407</code>我们知道即将进行的这步计算肯定要出错，算出来应该是<code>12340</code>，那就是说<code>input[4]</code>肯定不是<code>'5'</code>了，事实证明这个推理是不严谨的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x04    0x00</span><br></pre></td></tr></table></figure>
<p><code>input[4]</code>的确是<code>0x35</code>，产生<code>123407</code>还有另外一种可能，就是在下一次循环中<code>123450</code>不是加上而是减去一个数得到<code>123407</code>。可现在不是到字符串末尾了吗？怎么会有下一次循环呢？注意到循环控制条件是<code>input[i] != '\0'</code>，而本来应该是<code>0x00</code>的位置现在莫名其妙地变成了<code>0x04</code>，因此循环不会结束。继续单步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 12345</span></span><br><span class="line">(gdb) n</span><br><span class="line">12              sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">(gdb) x/7b input</span><br><span class="line">0xbfb8f0a7: 0x31    0x32    0x33    0x34    0x35    0x05    0x00</span><br></pre></td></tr></table></figure>
<p>进入下一次循环，原来的<code>0x04</code>又莫名其妙地变成了<code>0x05</code>，这是怎么回事？这个暂时解释不了，但<code>123407</code>这个结果可以解释了，是<code>12345*10 + 0x05 - 0x30</code>得到的，虽然多循环了一次，但下次一定会退出循环了，因为<code>0x05</code>的后面是<code>'\0'</code>。</p>
<p><code>input[4]</code>后面那个字节到底是什么时候变的？可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。下面删除原来设的断点，从头执行程序，重复上次的输入，用<code>watch</code>命令设置观察点，跟踪<code>input[4]</code>后面那个字节（可以用<code>input[5]</code>表示，虽然这是访问越界）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete breakpoints </span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x80483b5: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">main () at main.c:5</span><br><span class="line">5       int sum = 0, i = 0;</span><br><span class="line">(gdb) n</span><br><span class="line">9           sum = 0;</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">10          scanf(&quot;%s&quot;, input);</span><br><span class="line">(gdb) （直接回车）</span><br><span class="line">12345</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) watch input[5]</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line">(gdb) i watchpoints </span><br><span class="line">Num     Type           Disp Enb Address    What</span><br><span class="line">2       hw watchpoint  keep y              input[5]</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 0 &#x27;\0&#x27;</span><br><span class="line">New value = 1 &#x27;\001&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 1 &#x27;\001&#x27;</span><br><span class="line">New value = 2 &#x27;\002&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: input[5]</span><br><span class="line"></span><br><span class="line">Old value = 2 &#x27;\002&#x27;</span><br><span class="line">New value = 3 &#x27;\003&#x27;</span><br><span class="line">0x0804840c in main () at main.c:11</span><br><span class="line">11          for (i = 0; input[i] != &#x27;\0&#x27;; i++)</span><br></pre></td></tr></table></figure>
<p>已经很明显了，每次都是回到<code>for</code>循环开头的时候改变了<code>input[5]</code>的值，而且是每次加<code>1</code>，而循环变量<code>i</code>正是在每次回到循环开头之前加<code>1</code>，原来<code>input[5]</code>就是变量<code>i</code>的存储单元，换句话说，<code>i</code>的存储单元是紧跟在<code>input</code>数组后面的。</p>
<p>修正这个Bug对初学者来说有一定难度。如果你发现了这个Bug却没想到数组访问越界这一点，也许一时想不出原因，就会先去处理另外一个更容易修正的Bug：如果输入的不是数字而是字母或别的符号也能算出结果来，这显然是不对的，可以在循环中加上判断条件检查非法字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line">123a</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">dead</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234578</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">23</span><br><span class="line">input=23</span><br></pre></td></tr></table></figure>
<p>似乎是两个Bug一起解决掉了，但这是治标不治本的解决方法。看起来输入超长的错误是不出现了，但只要没有找到根本原因就不可能真的解决掉，等到条件一变，它可能又冒出来了，在下一节你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入超长也会报错。最后总结一下本节用到的gdb命令：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch</td>
<td>设置观察点</td>
</tr>
<tr>
<td>info（或i） watchpoints</td>
<td>查看当前设置了哪些观察点</td>
</tr>
<tr>
<td>x</td>
<td>从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量</td>
</tr>
</tbody>
</table>
<h2 id="段错误">段错误</h2>
<p>如果程序运行时出现段错误，用gdb可以很容易定位到究竟是哪一行引发的段错误，例如这个小程序：</p>
<p>例 段错误调试实例一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> man = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, man);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">123</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0xb7e1404b <span class="keyword">in</span> _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0xb7e1dd2b <span class="keyword">in</span> scanf () from /lib/tls/i686/cmov/libc.so.6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0804839f <span class="keyword">in</span> main () at main.c:6</span></span><br></pre></td></tr></table></figure>
<p>在gdb中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。gdb显示段错误出现在<code>_IO_vfscanf</code>函数中，用<code>bt</code>命令可以看到这个函数是被我们的<code>scanf</code>函数调用的，所以是<code>scanf</code>这一行代码引发的段错误。仔细观察程序发现是<code>man</code>前面少了个<code>&amp;</code>。</p>
<p>继续调试上一节的程序，上一节最后提出修正Bug的方法是在循环中加上判断条件，如果不是数字就报错退出，不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无论怎么运行都不出错了，但假如我们把<code>while (1)</code>循环去掉，每次执行程序只转换一个数：</p>
<p>例 段错误调试实例二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] &lt; <span class="string">&#x27;0&#x27;</span> || input[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input!\n&quot;</span>);</span><br><span class="line">            sum = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum*<span class="number">10</span> + input[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input=%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输入一个超长的字符串，看看会发生什么：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br></pre></td></tr></table></figure>
<p>看起来正常。再来一次，这次输个更长的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span> </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>
<p>又出段错误了。我们按同样的方法用gdb调试看看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb main</span></span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/akaedu/main </span><br><span class="line">1234567890abcdef</span><br><span class="line">Invalid input!</span><br><span class="line">input=-1</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0804848e in main () at main.c:19</span><br><span class="line">19  &#125;</span><br><span class="line">(gdb) l</span><br><span class="line">14          &#125;</span><br><span class="line">15          sum = sum*10 + input[i] - &#x27;0&#x27;;</span><br><span class="line">16      &#125;</span><br><span class="line">17      printf(&quot;input=%d\n&quot;, sum);</span><br><span class="line">18      return 0;</span><br><span class="line">19  &#125;</span><br></pre></td></tr></table></figure>
<p>gdb指出，段错误发生在第<code>19</code>行。可是这一行什么都没有啊，只有表示<code>main</code>函数结束的<code>&#125;</code>括号。这可以算是一条规律，如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误。</p>
<p>想要写出Bug-free的程序是非常不容易的，即使<code>scanf</code>读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误，有些错误现象是我们暂时没法解释的：为什么变量<code>i</code>的存储单元紧跟在<code>input</code>数组后面？为什么同样是访问越界，有时出段错误有时不出段错误？为什么访问越界的段错误在函数返回时才出现？还有最基本的问题，为什么<code>scanf</code>输入整型变量就必须要加<code>&amp;</code>，否则就出段错误，而输入字符串就不要加<code>&amp;</code>？这些问题在后续章节中都会解释清楚。其实现在讲<code>scanf</code>这个函数为时过早，读者还不具备充足的基础知识。但还是有必要讲的，学完这一阶段之后读者应该能写出有用的程序了，然而一个只有输出而没有输入的程序算不上是有用的程序，另一方面也让读者认识到，学C语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个<code>scanf</code>函数都没办法用好，更没有办法保证写出正确的程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:分支语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 18:33:21" itemprop="dateModified" datetime="2025-08-06T18:33:21+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="if语句">if语句</h2>
<p>目前我们写的简单函数中可以有多条语句，但这些语句总是从前到后顺序执行的。除了顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在C语言中可以用分支语句（Selection
Statement）实现，比如：</p>
<p>if (x != 0) { printf(“x is nonzero.”); } 其中x !=
0表示“x不等于0”的条件，这个表达式称为控制表达式（Controlling
Expression）如果条件成立，则{}中的语句被执行，否则{}中的语句不执行，直接跳到}后面。if和控制表达式改变了程序的控制流程（Control
Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支（Branch）。上例中的!=号表示“不等于”，像这样的运算符有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody>
</table>
<p>注意以下几点：</p>
<p>这里的<code>==</code>表示数学中的相等关系，相当于数学中的<code>=</code>号，初学者常犯的错误是在控制表达式中把<code>==</code>写成<code>=</code>，在C语言中<code>=</code>号是赋值运算符，两者的含义完全不同。</p>
<p>如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用<code>int</code>型的<code>1</code>和<code>0</code>表示。如果变量<code>x</code>的值是<code>-1</code>，那么<code>x&gt;0</code>这个表达式的值为<code>0</code>，<code>x&gt;-2</code>这个表达式的值为<code>1</code>。</p>
<p>在数学中<code>a&lt;b&lt;c</code>表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，但作为C语言表达式却不是这样。以上几种运算符都是左结合的，请读者想一下这个表达式应如何求值。</p>
<p>这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较，在第
1.5 节 “比较字符串”我们会介绍比较字符串的方法。</p>
<p><code>==</code>和<code>!=</code>称为相等性运算符（Equality
Operator），其余四个称为关系运算符（Relational
Operator），相等性运算符的优先级低于关系运算符。</p>
<p>总结一下，<code>if (x != 0) &#123; ... &#125;</code>这个语句的计算顺序是：首先求<code>x != 0</code>这个表达式的值，如果值为<code>0</code>，就跳过<code>&#123;&#125;</code>中的语句直接执行后面的语句，如果值为<code>1</code>，就先执行<code>&#123;&#125;</code>中的语句，然后再执行后面的语句。事实上控制表达式取任何非<code>0</code>值都表示真值，例如<code>if (x) &#123; ... &#125;</code>和<code>if (x != 0) &#123; ... &#125;</code>是等价的，如果<code>x</code>的值是<code>2</code>，则<code>x != 0</code>的值是<code>1</code>，但对于<code>if</code>来说不管是<code>2</code>还是<code>1</code>都表示真值。</p>
<p>和if语句相关的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 语句 → { 语句列表 } 语句 → ;</p>
<p>在C语言中，任何允许出现语句的地方既可以是由<code>;</code>号结尾的一条语句，也可以是由<code>&#123;&#125;</code>括起来的若干条语句或声明组成的语句块（Statement
Block），语句块和上一章介绍的函数体的语法相同。注意语句块的<code>&#125;</code>后面不需要加<code>;</code>号。如果<code>&#125;</code>后面加了<code>;</code>号，则这个<code>;</code>号本身又是一条新的语句了，在C语言中一个单独的<code>;</code>号表示一条空语句（Null
Statement）。上例的语句块中只有一条语句，其实没必要写成语句块，可以简单地写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is nonzero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>语句块中也可以定义局部变量，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d, j=%d\n&quot;</span>, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>, i); <span class="comment">/* cannot access j here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和函数的局部变量同样道理，每次进入语句块时为变量j分配存储空间，每次退出语句块时释放变量<code>j</code>的存储空间。语句块也构成一个作用域，和例
3.6
“作用域”的分析类似，如果整个源文件是一张大纸，<code>foo</code>函数是盖在上面的一张小纸，则函数中的语句块是盖在小纸上面的一张更小的纸。语句块中的变量<code>i</code>和函数的局部变量<code>i</code>是两个不同的变量，因此两次打印的<code>i</code>值是不同的；语句块中的变量<code>j</code>在退出语句块之后就没有了，因此最后一行的<code>printf</code>不能打印变量<code>j</code>，否则编译器会报错。语句块可以用在任何允许出现语句的地方，不一定非得用在<code>if</code>语句中，单独使用语句块通常是为了定义一些比函数的局部变量更“局部”的变量。</p>
<h2 id="ifelse语句">if/else语句</h2>
<p><code>if</code>语句还可以带一个<code>else</code>子句（Clause），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里的<code>%</code>是取模（Modulo）运算符，<code>x%2</code>表示<code>x</code>除以<code>2</code>所得的余数（Remainder），C语言规定<code>%</code>运算符的两个操作数必须是整型的。两个正数相除取余数很好理解，如果操作数中有负数，结果应该是正是负呢？C99规定，如果<code>a</code>和<code>b</code>是整型，<code>b</code>不等于<code>0</code>，则表达式<code>(a/b)*b+a%b</code>的值总是等于<code>a</code>，再结合第
5 节 “表达式”讲过的整数除法运算要Truncate Toward
Zero，可以得到一个结论：%运算符的结果总是与被除数同号（想一想为什么）。其它编程语言对取模运算的规定各不相同，也有规定结果和除数同号的，也有不做明确规定的。</p>
<p>取模运算在程序中是非常有用的，例如上面的例子判断<code>x</code>的奇偶性（Parity），看<code>x</code>除以<code>2</code>的余数是不是<code>0</code>，如果是<code>0</code>则打印<code>x is even.</code>，如果不是<code>0</code>则打印<code>x is odd.</code>，读者应该能看出<code>else</code>在这里的作用了，如果在上面的例子中去掉<code>else</code>，则不管<code>x</code>是奇是偶，<code>printf("x is odd.\n");</code>总是执行。为了让这条语句更有用，可以把它封装（Encapsulate）成一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_parity</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is even.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is odd.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把语句封装成函数的基本步骤是：把语句放到函数体中，把变量改成函数的参数。这样，以后要检查一个数的奇偶性只需调用这个函数而不必重复写这条语句了，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print_parity(<span class="number">17</span>);</span><br><span class="line">print_parity(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><code>if/else</code>语句的语法规则如下：</p>
<p>语句 → if (控制表达式) 语句 else 语句</p>
<p>右边的“语句”既可以是一条语句，也可以是由<code>&#123;&#125;</code>括起来的语句块。一条<code>if</code>语句中包含一条子语句，一条<code>if/else</code>语句中包含两条子语句，子语句可以是任何语句或语句块，当然也可以是另外一条<code>if</code>或<code>if/else</code>语句。根据组合规则，<code>if</code>或<code>if/else</code>可以嵌套使用。例如可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x is positive.\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is negative.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is zero.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一个问题，类似<code>if (A) if (B) C; else D;</code>形式的语句怎么理解呢？可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>也可以理解成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        D;</span><br></pre></td></tr></table></figure>
<p>在第 1 节 “继续Hello
World”讲过，C代码的缩进只是为了程序员看起来方便，实际上对编译器不起任何作用，你的代码不管写成上面哪一种缩进格式，在编译器看起来都是一样的。那么编译器到底按哪种方式理解呢？也就是说，<code>else</code>到底是和<code>if (A)</code>配对还是和<code>if (B)</code>配对？很多编程语言的语法都有这个问题，称为Dangling-else问题。C语言规定，<code>else</code>总是和它上面最近的一个<code>if</code>配对，因此应该理解成<code>else</code>和<code>if (B)</code>配对，也就是按第二种方式理解。如果你写成上面第一种缩进的格式就很危险了：你看到的是这样，而编译器理解的却是那样。如果你希望编译器按第一种方式理解，应该明确加上<code>&#123;&#125;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">    <span class="keyword">if</span> (B)</span><br><span class="line">        C;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    D;</span><br></pre></td></tr></table></figure>
<p>顺便提一下，浮点型的精度有限，不适合用<code>==</code>运算符做精确比较。以下代码可以说明问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> i = <span class="number">20.0</span>;</span><br><span class="line"><span class="type">double</span> j = i / <span class="number">7.0</span>;</span><br><span class="line"><span class="keyword">if</span> (j * <span class="number">7.0</span> == i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Equal.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unequal.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不同平台的浮点数实现有很多不同之处，在我的平台上运行这段程序结果为<code>Unequal</code>，即使在你的平台上运行结果为<code>Equal</code>，你再把<code>i</code>改成其它值试试，总有些值会使得结果为<code>Unequal</code>。等学习了第
4 节 “浮点数”你就知道为什么浮点型不能做精确比较了。</p>
<h2 id="布尔代数">布尔代数</h2>
<p>在第 1 节
“if语句”讲过，<code>a&lt;b&lt;c</code>不表示<code>b</code>既大于<code>a</code>又小于<code>c</code>，那么如果想表示这个含义该怎么写呢？可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以用逻辑与（Logical
AND）运算符表示这两个条件同时成立。逻辑与运算符在C语言中写成两个<code>&amp;</code>号（Ampersand），上面的语句可以改写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b is between a and c.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>a &lt; b &amp;&amp; b &lt; c</code>这个控制表达式，要求“<code>a &lt; b</code>的值非<code>0</code>”和“<code>b &lt; c</code>的值非<code>0</code>”这两个条件同时成立整个表达式的值才为<code>1</code>，否则整个表达式的值为<code>0</code>。也就是只有两个条件都为真，它们做逻辑与运算的结果才为真，有一个条件为假，则逻辑与运算的结果为假，如下表所示：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A AND B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>这种表称为真值表（Truth
Table）。注意逻辑与运算的操作数以非0表示真以0表示假，而运算结果以1表示真以0表示假（类型是int），我们忽略这些细微的差别，在表中全部以1表示真以0表示假。C语言还提供了逻辑或（Logical
OR）运算符，写成两个|线（Pipe Sign），逻辑非（Logical
NOT）运算符，写成一个!号（Exclamation Mark），它们的真值表如下：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A OR B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>表 4.4. NOT的真值表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>NOT A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>逻辑或表示两个条件只要有一个为真，它们做逻辑或运算的结果就为真，只有两个条件都为假，逻辑或运算的结果才为假。逻辑非的作用是对原来的逻辑值取反，原来是真的就是假，原来是假的就是真。逻辑非运算符只有一个操作数，称为单目运算符（Unary
Operator），以前讲过的加减乘除、赋值、相等性、关系、逻辑与、逻辑或运算符都有两个操作数，称为双目运算符（Binary
Operator）。</p>
<p>关于逻辑运算的数学体系称为布尔代数（Boolean
Algebra），以它的创始人布尔命名。在编程语言中表示真和假的数据类型叫做布尔类型，在C语言中通常用int型来表示，非0表示真，0表示假[6]。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。以下是一些布尔代数的基本定理，为了简洁易读，真和假用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有点像乘法和加法运算），NOT用¬表示，变量x、y、z的值可能是0也可能是1。</p>
<p>¬¬x=x</p>
<p>x*0=0 x+1=1</p>
<p>x*1=x x+0=x</p>
<p>x*x=x x+x=x</p>
<p>x*¬x=0 x+¬x=1</p>
<p>x<em>y=y</em>x x+y=y+x</p>
<p>x<em>(y</em>z)=(x<em>y)</em>z x+(y+z)=(x+y)+z</p>
<p>x<em>(y+z)=x</em>y+x<em>z x+y</em>z=(x+y)*(x+z)</p>
<p>x+x<em>y=x x</em>(x+y)=x</p>
<p>x<em>y+x</em>¬y=x (x+y)*(x+¬y)=x</p>
<p>¬(x<em>y)=¬x+¬y ¬(x+y)=¬x</em>¬y</p>
<p>x+¬x<em>y=x+y x</em>(¬x+y)=x*y</p>
<p>x<em>y+¬x</em>z+y<em>z=x</em>y+¬x<em>z
(x+y)</em>(¬x+z)<em>(y+z)=(x+y)</em>(¬x+z)</p>
<p>除了第1行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的<em>换成+、+换成</em>、0换成1、1换成0，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明，更多细节可参考有关数字逻辑的教材，例如[数字逻辑基础]。我们将在本节的练习题中强化训练对这些定理的理解。</p>
<p>目前为止介绍的这些运算符的优先级顺序是：!高于* / %，高于+ -，高于&gt;
&lt; &gt;= &lt;=，高于==
!=，高于&amp;&amp;，高于||，高于=。写一个控制表达式很可能同时用到这些运算符中的多个，如果记不清楚运算符的优先级一定要多套括号。我们将在第
4 节 “运算符总结”总结C语言所有运算符的优先级和结合性。</p>
<h2 id="switch语句">Switch语句</h2>
<p>switch语句可以产生具有多个分支的控制流程。它的格式是：</p>
<p>switch (控制表达式) { case 常量表达式： 语句列表 case 常量表达式：
语句列表 … default： 语句列表 }</p>
<p>例如以下程序根据传入的参数1<sub>7分别打印Monday</sub>Sunday：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_day</span><span class="params">(<span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        case1:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case2:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case3:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case4:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case5:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case6:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case7:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Illegal day number!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printf_day(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的参数是<code>2</code>，则从<code>case 2</code>分支开始执行，先是打印相应的信息，然后遇到<code>break</code>语句，它的作用是跳出整个<code>switch</code>语句块。C语言规定各<code>case</code>分支的常量表达式必须互不相同，如果控制表达式不等于任何一个常量表达式，则从<code>default</code>分支开始执行，通常把<code>default</code>分支写在最后，但不是必须的。使用<code>switch</code>语句要注意几点：</p>
<p><code>case</code>后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。</p>
<p>第 2 节
“if/else语句”讲过浮点型不适合做精确比较，所以C语言规定<code>case</code>后面跟的必须是整型常量表达式。</p>
<p>进入<code>case</code>后如果没有遇到<code>break</code>语句就会一直往下执行，后面其它<code>case</code>或<code>default</code>分支的语句也会被执行到，直到遇到<code>break</code>，或者执行到整个<code>switch</code>语句块的末尾。通常每个<code>case</code>后面都要加上<code>break</code>语句，但有时会故意不加<code>break</code>来利用这个特性</p>
<p><code>switch</code>语句不是必不可缺的，显然可以用一组<code>if ... else if ... else if ... else ...</code>代替，但是一方面用<code>switch</code>语句会使代码更清晰，另一方面，有时候编译器会对<code>switch</code>语句进行整体优化，使它比等价的<code>if/else</code>语句所生成的指令效率更高。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/FPGA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/FPGA/" class="post-title-link" itemprop="url">第一章:Verilog HDL数字集成电路设计方法概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-22 14:31:58" itemprop="dateModified" datetime="2025-11-22T14:31:58+08:00">2025-11-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/FPGA/" itemprop="url" rel="index"><span itemprop="name">FPGA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="modelsim的安装">Modelsim的安装</h2>
<p>在网上找到Modelsim 2020.2及其许可证license的安装包, 先安装.</p>
<p>对于license的导入, 按照以下步骤进行:</p>
<ol type="1">
<li>点击下载附件modelsim_crack.zip，解压。</li>
<li>进入Modelsim的软件安装目录（我的电脑的安装目录是D:/modeltech64_10.4/win64）文件夹下找到mgls64.dll文件，去掉只读属性.</li>
<li>将解压后的文件MentorKG.exe和patch_dll.bat复制到Modelsim软件安装目录下的win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>运行patch_dll.bat，稍等一段时间后即可生成一个TXT文本</li>
<li>将生成的TXT文本另存为LICENSE.TXT，另存的路径选择Modelsim软件的安装路径win64文件夹（我的电脑的安装目录是D:/modeltech64_10.4/win64）</li>
<li>恢复mgls64.dll文件的只读属性</li>
<li>接下来设置环境变量，在电脑桌面上点击“我的电脑”或“计算机”，右键选择【属性】-&gt;【高级系统设置】-&gt;选择“高级”选项卡下的【环境变量】</li>
<li>Windows环境变量有用户变量和系统变量两个环境变量，这里设置用户变量即可；如果最后使用不了，再以同样的方式设置系统变量。
点击【新建(N)】，打开编辑用户变量对话框，变量名命名为MGLS_LICENSE_FILE，变量值为刚才生成的LICENSE.TXT的文件路径，即D:/modeltech64_10.4/win64/LICENSE.TXT，点击【确定】</li>
<li>环境变量设置完成之后，点击两次【确定】按钮，返回电脑桌面即可设置完成。此时双击桌面上的Modelsim软件，可以进入.
操作完成后打开Modelsim，如果仍然未检测到License，可以试下重启电脑</li>
</ol>
<p>上面的是网络上的方法, 我之前可以正常打开modelsim,
但是有时候打开时可能会显示检测不到licence,
或者打开之后会显示用户图形界面使用不了, 这说明了原来的license已经过期了.
我打开了<code>C:\modeltech64_2020.4\win64</code>目录下的<code>patch64_dll.bat</code>文件,
然后会弹出一个窗口, 等运行停止后, 按下回车键, 就可以生成一个新的licence,
把这个licence放到这个目录下, 替换掉原来的license, 然后设置环境变量,
在用户变量里面把MGLS_LICENSE_FILE指向<code>C:\modeltech64_2020.4\win64\LICENSE.TXT</code>,
然后在系统变量里面把LM_LICENSE_FILE指向<code>C:\modeltech64_2020.4\win64\LICENSE.TXT</code>,
但是MGLS_LICENSE_FILE的优先级要更高一些, 似乎只用设置它就行了.
保存之后就可以正常打开modelsim了.</p>
<h2 id="modelsim的使用">Modelsim的使用</h2>
<ol type="1">
<li>打开Modelsim软件,在左上角选中File-&gt;Change
Directory,在弹出的对话框中选择当前项目所在的文件夹(注意路径中不能包含中文).</li>
<li>接下来,选择File-&gt;New-&gt;Project.会弹出一个Create
Project的界面,只需要输入Project Name这一项,其他保持默认,点击OK.</li>
<li>点击OK后,会弹出Add items to the Project界面,选择Add Existing
File,选中我们已经写好的RTL代码和Testbench代码,然后点击OK.</li>
<li>添加完代码后,在Modelsim上面一栏中选择Compile-&gt;Compile
All,软件就会编译所有的代码,如果代码正确,就会显示绿色的勾.</li>
<li>编译完成后,在Modelsim上面一栏中选择Simulate-&gt;Start
Simulation,这时会弹出一个窗口,点击Optimization
Options,在Visibility页面中勾选Apply full visibility to all modules(full
debug mode),然后在Options页面的Optimization一栏中勾选Disable
Optimization(-o0),最后点击OK保存选项.</li>
<li>设置好Optimization
Options之后,点击work左边的加号”+“,选中Testbench代码,然后点击OK.</li>
<li>此时会出现一个界面,我们用右键点击Testbench下面的实例化模块(通常以u_…开头),选择Add
Wave选项,就可以打开示波(Wave)界面了.</li>
<li>在Wave界面的最上面一栏,可以设置仿真的时间,然后点击右边的按钮就可以进行仿真了.</li>
</ol>
<h2 id="vivado的安装">Vivado的安装</h2>
<p>在网上找到Vivado的及其许可证license的安装包, 直接安装即可.</p>
<h2 id="vivado的使用">Vivado的使用</h2>
<h3 id="基本操作">基本操作</h3>
<ol type="1">
<li>打开Vivado软件,在最上面的Quick Start一栏中点击”Create
Project”,然后在弹出的窗口中点击”Next”,然后填写Project
Name和工程路径,点击”Next”后,仅勾选”RTL
Project”,再点”Next”,会相继弹出”Add Sources”和”Add
Constraints”,我们直接跳过这两项,接下来选择开发板的芯片型号,我们在Search一栏里面输入”xc7z020clg400-2”,选中这个型号的芯片后点击”Next”,就可以进入工程主界面了.</li>
<li>在工程主界面中,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,里面有三个选项
<ol type="1">
<li>Add or create constraints:添加或者创建管脚约束文件</li>
<li>Add or create design sources:添加或者创建RTL文件</li>
<li>Add or create simulation source:添加或者创建Testbench文件</li>
</ol></li>
<li>我们勾选Add or create design sources,在弹出的界面中选择”Add
Files”,添加我们已经写好的RTL代码文件,然后点击”Finish”,再点击”OK”,然后是”Yes”.</li>
<li>这时,Sources窗口下”Design
Sources”目录下就会出现我们刚刚添加的RTL文件了,利用同样的方法可以在Sources窗口下”Constrains”和”Simulation
Sources”目录下分别添加管脚约束文件和Testbench文件.</li>
<li>事实上,在添加好RTL文件后,就可以进行分析(Elaborated)与综合(Synthesis)了.点击工程主界面左侧一栏”Flow
Navigator”中的”Open Elaborated
Design”,此时,Vivado会编译RTL源文件并且进行语法检查,分析完成后,会增加”Schematic(原理图)“和”Netlist(网表)“窗口.</li>
<li>然后,我们点击工程主界面左侧一栏”Flow Navigator”中的”Run
Synthesis”来对代码进行综合,在弹出的窗口中直接点击”OK”.综合完成后,会弹出一个窗口,我们直接关闭.</li>
<li>接下来进行管脚约束,点击”Sources”窗口里面的加号”+“,弹出”Add
Sources”窗口,勾选Add or create constrains,在弹出的界面中选择”Create
File”,在弹出的对话框中填写约束文件的名称,注意约束文件是后缀为”XDC”的文本文件,然后点击”OK”和”Finish”,这时,Sources窗口下”Constrains”目录下就会出现我们刚刚添加的约束文件了.</li>
<li>我们双击打开这个约束文件,写好约束代码,然后保存即可.</li>
<li>下面我们可以实现设计了,点击工程主界面左侧一栏”Flow
Navigator”中的”Run
Implementation”,在弹出的界面直接点击”OK”,实现完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>在下载程序之前,首先要生成用于下载到器件中的比特流文件,点击工程主界面左侧一栏”Flow
Navigator”中的”Generate
Bitstream”,在弹出的窗口中直接点击”OK”,生成比特流完成后会弹出一个窗口,我们直接点击”Cancel”关闭窗口.</li>
<li>最后我们下载比特流,点击工程主界面左侧一栏”Flow Navigator”中的”Open
Hardware Manager”,然后工程主界面的窗口布局就会发生变化.</li>
<li>这时,我们将Xilinx下载器一端连接到电脑,另一端连接到JTAG接口,然后连接开发板电源线,打开开发板上面的电源开关.</li>
<li>在工程主界面中”Hardware”子窗口中点击”Auto
Connect”按钮(就是长得像关节一样的那个),再点击”Program
device”,点击”Program”,此时就会下载比特流文件到板子上,并且可以在板子上看到现象.</li>
</ol>
<h3 id="ip核">IP核</h3>
<h4
id="集成逻辑分析器integrated-logic-analyzerila">集成逻辑分析器(Integrated
Logic Analyzer,ILA)</h4>
<p>传统的FPGA板级调试是由外接的逻辑分析仪连接到FPGA的控制管脚,然后将内部信号引出至引脚IO上,进行板级调试.在线逻辑分析仪利用FPGA中的逻辑资源,将这些功能植入到FPGA的设计中.</p>
<p>在线逻辑分析仪通过一个或者多个探针(Probe)来采集希望观察的信号,然后通过片内的JTAG硬核组件来将捕获到的数据传送给下载器,进而上传到Vivado
IDE以供用户查看.Vivado
IDE也可以按照上述的路径,向在线逻辑分析仪传输一些控制信息.</p>
<p>在Vivado中,在线逻辑分析仪的功能被称为”集成逻辑分析器(ILA)“,它以IP核的形式来加入到用户设计中.Vivado提供了三种具有不同集成层次的插入ILA方法,以满足不同Vivado用户的需求.</p>
<p>这里我们介绍第一种:</p>
<h5 id="hdl实例化调试探针流程">HDL实例化调试探针流程</h5>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”ILA”关键字,我们找到”Debug
&amp; Verification”下的”Debug”下的”ILA(Integrated Logic
Analyzer)“,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”ila_0”.</p>
<p>IP核的配置包含两个子界面,分别是”General
Options”和”Probe_Ports(0..0)”</p>
<p>在”General Options”界面中,“Number of
Probe”一栏用于设置所需的探针数量,一般来说,一个探针对应一个待测信号.”Sample
Data
Depth”用于设置采样深度,在每个时钟采样下,ILA都会将捕获到的探针信号的值送入RAM中,由于RAM存储空间是有限的,所以此选项就用于设置RAM最大存储多少个探针信号的值,我们一般保持默认1024,数值阅读,占用的RAM资源就越多.其他的选项保持默认.</p>
<p>在”Probe_Ports(0..0)“中,用于设置每个探针的参数,一般我们只需要设置每个探针的宽度”Probe
Width”即可,例如,“sys_rst_n”,“led”,“cnt”分别是1位,2位,26位,所以我们就设置探针1,探针2,探针3的宽度分别为1位,2位,26位.</p>
<p>设置完成后,点击”OK”,“Generate”即可生成IP核.</p>
<p>生成好后,在”Sources”窗口下的”IP
Sources”中,打开”ila_0.veo”文件,将其中的模板代码复制到用户设计的RTL代码中,然后修改代码,将IP核的时钟信号连接到”sys_clk”,“probe1”连接到”sys_rst_n”,“probe2”连接到”led”,“probe3”连接到”cnt”.</p>
<p>完成后,就可以保存,直接综合并且生成比特流.我们打开”Hardware
Manager”,连接到开发板,并且下载比特流.在弹出的窗口中,点击”Program”,Vivado就会自动弹出ILA调试窗口.</p>
<p>如果Waveform窗口缺少信号,可以点击上面一栏的加号”+(add
probes)“将所有探针信号加入到波形窗口中.然后,我们点击上面一栏的三角形符号”run
trigger for this ILA core”,就可以观察到此时信号的波形.</p>
<p>在调试完毕后,可以在顶层RTL代码中注释掉ILA IP核的实例化.</p>
<h4 id="clocking-wizard">Clocking Wizard</h4>
<p>首先创建一个新的工程,命名为”ip_clk_wiz”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP
Catalog”窗口后,在Search中搜索”clock”关键字,Vivado就会自动查找包含”clock”的IP核,我们找到”FPGA
Features and Design”下的”Clocking”下的”Clocking
Wizard”,点击它弹出”Customize IP”窗口.</li>
<li>接下来我们在”Customize IP”窗口中设置IP核的时钟参数.</li>
</ol>
<p>在这个界面中,最上面一栏的”Component
Name”是该IP元件的名称,可以自行修改,我们保持默认为”clk_wiz_1”.</p>
<p>在第一个”Clocking
Options”选项卡中,“Primitive”一行可以选择使用MMCM模块还是PLL模块,我们选用功能比较多的MMCM模块.我们还需要修改”Input
Clock
Information”一栏,把”Primitive”的时钟输入频率修改为开发板核心板的晶振频率
<span class="math inline">\(50\rm{MHz}\)</span>,其他的设置保持默认.</p>
<p>接下来切换至”Output Clocks”选项卡,在”Output
Clock”一栏中,勾选前四个时钟(表明我们需要四个输出),并且在”Output
Freq(MHZ)“中分别设置为”<span
class="math inline">\(100,100,50,25\)</span>“,第二个<span
class="math inline">\(100\rm{MHZ}\)</span>时钟的相移”Phase(degrees)“一栏设置为”<span
class="math inline">\(180\)</span>“.</p>
<p>接下来切换至”Port
Renaming”,这个选项卡主要是对于一些控制信号的重命名.这里我们只用到锁定指示locked信号,其名称保持默认即可.</p>
<p>接下来切换至”MMCM
Setting”和”Summary”,这两个选项卡都保持默认,都点击OK.之后就会弹出”Generate
Output Products”窗口,我们直接点击”Generate”即可.</p>
<p>之后我们可以看到在”Design Run”窗口的”Out-of-Context Module
Runs”一栏中出现了该IP核对应的run”clk_wiz_0_synth_1”,其综合过程独立于顶层模块的综合.</p>
<h4 id="block-memory">Block Memory</h4>
<p>首先创建一个新的工程,命名为”ip_ram”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”Block
Memory”关键字,我们找到”Block Memory
Generator”(这里会出现两个相同名字的IP核,它们实际上是一样的),点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component Name”默认为”blk_mem_gen_0”,我们保持默认.</p>
<p>Interface
Type:RAM接口总线,这里保持默认的Native类型(标准RAM接口总线)</p>
<p>Memory Type:存储器类型.可以配置成Single Port RAM(单端口RAM),Simple
Dual Port RAM(伪双端口RAM),True Dual Port RAM(真双端口RAM),Single Port
ROM(单端口ROM),Dual Port ROM(双端口ROM).这里我们选择Single Port RAM.</p>
<p>ECC Options:即Error Correction
Capability,纠错能力选项,单端口RAM不支持ECC</p>
<p>Write
Enable:字节使能选项,选中后可以单独将数据的某个字节写入RAM中,这里不勾选.</p>
<p>Algorithm Options:算法选项.可选择Minimum Area(最小面积),Low
Power(低功耗),Fixed Primitives(固定原语),这里保持默认的Minimum Area.</p>
<p>“Port A Options”界面中,设置端口A的参数</p>
<p>Write Width:端口A写数据位宽,这里设置成8位</p>
<p>Read Width:端口A读数据位宽,这里设置成8位</p>
<p>Write
Width:端口A写数据深度,这里设置成32,即RAM所能访问的地址范围为0-31</p>
<p>Read Width:端口A读数据位宽,这里设置成32</p>
<p>Operating Mode:RAM读写模式.一共有三种模式</p>
<ol type="1">
<li>Write First:写优先模式,数据先写入RAM中,下一个时钟周期读出该数据</li>
<li>Read
First:读优先模式,数据先写入RAM中,同时输出RAM中同地址的上一次数据</li>
<li>No
Change:不变模式,读写分开操作,不能同时进行读写,我们选择这个选项</li>
</ol>
<p>Enable Port Type:使能端口类型.Use ENA Pin(添加使能端口A信号),Always
Enabled(取消使能信号,端口A一直处于使能状态),这里选择Use ENA Pin</p>
<p>Port A Optional Output
Register:端口A输出寄存器选项.其中我们取消勾选”Primitives Output
Register”</p>
<p>Port A Optional Reset
Options:RAM复位信号选项,这里不添加复位信号,保持默认.</p>
<p>接下来的”Other
Options”和”Summary”页面都不需要设置,点击”OK”,“Generate”选项后,就可以生成IP核了.</p>
<h4 id="fifo">FIFO</h4>
<p>首先创建一个新的工程,命名为”ip_fifo”,下面我们来添加IP核.</p>
<ol type="1">
<li>在Vivado左侧的”Flow Navigator”栏中点击”IP Catalog”</li>
<li>打开”IP Catalog”窗口后,在Search中搜索”fifo”关键字,我们找到”Memories
&amp; Storage Elements”下的”FIFOs”下的”FIFO
Generator”,点击它弹出IP核设置窗口.</li>
<li>接下来我们在该窗口中设置IP核的参数.</li>
</ol>
<p>“Basic”界面中,“Component
Name”默认为”fifo_generator_0”,我们保持默认.</p>
<p>Interface
Type:用于选择FIFO接口的类型,这里保持默认的Native类型(标准FIFO接口)</p>
<p>FIFO
Implementation:选择实现同步FIFO或者异步FIFO,这里我们选择”Independent
Clocks Block RAM”,即使用块RAM来实现异步FIFO</p>
<p>“Native Ports”界面中</p>
<p>Read Mode:设置读FIFO时的读模式,这里选择默认的”Standard FIFO”</p>
<p>Data Port Parameters:设置读写端口的数据总线宽度以及FIFO的深度,“Write
Width”设置为8位,“Write Depth”设置为256位(注意FIFO
IP核实际实现的深度是255位),“Read Width”和”Read Depth”设置同上.</p>
<p>Reset Pin:这里我们只是观察FIFO的读写,我们取消勾选这个选项.</p>
<p>“Status Flags”界面</p>
<p>我们勾选”Almost Full Flag(即将写满)“和”Almost Empty
Flag(即将读空)“这两个选项,其他保持默认</p>
<p>“Data
Counts”选项卡用于设置FIFO内部数据计数的输出信号,此信号表示当前FIFO内存在多少个有效的数据,这里我们勾选”Write
Data Count(写数据计数)“和”Read Data
Count(读数据计数)“,且计数值总线的位宽”Write/Read Count
Width”设置成8位</p>
<p>“Summary”界面是总结,我们之间点击”OK”,“Generate”,就可以生成IP核了.</p>
<h3 id="uart串口通信">UART串口通信</h3>
<p>串行通信分为两种方式,同步串行通信和异步串行通信.同步串行通信需要双方在同一时钟控制下同步传输数据;异步串行通信是通信双方使用各自的时钟控制数据的发送和接收过程.</p>
<p>UART是一种采用异步串行通信方式的通用异步收发传输器(universal
asynchroonous
receiver-transmitter),它在发送数据时将并行数据转化成串行数据来传输,在接收数据时把接收到的串行数据再转化成并行数据.</p>
<p>UART串口通信需要两根信号线,一根用于串口发送,一根用于串口接收.UART在发送或者接收过程中的一帧数据由4部分组成:</p>
<ol type="1">
<li>起始位:标志着一帧数据的起始</li>
<li>停止位:标志着一帧数据的结束</li>
<li>数据位:一帧数据中的有效数据</li>
<li>奇偶检验位:分为奇校验和偶校验,用于检测数据在传输过程中是否出错</li>
</ol>
<p>UART通信过程中的数据格式和传输速率是可以设置的,为了正确的通信,收发双方应该约定好同样的设置.数据位可以选择5,6,7,8位,其中8位数据最常用.校验位可以选择奇校验,偶校验或者无校验位.停止位可以选择1位(默认),1.5位,2位.串口通信的速率用波特率表示,它表示每秒传输二进制数据的位数,单位是bps(位/秒),常用的波特率有9600,19200,38400,57600,115200等.</p>
<p>设置好数据格式和传输速率之后,UART负责完成串并数据的转换,而信号的传输则由外部驱动电路实现.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/HSpice%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">HSpice的安装及其基本使用方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-03 20:22:37" itemprop="dateModified" datetime="2025-12-03T20:22:37+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hspice的安装及破解">HSpice的安装及破解</h2>
<p>下载好安装包解压之后,
有两个文件夹<code>HSpice 2009.09</code>和<code>Testbench</code>(我把它改成<code>HSpiceTestbench</code>了).</p>
<p>以管理员身份运行<code>HSpice 2009.09</code>文件夹下的<code>hspice_vC-2009.09_Win_setup.exe</code>和<code>sx_C-2009_09_windows.exe</code>这两个文件,
一路next, 注意安装路径, 就可以完成安装, 接下来是破解方法.</p>
<ol type="1">
<li>产生 License 档桉 (Hspice and Spiceexplorer)到 “keygen”
的目录下执行LicGen.exe 1.1 按 “Open” 开启 “Synopsys.lpd”档桉 1.2
在”Select Host ID” 选择 “Any” 勾选 “Use Daemon”并在 “Select Daemon ID”
选择”Disk” 1.3 按 “Generate” 后会出现一个视窗 “Generated
License”，按Save，将档名储存为 “license.dat” 1.4 复製此 “license.dat”
到目录 “C:_C-2009.09" 下</li>
<li>复製 “lm” 到目录 “C:Files" 下，进入”lm” 目录执行 “lmtools.exe” 2.1
选 “Config Services” 在”Service Name” 输入 “SPICE_Explorer_Server”
在”Path to the lmgrd.exe file” 按 “Browse” 选择 “lm” 目录下的
“lmgrd.exe” 在”Path to the license file” 按 “Browse” 选择步骤 2.3
所产生的 license.dat (将档桉类型选为 “*.dat”才可以选择) 在”Path to the
debug log file” 按 “Browse” 输入 “debug” 后按开启 勾选 “Use Services” 和
“Start Server at Power Up” 然后按 “Save Service” 2.2 在 “Service/License
File” 勾选 “Configuration using Services” 并选择 SPICE_Explorer_Server
2.3 选 “Start/Stop/Reread” ， 按 “Stop Server” 再按 “Start Server”</li>
<li>环境变数设定 (Hspice and Spiceexplorer) 到桌面选”我的电脑”按右键
=&gt; 内容 =&gt; 进阶 =&gt; 环境变数 在”xxx的使用者变数” 按
“新增”，变数名称 = LM_LICENSE_FILE 变数值 =
27000@localhost;C:_C-2009.09.dat 若已经有 LM_LICENSE_FILE ，请以分号 “;”
隔开加入 27000@localhost 和 C:_C-2009.09.dat 到变数值</li>
<li>复製 “Meta.cfg” 和 “Hspice.ini” 到 “C:_C-2009.09" 目录下</li>
</ol>
<h2 id="hspice的基本使用方法">HSpice的基本使用方法</h2>
<p>在目录<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\HSPICE C-2009.09</code>下打开Hspui
C-2009.09, 出现界面, 点击open,
打开<code>HSpiceTestbench</code>下的任意一个网表文件(后缀是.sp),
这里以inv.sp为例, 以文本文件打开inv.sp, 可以看到其关联的工艺库,
这里把工艺库的路径改成<code>.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</code>,
这个工艺库可以在这个目录下的对应文件中找到细节.</p>
<p>然后点击最上面一栏的configuration-&gt;versions,
在cscope中关联波形观测器,
也就是把<code>C:\Program Files (x86)\Synopsys\CustomExplorer C-2009.09\sx.exe</code>复制到这一栏中,
然后点击OK. 然后在最上面一栏中的File-&gt;Save Configuration保存设置.</p>
<p>接下来进行仿真, 点击Simulate, 仿真完成后再点击Edit LL,
如果出现<code>***** job concluded 1****** HSPICE -- C-2009.09 32-BIT (Aug 24 2009) winnt ******</code>
的字样, 则说明仿真成功.
这时我们可以发现在HSpiceTestbench文件夹下面多出了几个文件,
其中一个就是inv.tr0, 这个就是波形文件.</p>
<p>下面查看仿真波形, 点击CScope, 打开波形观察窗口,
在上面第二栏中选择Import Waveform File, 选择刚刚生成的inv.tr0,
在左边一栏出现D0:inv.tr0, 点击这个东西左边的+号， 有一个toplevel,
点击就可以发现出现了三个选项, 分别是v(vdd), v(in), v(out),
分别点击这三个选项就可以在右边的窗口看见仿真波形了.</p>
<h2 id="hspice概览">HSpice概览</h2>
<h3 id="hspice的网表">HSpice的网表</h3>
<p>HSpice的网表文件后缀是.sp, 但是是纯文本文件,
可以用文本编辑器打开并进行编辑.</p>
<p>HSpice网表文件包含如下要素:</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>.title</code></td>
<td>标题语句</td>
</tr>
<tr>
<td>2</td>
<td><code>Sources(I or V)</code></td>
<td>输入激励和源, 为电路描述语句</td>
</tr>
<tr>
<td>3</td>
<td><code>circuit description</code></td>
<td>电路元件描述语句, 为电路描述语句</td>
</tr>
<tr>
<td>4</td>
<td><code>.lib</code></td>
<td>元件库引用, 为电路描述语句</td>
</tr>
<tr>
<td>5</td>
<td><code>.model libraries</code></td>
<td>元件模型描述, 为电路描述语句</td>
</tr>
<tr>
<td>6</td>
<td><code>.inc</code></td>
<td>文件包含语句, 电路描述语句</td>
</tr>
<tr>
<td>7</td>
<td><code>.options</code></td>
<td>选项设置, 为命令语句</td>
</tr>
<tr>
<td>8</td>
<td><code>Analysis statement</code></td>
<td>仿真类型描述, 为命令语句</td>
</tr>
<tr>
<td>9</td>
<td><code>.print/.plot/.graph/.probe</code></td>
<td>输出方式描述, 为命令语句</td>
</tr>
<tr>
<td>10</td>
<td><code>.end</code></td>
<td>结束语句</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A SIMPLE AC RUN</span><br><span class="line">VS 1 0 10 AC 1</span><br><span class="line">R1 1 2 1K</span><br><span class="line">R2 2 0 1K</span><br><span class="line">C1 2 0 1n</span><br><span class="line">.OPTIONS LIST NODE POST</span><br><span class="line">.OP</span><br><span class="line">.AC DEC 10 1K 1MEG</span><br><span class="line">.PRINT AC V(1) V(2) I(R2) I(C1)</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h4 id="电路描述语句总览">电路描述语句总览</h4>
<p>元件描述语句:</p>
<p>无源: 电阻<code>R</code>, 电容<code>C</code>, 电感<code>L</code>,
传输线 有源: 二极管<code>D</code>, 三极管<code>Q</code>,
JFET<code>J</code>, MOS<code>M</code></p>
<p>激励源描述语句:</p>
<p>独立源: 独立电压源<code>V</code>, 独立电流源<code>I</code> 源控源:
压控电压源<code>E</code>, 流控电流源<code>F</code>,
压控电流源<code>G</code>, 流控电压源<code>H</code></p>
<p>子电路描述语句<code>.SUBCKT</code>或<code>.MACRO</code></p>
<p>模型描述语句<code>.MODEL</code></p>
<p>库文件调用及定义语句<code>.LIB</code></p>
<h4 id="命令语句">命令语句</h4>
<p>电路性能仿真:</p>
<p>直流分析:</p>
<ol type="1">
<li>直流工作点分析<code>.OP</code></li>
<li>直流扫描分析<code>.DC</code></li>
<li>直流小信号传输函数<code>.TF</code></li>
<li>直流小信号灵敏度分析<code>.SENS</code></li>
</ol>
<p>交流分析:</p>
<ol type="1">
<li>交流小信号分析<code>.AC</code></li>
<li>零极点分析<code>.PZ</code></li>
<li>交流小信号失真分析<code>.DISTO</code></li>
<li>交流噪声分析<code>.NOISE</code></li>
</ol>
<p>瞬态分析<code>.TRAN</code></p>
<p>蒙特卡洛/最坏情况分析:</p>
<ol type="1">
<li>直流工作分析</li>
<li>直流扫描分析</li>
<li>交流扫描分析</li>
<li>瞬态扫描分析</li>
</ol>
<p>温度分析</p>
<p>输入控制: <code>.ALTER</code>, <code>.PARAM</code>,
<code>.DATA</code>, <code>.OPTIONS</code> 输出控制: <code>.PRINT</code>,
<code>.PLOT</code>, <code>.PROBE</code>, <code>.GRAPH</code>,
<code>.MEASURE</code></p>
<h4 id="hspice的输出">HSPice的输出</h4>
<p>输出文件也是一系列文本文件</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.ic</td>
<td>initial conditions for the circuit</td>
</tr>
<tr>
<td>*.lis</td>
<td>text simulation output listing</td>
</tr>
<tr>
<td>*.mt(0), *.mt(1), …</td>
<td>post-processor output for MEASURE statements</td>
</tr>
<tr>
<td>*.pa0</td>
<td>subscricuit path table</td>
</tr>
<tr>
<td>*.st0</td>
<td>run-time statistics</td>
</tr>
<tr>
<td>*.tr0,*.tr1…</td>
<td>post-processor output for transient analysis</td>
</tr>
<tr>
<td>*.ac0,*.ac1…</td>
<td>post-processor output for AC analysis</td>
</tr>
</tbody>
</table>
<p>Waveview or Cscope: 观察波形, 人机交互界面</p>
<h2 id="hspice基本语法">HSPice基本语法</h2>
<h3 id="文件名格式">文件名格式</h3>
<ol type="1">
<li>文件的后缀名必须是.sp, 可以用文本编辑器产生,
只需要修改后缀名即可.</li>
<li>文件名必须是英文.</li>
<li>网表文件第一行必须是标题行,
最后一个语句必须是<code>.END</code>.</li>
<li>标题语句和结束语句的中间语句没有任何先后次序.</li>
<li>续行用加号<code>+</code>表示.</li>
<li>不区分大小写</li>
<li>分隔符可以是<code>tab</code>, 空格, 逗号, 等号, 括号.</li>
<li>元素的属性由冒号分割, 例如<code>M1:beta</code>.</li>
<li>用句号表示隶属关系,
例如<code>X1.A1.V</code>表示电路<code>X1</code>的子电路<code>A1</code>的节点<code>V</code>.</li>
</ol>
<h3 id="节点">节点</h3>
<ol type="1">
<li>节点名可以由下列字符开头<code># _ ! %</code>.</li>
<li>节点可以由<code>.GLOBAL</code>语句声明为全局调用,
例如<code>.GLOBAL 1</code>声明节点1为全局调用.</li>
<li>节点<code>0, GND, GND!, GROUND</code>均指的是HSPice全局的地.</li>
<li>HSPice要求每个节点对地均要有直流通路. 当这个条件不满足时,
通常是接一个大电阻使得该悬浮节点具有直流通路.</li>
<li>每个节点至少应该连接两个元件, 不能有浮空节点存在.</li>
</ol>
<h3 id="数值及比例因子">数值及比例因子</h3>
<p>数字的表示:</p>
<ol type="1">
<li>整数, 如<code>12, -5</code>.</li>
<li>浮点数, 如<code>2.13, 3.14159</code></li>
<li>指数, 如<code>6E-14, 3.89E+13</code></li>
<li>在整数或浮点数后面跟比例因子, 如<code>10.18K</code>,
常用的比例因子有<code>T=1E+12, G=1E+9, MEG=1E+6, K=1E+3, M=1E-3, U=1E-6, N=1E-9, P=1E-12, F=1E-15, DB=20lg_&#123;10&#125;, MIL=25.4E-6</code>.</li>
</ol>
<h3 id="单位及关键字">单位及关键字</h3>
<p>单位: 电学单位可以省略,
例如<code>10</code>和<code>10V</code>表示相同电压.
<code>1000Hz, 1000, 1E+3, 1k, 1kHz</code>表示相同的频率. 同样,
<code>W, A</code>等标准单位在描述时均可省略.</p>
<p>元件关键字: 电压<code>V</code>, 电流<code>I</code>,
频率<code>F</code>, 电阻<code>R</code>, 电容<code>C</code>,
电感<code>L</code>.</p>
<h2 id="hspice的标题-结束及注释语句">HSpice的标题, 结束及注释语句</h2>
<h3 id="title语句">.TITLE语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TITLE &lt;string of up to 72 characters&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string of up to 72 characters&gt;</span><br></pre></td></tr></table></figure>
<h3 id="end语句">.END语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.END &lt;comment&gt;</span><br></pre></td></tr></table></figure>
<p><code>.END</code>后面的文本对仿真没有任何影响.</p>
<h3 id="注释语句">注释语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&lt;comment on a line by itself&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HSPICE statement&gt;$&lt;comment on the same line as and following HSPICE input&gt;</span><br></pre></td></tr></table></figure>
<p>注意<code>*</code>开头的注释放在每一行的开头,
<code>$</code>开头的注释紧跟在语句之后.</p>
<h2 id="电路描述语句">电路描述语句</h2>
<h3 id="元件描述语句">元件描述语句</h3>
<p>HSpice中元件的属性由器件名, 器件位置, 器件类型, 器件参数值等来定义.
格式为<code>名称 器件所连接的节点 器件类型 参数值</code>.</p>
<h4 id="无源器件">无源器件</h4>
<h5 id="电阻">电阻</h5>
<p>电阻的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RXXX n1 n2 Rvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电阻的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[R=R_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1 1 2 100k</span><br><span class="line">RC1 12 17 1k TC=0.001, 0</span><br></pre></td></tr></table></figure>
<h5 id="电容">电容</h5>
<p>电容的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXXX n1 n2 Cvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电容的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[C=C_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C1 1 2 10u</span><br><span class="line">CP 12 17 1p TC=0.001, 0</span><br></pre></td></tr></table></figure>
<h5 id="电感和互感">电感和互感</h5>
<p>电感的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LXXX n1 n2 Lvalue TC=TC1, TC2</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p><code>TC1, TC2</code>是电感的温度系数, 如果缺省则默认是0</p>
<p><span
class="math display">\[L=L_0\left[1+TC1(T-T_0)+TC2(T-T_0)^2\right]\]</span></p>
<p>其中<span class="math inline">\(T\)</span>为室温.</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1 1 2 10u</span><br><span class="line">LP 12 17 1u TC=0.001, 0</span><br></pre></td></tr></table></figure>
<p>另一种写法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LXXX n1 n2 POLY L0 L1 L2</span><br></pre></td></tr></table></figure>
<p>这里</p>
<p><span class="math display">\[L=L0+L1\times I+L2\times
I^2+\cdots\]</span></p>
<p>其中<span class="math inline">\(I\)</span>是流过电感的电流.</p>
<p>互感的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KXXX LYYY LZZZ Kvalue</span><br></pre></td></tr></table></figure>
<p>其中<code>LYYY, LZZZ</code>是两个耦合电感的名字,
<code>K</code>是耦合系数, <span class="math inline">\(0&lt;K\leq
1\)</span>.</p>
<h4 id="有源器件">有源器件</h4>
<h5 id="晶体二极管diode-d">晶体二极管(diode, D)</h5>
<p>一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DXXX nplus nminus mname </span><br><span class="line">+&lt;area=value, area&gt; &lt;PJ=value&gt; &lt;WP=value&gt;</span><br><span class="line">+&lt;LP=value&gt; &lt;WM=value&gt; &lt;LM=value&gt;</span><br><span class="line">+&lt;OFF&gt; &lt;IC=vd&gt; &lt;M=value&gt; &lt;DTEMP=value&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>上面的加号<code>+</code>表示续行.</li>
<li><code>DXXX</code>: 二极管元件名, 必须以<code>D</code>开头,
后面最多跟15个字符</li>
<li><code>nplus/nminus</code>: 二极管的正极和负极</li>
<li><code>mname</code>: 二极管模型名</li>
<li><code>area</code>: 二极管面积, 它定义了饱和电流, 电容与电阻值.
可以写为<code>area=xxx</code>, 也可以直接写为<code>xxx</code>,
缺省值为1.0, 若不定义<code>area</code>,
用定义<code>W</code>和<code>L</code>来代替也可以,
<code>area=W*L</code>.</li>
<li><code>PJ</code>: 二极管周长, <code>PJ=2(L+M)</code></li>
<li><code>WP/LP</code>: 寄生多晶电容的宽度和长度, 缺省值为0</li>
<li><code>WM/LM</code>: 寄生金属电容的宽度和长度, 缺省值为0</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件</li>
<li><code>M</code>: 多重二极管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DBRIDGE 6 7 DIODE 1</span><br><span class="line">DCLMMMP 3 GND DMOD 3 IC=0.2</span><br></pre></td></tr></table></figure>
<h5 id="双极性晶体三极管">双极性晶体三极管</h5>
<p>一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QXXX nc nb ne &lt;ns&gt; mname</span><br><span class="line">+&lt;avalue; AREAA=value, AREAB=value, AREAC=value&gt;</span><br><span class="line">+&lt;OFF&gt; &lt;IC=vbevalue, vcevalue; VBE=value, VCE=value&gt;</span><br><span class="line">+&lt;M=value&gt;&lt;DTEMP=value&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>QXXX</code>: 三极管元件名, 必须以<code>Q</code>开头,
后面最多跟15个字符</li>
<li><code>nc/nb/ne/ns</code>: 集电极, 基极, 发射极, 基底节点</li>
<li><code>mname</code>: 三极管模型名</li>
<li><code>avalue</code>: 三极管面积,
也可以用<code>areaA=?, areaB=?, areaC=?</code>来定义.
其中<code>areaA, areaB, areaC</code>分别为发射区, 基区,
集电区的面积倍增因子, 缺省值为1.</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件两种表达方式</li>
<li><code>M</code>: 多重三极管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q11 CX BX EX QPNP AREAA=1.5 AREAB=2.5 AREAC=3.0</span><br><span class="line">Q22 10 18 12 QMOD IC=0.5, 5.0</span><br><span class="line">Q33 11 265 4 20 MOD</span><br></pre></td></tr></table></figure>
<h5 id="mos场效应管">MOS场效应管</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MXXX nd ng ns nb mname</span><br><span class="line">+&lt;L=value&gt;&lt;W=val&gt;&lt;AD=val&gt;&lt;AS=val&gt;&lt;PD=val&gt;&lt;PS=val&gt;</span><br><span class="line">+&lt;NRD=val&gt;&lt;NRS=val&gt;&lt;RDC=val&gt;&lt;RSC=val&gt;</span><br><span class="line">+&lt;OFF&gt;&lt;IC=vds,vgs,vbs&gt;&lt;M=val&gt;&lt;DTEMP=val&gt;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>MXXX</code>: 元件名, 必须以<code>M</code>开头,
后面最多跟15个字符</li>
<li><code>nd/ng/ns/nb</code>: 漏极, 栅极, 源极, 基底节点</li>
<li><code>mname</code>: 场效应管模型名</li>
<li><code>L/W</code>: 沟道长度和宽度</li>
<li><code>AD/AS</code>: 漏扩散区和源扩散区的面积</li>
<li><code>PD/PS</code>: 漏结和源结的周长</li>
<li><code>NRD/NRS</code>:
用以计算漏源级寄生串联电阻的漏扩散区等效方块数</li>
<li><code>RDC/RSC</code>: 漏极, 源极与连线的接触电阻</li>
<li><code>OFF</code>: 规定在进行直流分析时忽略初始条件,
缺省值为<code>ON</code></li>
<li><code>IC</code>: 瞬态分析的初始条件</li>
<li><code>M</code>: 多重MOS管仿真时的倍增因子, 缺省值为1</li>
<li><code>MTEMP</code>: 元件温度与电路温度之间的差额, 缺省值为0</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M11 D G S B MM1</span><br><span class="line">M22 10 18 12 1 MODM L=0.5 W=2U (0.5U 2U)</span><br><span class="line">M33 11 265 4 1 MOD OFF 10U 5U 2P 2P</span><br></pre></td></tr></table></figure>
<h3 id="激励源描述语句">激励源描述语句</h3>
<h4 id="独立电压源和独立电流源">独立电压源和独立电流源</h4>
<p>直流源一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- &lt;DC=value&gt;</span><br><span class="line">IXXX n+ n- &lt;DC=value&gt;</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V11 2 0 DC=5V</span><br><span class="line">V11 2 0 5V</span><br><span class="line">I11 3 0 DC 3mA</span><br><span class="line">I11 3 0 3mA</span><br></pre></td></tr></table></figure>
<p>交流源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- AC&lt;=&gt;&lt;acmag, &lt;acphase&gt;&gt;</span><br><span class="line">IXXX n+ n- AC&lt;=&gt;&lt;acmag, &lt;acphase&gt;&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V11 2 0 AC=10V 90</span><br><span class="line">V11 2 0 AC 10V 90</span><br><span class="line">I11 3 0 AC=3mA 0</span><br><span class="line">I11 3 0 AC 3mA</span><br></pre></td></tr></table></figure>
<p>脉冲源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- PULSE(V0 Va td tr tf pw per)</span><br><span class="line">IXXX n+ n- PULSE(I0 Ia td tr tf pw per)</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>V0/I0, Va/Ia</code>分别代表信号的最小值和最大值</li>
<li><code>td</code>表示信号最小值持续的时间</li>
<li><code>tr</code>表示信号上升持续时间</li>
<li><code>tf</code>表示信号下降持续时间</li>
<li><code>pw</code>表示信号最大值持续时间</li>
<li><code>per</code>表示信号周期</li>
</ol>
<p>例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VIN 3 0 PULSE -1 1 2ns 2ns 2ns 50ns 100ns</span><br></pre></td></tr></table></figure>
<p>正弦源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- SIN V0 Va &lt;freq td theta phi&gt;</span><br><span class="line">IXXX n+ n- SIN I0 Ia &lt;freq td theta phi&gt;</span><br></pre></td></tr></table></figure>
<p>对应的表达式为</p>
<p><span class="math display">\[V0+Vae^{-\theta t}\sin(2\pi
f(t-td)+\varphi)\]</span></p>
<p>指数源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- EXP V0 Va &lt;td1 t1 td2 t2&gt;</span><br><span class="line">IXXX n+ n- EXP I0 Ia &lt;td1 t1 td2 t2&gt;</span><br></pre></td></tr></table></figure>
<p>对应的表达式为</p>
<p><span class="math display">\[\begin{cases}
\displaystyle
V0+(Va-V0)\cdot\left[1-\exp\left(-\frac{t-td1}{t1}\right)\right]~~~~td1&lt;t&lt;td2\\
\\
\displaystyle
V0+(Va-V0)\cdot\left[1-\exp\left(-\frac{td2-td1}{t1}\right)\right]\cdot\exp\left(-\frac{t-td2}{t2}\right)~~~~t&gt;td2\\
\end{cases}\]</span></p>
<p>分段线性源的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VXXX n+ n- PWL t1 V1 &lt;t2 V2... R td&gt;</span><br><span class="line">IXXX n+ n- PWL t1 I1 &lt;t2 I2... R td&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>t1 V1 t2 V2 t3 V3...</code>:
在V-t平面上面依次连接<code>(t1, V1), (t2, V2), (t3, V3)...</code></li>
<li><code>R</code>: 是否周期重复</li>
<li><code>td</code>: 重复时延迟时间</li>
</ol>
<h3 id="子电路">子电路</h3>
<p>子电路一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.SUBCKT(.MACRO) SUBNAME N1 &lt;N2...&gt;</span><br><span class="line">具体描述</span><br><span class="line">.ENDS&lt;SUBNAME&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>子电路是以<code>.SUBCKT</code>或者<code>.MACRO</code>开头,
以<code>.END</code>结束的一组语句. 子电路可以嵌套其他子电路.</li>
<li><code>SUBNAME</code>: 子电路模型名</li>
<li><code>N1, N2, ...</code>: 子电路外部的节点名称</li>
<li><code>.END</code>: 结束语句,
只有二次以上嵌套时才后跟子电路模型名.</li>
</ol>
<p>子电路调用语句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XNNN N1 &lt;N2...&gt; SUBNAME</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>子电路调用时, 可以将其看成是以<code>X</code>为关键字的器件.</li>
<li><code>XNNN</code>: 子电路名称</li>
<li><code>N1, N2, ...</code>: 子电路外部的节点名称</li>
<li><code>SUBNAME</code>: 子电路模型名</li>
</ol>
<h3 id="模型描述语句.model语句">模型描述语句(.MODEL语句)</h3>
<p>电路元件的描述语句为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D(Q,J,M) n1 n2 (n3) mname &lt;parameter&gt;</span><br></pre></td></tr></table></figure>
<p><code>mname</code>: 模型名称, 每一个模型名称对应于一类元件,
用户根据自己的需求定义其包含哪些内容, 即类的范围.
<code>parameter</code>: 模型之外的参数的定义</p>
<p>模型的定义: 一条以<code>.MODEL</code>引导的模型说明语句.
这一类元件中的共同点在模型说明语句中给出. 模型语句的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.MODEL mname type &lt;parameter1=value1 parameter2=value2 ...&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>mname</code>: 模型参考名,
与元件描述语句的<code>mname</code>相同</li>
<li><code>type</code>: 用来选择模型类型</li>
<li><code>parameter1,2...</code>: 此类模型所共有的参数值</li>
</ol>
<p>模型的类型如下:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>电阻模型</td>
</tr>
<tr>
<td>C</td>
<td>电容模型</td>
</tr>
<tr>
<td>CORE</td>
<td>磁芯模型</td>
</tr>
<tr>
<td>L</td>
<td>磁芯互感模型</td>
</tr>
<tr>
<td>D</td>
<td>二极管模型</td>
</tr>
<tr>
<td>NPN</td>
<td>NPN双极型晶体管模型</td>
</tr>
<tr>
<td>PNP</td>
<td>PNP双极型晶体管模型</td>
</tr>
<tr>
<td>NJF</td>
<td>N沟道JFET模型</td>
</tr>
<tr>
<td>PJF</td>
<td>P沟道JFET模型</td>
</tr>
<tr>
<td>NMOS</td>
<td>N沟道MOSFET模型</td>
</tr>
<tr>
<td>PMOS</td>
<td>P沟道MOSFET模型</td>
</tr>
<tr>
<td>AMP</td>
<td>运算放大器模型</td>
</tr>
<tr>
<td>OPT</td>
<td>优化模型</td>
</tr>
<tr>
<td>PLOT</td>
<td>针对<code>.GRAPH</code>语句的硬盘拷贝绘图模型</td>
</tr>
</tbody>
</table>
<p>MOSFET模型的描述方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.MODEL 模型名 PMOS &lt;LEVEL=val&gt; &lt;parameters&gt;</span><br><span class="line">.MODEL 模型名 NMOS &lt;LEVEL=val&gt; &lt;parameters&gt;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p>第一代元件模型: <code>LEVEL1, LEVEL2, LEVEL3</code> 第二代元件模型:
BSIM1模型<code>LEVEL13</code>, 修正的BSIM1模型<code>LEVEL28</code>,
BSIM2模型<code>LEVEL39</code> 第三代元件模型:
BSIM3模型<code>LEVEL49</code></p>
<h3 id="库文件的使用">库文件的使用</h3>
<p>库文件可包含</p>
<ol type="1">
<li>器件模型<code>.MODEL</code></li>
<li>子电路</li>
<li>有关注释语句</li>
<li>库文件调用语句<code>.LIB</code>等</li>
</ol>
<h4 id="库文件的创建">库文件的创建</h4>
<p>创建库文件的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.LIB entryname</span><br><span class="line">具体库文件的描述</span><br><span class="line">.ENDL entryname</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>.LIB entryname</code>:
定义入口名为<code>entryname</code>的库</li>
<li><code>.ENDL</code>: 结束库定义语句</li>
<li>不能包含<code>.END</code>语句·</li>
</ol>
<h4 id="库文件的调用">库文件的调用</h4>
<p>库文件调用的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.LIB &#x27;&lt;file path&gt; file name&#x27; entryname</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>file path</code>: 库文件所在的路径,
若<code>.lib</code>与所运行的网表在相同目录下, 则可以缺省.</li>
<li><code>filename</code>: 库文件名, 扩展名.lib不可缺少.
路径和文件名必须包含在双引号或者单引号里面.</li>
<li><code>entryname</code>: 将要包括的库文件段的入口名</li>
</ol>
<h4 id="库文件的嵌套">库文件的嵌套</h4>
<p>库文件嵌套的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.LIB entryname</span><br><span class="line">具体库文件模型的描述</span><br><span class="line">.LIB &#x27;&lt;file path&gt; file name&#x27; entryname1</span><br><span class="line">.ENDL entryname</span><br></pre></td></tr></table></figure>
<p>注意库文件定义中嵌套调用其他库文件的入口名不能与所要定义的名字相同,
可以无限嵌套.</p>
<h2 id="命令语句-1">命令语句</h2>
<h3 id="电路性能仿真">电路性能仿真</h3>
<h4 id="直流分析">直流分析</h4>
<p>直流工作点分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.OP</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流工作点分析是指所有独立源或者受控源都是直流形态, 所有电感短路,
电容开路</li>
<li>输出: 节点电压, 电源电流, 静态功耗, 半导体器件的电流, 阻抗和电容.
仿真结果储存在.dp0文件中</li>
<li>只能出现一次<code>.OP</code>语句</li>
</ol>
<p>直流扫描分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC variable start stop step</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>variable</code>: 要扫描的对象的变量名</li>
<li><code>start</code>: 扫描初始值</li>
<li><code>stop</code>: 扫描终值值</li>
<li><code>step</code>: 扫描步长</li>
</ol>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC VIN 0.25 5.0 0.25</span><br></pre></td></tr></table></figure>
<p>直流小信号传输函数的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TF variable1 variable2</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流传输函数就是在直流工作点附近对电路进行线性化处理,
然后对电路进行如下分析: 直流小信号传输函数(小信号增益,
即输出变量对于输入源的增益), 电路输入电阻, 电路输出电阻.</li>
<li>该语句特别适用于直流电路和直接耦合放大器(差动电路和运算放大器)的增益,
输入电阻, 输出电阻的计算.</li>
<li><code>variable1</code>: 传输函数中分子变量, 一般为输出变量</li>
<li><code>variable2</code>: 传输函数中分母变量, 一般为输入变量</li>
<li>每一个电路模拟中只能有一个<code>.TF</code>语句</li>
</ol>
<p>直流小信号灵敏度分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.SENS VO1 &lt;VO2...&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li>直流小信号灵敏度是指在指定范围内,
各个指定的输出变量相对于某一电路参数(如主被动元件值,
独立电源等)的直流小信号灵敏度.</li>
<li>绝对灵敏度是指, 输入参数每改变一个单位值, 输出的变化量,
如输入电阻每改变1欧姆, 输出电压的变化量, 这里单位便为V/1欧.
绝对灵敏度用来测试输入大幅度变化情况下输出的变化情况, 用于粗调.
定义式为<span class="math inline">\(S_E=\partial V_o/\partial
P\)</span>.</li>
<li>相等灵敏度是指, 输入参数在原来的基础上每改变百分之一, 输出的变化量.
如输入电阻为10欧姆, 每改变百分之一, 也就是0.1欧时, 输出电压的变化量,
单位为V/%, 相对灵敏度用来估计最大可允许输入误差范围. 定义式为<span
class="math inline">\(S_N=\partial V_o/\partial P\cdot P
\%\)</span></li>
<li><code>VO</code>: 输出的支路电流或者节点电压</li>
<li>灵敏度分析可以帮助设计者了解电路中哪些元件和模型参数对直流偏置的影响最大,
据此可以判断哪些元件和参数的作用是关键的,
它们参数的变化都会对输出造成较大的影响,
从而对元件精密度的选择做出了要求.</li>
</ol>
<h4 id="交流分析">交流分析</h4>
<p>交流信号包含幅值, 相位, 频率等的信号.
交流分析就是分析输出参数随频率变化的规律, 也就是频率响应.</p>
<p>交流分析中的一些规定:</p>
<ul>
<li>电阻: 若包含交流电阻, 则使用交流电阻</li>
<li>电容: 阻抗为<span class="math inline">\(1/j\omega C\)</span></li>
<li>电感: 阻抗为<span class="math inline">\(j\omega L\)</span></li>
<li>有源元件, 非线性元件全部转化为小信号模型</li>
<li>直流源全部接地</li>
</ul>
<p>交流小信号分析的一般形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC type np fstart fstop</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>type</code>是扫描类型</li>
<li><code>np</code>是扫描点数</li>
<li><code>fstrat/fstop</code>是起始和终止频率</li>
<li>注意电路中至少含有一个交流源</li>
</ol>
<p>扫描类型<code>type</code>有如下的选项:</p>
<ol type="1">
<li><code>DEC</code>: 每十进制实现对<code>np</code>个点进行扫描,
对数坐标</li>
<li><code>OCT</code>: 每八进制实现对<code>np</code>个点进行扫描,
对数坐标</li>
<li><code>LIN</code>: 线性扫描,
在指定的<code>fstart/fstop</code>频率范围内进行线性扫描</li>
<li><code>POI</code>: 按照所列参数点表进行扫描</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC DEC 10 1k 100MEG</span><br></pre></td></tr></table></figure>
<p>Sweep from 1kHz to 100MEGHz, with 10 points per decade</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC LIN 100 1 100Hz</span><br></pre></td></tr></table></figure>
<p>A 100 points frequency from 1Hz to 100Hz</p>
<p>AC的通用形式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.AC type np fstart fstop </span><br><span class="line">+SWEEP variable start-value stop-value </span><br><span class="line">+increment(type np start-value stop-value)</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC DEC 10 1 10k SWEEP Cload LIN 20 1pf 10pf</span><br></pre></td></tr></table></figure>
<p>对电容<code>Cload</code>的每个值进行AC分析, 扫描频率为1Hz到10kHZ,
每10进制扫描10个点,
其中<code>Cload</code>的值为从1pf到10pf等距离取20个点.</p>
<p>零极点分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PZ OUTPUT INPUT</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>OUTPUT</code>为输出变量, 可以是任一支路电流或者节点电压</li>
<li><code>INPUT</code>为输入变量, 可以是任一独立电压或电流源名称</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PZ V(10) VIN</span><br></pre></td></tr></table></figure>
<p>交流噪声分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.NOISE OVV srcnam inter</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>OVV</code>是指定节点总的噪声输出电压</li>
<li><code>srcnam</code>是作为噪声输入基准的独立电压源或者独立电流源</li>
<li><code>inter</code>是打印噪声分析结果的频率间隔</li>
</ol>
<h4 id="瞬态分析">瞬态分析</h4>
<p>瞬态分析也称为时域的暂态分析,
是指对所选定的电路节点的时域相应进行分析,
即观察该节点在整个显示周期中每一时刻的波形.</p>
<p>瞬态分析的条件:</p>
<ul>
<li>电路中含有储能元件, 如电容, 电感等</li>
<li>换路条件: 电源值的升高或降低, 接通或断开, 电路中元件参数的改变</li>
<li>换路定理1: 换路瞬间, 电容上的电压, 电感中的电流不能突变,
这就意味着瞬态分析需要设置初始条件.</li>
<li>换路定理2: 换路瞬间, 电感相当于理想恒流源,
电容相当于理想恒压源.</li>
</ul>
<p>瞬态分析的目的就是要分析电路的相应速度, 也就是时间常数<span
class="math inline">\(\tau\)</span>. 时间常数越大, 过渡过程,
即瞬态时间越长, 达到稳态所需的时间就越长.</p>
<p>瞬态分析不收敛的原因:</p>
<ol type="1">
<li>模型参数不连续</li>
<li>可选项设置不恰当</li>
<li>初始条件的设置不合适</li>
</ol>
<p>初始条件设定的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.IC var1=val1 &lt;var2=val2&gt; &lt;...&gt;</span><br><span class="line">.DCVOLT V(node1)/node1=val1 &lt;...&gt;</span><br></pre></td></tr></table></figure>
<p>注意<code>.IC</code>可以设置任意变量初始值,
<code>.DCVOLT</code>只能设置电压初始值.</p>
<p>节点电压语句的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.NODESET V(node1)=val1 &lt;V(node2)=val2&gt; &lt;...&gt;</span><br><span class="line">.NODESET node1=val1 node2=val2 ...</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.IC V(11)=5 V(4)=-5 V(2)=2.2</span><br><span class="line">.DCVOLT 11 5 4 -5 2 2.2</span><br><span class="line">.NODESET V(12)=4.5 V(4)=2.23</span><br><span class="line">.NODESET 12 4.5 4 2.23</span><br></pre></td></tr></table></figure>
<p>初始条件设置的三种形式:</p>
<p>一. 利用<code>IC=?</code>直接描述元件两端的初始电压, 例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C1 2 0 1uF IC=2V</span><br></pre></td></tr></table></figure>
<p>二. 初始条件语句<code>.IC</code></p>
<p>三. 节点电压语句<code>.NODESET/.DCVOLT</code></p>
<p>当这三种语句同时存在时,
优先级为<code>IC&gt;.IC&gt;.NODESET</code>.</p>
<p>瞬态分析的一般形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN TSTEP TSTOP &lt;TSTART&gt; &lt;UIC&gt;</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>TSTEP</code>是瞬态分析的步长</li>
<li><code>TSTOP</code>是瞬态分析终止的时间,
瞬态分析一般是从0开始分析到稳态结束,
但是只打印<code>TSTART</code>到<code>TSTOP</code>时间段的结果</li>
<li><code>TSTART</code>是分析的起始时间, 若不写则默认为0</li>
<li><code>UIC</code>:
若<code>.TRAN</code>语句中规定了<code>UIC</code>参数,
HSPICE不去计算初始直流工作点,
而是用<code>.IC</code>语句规定的节点电压计算电路中的初始条件.
这时需要仔细检查各个节点的直流电压值.
若<code>.TRAN</code>语句未规定<code>UIC</code>参数时,
HSPICE在瞬态分析前先计算直流工作点. 这时如果有<code>.IC</code>语句,
则仅当作求解直流工作点时相应的节点初始值,
而瞬态分析忽略这些电压限制.</li>
</ol>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 1NS 100NS UIC</span><br></pre></td></tr></table></figure>
<p>分析和打印瞬态分析结果, 从0~100ns, 每1ns打印一次. 忽略初始直流工作点,
以<code>.IC</code>规定的节点电压,
电流或者某个元件两端的初始电压值作为初始条件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN .1NS 25NS 1NS 40NS STRAT=10NS</span><br></pre></td></tr></table></figure>
<p>分析和打印10ns~25ns, 步长为0.1ns; 25ns~40ns, 步长为1ns</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 10NS 1US UIC SWEEP TEMP -55 75 10</span><br></pre></td></tr></table></figure>
<p>对温度-55, -45,…, 75进行瞬态扫描, 时间从0~1us, 步长为10ns,
初始条件为<code>IC</code>规定的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 10NS 1US SWEEP Cload POI 3 1pF 5pF 10pF</span><br></pre></td></tr></table></figure>
<p>对负载参数电容<code>Cload</code>为1pf, 5pf, 10pf分别进行瞬态扫描,
时间从0~1us, 步长为10ns, <code>POI</code>为要扫描的参数列表.</p>
<h4 id="蒙特卡洛分析">蒙特卡洛分析</h4>
<p>蒙特卡洛分析的含义: 在给定标准差资料的基础上,
使用随机数发生器按照元件值的概率分布来选择元件值,
然后对电路进行模拟分析.</p>
<p>目的:</p>
<ol type="1">
<li>计算一定的工艺误差允许范围内的元件值</li>
<li>计算一定元件值下所允许的工艺误差容忍值</li>
</ol>
<p>应用:</p>
<ol type="1">
<li>预测元件参数的变化对产品效能的影响</li>
<li>电路生产的成品率以及成本</li>
</ol>
<p>蒙特卡洛直流分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛直流扫描分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.DC vin 15 .25 SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛交流扫描分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AC dec 10 100 10meg SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>蒙特卡洛瞬态扫描分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TRAN 1n 10n SWEEP MONTE=val</span><br></pre></td></tr></table></figure>
<p>注释: <code>val</code>是蒙特卡洛分析中迭代的次数.</p>
<p>蒙特卡洛分析的元件参数设定</p>
<p>均匀分布情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=UNIF(NOM_VALUE, REL_VARIATION &lt;,multiplier&gt;) * 相对变化</span><br><span class="line">.PARAM XX=UNIF(NOM_VALUE, ABS_VARIATION &lt;,multiplier&gt;) * 绝对变化</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>REL_VARIATION</code>为相对变化值R, 在[N-N*R,
N+N*R]之间均匀分布</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间均匀分布</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<p>高斯分布情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=GAUSS(NOM_VALUE, REL_VARIATION, +&lt;Sigm&gt;&lt;,multiplier&gt;) * 相对变化</span><br><span class="line">.PARAM XX=GAUSS(NOM_VALUE, ABS_VARIATION, +&lt;Sigm&gt;&lt;,multiplier&gt;) * 绝对变化</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>REL_VARIATION</code>为相对变化值R, 在[N-N*R,
N+N*R]之间高斯分布</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间高斯分布</li>
<li><code>Sigm</code>为标准差参数, 实际标准差=A/S</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<p>随机范围参数分布:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PARAM XX=LIMIT(NOM_VALUE, ABS_VARIATION&lt;,multiplier&gt;)</span><br></pre></td></tr></table></figure>
<p>注释:</p>
<ol type="1">
<li><code>XX</code>是变化参数名</li>
<li><code>NOM_VALUE</code>是参数变化中心值N</li>
<li><code>ABS_VARIATION</code>为绝对变化值A, 在[N-A,
N+A]之间随机分布</li>
<li><code>multiplier</code>为重复计算的次数, 并储存最大偏离值,
默认为1.</li>
</ol>
<h4 id="温度特性">温度特性</h4>
<p>电路温度由<code>.TEMP</code>语句设定:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.TEMP T1 T2 T3...</span><br></pre></td></tr></table></figure>
<p>电路对每个设定温度都模拟一次, 若缺省,
则电路温度为<code>TNOM</code>(由<code>.option</code>设定, 如果未设定,
默认为25).</p>
<p>单个元件温度是用<code>DTEMP</code>参数的扩展功能,
指的是元件温度与电路温度的差值.</p>
<p>模型参考温度由<code>.MODEL</code>语句中的<code>TREF</code>参数决定.</p>
<h3 id="输入输出控制">输入输出控制</h3>
<h4 id="输入控制">输入控制</h4>
<h4 id="输出控制">输出控制</h4>
<h2 id="实验及作业">实验及作业</h2>
<h3 id="实验例程inv">实验例程inv</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.title inv by liang yuhua</span><br><span class="line">*******************************************************************************************************</span><br><span class="line">* 电路描述：这是一个基于TSMC 65nm工艺的反相器电路，用于蒙特卡洛仿真分析</span><br><span class="line">*******************************************************************************************************</span><br><span class="line"></span><br><span class="line">* 工艺库文件引用</span><br><span class="line">.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">* 可选的工艺角库文件：</span><br><span class="line">* tt_lib    - 典型工艺角</span><br><span class="line">* ff_lib    - 快-快工艺角  </span><br><span class="line">* ss_lib    - 慢-慢工艺角</span><br><span class="line">* sf_lib    - 慢-快工艺角</span><br><span class="line">* fs_lib    - 快-慢工艺角</span><br><span class="line">* mc_lib    - 蒙特卡洛分析库（当前使用）</span><br><span class="line">* mismatch_lib - 失配分析库</span><br><span class="line">* noise_best/noise_worst - 噪声分析库</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">* 仿真控制选项</span><br><span class="line">.OPTION POST        $ 生成后处理输出文件</span><br><span class="line">.option lis_new     $ 使用新的列表文件格式</span><br><span class="line">.TEMP 27            $ 设置仿真温度为27°C</span><br><span class="line">.option ingold      $ 使用Gold格式输出，便于数据处理</span><br><span class="line">.OPTION method=BDF  $ 使用后向差分公式积分方法，适合刚性电路</span><br><span class="line">.OPTION runlvl=6    $ 设置运行级别为6，提高仿真精度</span><br><span class="line">.OPTION CO=132      $ 设置输出行宽为132字符</span><br><span class="line">.option measform=3  $ 设置测量结果输出格式</span><br><span class="line">.option dcon=1      $ 启用直流收敛辅助</span><br><span class="line">.op                  $ 执行直流工作点分析</span><br><span class="line">.option probe       $ 启用探测功能</span><br><span class="line">.OPTION LIST NODE   $ 在列表文件中包含节点信息</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 全局参数定义</span><br><span class="line">.param vdd    =1.2                    $ 定义电源电压为1.2V</span><br><span class="line">.param mismatchflag_mos_rf=1          $ 启用RF MOS管的失配效应（蒙特卡洛分析）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 电源和信号源定义</span><br><span class="line">vdd vdd 0 pwl 0 0 5n 0 5.0001n &#x27;vdd&#x27;  $ 电源电压：0-5ns为0V，5ns后跳变到1.2V</span><br><span class="line">vss vss 0 0                           $ 地电位定义</span><br><span class="line">vin in  0 pwl 0 0 20n 0 20.00001n vdd 35n vdd 35.00001n 0 50n 0  </span><br><span class="line">* 输入信号vin：0-20ns为0V，20ns跳变到1.2V，35ns跳变回0V，持续到50ns</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 反相器电路核心器件</span><br><span class="line">* NMOS晶体管：RF NMOS，工作在饱和区</span><br><span class="line">XN1 out in vss vss   nmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* 器件说明：X开头表示子电路调用，N1为实例名</span><br><span class="line">* 端口连接：out-漏极, in-栅极, vss-源极, vss-体端（四端口器件）</span><br><span class="line">* 参数：lr=栅长60nm, wr=栅宽1μm, nr=栅指数为1（单指）</span><br><span class="line">*       mismatchflag=1启用失配, sigma=1标准差倍数</span><br><span class="line"></span><br><span class="line">* PMOS晶体管：RF PMOS，与NMOS构成互补结构  </span><br><span class="line">XP1 out in vdd vdd   pmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* 器件说明：P1为PMOS实例名</span><br><span class="line">* 端口连接：out-漏极, in-栅极, vdd-源极, vdd-体端</span><br><span class="line">* 参数与NMOS对称，形成标准CMOS反相器</span><br><span class="line"></span><br><span class="line">* 负载电容</span><br><span class="line">CL out 0 1p          $ 输出端接1pF负载电容，模拟实际负载条件</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 瞬态分析设置</span><br><span class="line">.tran 0.005n 50n $sweep monte=10    $ 瞬态分析：时间步长5ps，总时长50ns</span><br><span class="line">*                $ 蒙特卡洛分析：进行10次随机采样，分析工艺波动影响</span><br><span class="line"></span><br><span class="line">* 输出信号定义</span><br><span class="line">.print tran V(in) V(out) V(vdd)     $ 输出输入、输出和电源电压波形</span><br><span class="line"></span><br><span class="line">.end</span><br></pre></td></tr></table></figure>
<h3 id="实验例程二">实验例程二</h3>
<p>对TSMC65nm工艺下SVT型NMOS晶体管, 在VD=1.2V, VG=0.6V的条件下,
仿真M0的静态工作点.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A SIMPLE AC RUN $title</span><br><span class="line">.LIB .lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">VD D 0 1.2</span><br><span class="line">VG G 0 0.6</span><br><span class="line">XN1 D G 0 0 RF_NMOS lr=0.5u wr=1u nr=2</span><br><span class="line">.OPTIONS LIST NODE POST $control options</span><br><span class="line">.OP</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
<h3 id="作业一">作业一</h3>
<p>详细阐述噪声容限的概念, 图示说明. 然后使用HSpice进行仿真.</p>
<h4 id="噪声容限的概念">噪声容限的概念</h4>
<p>噪声容限是衡量数字电路抗干扰能力的重要指标<a
href="#ref1"><sup>[1]</sup></a>.</p>
<p>假设一个反相器门电路的输入为逻辑变量in, 产生输出变量out.
一个逻辑门的电路可以用它的电压传输特性(VTC,
有时称为DC传输特性)得到最佳描述, 它画出了输出电压与输入电压的关系 <span
class="math inline">\(V_{out}=f(V_{in})\)</span>.
额定高电压和额定低电压分别为 <span
class="math inline">\(V_{OH}=f(V_{OL})\)</span>, <span
class="math inline">\(V_{OL}=f(V_{OH})\)</span>.
门阈值电压或者开关阈值电压 <span
class="math inline">\(V_M=f(V_M)\)</span>, 如下图所示.</p>
<p><img src="/source/images/HSpice/invtransfer.jpg" /></p>
<p>可接受的高电压和低电压的区域分别由<span
class="math inline">\(V_{IH}\)</span>和<span
class="math inline">\(V_{IL}\)</span>来界定, 根据定义,
它们代表了VTC增益(<span
class="math inline">\(=\mathrm{d}V_{out}/\mathrm{d}V_{in}\)</span>)等于<span
class="math inline">\(-1\)</span>的点, 如下图所示. <span
class="math inline">\(V_{IH}\)</span>和<span
class="math inline">\(V_{IL}\)</span>之间的区域称为不确定区,
有时也称为过度宽度(Transition Width, TW), 为了电路正确工作,
稳态信号应该避开这个区域.</p>
<p><img src="/source/images/HSpice/voltage.jpg" /></p>
<p>为了使一个门的稳定性较好且对噪声干扰不敏感,
应当使得”0”和”1”的区间越大越好. 一个门对于噪声的灵敏度是由噪声容限<span
class="math inline">\(NM_L\)</span>(低电平噪声容限)和<span
class="math inline">\(NM_H\)</span>(高电平噪声容限)来度量的,
它们分别量化了合法的”0”和”1”的范围, 并且确定了噪声的最大固定阈值:</p>
<p><span class="math display">\[\begin{aligned}
   &amp; NM_L=V_{IL}-V_{OL}\\
   &amp; NM_H=V_{OH}-V_{IH}\\
\end{aligned}\]</span></p>
<p><img src="/source/images/HSpice/NM.jpg" /></p>
<h4 id="仿真">仿真</h4>
<p>为了得到<span class="math inline">\(V_{out}=f(V_{in})\)</span>的曲线,
我们对反相器进行直流扫描, 将原来的inv.sp文件修改如下,命名为invnm.sp:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">.title inv by liang yuhua</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">.lib E:\HspiceTestbench\TSMC65\toplevel.l mc_lib</span><br><span class="line">* 引用工艺库文件：TSMC 65nm工艺库，使用mc_lib（蒙特卡洛库）</span><br><span class="line">* 可选的库类型注释：</span><br><span class="line">* tt_lib - 典型工艺角</span><br><span class="line">* ff_lib - 快工艺角（fast-fast）</span><br><span class="line">* ss_lib - 慢工艺角（slow-slow）</span><br><span class="line">* sf_lib - PMOS快NMOS慢工艺角</span><br><span class="line">* fs_lib - PMOS慢NMOS快工艺角</span><br><span class="line">* mc_lib - 蒙特卡洛分析库</span><br><span class="line">* mismatch_lib - 失配分析库</span><br><span class="line">* noise_best - 最佳噪声特性</span><br><span class="line">* noise_worst - 最差噪声特性</span><br><span class="line"></span><br><span class="line">*******************************************************************************************************</span><br><span class="line">.OPTION POST=2</span><br><span class="line">* 设置后处理选项：POST=2 生成二进制格式的输出文件，用于波形查看器如CScope</span><br><span class="line"></span><br><span class="line">.option lis_new</span><br><span class="line">* 使用新的列表文件格式</span><br><span class="line"></span><br><span class="line">.TEMP 27</span><br><span class="line">* 设置仿真温度：27摄氏度</span><br><span class="line"></span><br><span class="line">.option ingold=1</span><br><span class="line">* 使用Gold格式输出，与CScope兼容</span><br><span class="line"></span><br><span class="line">.OPTION method=BDF</span><br><span class="line">* 设置数值积分方法：BDF（Backward Differentiation Formula），适合刚性电路</span><br><span class="line"></span><br><span class="line">.OPTION runlvl=6</span><br><span class="line">* 设置仿真运行级别：6（较高的精度级别）</span><br><span class="line"></span><br><span class="line">.OPTION CO=132</span><br><span class="line">* 设置输出行宽度：132个字符</span><br><span class="line"></span><br><span class="line">.option measform=3</span><br><span class="line">* 设置测量结果输出格式：3（详细格式）</span><br><span class="line"></span><br><span class="line">.option dcon=1</span><br><span class="line">* 直流收敛辅助选项：开启直流收敛帮助</span><br><span class="line"></span><br><span class="line">.op</span><br><span class="line">* 要求输出直流工作点信息</span><br><span class="line"></span><br><span class="line">.option probe</span><br><span class="line">* 启用探测功能，生成波形数据</span><br><span class="line"></span><br><span class="line">.OPTION LIST NODE</span><br><span class="line">* 在列表文件中包含节点信息</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">.param vdd    =1.2</span><br><span class="line">* 定义参数：电源电压vdd = 1.2V</span><br><span class="line"></span><br><span class="line">.param mismatchflag_mos_rf=1</span><br><span class="line">* 定义参数：MOS管失配标志 = 1（启用失配效应）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">vdd vdd 0 dc &#x27;vdd&#x27;</span><br><span class="line">* 定义直流电压源：vdd节点到地（0），电压值为参数vdd的值（1.2V）</span><br><span class="line">* &#x27;vdd&#x27;表示使用之前定义的参数值</span><br><span class="line"></span><br><span class="line">vss vss 0 0</span><br><span class="line">* 定义地节点：vss节点连接到地，电压为0V</span><br><span class="line"></span><br><span class="line">vin in  0 dc 0</span><br><span class="line">* 定义输入直流电压源：in节点到地，初始电压为0V（将在直流扫描中变化）</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 反相器电路结构：</span><br><span class="line">XN1 out in vss vss   nmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* NMOS晶体管XN1：</span><br><span class="line">*   - 漏极：out，栅极：in，源极：vss，体端：vss</span><br><span class="line">*   - 模型：nmos_rf（RF NMOS）</span><br><span class="line">*   - 参数：lr=0.06μm（栅长），wr=1.0μm（栅宽），nr=1（手指数）</span><br><span class="line">*   - mismatchflag=&#x27;mismatchflag_mos_rf&#x27;（使用失配标志参数）</span><br><span class="line">*   - sigma=1（标准差系数）</span><br><span class="line"></span><br><span class="line">XP1 out in vdd vdd   pmos_rf lr=0.06E-6 wr=1.0E-6 nr=1 mismatchflag=&#x27;mismatchflag_mos_rf&#x27; sigma=1</span><br><span class="line">* PMOS晶体管XP1：</span><br><span class="line">*   - 漏极：out，栅极：in，源极：vdd，体端：vdd</span><br><span class="line">*   - 模型：pmos_rf（RF PMOS）</span><br><span class="line">*   - 参数：lr=0.06μm（栅长），wr=1.0μm（栅宽），nr=1（手指数）</span><br><span class="line">*   - mismatchflag=&#x27;mismatchflag_mos_rf&#x27;（使用失配标志参数）</span><br><span class="line">*   - sigma=1（标准差系数）</span><br><span class="line"></span><br><span class="line">CL out 0 1p</span><br><span class="line">* 负载电容：out节点到地，电容值1pF</span><br><span class="line"></span><br><span class="line">******************************************************************************************************</span><br><span class="line">* 直流扫描分析</span><br><span class="line">.dc vin 0 vdd 0.01</span><br><span class="line">* 直流扫描分析命令：</span><br><span class="line">*   - 扫描变量：vin（输入电压源）</span><br><span class="line">*   - 扫描范围：从0V到vdd（1.2V）</span><br><span class="line">*   - 扫描步长：0.01V（10mV）</span><br><span class="line">*   这将生成反相器的电压传输特性曲线</span><br><span class="line"></span><br><span class="line">* 添加.probe语句来生成CScope可查看的波形</span><br><span class="line">.probe dc V(in) V(out)</span><br><span class="line">* 指定要保存的直流分析节点电压：</span><br><span class="line">*   - V(in)：输入电压</span><br><span class="line">*   - V(out)：输出电压</span><br><span class="line">*   这些数据将被保存到.tr0文件中，供CScope查看</span><br><span class="line"></span><br><span class="line">.end</span><br><span class="line">* 仿真结束</span><br></pre></td></tr></table></figure>
<p>用CScope打开生成的invnm.sw0, 可以得到波形图, 添加cursor, 在configure
cursor中设置为drivative, 即可得到<span
class="math inline">\(V_{out}\)</span>关于<span
class="math inline">\(V_{in}\)</span>的导数. 寻找导数约为<span
class="math inline">\(-1\)</span>的点对应的横坐标. 见下图</p>
<p><img src="/source/images/HSpice/invnm1.png" /></p>
<p><img src="/source/images/HSpice/invnm2.png" /></p>
<p>可得<span class="math inline">\(V_{IL}=450mV, V_{IH}=637mV\)</span>,
而<span class="math inline">\(V_{OH}\approx 1.2V, V_{OL}\approx
0V\)</span>, 所以噪声容限为:</p>
<p><span class="math display">\[\begin{aligned}
   &amp; NM_L=V_{IL}-V_{OL}=0.45-0=0.45V\\
   &amp; NM_H=V_{OH}-V_{IH}=1.2-0.637=0.563V\\
\end{aligned}\]</span></p>
<h4 id="参考文献">参考文献</h4>
<p><a id="ref1"></a> [1] Jan M. Rabaey, Anantha Chandrakasan, Borivoje
Nikolic. 数字集成电路——电路、系统与设计（第二版）[M]. 北京:
电子工业出版社, 2017.1: 13-15.</p>
<h3 id="作业二">作业二</h3>
<p>用HSpice仿真如下电路的噪声</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A simple noise run</span><br><span class="line">   R1 1 2 5</span><br><span class="line">   C1 2 0 500pf</span><br><span class="line">   V1 1 0 0 AC=10V, 37</span><br><span class="line">   .AC DEC 10 1 100MEG</span><br><span class="line">   .noise v(2) v1 20</span><br><span class="line">   .END</span><br></pre></td></tr></table></figure>
<p>我们把网表文件命名为<code>example2.sp</code>.</p>
<p>这个网表是一个<strong>基础的无源RC电路</strong>, 仅包含电阻和电容.
HSpice软件的内置模型已包含这些基础元件的噪声模型: *
电阻元件的<strong>热噪声（约翰逊噪声）</strong>
是HSpice内置的基础噪声源之一. 进行<code>.NOISE</code>分析时,
HSpice会自动计算此类噪声。 *
电容元件在HSpice中通常被视为<strong>无噪声元件</strong></p>
<p>由于电路中没有使用晶体管等有源半导体器件(这些器件的噪声模型,
如MOSFET的<strong>热噪声</strong>和<strong>1/f
噪声（闪烁噪声）</strong>, 通常需要专门的工艺库文件提供精确参数),
因此不包含工艺库文件不影响此电路的噪声仿真.</p>
<p>代码中与噪声分析相关的语句设置是合理的: *
<code>.AC DEC 10 1 100MEG</code>: 在1Hz到100MHz频率范围内,
以10倍频程进行扫描, 每个倍频计算10个点.
这是<code>.NOISE</code>分析的基础。 * <code>.noise v(2) v1 20</code>:
指定噪声分析. <code>v(2)</code>是输出节点,
<code>v1</code>是作为噪声输入参考的独立源,
<code>20</code>代表每隔20个频率点打印一次详细的噪声贡献.</p>
<p>仿真的结果保存在<code>example2.lis</code>,
用文本编辑器打开即可查看噪声仿真结果.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Hexo%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">Hexo+GitHub搭建博客教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-28 12:59:43" itemprop="dateModified" datetime="2026-02-28T12:59:43+08:00">2026-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E7%BD%91%E7%AB%99%E5%88%B6%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">网站制作</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装">安装</h2>
<h3 id="github的注册及创建域名">GitHub的注册及创建域名</h3>
<p>注册这一步就不说了. 注册完成后点击New创建一个新的repository,
在Owner填自己的<code>username</code>, 在Repository
name里面填<code>username.github.io</code> 这样就成功建立了一个域名.</p>
<h3 id="git的安装">Git的安装</h3>
<p>在搜索引擎中直接搜索Git进入官方网站, 点击Download for Windows,
在Standalone Installer下点击64-bit Git for Windows Setup,
下载好之后一直点击next(可以自己设置下载路径)就可以下载完成了.
最后可以按<code>win+R</code>输入cmd, 然后输入<code>git --version</code>,
如果出现git的版本, 说明安装完成.</p>
<p>在git的安装目录下打开git bash, 输入命令</p>
<p><code>ssh-keygen -t rsa -C "你自己的邮箱的地址"</code></p>
<p>然后回车, 遇到Enter file in which to save the
key时输入一个路径,生成的ssh文件就放在那里, 在遇到Enter
passphrase时回车两次(或者输入你自己的密码两次)即可.</p>
<p>打开GitHub网页,在Setting界面点开SSH and GPG keys, 点击New SSH,
title随便输一个名字, 然后打开刚刚生成的id_rsa.pub, 复制里面的内容,
粘贴到key这一栏下面, 然后点击Add SSH key即可.</p>
<h3 id="node.js的安装">Node.js的安装</h3>
<p>在搜索引擎中直接搜索Node js进入官方网站, 点击Recommended For Most
Users的下载按钮, 下载好之后打开, 一直点next 就可以下载完成了.
最后可以按<code>win+R</code>输入cmd,
然后输入<code>node --version</code>, 如果出现node的版本,
说明安装完成.</p>
<h3 id="hexo的安装">Hexo的安装</h3>
<p>在搜索引擎中直接搜索Hexo进入官方网站, 在网站上直接复制下面的代码</p>
<p><code>npm install hexo-cli -g</code></p>
<p>在C盘中创建一个新的文件夹blog,
在其中右键打开git的bash(这里需要安装git才能看见这个选项,
还需要安装node.js)窗口, 将代码粘贴进去回车, 等待下载, 下载好之后,
输入</p>
<p><code>hexo init Blog</code></p>
<p>然后就会发现blog文件夹下面有一个新的Blog文件夹,
在这个文件夹里面打开git bash, 输入</p>
<p><code>npm install</code></p>
<p>安装完成后输入</p>
<p><code>hexo s</code></p>
<p>就会出现一个localhost的网址, 复制之后在浏览器中打开,
就可以看见Hexo的默认界面了.</p>
<h2 id="主题的设置">主题的设置</h2>
<h3 id="next主题">Next主题</h3>
<h4 id="next主题的启用">Next主题的启用</h4>
<p>在C盘Blog文件夹下找到_config.yml文件, 用VScode打开,
在<code>theme</code>后面的东西改成<code>next</code>, Blog里面打开git
bash, 输入<code>hexo s</code>, 复制网站在浏览器打开,
就可以看见Next主题的默认界面了.</p>
<h4 id="语言的更改">语言的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>language</code>选项改成<code>zh-Hans</code>保存好之后,
输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会变成中文了.</p>
<h4 id="标签页和分类页">标签页和分类页</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件, 用VScode打开,
将<code>menu</code>下面的默认的<code>categories</code>和<code>tags</code>取消注释,
并保存, 输入<code>hexo clean</code>清理, <code>hexo g</code>生成,
<code>hexo s</code>得到的网站就会有标签页和分类页了,
但是点进去会出现空白页面.</p>
<p>在C盘Blog文件夹下找到source文件夹, 在Blog文件夹下面打开git bash,
输入<code>hexo n page tags</code>回车之后,
source文件里面就会多出来一个tags文件夹，
打开tags文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>标签</code>,
然后增加一行<code>type: "tags"</code>;
同样地输入<code>hexo n page categories</code>回车之后,
source文件里面就会多出来一个categories文件夹，
打开categories文件夹里面的index.md文件,
可以把<code>title</code>设置成中文<code>分类</code>,
然后增加一行<code>type: "categories"</code>,
保存之后就可以看见标签和分类页了.</p>
<h4 id="主题样式的更改">主题样式的更改</h4>
<p>在C盘Blog/themes/next文件夹下找到_config.yml文件,
找到<code>scheme</code>, 把默认的<code>scheme: Muse</code>注释掉,
然后把<code>scheme: Pisces</code>取消注释, 保存即可.</p>
<p>下面来设置Pisces.</p>
<p>头像: 把<code>avatar: /images/avatar.gif</code>取消注释,
在Blog/themes/next/source/images文件夹下面删除默认的avatar.gif,
替换成你自己的femboy.jpg,
然后修改url为<code>url: /images/femboy.jpg</code>然后保存即可.</p>
<p>网站标题: 在C盘Blog文件夹下找到_config.yml文件,
作如下修改<code>title: SiyuanLei'blog</code>,
<code>author: SiyuanLei</code></p>
<p>侧边栏: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>social</code>一栏取消注释,
在对应的社交网站后面改成自己的社交平台链接即可.</p>
<p>友情链接: 在C盘Blog/themes/next文件夹下找到_config.yml文件,
把<code>links</code>一栏取消注释, 然后加上一些连接, 比如Arxiv,
Libgen之类的.</p>
<h2 id="文章">文章</h2>
<p>我自己常用的方式是, 在C: _posts下面直接加入一个markdown文件,
但是文件开头一定要是下面的格式:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 第四章:Verilog HDL数字逻辑电路设计方法</span><br><span class="line">date: 2025-05-04</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> [EE,数字设计,Verilog]</span><br><span class="line">tags:</span><br><span class="line"><span class="section">- Verilog</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h2 id="博客的发布">博客的发布</h2>
<p>在<code>C:\blog\Blog</code>下打开终端, 然后依次输入以下指令即可:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="一些意外">一些意外</h2>
<h3
id="在博客根目录下的终端无法使用hexo命令">在博客根目录下的终端无法使用hexo命令</h3>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\blog\Blog&gt; hexo d</span><br><span class="line">hexo : 无法将“hexo”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确</span><br><span class="line">，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ hexo</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (hexo:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure>
<p>但是在命令行窗口输入<code>npm -v</code>, <code>node -v</code>都正常.
这说明环境变量出了问题.</p>
<p>首先需要配置环境变量,
在Windows上，通过npm全局安装的包（比如hexo），其可执行文件通常位于一个特定的目录。你需要确保这个目录被添加到了系统的PATH环境变量中。查找路径：全局安装的包默认在
C:。</p>
<p>修改环境变量：在Windows搜索框输入“环境变量”，选择“编辑系统环境变量”。在弹出窗口中，点击右下角的“环境变量”按钮。在“用户变量”或“系统变量”区域，找到名为
Path
的变量，双击它。点击“新建”，然后将上述的npm路径（例如C:）添加进去。逐一点击“确定”保存所有更改。重启终端：非常重要的一步！
完全关闭你当前的PowerShell或命令提示符窗口，然后重新打开，再尝试输入
hexo 命令。</p>
<p>然后出现了如下报错</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\blog\Blog&gt; hexo cl</span><br><span class="line">hexo : 无法加载文件 C:\Users\XQ\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/g</span><br><span class="line">o.microsoft.com/fwlink/?LinkID=<span class="number">135170</span> 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ hexo cl</span><br><span class="line">+ ~~~~</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure>
<p>这个错误是因为Windows PowerShell的执行策略（Execution
Policy）限制了脚本运行。不过别担心，这个问题很常见，很容易解决。简单来说，Windows为了防止恶意脚本自动执行，默认禁止运行任何PowerShell脚本。你刚才配置好环境变量，系统找到了hexo.ps1脚本，但这个“安全门”却把它拦住了。</p>
<p>为了永久取消这个限制, 先右键点击“开始”菜单或按 Win + X，然后选择
“Windows PowerShell（管理员）”或
“终端（管理员）”。在打开的窗口中，输入<code>Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned</code>.
完成此操作后，关闭当前的PowerShell窗口（包括之前报错的那个），重新打开一个新的终端，再进入你的博客目录
C:，尝试执行<code>hexo cl, hexo g, hexo d</code>就可以正常工作了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Minecraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Minecraft/" class="post-title-link" itemprop="url">Minecraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-19 19:50:11" itemprop="dateModified" datetime="2026-01-19T19:50:11+08:00">2026-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Game/" itemprop="url" rel="index"><span itemprop="name">Game</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="光影">光影</h2>
<p>下载对应版本的Optifine, 下载完成后打开java文件,
然后直接安装到<code>C:\Users\XQ\AppData\Roaming\.minecraft</code>文件夹下面,
然后打开游戏, 就可以看见光影的选项了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Linux%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Linux%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Linux入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-10 18:50:30" itemprop="dateModified" datetime="2025-08-10T18:50:30+08:00">2025-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。
但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。
在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。
但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，
或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。</p>
<p>本课程意在帮你解决这一问题。</p>
<p>我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。
我们认为这是大多数计算机科学相关课程中缺少的重要一环。</p>
<h2 id="the-shell">The Shell</h2>
<h3 id="shell-是什么">shell 是什么？</h3>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是
AR/VR 都已经无处不在。 这些交互接口可以覆盖 80%
的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。
为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的
shell，有些甚至还提供了多种 shell
供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。
这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开
shell 提示符（您输入指令的地方），您首先需要打开 终端
。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h3 id="使用-shell">使用 shell</h3>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$</span><br></pre></td></tr></table></figure>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是
<code>missing</code> 并且您当前的工作目录（”current working
directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。
<code>$</code> 符号表示您现在的身份不是 root
用户（稍后会介绍）。在这个提示符中，您可以输入 命令 ，命令最终会被 shell
解析。最简单的命令是执行一个程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$ </span><br></pre></td></tr></table></figure>
<p>这里，我们执行了 <code>date</code>
这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell
等待我们输入其他命令。我们可以在执行命令的同时向程序传递 参数 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数
<code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell
基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为
My Photos
的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号
<code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或
<code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell
是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在
shell 中执行命令时，您实际上是在执行一段 shell
可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是
shell 所了解的编程关键字，那么它会去咨询 环境变量
<code>$PATH</code>，它会列出当 shell
接到某条指令时，进行程序搜索的路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行
<code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 :
所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是
可执行程序，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用
<code>which</code> 程序。我们也可以绕过
<code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p>
<h3 id="在-shell-中导航">在 shell 中导航</h3>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用
<code>/</code> 分割，而在 Windows 上是 <code>\</code>。路径
<code>/</code>
代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在 Windows
上每个盘都有一个根目录（例如： <code>C:\</code>）。
我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以
<code>/</code> 开头，那么它是一个 绝对路径，其他的都是 相对路径
。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用
<code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code>
命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code>
表示上级目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ cd /home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ pwd</span><br><span class="line">/</span><br><span class="line">missing:/$ cd ./home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd missing</span><br><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ ../../bin/echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell
提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls</span><br><span class="line">missing:~$ cd ..</span><br><span class="line">missing:/home$ ls</span><br><span class="line">missing</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code>
会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以
<code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用
<code>-h</code> 或 <code>--help</code>
标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code>
的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l                         use a long listing format</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l /home</span><br><span class="line">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure>
<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符
<code>d</code> 表示 <code>missing</code>
是一个目录。然后接下来的九个字符，每三个字符构成一组。
（<code>rwx</code>）.
它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>）
以及其他所有人具有的权限。其中 <code>-</code>
表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code>
文件夹
（例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code>
目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code>
权限，也就是说任何人都可以执行这些程序。</p>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如
<code>mv</code>（用于重命名或移动文件）、
<code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试
<code>man</code>
这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用
<code>q</code> 可以退出该程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ man ls</span><br></pre></td></tr></table></figure>
<h3 id="在程序间创建连接">在程序间创建连接</h3>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。
当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。
通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。
但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和
<code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（
pipes ），我们能够更好的利用文件重定向。 <code>|</code>
操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h3 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h3>
<p>对于大多数的类 Unix
系统，有一类用户是非常特殊的，那就是：根用户（root user）。
您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。
通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。
取而代之的是我们会在需要的时候使用 <code>sudo</code>
命令。顾名思义，它的作用是让您可以以 su（super user 或 root
的简写）的身份执行一些操作。 当您遇到拒绝访问（permission
denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code>
文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code>
文件则暴露了一些内核（kernel）参数。
因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。注意
Windows 和 macOS 没有这个文件</p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code>
文件中，它位于</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/backlight</span><br></pre></td></tr></table></figure>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> find -L /sys/class/backlight -maxdepth 2 -name <span class="string">&#x27;*brightness*&#x27;</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file &#x27;brightness&#x27;</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了
<code>sudo</code> 命令！关于
shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和
<code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。
<code>echo</code> 等程序并不知道 <code>|</code>
的存在，它们只知道从自己的输入输出流中进行读写。
回到上面更改屏幕亮度命令执行的报错，为了能让 <code>sudo echo</code>
命令输出的亮度值写入 <code>brightness</code> 文件， shell
(权限为当前用户) 会先尝试打开 <code>brightness</code> 文件，但此时操作
shell 的不是根（root）用户，所以系统拒绝了这个打开操作，提示无权限。</p>
<p>明白这一点后，我们可以这样操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 | <span class="built_in">sudo</span> <span class="built_in">tee</span> brightness</span></span><br></pre></td></tr></table></figure>
<p>此时打开 <code>/sys</code> 文件的是 <code>tee</code>
这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。
这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种 LED
的状态（路径可能会有所不同）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 1 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/class/leds/input6::scrolllock/brightness</span></span><br></pre></td></tr></table></figure>
<h2 id="shell-工具和脚本">Shell 工具和脚本</h2>
<p>我们将会展示 bash 作为脚本语言的一些基础操作，以及几种最常用的 shell
工具。</p>
<h3 id="shell-脚本">Shell 脚本</h3>
<p>到目前为止，我们已经学习了如何在 shell
中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell 脚本的复杂性进一步提高。</p>
<p>大多数 shell
都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell
脚本与其他脚本语言不同之处在于，shell 脚本针对 shell
所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是
shell
脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于
bash 脚本，因为它最流行，应用更为广泛。</p>
<p>在 bash 中为变量赋值的语法是
<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。
需要注意的是，<code>foo = bar</code>
（使用空格隔开）是不能正确工作的，因为解释器会调用程序 <code>foo</code>
并将 <code>=</code> 和 <code>bar</code> 作为参数。 总的来说，在 shell
脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash 中的字符串通过 <code>'</code> 和 <code>"</code>
分隔符来定义，但是它们的含义并不相同。以 <code>'</code>
定义的字符串为原义字符串，其中的变量不会被转义，而 <code>"</code>
定义的字符串会将变量值进行替换。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 bar</span></span><br><span class="line">echo &#x27;$foo&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 <span class="variable">$foo</span></span></span><br></pre></td></tr></table></figure>
<p>和其他大多数的编程语言一样，<code>bash</code> 也支持 <code>if</code>,
<code>case</code>, <code>while</code> 和 <code>for</code>
这些控制流关键字。同样地， <code>bash</code>
也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用
<code>cd</code> 进入该文件夹。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>$1</code>
是脚本的第一个参数。与其他脚本语言不同的是，<code>bash</code>
使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考
这里。</p>
<p><code>$0</code> - 脚本名 <code>$1</code> 到 <code>$9</code> -
脚本的参数。 <code>$1</code> 是第一个参数，依此类推。 <code>$@</code> -
所有参数 <code>$#</code> - 参数个数 <code>$?</code> - 前一个命令的返回值
<code>$$</code> - 当前脚本的进程识别码 <code>!!</code> -
完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用
<code>sudo !!</code> 再尝试一次。 <code>$_</code> -
上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下
<code>Esc</code> 之后键入 . 来获取这个值。</p>
<p>命令通常使用 <code>STDOUT</code> 来返回输出值，使用
<code>STDERR</code>
来返回错误及错误码，便于脚本以更加友好的方式报告错误。
返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值 0
表示正常执行，其他所有非 0 的返回值都表示有错误发生。</p>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和
<code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路
运算符（short-circuiting） 同一行的多个命令可以用 <code>;</code>
分隔。程序 <code>true</code> 的返回码永远是
<code>0</code>，<code>false</code> 的返回码永远是
<code>1</code>。让我们看几个例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false || echo &quot;Oops, fail&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Oops, fail</span></span><br><span class="line"></span><br><span class="line">true || echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true &amp;&amp; echo &quot;Things went well&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Things went well</span></span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">false ; echo &quot;This will always run&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过
命令替换（command substitution）实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code>
这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行
<code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code>
，然后遍历得到的这些返回值。还有一个冷门的类似特性是 进程替换（process
substitution）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code>
并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code>
替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN
传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code>
会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用
<code>grep</code> 搜索字符串
<code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # 如果模式没有找到，则grep退出状态为 1</span><br><span class="line">    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于 0。 Bash
实现了许多类似的比较操作，您可以查看 test 手册。 在 bash
中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号
<code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容
<code>sh</code>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash
使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为
shell 的 通配（globbing）</p>
<p>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code>
和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件
<code>foo</code>, <code>foo1</code>, <code>foo2</code>,
<code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>
这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而
<code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。
花括号 <code>&#123;&#125;</code> -
当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以结合通配使用</span></span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会移动所有 *.py 和 *.sh 文件</span></span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件</span></span><br><span class="line">touch &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; y</span></span><br></pre></td></tr></table></figure>
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 shellcheck
这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p>
<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段
Python 脚本，作用是将输入的参数倒序输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/local/bin/python</span></span><br><span class="line">import sys</span><br><span class="line">for arg in reversed(sys.argv[1:]):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure>
<p>内核知道去用 python 解释器而不是 shell
命令来运行这段脚本，是因为脚本的开头第一行的 shebang。</p>
<p>在 <code>shebang</code> 行中使用 <code>env</code>
命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。env
会利用我们第一节讲座中介绍过的 <code>PATH</code> 环境变量来进行定位。
例如，使用了 <code>env</code> 的 shebang 看上去是这样的
<code>#!/usr/bin/env python</code>。</p>
<p>shell 函数和脚本有如下一些不同点：</p>
<p>函数只能与 shell
使用相同的语言，脚本可以使用任意语言。因此在脚本中包含
<code>shebang</code> 是很重要的。
函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
函数会在当前的 shell
环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用
export 将环境变量导出，并将值传递给环境变量。
与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell
脚本中往往也会包含它们自己的函数定义。</p>
<h3 id="shell-工具">Shell 工具</h3>
<h4 id="查看命令如何使用">查看命令如何使用</h4>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如
<code>ls -l</code>, <code>mv -i</code> 和
<code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？
一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow
出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加
<code>-h</code> 或 <code>--help</code>
标记。另外一个更详细的方法则是使用 <code>man</code>
命令。<code>man</code>
命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code>
的说明，同时还有其标记列表，包括之前我们介绍过的 <code>-i</code>。
事实上，目前我们给出的所有命令的说明链接，都是网页版的 Linux
命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过
<code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。
TLDR pages
是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在 tldr 上搜索 <code>tar</code> 和
<code>ffmpeg</code> 的用法。</p>
<h4 id="查找文件">查找文件</h4>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类 UNIX
系统都包含一个名为 <code>find</code> 的工具，它是 shell
上用于查找文件的绝佳工具。<code>find</code>
命令会递归地搜索符合条件的文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>
<p>除了列出所寻找的文件之外，<code>find</code>
还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>find</code>
用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式
<code>PATTERN</code> 的文件，您需要执行
<code>find -name '*PATTERN*'</code>
(如果您希望模式匹配时是不区分大小写，可以使用 <code>-iname</code>
选项)</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell
的哲学之一便是寻找（更好用的）替代方案。 记住，shell
最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<code>fd</code>
就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code>
的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持
unicode 并且我认为它的语法更符合直觉。以模式 <code>PATTERN</code>
搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code>
已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <code>locate</code> 了。 <code>locate</code> 使用一个由
<code>updatedb</code> 负责更新的数据库，在大多数系统中
<code>updatedb</code> 都会通过 <code>cron</code>
每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code>
和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>
则只能通过文件名。 这里 有一个更详细的对比。</p>
<h4 id="查找代码">查找代码</h4>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类 UNIX 的系统都提供了 <code>grep</code>
命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 shell
工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code>
有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有
<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code>
将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说，
<code>grep -C 5</code>
会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code>
会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code>
进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p>
<p>因此也出现了很多它的替代品，包括 ack, ag 和
rg。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep
(<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>
<p>与 <code>find</code>/<code>fd</code>
一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h4 id="查找-shell-命令">查找 shell 命令</h4>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用 shell
的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问 shell
中输入的历史命令。这个命令会在标准输出中打印 shell
中的历史命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给
<code>grep</code> 进行模式搜索。 <code>history | grep find</code>
会打印包含 find 子串的命令。</p>
<p>对于大多数的 shell 来说，您可以使用 <code>Ctrl+R</code>
对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code>
后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 zsh
中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 fzf 使用。<code>fzf</code>
是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为 基于历史的自动补全。
这一特性最初是由 fish shell
创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前的 shell
命令进行补全。这一功能在 zsh
中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history
的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell
记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。
为此你需要在 <code>.bashrc</code> 中添加
<code>HISTCONTROL=ignorespace</code> 或者向 <code>.zshrc</code> 添加
<code>setopt HIST_IGNORE_SPACE</code>。
如果你不小心忘了在前面加空格，可以通过编辑 <code>.bash_history</code> 或
<code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h4 id="文件夹导航">文件夹导航</h4>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置
alias，使用 ln -s
创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用
fasd 和 autojump 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 frecency
对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，<code>fasd</code>
使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如，
如果您经常访问 <code>/home/user/files/cool_project</code>
目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于
autojump，则使用 <code>j cool</code> 代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <code>tree</code>,
<code>broot</code> 或更加完整的文件管理器，例如 <code>nnn</code> 或
<code>ranger</code>。</p>
<h2 id="编辑器vim">编辑器Vim</h2>
<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的
Word 与 Visual Studio Code）。</p>
<p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p>
<p>阅读教程（比如这节课以及我们为您提供的资源）
坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）
随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有
如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到
20
个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p>
<h3 id="该学哪个编辑器">该学哪个编辑器？</h3>
<p>程序员们对自己正在使用的文本编辑器通常有着 非常强的执念。</p>
<p>现在最流行的编辑器是什么？Stack Overflow
的调查（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow
的用户并不能代表所有程序员）显示，Visual Studio Code
是目前最流行的代码编辑器。而 Vim 则是最流行的基于命令行的编辑器。</p>
<h4 id="vim">Vim</h4>
<p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976
年的 Vi 编辑器，到现在还在 不断开发中。Vim
有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140
万人安装了 Vim emulation for VS code）。即使你最后使用 其他编辑器，Vim
也值得学习。</p>
<p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim
的设计哲学，教你基础知识，
并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p>
<h3 id="vim的哲学">Vim的哲学</h3>
<p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim
是一个 多模态 编辑 器：它对于插入文字和操纵文字有不同的模式。Vim
是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim
的接口本身也是一个程序语言：键入操作（以及其助记名）
是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim
甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h3 id="编辑模式">编辑模式</h3>
<p>Vim
的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<p>正常模式：在文件中四处移动光标进行修改 插入模式：插入文本
替换模式：替换文本 可视化模式（一般，行，块）：选中文本块
命令模式：用于执行命令</p>
<p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code>
在插入模式会插入字母 <code>x</code>，但是在正常模式
会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p>
<p>在默认设置下，Vim 会在左下角显示当前的模式。Vim
启动时的默认模式是正常模式。通常你会把大部分
时间花在正常模式和插入模式。</p>
<p>你可以按下
<code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入
<code>i</code> 进入插入 模式，<code>R</code>
进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code>
进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作
<code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code>
键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键。</p>
<h3 id="基本操作">基本操作</h3>
<h4 id="插入文本">插入文本</h4>
<p>在正常模式，键入 <code>i</code> 进入插入模式。现在 Vim
跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code>
返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim
来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p>
<h4 id="缓存-标签页-窗口">缓存， 标签页， 窗口</h4>
<p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim
会话包含一系列标签页，每个标签页包含
一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是，
缓存和窗口不是一一对应的关系；窗口只是缓冲区的视图。一个缓存可以在 多个
窗口打开，甚至在同一
个标签页内的多个窗口打开。这个功能其实很好用，比如可以查看同一个文件的不同部分。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h4 id="命令行">命令行</h4>
<p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入
<code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。
这个模式有很多功能，包括打开，保存，关闭文件，以及 退出 Vim。</p>
<p><code>:q</code> 退出（关闭窗口） <code>:w</code> 保存（写）
<code>:wq</code> 保存然后退出 <code>:e &#123;文件名&#125;</code> 打开要编辑的文件
<code>:ls</code> 显示打开的缓存 <code>:help &#123;标题&#125;</code> 打开帮助文档
<code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档
<code>:help w</code> 打开 <code>w</code> 移动的帮助文档</p>
<h3 id="vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</h3>
<p>Vim 最重要的设计思想是 Vim
的界面本身是一个程序语言。键入操作（以及他们的助记名）
本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h4 id="移动">移动</h4>
<p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim
里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<p>基本移动: <code>hjkl</code> （左， 下， 上， 右） 词： <code>w</code>
（下一个词）， <code>b</code> （词初）， <code>e</code> （词尾） 行：
<code>0</code> （行初）， <code>^</code> （第一个非空格字符），
<code>$</code> （行尾） 屏幕： <code>H</code> （屏幕首行），
<code>M</code> （屏幕中间）， <code>L</code> （屏幕底部） 翻页：
<code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻） 文件：
<code>gg</code> （文件头）， <code>G</code> （文件尾） 行数：
<code>:&#123;行数&#125;&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code> ({行数}为行数)
杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）
查找： <code>f&#123;字符&#125;</code>， <code>t&#123;字符&#125;</code>，
<code>F&#123;字符&#125;</code>， <code>T&#123;字符&#125;</code> 查找/到 向前/向后
在本行的{字符} <code>,</code> / <code>;</code> 用于导航匹配 搜索:
<code>/&#123;正则表达式&#125;</code>, <code>n</code> / <code>N</code>
用于导航匹配</p>
<h4 id="选择">选择</h4>
<p>可视化模式:</p>
<p>可视化：<code>v</code> 可视化行： <code>V</code>
可视化块：<code>Ctrl+v</code></p>
<p>可以用移动命令来选中。</p>
<h4 id="编辑">编辑</h4>
<p>所有你需要用鼠标做的事，
你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim
的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”，
因为动词可以施动于名词。</p>
<p><code>i</code> 进入插入模式 但是对于操纵/编辑文本，不单想用退格键完成
<code>O</code> / <code>o</code> 在之上/之下插入行
<code>d&#123;移动命令&#125;</code> 删除 {移动命令} 例如，<code>dw</code> 删除词,
<code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。
<code>c&#123;移动命令&#125;</code> 改变 {移动命令} 例如，<code>cw</code> 改变词
比如 <code>d&#123;移动命令&#125;</code> 再 <code>i</code> <code>x</code>
删除字符（等同于 <code>dl</code>） <code>s</code> 替换字符（等同于
<code>xi</code>） 可视化模式 + 操作 选中文字, <code>d</code> 删除 或者
<code>c</code> 改变 <code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做
<code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code>
也会复制） <code>p</code> 粘贴 更多值得学习的: 比如 <code>~</code>
改变字符的大小写</p>
<h4 id="计数">计数</h4>
<p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p>
<p><code>3w</code> 向后移动三个词 <code>5j</code> 向下移动 5 行
<code>7dw</code> 删除 7 个词</p>
<h4 id="修饰语">修饰语</h4>
<p>你可以用修饰语改变“名词”的意义。修饰语有
<code>i</code>，表示“内部”或者“在内”，和 <code>a</code>，
表示“周围”。</p>
<p><code>ci(</code> 改变当前括号内的内容 <code>ci[</code>
改变当前方括号内的内容 <code>da'</code> 删除一个单引号字符串，
包括周围的单引号</p>
<h3 id="演示">演示</h3>
<p>这里是一个有问题的 fizz buzz 实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fizz_buzz(limit):</span><br><span class="line">    for i in range(limit):</span><br><span class="line">        if i % 3 == 0:</span><br><span class="line">            print(&#x27;fizz&#x27;)</span><br><span class="line">        if i % 5 == 0:</span><br><span class="line">            print(&#x27;fizz&#x27;)</span><br><span class="line">        if i % 3 and i % 5:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    fizz_buzz(10)</span><br></pre></td></tr></table></figure>
<p>我们会修复以下问题：</p>
<p>主函数没有被调用 从 0 而不是 1 开始 在 15 的整数倍的时候在不同行打印
“fizz” 和 “buzz” 在 5 的整数倍的时候打印 “fizz” 采用硬编码的参数 10
而不是从命令控制行读取参数</p>
<p>主函数没有被调用 <code>G</code> 文件尾 <code>o</code>
向下打开一个新行 输入 “if name …”</p>
<p>从 0 而不是 1 开始 搜索 <code>/range</code> <code>ww</code>
向后移动两个词 <code>i</code> 插入文字， “1, “ <code>ea</code> 在 limit
后插入， “+1”</p>
<p>在新的一行 “fizzbuzz” <code>jj$i</code> 插入文字到行尾 加入 “,
end=’’” <code>jj.</code> 重复第二个打印 <code>jjo</code> 在 if 打开一行
加入 “else: print()”</p>
<p>fizz fizz <code>ci'</code> 变到 fizz</p>
<p>命令控制行参数 <code>ggO</code> 向上打开 “import sys”
<code>/10</code> <code>ci(</code> to “int(sys.argv[1])”
展示详情请观看课程视频。比较上面用 Vim
的操作和你可能使用其他程序的操作。 值得一提的是 Vim
需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p>
<h3 id="自定义-vim">自定义 Vim</h3>
<p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim
脚本命令）。你可能会启用很多基本 设置。</p>
<p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为它修复了一些
Vim 默认设置奇怪行为。 在 这儿 下载我们的设置，然后将它保存成
~/.vimrc.</p>
<p>Vim
能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在
GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (Anish, Jon (uses
neovim), Jose)。
有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件，
而是阅读和理解它，然后采用对你有用的部分。</p>
<h3 id="扩展-vim">扩展 Vim</h3>
<p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你 不 需要在
Vim 使用一个插件 管理器（从 Vim 8.0
开始）。你可以使用内置的插件管理系统。只需要创建一个
<code>~/.vim/pack/vendor/start/</code>
的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p>
<p>以下是一些我们最爱的插件：</p>
<p>ctrlp.vim: 模糊文件查找 ack.vim: 代码搜索 nerdtree: 文件浏览器
vim-easymotion: 魔术操作</p>
<p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件
(Anish, Jon (使用了 neovim), Jose) 来看看我们使用的其他插件。 浏览 Vim
Awesome 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim
plugins”。</p>
<h3 id="其他程序的-vim-模式">其他程序的 Vim 模式</h3>
<p>很多工具提供了 Vim 模式。这些 Vim
模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim
功能，但是大多数对基本功能支持的很好。</p>
<h4 id="shell">Shell</h4>
<p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用
Zsh：<code>bindkey -v</code>。Fish 用
<code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以
<code>export EDITOR=vim</code>。
这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。
例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p>
<h4 id="readline">Readline</h4>
<p>很多程序使用 GNU Readline 库来作为 它们的命令控制行界面。Readline
也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code>
添加如下行开启：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure>
<p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p>
<h4 id="其他">其他</h4>
<p>甚至有 Vim 的网页浏览快捷键 browsers, 受欢迎的有 用于 Google Chrome
的 Vimium 和用于 Firefox 的 Tridactyl。 你甚至可以在 Jupyter notebooks
中用 Vim 快捷键。 这个列表 中列举了支持类 vim 键位绑定的软件。</p>
<h3 id="vim-进阶">Vim 进阶</h3>
<p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你
可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉
“一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p>
<h4 id="搜索和替换">搜索和替换</h4>
<p><code>:s</code> （替换）命令（文档）。</p>
<p><code>%s/foo/bar/g</code> 在整个文件中将 foo 全局替换成 bar</p>
<p><code>%s/\[.*\](\(.*\))/\1/g</code> 将有命名的 Markdown
链接替换成简单 URLs</p>
<h4 id="多窗口">多窗口</h4>
<p>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口
同一个缓存可以在多个窗口中显示。</p>
<h4 id="宏">宏</h4>
<p><code>q&#123;字符&#125;</code> 来开始在寄存器 <code>&#123;字符&#125;</code> 中录制宏
<code>q</code> 停止录制 <code>@&#123;字符&#125;</code> 重放宏 宏的执行遇错误会停止
<code>&#123;计数&#125;@&#123;字符&#125;</code> 执行一个宏{计数}次 宏可以递归 首先用
<code>q&#123;字符&#125;q</code> 清除宏 录制该宏，用 <code>@&#123;字符&#125;</code>
来递归调用该宏 （在录制完成之前不会有任何操作） 例子：将 xml 转成 json
(file) 一个有 “name” / “email” 键对象的数组 用一个 Python 程序？ 用 sed
/ 正则表达式 <code>g/people/d</code> <code>%s/&lt;person&gt;/&#123;/g</code>
<code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code> … Vim
命令 / 宏 <code>ggdd</code>, <code>Gdd</code> 删除第一行和最后一行
格式化最后一个元素的宏 （寄存器 <code>e</code>） 跳转到有
<code>&lt;name&gt;</code> 的行
<code>qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q</code> 格式化一个
的宏 跳转到有 <code>&lt;person&gt;</code> 的行
<code>qpS&#123;&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS&#125;,&lt;ESC&gt;q</code>
格式化一个 标签然后转到另外一个 的宏 跳转到有
<code>&lt;person&gt;</code> 的行 <code>qq@pjq</code> 执行宏到文件尾
<code>999@q</code> 手动移除最后的 , 然后加上 <code>[</code> 和
<code>]</code> 分隔符</p>
<h2 id="数据整理">数据整理</h2>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式?
肯定有过，对吧！
这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令
<code>journalctl | grep -i intel</code>，它会找到所有包含
intel（不区分大小写）的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含
intel
的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br></pre></td></tr></table></figure>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl | grep sshd</span><br></pre></td></tr></table></figure>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的
<code>grep</code> 程序！ <code>ssh</code>
太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论
<code>ssh</code>
的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver &#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27; | less</span><br></pre></td></tr></table></figure>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。
<code>less</code>
为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh myserver <span class="string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> &gt; ssh.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ssh.log</span></span><br></pre></td></tr></table></figure>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下
<code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器 <code>ed</code> 构建的
“流编辑器” 。在 <code>sed</code>
中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是
<code>s</code>，即 替换 命令，例如我们可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed &#x27;s/.*Disconnected from //&#x27;</span><br></pre></td></tr></table></figure>
<p>上面这段命令中，我们使用了一段简单的
正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code>
命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中
<code>REGEX</code> 部分是我们需要使用的正则表达式，而
<code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习：
<code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是）
<code>/</code> 开始和结束。大多数的 ASCII
字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<p><code>.</code> 除换行符之外的 “任意单个字符” <code>*</code>
匹配前面字符零次或多次 <code>+</code> 匹配前面字符一次或多次
<code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code>
中的任意一个 <code>(RX1|RX2)</code> 任何能够匹配 <code>RX1</code> 或
<code>RX2</code> 的结果 <code>^</code> 行首 <code>$</code> 行尾</p>
<p><code>sed</code>
的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加
<code>\</code> 才能使其具有特殊含义。或者，您也可以添加 <code>-E</code>
选项来支持这些匹配。</p>
<p>回过头我们再看
<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含
“Disconnected from”
的字符串。这也正是我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将
“Disconnected from” 作为自己的用户名会怎样呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code>
在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给
<code>*</code> 或 <code>+</code> 增加一个 <code>?</code>
后缀使其变成非贪婪模式，但是很可惜 <code>sed</code>
并不支持该后缀。不过，我们可以切换到 perl
的命令行模式，该模式支持编写这样的正则表达式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s/.*?Disconnected from //&#x27;</span><br></pre></td></tr></table></figure>
<p>让我们回到 <code>sed</code>
命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>
是最常见的工具。<code>sed</code>
还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code>
本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配
一整行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//&#x27;</span><br></pre></td></tr></table></figure>
<p>让我们借助正则表达式在线调试工具 regex debugger
来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code>
会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀
<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected
from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名
保留 下来。对此，我们可以使用“捕获组（capture
groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如
<code>\1</code>、 <code>\2</code>、<code>\3</code>
等等，因此可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></pre></td></tr></table></figure>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章
e-mail address，匹配电子邮箱可一点
也不简单。网络上还有很多关于如何匹配电子邮箱地址的
讨论。人们还为其编写了 测试用例 及
测试矩阵。您甚至可以编写一个用于判断一个数 是否为质数 的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h3 id="回到数据整理">回到数据整理</h3>
<p>OK，现在我们有如下表达式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></pre></td></tr></table></figure>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用
<code>i</code> 命令)，打印特定的行 (使用 <code>p</code>
命令)，基于索引选择特定行等等。详情请见 <code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br></pre></td></tr></table></figure>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code>
会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br></pre></td></tr></table></figure>
<p><code>sort -n</code>
会按照数字顺序对输入进行排序（默认情况下是按照字典序排序
<code>-k1,1</code>
则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code>
部分表示“仅排序到第 n
个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code>
来代替 <code>tail</code>。或者使用 <code>sort -r</code>
来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | awk &#x27;&#123;print $2&#125;&#x27; | paste -sd,</span><br></pre></td></tr></table></figure>
<p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD
<code>paste</code> 使用。</p>
<p>我们可以利用 <code>paste</code>
命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割
(<code>-d</code>)，那 <code>awk</code> 的作用又是什么呢？</p>
<h3 id="awk-另外一种编辑器">awk – 另外一种编辑器</h3>
<p><code>awk</code>
其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code>
可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code>
程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。
在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到
<code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code>
的域分隔符（默认是空格，可以通过 <code>-F</code>
来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以
<code>c</code> 开头，以 <code>e</code>
结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>
指定了一个匹配模式串（也就是 <code>&#123;...&#125;</code>
前面的那部分内容）。该匹配要求文本的第一部分需要等于 1（这部分刚好是
<code>uniq -c</code>
得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用
<code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 == 1 &amp;&amp; <span class="variable">$2</span> ~ /^c[^ ]*e$/ &#123; rows += <span class="variable">$1</span> &#125;</span></span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（
<code>END</code>
则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃
<code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以
解决所有问题。至于怎么做，就留给读者们做课后练习吧。</p>
<h3 id="分析数据">分析数据</h3>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| paste -sd+ | bc -l</span><br></pre></td></tr></table></figure>
<p>下面这种更加复杂的表达式也可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;2*($(data | paste -sd+))&quot; | bc -l</span><br></pre></td></tr></table></figure>
<p>您可以通过多种方式获取统计数据。如果已经安装了 R
语言，<code>st</code> 是个不错的选择：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | awk &#x27;&#123;print $1&#125;&#x27; | R --slave -e &#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span><br></pre></td></tr></table></figure>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和
绘制图表。这里我们不会讲的特别详细， 您只需要知道 <code>summary</code>
可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用
R 语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code>
可以帮助到您：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | gnuplot -p -e &#x27;set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="利用数据整理来确定参数">利用数据整理来确定参数</h3>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合
<code>xargs</code> 即可实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#x27;s/-x86.*//&#x27; | xargs rustup toolchain uninstall</span><br></pre></td></tr></table></figure>
<h3 id="整理二进制数据">整理二进制数据</h3>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用
ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过 SSH
将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -</span><br><span class="line"> | convert - -colorspace gray -</span><br><span class="line"> | gzip</span><br><span class="line"> | ssh mymachine &#x27;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="命令行环境">命令行环境</h2>
<p>当您使用 shell
进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p>
<p>我们已经使用 shell
一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p>
<p>我们还将学习一些能够改善您的 shell
及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用
SSH 操作远端机器。</p>
<h3 id="任务控制">任务控制</h3>
<p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用
<code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用
<code>Ctrl-C</code>
来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p>
<h4 id="结束进程">结束进程</h4>
<p>您的 shell 会使用 UNIX
提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种
软件中断。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个
<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号 <code>SIGINT</code>
并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用
<code>SIGQUIT</code> 信号，通过输入 <code>Ctrl-\</code>
可以发送该信号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line">import signal, time</span><br><span class="line"></span><br><span class="line">def handler(signum, time):</span><br><span class="line">    print(&quot;\nI got a SIGINT, but I am not stopping&quot;)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    time.sleep(.1)</span><br><span class="line">    print(&quot;\r&#123;&#125;&quot;.format(i), end=&quot;&quot;)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>
<p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次
<code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code>
是我们在终端输入 <code>Ctrl</code> 时的表示形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python sigint.py</span></span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></table></figure>
<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code>
都常常用来发出和终止程序相关的请求。<code>SIGTERM</code>
则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用
<code>kill</code> 命令, 它的语法是：
<code>kill -TERM &lt;PID&gt;</code>。</p>
<h4 id="暂停和后台执行进程">暂停和后台执行进程</h4>
<p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code>
会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送
<code>SIGTSTP</code> 信号，<code>SIGTSTP</code> 是 Terminal Stop
的缩写（即 <code>terminal</code> 版本的 SIGSTOP）。</p>
<p>我们可以使用 <code>fg</code> 或 <code>bg</code>
命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><code>jobs</code>
命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid
引用这些任务（也可以用 <code>pgrep</code> 找出
pid）。更加符合直觉的操作是您可以使用百分号 +
任务编号（<code>jobs</code>
会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用
<code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code>
后缀可以让命令在直接在后台运行，这使得您可以直接在 shell
中继续做其他操作，不过它此时还是会使用 shell
的标准输出，这一点有时会比较恼人（这种情况可以使用 shell
重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入 <code>Ctrl-Z</code>
，然后紧接着再输入
<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号
<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用
<code>nohup</code>（一个用来忽略 <code>SIGHUP</code>
的封装）来运行程序。针对已经运行的程序，可以使用 <code>disown</code>
。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>
<p>下面这个简单的会话中展示来了些概念的应用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 1000</span></span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> <span class="built_in">sleep</span> 2000 &amp;</span></span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">bg</span> %1</span></span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -STOP %1</span></span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %1</span></span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %2</span></span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br></pre></td></tr></table></figure>
<p><code>SIGKILL</code>
是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<p>您可以输入 <code>man signal</code> 或使用 <code>kill -l</code>
来获取更多关于信号的信息。</p>
<h3 id="终端多路复用">终端多路复用</h3>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <code>tmux</code>
这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个
shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code>
和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <code>tmux</code>。<code>tmux</code>
是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似
<code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下
<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code>
中对象的继承结构如下：</p>
<p>会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口</p>
<p><code>tmux</code> 开始一个新的会话 <code>tmux new -s NAME</code>
以指定名称开始一个新的会话 <code>tmux ls</code> 列出当前所有会话 在
<code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离
<code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code>
来指定具体的会话</p>
<p>窗口 -
相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分</p>
<p><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用
<code>&lt;C-d&gt;</code> 关闭 <code>&lt;C-b&gt; N</code> 跳转到第 N
个窗口，注意每个窗口都是有编号的 <code>&lt;C-b&gt; p</code>
切换到前一个窗口 <code>&lt;C-b&gt; n</code> 切换到下一个窗口
<code>&lt;C-b&gt; ,</code> 重命名当前窗口 <code>&lt;C-b&gt; w</code>
列出当前所有窗口</p>
<p>面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个
shell</p>
<p><code>&lt;C-b&gt; "</code> 水平分割 <code>&lt;C-b&gt; %</code>
垂直分割 <code>&lt;C-b&gt; &lt;方向&gt;</code>
切换到指定方向的面板，<方向> 指的是键盘上的方向键
<code>&lt;C-b&gt; z</code> 切换当前面板的缩放 <code>&lt;C-b&gt; [</code>
开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分
<code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</p>
<h3 id="别名">别名</h3>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell
都支持设置别名。shell 的别名相当于一个长命令的缩写，shell
会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>
<p>注意， <code>=</code> 两边是没有空格的，因为 <code>alias</code>
是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建常用命令的缩写</span></span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">能够少输入很多</span></span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手误打错命令也没关系</span></span><br><span class="line">alias sl=ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新定义一些命令行的默认行为</span></span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">别名可以组合使用</span></span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在忽略某个别名</span></span><br><span class="line">\ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者禁用别名</span></span><br><span class="line">unalias la</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取别名的定义</span></span><br><span class="line">alias ll</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会打印 ll=<span class="string">&#x27;ls -lh&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在默认情况下 shell
并不会保存别名。为了让别名持续生效，您需要将配置放进 shell
的启动文件里，像是 <code>.bashrc</code> 或
<code>.zshrc</code>，下一节我们就会讲到。</p>
<h3 id="配置文件dotfiles">配置文件（Dotfiles）</h3>
<p>很多程序的配置都是通过纯文本格式的被称作 点文件
的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 . 开头，例如
<code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>
并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell
程序会读取很多文件以加载其配置项。根据 shell
本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。</p>
<p>对于 <code>bash</code> 来说，在大多数系统下，您可以通过编辑
<code>.bashrc</code> 或 <code>.bash_profile</code>
来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似
<code>export PATH="$PATH:/path/to/program/bin"</code>
的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过 点文件 进行配置：</p>
<p><code>bash</code> - <code>~/.bashrc, ~/.bash_profile</code>
<code>git</code> - <code>~/.gitconfig</code> <code>vim</code> -
<code>~/.vimrc</code> 和 <code>~/.vim</code> 目录 <code>ssh</code> -
<code>~/.ssh/config</code> <code>tmux</code> -
<code>~/.tmux.conf</code></p>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其
符号链接 到需要的地方。这么做有如下好处：</p>
<p>安装简单:
如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；
可移植性: 您的工具在任何地方都以相同的配置工作 同步:
在一处更新配置文件，可以同步到其他所有地方 变更追踪:
您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的
配置文件中需要放些什么？您可以通过在线文档和 帮助手册
了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的
dotfiles 仓库 —— 其中最受欢迎的那些可以在 这里
找到（我们建议您不要直接复制别人的配置）。这里
也有一些非常有用的资源。</p>
<p>本课程的老师们也在 GitHub 上开源了他们的配置文件： Anish, Jon,
Jose.</p>
<h4 id="可移植性">可移植性</h4>
<p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者
shell
是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if
语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell
可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用和 shell 相关的配置时先检查当前 shell 类型</span></span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">您也可以针对特定的设备进行配置</span></span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>
<p>如果配置文件支持 include
功能，您也可以多加利用。例如：<code>~/.gitconfig</code>
可以这样编写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>
<p>然后我们可以在日常使用的设备上创建配置文件
<code>~/.gitconfig_local</code>
来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在
<code>bash</code> 和 <code>zsh</code>
中同时启用一些别名，您可以把它们写在 <code>.aliases</code>
里，然后在这两个 shell 里应用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test <span class="keyword">if</span> ~/.aliases exists and <span class="built_in">source</span> it</span></span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="远端设备">远端设备</h3>
<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全
shell（SSH）。和其他工具一样，SSH
也是可以高度定制的，也值得我们花时间学习它。</p>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器
<code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如
<code>bar.mit.edu</code>），也可以使用 IP 指定（例如
<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh
配置文件使我们可以用类似 <code>ssh bar</code>
这样的命令来登录服务器。</p>
<h4 id="执行命令">执行命令</h4>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。
<code>ssh foobar@server ls</code> 可以直接在用 foobar 的命令下执行
<code>ls</code> 命令。 想要配合管道来使用也可以，
<code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端
<code>ls</code> 的输出而
<code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地
<code>ls</code> 输出的结果进行查询。</p>
<h4 id="ssh-密钥">SSH 密钥</h4>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是
<code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>)
等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成">密钥生成</h4>
<p>使用 <code>ssh-keygen</code> 命令可以生成一对密钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用
<code>ssh-agent</code> 或 <code>gpg-agent</code>
，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了 这里
介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行
<code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制">基于密钥的认证机制</h4>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code>
来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh/id_ed25519.pub | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>
<p>如果支持 <code>ssh-copy-id</code>
的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>
<h4 id="通过-ssh-复制文件">通过 SSH 复制文件</h4>
<p>使用 ssh 复制文件有很多方法：</p>
<p><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code>
命令，然后通过这样的方法利用标准输入实现
<code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<code>tee</code>
命令会将标准输出写入到一个文件； <code>scp</code>
：当需要拷贝大量的文件或目录时，使用 <code>scp</code>
命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；
<code>rsync</code> 对 <code>scp</code>
进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于
<code>--partial</code> 标记实现断点续传。<code>rsync</code> 的语法和
<code>scp</code> 类似；</p>
<h4 id="端口转发">端口转发</h4>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用
<code>localhost:PORT</code> 或
<code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行
端口转发。端口转发有两种，一种是本地端口转发和远程端口转发</p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行
Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口
<code>9999</code> 的转发，使用
<code>ssh -L 9999:localhost:8888 foobar@remote_server</code>
。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h4 id="ssh-配置">SSH 配置</h4>
<p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span><br></pre></td></tr></table></figure>
<p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在配置文件中也可以使用通配符</span></span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></table></figure>
<p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似
<code>scp</code>、<code>rsync</code> 和 <code>mosh</code>
的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p>
<p>注意，<code>~/.ssh/config</code>
文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p>
<p>服务器侧的配置通常放在
<code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh
端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p>
<h4 id="杂项">杂项</h4>
<p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。Mosh（即
mobile shell ）对 ssh
进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p>
<p>有时将一个远端文件夹挂载到本地会比较方便， sshfs
可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p>
<h3 id="shell-框架">Shell &amp; 框架</h3>
<p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code>
shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认
shell。但是，它并不是唯一的选项。</p>
<p>例如，<code>zsh</code> shell 是 bash
的超集并提供了一些方便的功能：</p>
<p>智能替换, <code>**</code> 行内替换/通配符扩展 拼写纠错 更好的 tab
补全和选择 路径展开 (<code>cd /u/lo/b</code> 会被展开为
<code>/usr/local/bin</code>)</p>
<p>框架 也可以改进您的 shell。比较流行的通用框架包括 prezto 或
oh-my-zsh。还有一些更精简的框架，它们往往专注于某一个特定功能，例如 zsh
语法高亮 或 zsh 历史子串查询。 像 fish 这样的 shell
包含了很多用户友好的功能，其中一些特性包括：</p>
<p>向右对齐 命令语法高亮 历史子串查询 基于手册页面的选项补全
更智能的自动补全 提示符主题</p>
<p>需要注意的是，使用这些框架可能会降低您 shell
的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p>
<h3 id="终端模拟器">终端模拟器</h3>
<p>和自定义 shell 一样，花点时间选择适合您的 终端模拟器
并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间
比较 的信息）</p>
<p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p>
<p>字体选择 彩色主题 快捷键 标签页/面板支持 回退配置 性能（像 Alacritty
或者 kitty 这种比较新的终端，它们支持 GPU 加速）。</p>
<h2 id="版本控制git">版本控制(Git)</h2>
<p>版本控制系统 (VCSs)
是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS
通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了顶级目录中所有的文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p>
<p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p>
<p>当前模块是谁编写的？
这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？
最近的 1000 个版本中，何时/为什么导致了单元测试失败？
尽管版本控制系统有很多， 其事实上的标准则是 Git 。</p>
<p>因为 Git 接口的抽象泄漏（leaky
abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git
可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p>
<p>尽管 Git
的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍
Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git
的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p>
<h3 id="git-的数据模型">Git 的数据模型</h3>
<p>进行版本控制的方法很多。Git
拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h4 id="快照">快照</h4>
<p>Git
将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在
Git 的术语里，文件被称作 Blob
对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob
对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure>
<p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个
blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h4 id="历史记录建模关联快照">历史记录建模：关联快照</h4>
<p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过出于种种原因，Git
并没有采用这样的模型。</p>
<p>在 Git
中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表
Git
中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
<p>在 Git
中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^</span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>
<p>上面是一个 ASCII 码构成的简图，其中的 o 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;----  o </span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>
<p>Git
中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h4 id="数据模型及其伪代码表示">数据模型及其伪代码表示</h4>
<p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parents: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种简洁的历史模型。</p>
<h4 id="对象和内存寻址">对象和内存寻址</h4>
<p>Git 中的对象可以是 blob、树或提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure>
<p>Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure>
<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，上面 例子中的树（可以通过
<code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>
来进行可视化），看上去是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure>
<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt (blob)</code>
和 <code>foo</code> (树)。如果我们用
<code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看
baz.txt 的内容，会得到以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure>
<h4 id="引用">引用</h4>
<p>现在，所有的快照都可以通过它们的 SHA-1
哈希值来标记了。但这也太不方便了，谁也记不住一串 40
位的十六进制字符。</p>
<p>针对这一问题，Git
的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code>
引用通常会指向主分支的最新一次提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></table></figure>
<p>这样，Git 就可以使用诸如 “master”
这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意，
通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在
Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h4 id="仓库">仓库</h4>
<p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和
<code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的
<code>git</code>
命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将
‘master’ 引用指向提交 <code>5d83f9e</code>
时，有什么命令可以完成该操作（针对这个具体问题，您可以使用
<code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h3 id="暂存区">暂存区</h3>
<p>Git
中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照”
的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但
Git
不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复
bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging
area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h3 id="git-的命令行接口">Git 的命令行接口</h3>
<p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 Pro
Git 中文版 或可以观看本讲座的视频来学习。</p>
<h4 id="基础">基础</h4>
<p><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息
<code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为
<code>.git</code> 的目录下 <code>git status</code>: 显示当前的仓库状态
<code>git add &lt;filename&gt;</code>: 添加文件到暂存区
<code>git commit</code>: 创建一个新的提交 如何编写 良好的提交信息!
为何要 编写良好的提交信息 <code>git log</code>: 显示历史日志
<code>git log --all --graph --decorate</code>:
可视化历史记录（有向无环图） <code>git diff &lt;filename&gt;</code>:
显示与暂存区文件的差异
<code>git diff &lt;revision&gt; &lt;filename&gt;</code>:
显示某个文件两个版本之间的差异
<code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</p>
<h4 id="分支和合并">分支和合并</h4>
<p><code>git branch</code>: 显示分支
<code>git branch &lt;name&gt;</code>: 创建分支
<code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支 相当于
<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code>
<code>git merge &lt;revision&gt;</code>: 合并到当前分支
<code>git mergetool</code>: 使用工具来处理合并冲突
<code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</p>
<h4 id="远端操作">远端操作</h4>
<p><code>git remote</code>: 列出远端
<code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端
<code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:
将对象传送至远端并更新远端引用
<code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:
创建本地和远端分支的关联关系 <code>git fetch</code>: 从远端获取对象/索引
<code>git pull</code>: 相当于 <code>git fetch; git merge</code>
<code>git clone</code>: 从远端下载仓库</p>
<h4 id="撤销">撤销</h4>
<p><code>git commit --amend</code>: 编辑提交的内容或信息
<code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件
<code>git checkout -- &lt;file&gt;</code>: 丢弃修改
<code>git restore</code>: git2.32 版本后取代 git reset
进行许多撤销操作</p>
<h3 id="git-高级操作">Git 高级操作</h3>
<p><code>git config</code>: Git 是一个 高度可定制的 工具
<code>git clone --depth=1</code>: 浅克隆（shallow
clone），不包括完整的版本历史信息 <code>git add -p</code>: 交互式暂存
<code>git rebase -i</code>: 交互式变基 <code>git blame</code>:
查看最后修改某行的人 <code>git stash</code>:
暂时移除工作目录下的修改内容 <code>git bisect</code>:
通过二分查找搜索历史记录 <code>.gitignore</code>: 指定
故意不追踪的文件</p>
<h3 id="杂项-1">杂项</h3>
<p>图形用户界面: Git 的 图形用户界面客户端
有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口
Shell 集成: 将 Git 状态集成到您的 shell 中会非常方便。(zsh, bash)。Oh My
Zsh 这样的框架中一般已经集成了这一功能 编辑器集成: 和上面一条类似，将
Git 集成到编辑器中好处多多。fugitive.vim 是 Vim 中集成 Git 的常用插件
工作流:
我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例
( 有 很多 不同的 处理方法) GitHub: Git 并不等同于 GitHub。 在 GitHub
中您需要使用一个被称作 拉取请求（pull request）
的方法来向其他项目贡献代码 其他 Git 提供商: GitHub 并不是唯一的。还有像
GitLab 和 BitBucket 这样的平台。</p>
<h2 id="调试及性能分析">调试及性能分析</h2>
<p>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。</p>
<p>让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的
bug 和程序性能问题。</p>
<h3 id="调试代码">调试代码</h3>
<h4 id="打印调试法与日志">打印调试法与日志</h4>
<p>“最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian
Kernighan, Unix 新手入门。</p>
<p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p>
<p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p>
<p>您可以将日志写入文件、socket
或者甚至是发送到远端服务器而不仅仅是标准输出；
日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR
等），这使您可以根据需要过滤日志；
对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。
这里 是一个包含日志的例程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Raw output as with just prints</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py <span class="built_in">log</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log formatted output</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py <span class="built_in">log</span> ERROR</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Print only ERROR levels and above</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py color</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Color formatted output</span></span><br></pre></td></tr></table></figure>
<p>有很多技巧可以使日志的可读性变得更好，我最喜欢的一个是技巧是对其进行着色。到目前为止，您应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p>
<p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 ANSI escape
codes，它是一系列的特殊字符，可以使您的 shell
改变输出结果的颜色。例如，执行
<code>echo -e "\e[38;2;255;0;0mThis is red\e[0m"</code>
会打印红色的字符串：<code>This is red</code> 。只要您的终端支持
真彩色。如果您的终端不支持真彩色（例如 MacOS 的
Terminal.app），您可以使用支持更加广泛的 16
色，例如：<code>”\e[31; 1mThis is red\e[0m “</code>。</p>
<p>下面这个脚本向您展示了如何在终端中打印多种颜色（只要您的终端支持真彩色）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line">for R in $(seq 0 20 255); do</span><br><span class="line">    for G in $(seq 0 20 255); do</span><br><span class="line">        for B in $(seq 0 20 255); do</span><br><span class="line">            printf &quot;\e[38;2;$&#123;R&#125;;$&#123;G&#125;;$&#123;B&#125;m█\e[0m&quot;;</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="第三方日志系统">第三方日志系统</h4>
<p>如果您正在构建大型软件系统，您很可能会使用到一些依赖，有些依赖会作为程序单独运行。如
Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p>
<p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p>
<p>幸运的是，大多数的程序都会将日志保存在您的系统中的某个地方。对于 UNIX
系统来说，程序的日志通常存放在 <code>/var/log</code>。例如， NGINX web
服务器就将其日志存放于 <code>/var/log/nginx</code>。</p>
<p>目前，系统开始使用 system
log，您所有的日志都会保存在这里。大多数（但不是全部的）Linux
系统都会使用
<code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code>
会将日志以某种特殊格式存放于 <code>/var/log/journal</code>，您可以使用
<code>journalctl</code> 命令显示这些消息。</p>
<p>类似地，在 macOS 系统中是
<code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用
<code>log show</code> 显示。</p>
<p>对于大多数的 UNIX 系统，您也可以使用 <code>dmesg</code>
命令来读取内核的日志。</p>
<p>如果您希望将日志加入到系统日志中，您可以使用 <code>logger</code> 这个
shell 程序。下面这个例子显示了如何使用 <code>logger</code>
并且如何找到能够将其存入系统日志的条目。</p>
<p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger &quot;Hello Logs&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On macOS</span></span><br><span class="line">log show --last 1m | grep Hello</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On Linux</span></span><br><span class="line">journalctl --since &quot;1m ago&quot; | grep Hello</span><br></pre></td></tr></table></figure>
<p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p>
<p>如果您发现您需要对 <code>journalctl</code> 和 <code>log show</code>
的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像
<code>lnav</code>
这样的工具，它为日志文件提供了更好的展现和浏览方式。</p>
<h4 id="调试器">调试器</h4>
<p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p>
<p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p>
<p>当到达某一行时将程序暂停； 一次一条指令地逐步执行程序；
程序崩溃后查看变量的值； 满足特定条件时暂停程序； 其他高级功能。</p>
<p>很多编程语言都有自己的调试器。Python 的调试器是 <code>pdb</code>.</p>
<p>下面对 <code>pdb</code> 支持的命令进行简单的介绍：</p>
<p>l(ist) - 显示当前行附近的 11 行或继续执行之前的显示； s(tep) -
执行当前行，并在第一个可能的地方停止； n(ext) -
继续执行直到当前函数的下一条语句或者 return 语句； b(reak) -
设置断点（基于传入的参数）； p(rint) -
在当前上下文对表达式求值并打印结果。还有一个命令是 pp ，它使用
<code>pprint</code> 打印； r(eturn) - 继续执行直到当前函数返回； q(uit)
- 退出调试器。</p>
<p>让我们使用 <code>pdb</code> 来修复下面的 Python
代码（参考讲座视频）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(arr):</span><br><span class="line">    n = len(arr)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if arr[j] &gt; arr[j+1]:</span><br><span class="line">                arr[j] = arr[j+1]</span><br><span class="line">                arr[j+1] = arr[j]</span><br><span class="line">    return arr</span><br><span class="line"></span><br><span class="line">print(bubble_sort([4, 2, 1, 8, 7, 6]))</span><br></pre></td></tr></table></figure>
<p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code>
shell 执行命令。 <code>ipdb</code> 是一种增强型的 <code>pdb</code>
，它使用 <code>IPython</code> 作为 REPL 并开启了 tab
补全、语法高亮、更好的回溯和更好的内省，同时还保留了 <code>pdb</code>
模块相同的接口。</p>
<p>对于更底层的编程语言，您可能需要了解一下 <code>gdb</code> (
以及它的改进版 <code>pwndbg</code>) 和 <code>lldb</code>。</p>
<p>它们都对类 C
语言的调试进行了优化，它允许您探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p>
<h4 id="专门工具">专门工具</h4>
<p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用
系统调用。有一些命令可以帮助您追踪您的程序执行的系统调用。在 Linux
中可以使用 <code>strace</code> ，在 macOS 和 BSD 中可以使用
<code>dtrace</code>。<code>dtrace</code>
用起来可能有些别扭，因为它使用的是它自有的 D
语言，但是我们可以使用一个叫做 <code>dtruss</code> 的封装使其具有和
<code>strace</code> 类似的接口</p>
<p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code>
来显示 <code>ls</code> 执行时，对 <code>stat</code>
系统调用进行追踪对结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On Linux</span></span><br><span class="line">sudo strace -e lstat ls -l &gt; /dev/null</span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On macOS</span></span><br><span class="line">sudo dtruss -t lstat64_extended ls -l &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>有些情况下，我们需要查看网络数据包才能定位问题。像
<code>tcpdump</code> 和 Wireshark
这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。</p>
<p>对于 web 开发， Chrome/Firefox
的开发者工具非常方便，功能也很强大：</p>
<p>源码 -查看任意站点的 HTML/CSS/JS 源码； 实时地修改 HTML, CSS, JS 代码
-
修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）；
Javascript shell - 在 JS REPL 中执行命令； 网络 - 分析请求的时间线；
存储 - 查看 Cookies 和本地应用存储。</p>
<h4 id="静态分析">静态分析</h4>
<p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。
这种情况下 静态分析
工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p>
<p>下面这段 Python 代码中存在几个问题。 首先，我们的循环变量
<code>foo</code> 覆盖了之前定义的函数
<code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了
<code>baz</code>，因此当程序完成 <code>sleep</code>
(一分钟)后，执行到这一行的时候便会崩溃。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> foo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(foo)</span><br><span class="line">bar = <span class="number">1</span></span><br><span class="line">bar *= <span class="number">0.2</span></span><br><span class="line">time.sleep(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(baz)</span><br></pre></td></tr></table></figure>
<p>静态分析工具可以发现此类的问题。当我们使用 <code>pyflakes</code>
分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<code>mypy</code>
则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code>
会经过我们 <code>bar</code> 起初是一个 <code>int</code> ，然后变成了
<code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyflakes foobar.py</span></span><br><span class="line">foobar.py:6: redefinition of unused &#x27;foo&#x27; from line 3</span><br><span class="line">foobar.py:11: undefined name &#x27;baz&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mypy foobar.py</span></span><br><span class="line">foobar.py:6: error: Incompatible types in assignment (expression has type &quot;int&quot;, variable has type &quot;Callable[[], Any]&quot;)</span><br><span class="line">foobar.py:9: error: Incompatible types in assignment (expression has type &quot;float&quot;, variable has type &quot;int&quot;)</span><br><span class="line">foobar.py:11: error: Name &#x27;baz&#x27; is not defined</span><br><span class="line">Found 3 errors in 1 file (checked 1 source file)</span><br></pre></td></tr></table></figure>
<p>在 shell 工具那一节课的时候，我们介绍了
<code>shellcheck</code>，这是一个类似的工具，但它是应用于 shell
脚本的。</p>
<p>大多数的编辑器和 IDE
都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。
这个过程通常称为 code linting
。风格检查或安全检查的结果同样也可以进行相应的显示。</p>
<p>在 vim 中，有 <code>ale</code> 或 <code>syntastic</code>
可以帮助您做同样的事情。 在 Python 中， <code>pylint</code> 和
<code>pep8</code> 是两种用于进行风格检查的工具，而 <code>bandit</code>
工具则用于检查安全相关的问题。</p>
<p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：Awesome
Static Analysis (您也许会对 Writing 一节感兴趣) 。对于 linters
则可以参考这个列表： Awesome Linters。</p>
<p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python
的 <code>black</code>、用于 Go 语言的 <code>gofmt</code>、用于 Rust 的
<code>rustfmt</code> 或是用于 JavaScript, HTML 和 CSS 的
<code>prettier</code>
。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。
尽管您可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读您的代码，也可以方便您阅读它的代码。</p>
<h3 id="性能分析">性能分析</h3>
<p>即使您的代码能够像您期望的一样运行，但是如果它消耗了您全部的 CPU
和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大 O
标记法，但却没教给我们如何找到程序中的热点。 鉴于
过早的优化是万恶之源，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。</p>
<h4 id="计时">计时</h4>
<p>和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了
Python 的 <code>time</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure>
<p>不过，执行时间（wall clock
time）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。
对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间 +
系统时间代表了您的进程所消耗的实际 CPU （更详细的解释可以参照
这篇文章）。</p>
<p>真实时间 Real -
从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待
I/O 或网络）； 用户时间 User - CPU 执行用户代码所花费的时间； 系统时间
Sys - CPU 执行系统内核代码所花费的时间。</p>
<p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加
<code>time</code>
前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 2s
多才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU
内核时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> curl https://missing.csail.mit.edu &amp;&gt; /dev/null</span></span><br><span class="line">real    0m2.561s</span><br><span class="line">user    0m0.015s</span><br><span class="line">sys     0m0.012s</span><br></pre></td></tr></table></figure>
<h4 id="性能分析工具profilers">性能分析工具（profilers）</h4>
<h5 id="cpu">CPU</h5>
<p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU
性能分析工具。 CPU 性能分析工具有两种：
追踪分析器（tracing）及采样分析器（sampling）。 追踪分析器
会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考
这篇 介绍性的文章。</p>
<p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在
IDE 中，但是本节课我们会专注于这些命令行工具本身。</p>
<p>在 Python 中，我们使用 <code>cProfile</code>
模块来分析每次函数调用所消耗的时间。
在下面的例子中，我们实现了一个基础的 <code>grep</code> 命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern, file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(file)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f.readlines()):</span><br><span class="line">            pattern = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">            <span class="keyword">match</span> = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, line), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    times = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    pattern = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">            grep(pattern, file)</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO
消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到
for 循环外面来改进性能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -m cProfile -s tottime grep.py 1000 <span class="string">&#x27;^(import|\s*def)[^,]*$&#x27;</span> *.py</span></span><br><span class="line"></span><br><span class="line">[omitted program output]</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">   8000    0.266    0.000    0.292    0.000 &#123;built-in method io.open&#125;</span><br><span class="line">   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)</span><br><span class="line">  17000    0.101    0.000    0.101    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">   8000    0.100    0.000    0.129    0.000 &#123;method &#x27;readlines&#x27; of &#x27;_io._IOBase&#x27; objects&#125;</span><br><span class="line">  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)</span><br><span class="line">  93000    0.069    0.000    0.069    0.000 &#123;method &#x27;search&#x27; of &#x27;_sre.SRE_Pattern&#x27; objects&#125;</span><br><span class="line">  93000    0.030    0.000    0.141    0.000 re.py:231(compile)</span><br><span class="line">  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)</span><br><span class="line">      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)</span><br><span class="line"></span><br><span class="line">[omitted lines]</span><br></pre></td></tr></table></figure>
<p>关于 Python 的 <code>cProfile</code>
分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p>
<p>更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是
行分析器 的工作。例如，下面这段 Python
代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部
URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个装饰器会告诉行分析器 </span></span><br><span class="line"><span class="comment"># 我们想要分析这个函数</span></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_urls</span>():</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line">    s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_urls()</span><br></pre></td></tr></table></figure>
<p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过
2500
行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用
<code>line_profiler</code>，它会基于行来显示时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kernprof -l -v a.py</span></span><br><span class="line">Wrote profile results to urls.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 0.636188 s</span><br><span class="line">File: a.py</span><br><span class="line">Function: get_urls at line 5</span><br><span class="line"></span><br><span class="line">Line #  Hits         Time  Per Hit   % Time  Line Contents</span><br><span class="line">==============================================================</span><br><span class="line"> 5                                           @profile</span><br><span class="line"> 6                                           def get_urls():</span><br><span class="line"> 7         1     613909.0 613909.0     96.5      response = requests.get(&#x27;https://missing.csail.mit.edu&#x27;)</span><br><span class="line"> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, &#x27;lxml&#x27;)</span><br><span class="line"> 9         1          2.0      2.0      0.0      urls = []</span><br><span class="line">10        25        685.0     27.4      0.1      for url in s.find_all(&#x27;a&#x27;):</span><br><span class="line">11        24         33.0      1.4      0.0          urls.append(url[&#x27;href&#x27;])</span><br></pre></td></tr></table></figure>
<h5 id="内存">内存</h5>
<p>像 C 或者 C++
这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的
Bug，我们可以使用类似 Valgrind 这样的工具来检查内存泄漏问题。</p>
<p>对于 Python
这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p>
<p>下面这个例子及其输出，展示了 memory-profiler
是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -m memory_profiler example.py</span></span><br><span class="line">Line #    Mem usage  Increment   Line Contents</span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       return a</span><br></pre></td></tr></table></figure>
<h5 id="事件分析">事件分析</h5>
<p>在我们使用 <code>strace</code>
调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<code>perf</code>
命令将 CPU
的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache
locality）、大量的页错误（page
faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<p><code>perf list</code> - 列出可以被 pref 追踪的事件；
<code>perf stat COMMAND ARG1 ARG2</code> -
收集与某个进程或指令相关的事件；
<code>perf record COMMAND ARG1 ARG2</code> -
记录命令执行的采样信息并将统计数据储存在 <code>perf.data</code> 中；
<code>perf report</code> - 格式化并打印 <code>perf.data</code>
中的数据。</p>
<h5 id="可视化">可视化</h5>
<p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p>
<p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是
火焰图，火焰图会在 Y 轴显示函数调用关系，并在 X
轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪。</p>
<p>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。
在 Python 中您可以使用 <code>pycallgraph</code> 来生成这些图片。</p>
<h5 id="资源监控">资源监控</h5>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU
占用、内存使用、网络、磁盘使用等。</p>
<p>通用监控 - 最流行的工具要数 <code>htop</code>, 了，它是
<code>top</code> 的改进版。<code>htop</code>
可以显示当前运行进程的多种统计信息。<code>htop</code>
有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、
<code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。
还可以留意一下 <code>glances</code>
，它的实现类似但是用户界面更好。如果需要合并测量全部的进程，
<code>dstat</code>
是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如
I/O、网络、 CPU 利用率、上下文切换等等； I/O 操作 - <code>iotop</code>
可以显示实时 I/O
占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；
磁盘使用 - <code>df</code> 可以显示每个分区的信息，而 <code>du</code>
则可以显示当前目录下每个文件的磁盘使用情况（ d isk u
sage）。<code>-h</code> 选项可以使命令以对人类（h
uman）更加友好的格式显示数据；<code>ncdu</code> 是一个交互性更好的
<code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；
内存使用 - <code>free</code> 可以显示系统当前空闲的内存。内存也可以使用
<code>htop</code> 这样的工具来显示； 打开文件 - <code>lsof</code>
可以列出被进程打开的文件信息。
当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；
网络连接和配置 - <code>ss</code>
能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code>
常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用
<code>ip</code> 命令。注意，<code>netstat</code> 和
<code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。 网络使用 -
<code>nethogs</code> 和 <code>iftop</code>
是非常好的用于对网络占用进行监控的交互式命令行工具。</p>
<p>如果您希望测试一下这些工具，您可以使用 <code>stress</code>
命令来为系统人为地增加负载。</p>
<h5 id="专用工具">专用工具</h5>
<p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。
类似 <code>hyperfine</code>
这样的命令行可以帮您快速进行基准测试。例如，我们在 shell
工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替
<code>find</code>。我们这里可以用 <code>hyperfine</code>
来比较一下它们。</p>
<p>例如，下面的例子中，我们可以看到 <code>fd</code> 比 <code>find</code>
要快 20 倍。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hyperfine --warmup 3 <span class="string">&#x27;fd -e jpg&#x27;</span> <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span></span><br><span class="line">Benchmark #1: fd -e jpg</span><br><span class="line">  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]</span><br><span class="line">  Range (min … max):    44.2 ms …  60.1 ms    56 runs</span><br><span class="line"></span><br><span class="line">Benchmark #2: find . -iname &quot;*.jpg&quot;</span><br><span class="line">  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]</span><br><span class="line">  Range (min … max):    0.975 s …  1.287 s    10 runs</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">  &#x27;fd -e jpg&#x27; ran</span><br><span class="line">   21.89 ± 2.33 times faster than &#x27;find . -iname &quot;*.jpg&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>和 debug
一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。</p>
<h2 id="元编程">元编程</h2>
<p>我们这里说的 “元编程（metaprogramming）”
是什么意思呢？好吧，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于
流程
，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。在您还是学生的时候，这些东西看上去似乎对您来说没那么重要，不过当您开始实习或走进社会的时候，您将会接触到大型的代码库，本节课讲授的这些东西也会变得随处可见。必须要指出的是，“元编程”
也有 “用于操作程序的程序”
之含义，这和我们今天讲座所介绍的概念是完全不同的。</p>
<h3 id="构建系统">构建系统</h3>
<p>如果您使用 LaTeX
来编写论文，您需要执行哪些命令才能编译出您想要的论文呢？执行基准测试、绘制图表然后将其插入论文的命令又有哪些？或者，如何编译本课程提供的代码并执行测试呢？</p>
<p>对于大多数系统来说，不论其是否包含代码，都会包含一个
“构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，您并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p>
<p>这些工具通常被称为
“构建系统”，而且这些工具还不少。如何选择工具完全取决于您当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的。您需要定义
依赖、目标 和
规则。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。</p>
<p><code>make</code>
是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于 UNIX
的系统中。<code>make</code>
并不完美，但是对于中小型项目来说，它已经足够好了。当您执行
<code>make</code> 时，它会去参考当前目录下名为 <code>Makefile</code>
的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paper.pdf: paper.tex plot-data.png</span><br><span class="line">    pdflatex paper.tex</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">plot-%</span><span class="language-bash">.png: %.dat plot.py</span></span><br><span class="line">    ./plot.py -i $*.dat -o $@</span><br></pre></td></tr></table></figure>
<p>这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。或者，换句话说，冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段命令。在
<code>make</code> 中，第一条指令还指明了构建的目的，如果您使用不带参数的
<code>make</code>，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p>
<p>规则中的 <code>%</code>
是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是
<code>plot-foo.png</code>， <code>make</code> 会去寻找
<code>foo.dat</code> 和 <code>plot.py</code>
作为依赖。现在，让我们看看如果在一个空的源码目录中执行 <code>make</code>
会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;paper.tex&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p><code>make</code> 会告诉我们，为了构建出
<code>paper.pdf</code>，它需要
<code>paper.tex</code>，但是并没有一条规则能够告诉它如何构建该文件。让我们构建它吧！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;plot-data.png&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p>哟，有意思，我们是 有 构建 <code>plot-data.png</code>
的规则的，但是这是一条模式规则。因为源文件 <code>data.dat</code>
并不存在，因此 <code>make</code> 就会告诉您它不能构建
<code>plot-data.png</code>，让我们创建这些文件：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> cat paper.tex</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=0.65]&#123;plot-data.png&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"><span class="built_in">$</span> cat plot.py</span><br><span class="line"><span class="params">#</span>!/usr/bin/env python</span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add<span class="built_in">_</span>argument(&#x27;-i&#x27;, type=argparse.FileType(&#x27;r&#x27;))</span><br><span class="line">parser.add<span class="built_in">_</span>argument(&#x27;-o&#x27;)</span><br><span class="line">args = parser.parse<span class="built_in">_</span>args()</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(args.i)</span><br><span class="line">plt.plot(data[:, 0], data[:, 1])</span><br><span class="line">plt.savefig(args.o)</span><br><span class="line"><span class="built_in">$</span> cat data.dat</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 8</span><br></pre></td></tr></table></figure>
<p>当我们执行 make 时会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">./plot.py -i data.dat -o plot-data.png</span><br><span class="line">pdflatex paper.tex</span><br><span class="line">... lots of output ...</span><br></pre></td></tr></table></figure>
<p>看！PDF ！</p>
<p>如果再次执行 <code>make</code> 会怎样？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: &#x27;paper.pdf&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p>什么事情都没做！为什么？好吧，因为它什么都不需要做。<code>make</code>
检查出所有之前构建的目标仍然与其列出的依赖项保持最新状态。让我们试试修改
<code>paper.tex</code> 后再重新执行 <code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">pdflatex paper.tex</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意 <code>make</code> 并 没有 重新构建
<code>plot.py</code>，因为没必要；<code>plot-data.png</code>
的所有依赖都没有发生改变。</p>
<h3 id="依赖管理">依赖管理</h3>
<p>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序（例如
<code>python</code>）、系统包（例如
<code>openssl</code>）或相关编程语言的库（例如
<code>matplotlib</code>）。 现在，大多数的依赖可以通过某些 软件仓库
来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如
Ubuntu 系统下面有 Ubuntu 软件包仓库，您可以通过 <code>apt</code>
这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python
库， Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。</p>
<p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如
版本控制。大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个
版本号。通常看上去像 8.1.3 或
64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p>
<p>这样还并不理想！如果我们发布了一项和安全相关的升级，它并 没有
影响到任何公开接口（API），但是处于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是
语义版本号，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：</p>
<p>如果新的版本没有改变 API，请将补丁号递增； 如果您添加了 API
并且该改动是向后兼容的，请将次版本号递增； 如果您修改了 API
但是它并不向后兼容，请将主版本号递增。</p>
<p>这么做有很多好处。现在如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的
，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是
<code>1.3.7</code>，那么使用
<code>1.3.8</code>、<code>1.6.1</code>，甚至是 <code>1.3.0</code>
都是可以的。如果版本号是 <code>2.2.4</code>
就不一定能用了，因为它的主版本号增加了。我们可以将 Python
的版本号作为语义版本号的一个实例。您应该知道，Python 2 和 Python 3
的代码是不兼容的，这也是为什么 Python 的主版本号改变的原因。类似的，使用
Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。</p>
<p>使用依赖管理系统的时候，您可能会遇到锁文件（lock
files）这一概念。锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含
bug）。还有一种极端的依赖锁定叫做
vendoring，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。</p>
<h3 id="持续集成系统">持续集成系统</h3>
<p>随着您接触到的项目规模越来越大，您会发现修改代码之后还有很多额外的工作要做。您可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到
pypi，执行测试套件等等。或许您希望每次有人提交代码到 GitHub
的时候，他们的代码风格被检查过并执行过某些基准测试？如果您有这方面的需求，那么请花些时间了解一下持续集成。</p>
<p>持续集成（Continuous integration），或者叫做 CI
是一种雨伞术语（umbrella
term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样
CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis
CI、Azure Pipelines 和 GitHub
Actions。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI
提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</p>
<p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages
在每次 master 有代码更新时，会执行 Jekyll
博客软件，然后使您的站点可以通过某个 GitHub
域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用
git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p>
<h4 id="测试简介">测试简介</h4>
<p>多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：</p>
<p>测试套件（Test suite）：所有测试的统称。 单元测试（Unit
test）：一种“微型测试”，用于对某个封装的特性进行测试。
集成测试（Integration
test）：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能
协同 工作。 回归测试（Regression
test）：一种实现特定模式的测试，用于保证之前引起问题的 bug
不会再次出现。 模拟（Mocking）:
使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接”
或 “模拟硬盘”。</p>
<h2 id="安全和密码学">安全和密码学</h2>
<p>我们将关注比如散列函数、密钥生成函数、对称/非对称密码体系这些安全和密码学的概念是如何应用于前几节课所学到的工具（Git
和 SSH）中的。</p>
<p>如果你不是密码学的专家，请不要
试图创造或者修改加密算法。从事和计算机系统安全相关的工作同理。</p>
<p>这节课将对一些基本的概念进行简单（但实用）的说明。
虽然这些说明不足以让你学会如何 设计
安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</p>
<h3 id="熵">熵</h3>
<p>熵 (Entropy) 是不确定性的度量，这很有用，可以用来决定密码的强度。</p>
<p>“correcthorsebatterystaple” 这个密码比 “Tr0ub4dor&amp;3”
更安全——可是熵是如何量化安全性的呢？</p>
<p>熵的单位是 比特。对于一个均匀分布的随机离散变量，熵等于
<code>log_2(所有可能的个数，即 n)</code>。 扔一次硬币的熵是 1
比特。掷一次（六面）骰子的熵大约为 2.58 比特。</p>
<p>一般我们认为攻击者了解密码的模型（最小长度，最大长度，可能包含的字符种类等），但是不了解某个密码是如何随机选择的——
比如 掷骰子。</p>
<p>使用多少比特的熵取决于应用的威胁模型。 大约 40
比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。
而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如 80
比特或更多)。</p>
<h3 id="散列函数">散列函数</h3>
<p>密码散列函数 (Cryptographic hash function)
可以将任意大小的数据映射为一个固定大小的输出。除此之外，还有一些其他特性。
一个散列函数的大概规范如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt;  (N对于该函数固定)</span><br></pre></td></tr></table></figure>
<p>SHA-1 是 Git 中使用的一种散列函数， 它可以将任意大小的输入映射为一个
160 比特（可被 40 位十六进制数表示）的输出。 下面我们用
<code>sha1sum</code> 命令来测试 SHA1 对几个字符串的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;Hello&#x27;</span> | <span class="built_in">sha1sum</span></span> </span><br><span class="line">f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0</span><br></pre></td></tr></table></figure>
<p>抽象地讲，散列函数可以被认为是一个不可逆，且看上去随机（但具确定性）的函数
（这就是 散列函数的理想模型）。 一个散列函数拥有以下特性：</p>
<p>确定性：对于不变的输入永远有相同的输出。 不可逆性：对于
<code>hash(m) = h</code>，难以通过已知的输出 <code>h</code>
来计算出原始输入 <code>m</code>。
目标碰撞抵抗性/弱无碰撞：对于一个给定输入 <code>m_1</code>，难以找到
<code>m_2 != m_1</code> 且 <code>hash(m_1) = hash(m_2)</code>。
碰撞抵抗性/强无碰撞：难以找到一组满足 <code>hash(m_1) = hash(m_2)</code>
的输入 <code>m_1, m_2</code>（该性质严格强于目标碰撞抵抗性）。</p>
<p>注：虽然 SHA-1 还可以用于特定用途，但它已经 不再被认为
是一个强密码散列函数。 你可参照 密码散列函数的生命周期
这个表格了解一些散列函数是何时被发现弱点及破解的。
请注意，针对应用推荐特定的散列函数超出了本课程内容的范畴。
如果选择散列函数对于你的工作非常重要，请先系统学习信息安全及密码学。</p>
<h4 id="密码散列函数的应用">密码散列函数的应用</h4>
<p>Git 中的内容寻址存储(Content-addressed storage)：散列函数
是一个宽泛的概念（存在非密码学的散列函数），那么 Git
为什么要特意使用密码散列函数？ 文件的信息摘要(Message digest)：像 Linux
ISO
这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。
官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。
用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。
承诺机制(Commitment scheme)： 假设我希望承诺一个值，但之后再透露它——
比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的“扔一次硬币”。
我可以选择一个值 <code>r = random()</code>，并和你分享它的哈希值
<code>h = sha256(r)</code>。
这时你可以开始猜硬币的正反：我们一致同意偶数 <code>r</code>
代表正面，奇数 <code>r</code> 代表反面。 你猜完了以后，我告诉你值
<code>r</code> 的内容，得出胜负。同时你可以使用 <code>sha256(r)</code>
来检查我分享的哈希值 <code>h</code> 以确认我没有作弊。</p>
<h3 id="密钥生成函数">密钥生成函数</h3>
<p>密钥生成函数 (Key Derivation Functions)
作为密码散列函数的相关概念，被应用于包括生成固定长度，可以使用在其他密码算法中的密钥等方面。
为了对抗穷举法攻击，密钥生成函数通常较慢。</p>
<h4 id="密钥生成函数的应用">密钥生成函数的应用</h4>
<p>从密码生成可以在其他加密算法中使用的密钥，比如对称加密算法（见下）。
存储登录凭证时不可直接存储明文密码。
正确的方法是针对每个用户随机生成一个 盐 <code>salt = random()</code>，
并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值
<code>KDF(password + salt)</code>。
在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值
<code>KDF(input + salt)</code>，并与存储的哈希值对比。</p>
<h3 id="对称加密">对称加密</h3>
<p>说到加密，可能你会首先想到隐藏明文信息。对称加密使用以下几个方法来实现这个功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; key  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出明文)</span><br></pre></td></tr></table></figure>
<p>加密方法 <code>encrypt()</code> 输出的密文 <code>ciphertext</code>
很难在不知道 <code>key</code> 的情况下得出明文 <code>plaintext</code>。
解密方法 <code>decrypt()</code>
有明显的正确性。因为功能要求给定密文及其密钥，解密方法必须输出明文：<code>decrypt(encrypt(m, k), k) = m</code>。</p>
<p>AES 是现在常用的一种对称加密系统。</p>
<h4 id="对称加密的应用">对称加密的应用</h4>
<p>加密不信任的云服务上存储的文件。对称加密和密钥生成函数配合起来，就可以使用密码加密文件：
将密码输入密钥生成函数生成密钥
<code>key = KDF(passphrase)</code>，然后存储
<code>encrypt(file, key)</code>。</p>
<h3 id="非对称加密">非对称加密</h3>
<p>非对称加密的“非对称”代表在其环境中，使用两个具有不同功能的密钥：
一个是私钥(private key)，不向外公布；另一个是公钥(public
key)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。
非对称加密使用以下几个方法来实现加密/解密(encrypt/decrypt)，以及签名/验证(sign/verify)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; (public key, private key)  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (输出明文)</span><br><span class="line"></span><br><span class="line">sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (生成签名)</span><br><span class="line">verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool  (验证签名是否是由和这个公钥相关的私钥生成的)</span><br></pre></td></tr></table></figure>
<p>非对称的加密/解密方法和对称的加密/解密方法有类似的特征。
信息在非对称加密中使用 公钥 加密， 且输出的密文很难在不知道 私钥
的情况下得出明文。 解密方法 <code>decrypt()</code> 有明显的正确性。
给定密文及私钥，解密方法一定会输出明文：
<code>decrypt(encrypt(m, public key), private key) = m</code>。</p>
<p>对称加密和非对称加密可以类比为机械锁。
对称加密就好比一个防盗门：只要是有钥匙的人都可以开门或者锁门。
非对称加密好比一个可以拿下来的挂锁。你可以把打开状态的挂锁（公钥）给任何一个人并保留唯一的钥匙（私钥）。这样他们将给你的信息装进盒子里并用这个挂锁锁上以后，只有你可以用保留的钥匙开锁。</p>
<p>签名/验证方法具有和书面签名类似的特征。 在不知道 私钥
的情况下，不管需要签名的信息为何，很难计算出一个可以使
<code>verify(message, signature, public key)</code> 返回为真的签名。
对于使用私钥签名的信息，验证方法验证和私钥相对应的公钥时一定返回为真：
<code>verify(message, sign(message, private key), public key) = true</code>。</p>
<h4 id="非对称加密的应用">非对称加密的应用</h4>
<p>PGP 电子邮件加密：用户可以将所使用的公钥在线发布，比如：PGP
密钥服务器或 Keybase。任何人都可以向他们发送加密的电子邮件。
聊天加密：像 Signal 和 Keybase 使用非对称密钥来建立私密聊天。
软件签名：Git 支持用户对提交(commit)和标签(tag)进行 GPG
签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。</p>
<h4 id="密钥分发">密钥分发</h4>
<p>非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。</p>
<p>Signal 的信任模型是，信任用户第一次使用时给出的身份(trust on first
use)，同时支持用户线下(out-of-band)、面对面交换公钥（Signal 里的 safety
number）。</p>
<p>PGP 使用的是
信任网络。简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，比如对比证件。验证无误后，信任网络的成员使用私钥对我的公钥进行签名。这样我就成为了信任网络的一部分。只要我使用签名过的公钥所对应的私钥就可以证明“我是我”。</p>
<p>Keybase 主要使用 社交网络证明 (social
proof)，和一些别的精巧设计。</p>
<p>每个信任模型有它们各自的优点：我们（讲师）更倾向于 Keybase
使用的模型。</p>
<h3 id="案例分析">案例分析</h3>
<h4 id="密码管理器">密码管理器</h4>
<p>每个人都应该尝试使用密码管理器，比如 KeePassXC、pass 和
1Password)。</p>
<p>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，并使用你指定的主密码配合密钥生成函数来对称加密它们。</p>
<p>你只需要记住一个复杂的主密码，密码管理器就可以生成很多复杂度高且不会重复使用的密码。密码管理器通过这种方式降低密码被猜出的可能，并减少网站信息泄露后对其他网站密码的威胁。</p>
<h4 id="两步验证双因子验证">两步验证（双因子验证）</h4>
<p>两步验证（2FA）要求用户同时使用密码（“你知道的信息”）和一个身份验证器（“你拥有的物品”，比如
YubiKey）来消除密码泄露或者 钓鱼攻击 的威胁。</p>
<h4 id="全盘加密">全盘加密</h4>
<p>对笔记本电脑的硬盘进行全盘加密是防止因设备丢失而信息泄露的简单且有效方法。
Linux 的cryptsetup + LUKS， Windows 的 BitLocker，或者 macOS 的
FileVault 都使用一个由密码保护的对称密钥来加密盘上的所有信息。</p>
<h4 id="聊天加密">聊天加密</h4>
<p>Signal 和 Keybase 使用非对称加密对用户提供端到端 （End-to-end）
安全性。</p>
<p>获取联系人的公钥非常关键。为了保证安全性，应使用线下方式验证 Signal
或者 Keybase 的用户公钥，或者信任 Keybase 用户提供的社交网络证明。</p>
<h4 id="ssh">SSH</h4>
<p>我们在 之前的一堂课 讨论了 SSH 和 SSH
密钥的使用。那么我们今天从密码学的角度来分析一下它们。</p>
<p>当你运行 <code>ssh-keygen</code>
命令，它会生成一个非对称密钥对：公钥和私钥
<code>(public_key, private_key)</code>。
生成过程中使用的随机数由系统提供的熵决定。这些熵可以来源于硬件事件(hardware
events)等。 公钥最终会被分发，它可以直接明文存储。
但是为了防止泄露，私钥必须加密存储。<code>ssh-keygen</code>
命令会提示用户输入一个密码，并将它输入密钥生成函数
产生一个密钥。最终，<code>ssh-keygen</code>
使用对称加密算法和这个密钥加密私钥。</p>
<p>在实际运用中，当服务器已知用户的公钥（存储在
<code>.ssh/authorized_keys</code> 文件中，一般在用户 HOME
目录下），尝试连接的客户端可以使用非对称签名来证明用户的身份——这便是
挑战应答方式。
简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。
服务器随后使用 <code>.ssh/authorized_keys</code>
文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效证明试图登录的用户持有所需的私钥。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
