<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:40" itemprop="dateModified" datetime="2025-08-08T19:53:40+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="指针的基本概念">指针的基本概念</h2>
<p>在第 12 章
栈与队列讲过，堆栈有栈顶指针，队列有头指针和尾指针，这些概念中的“指针”本质上是一个整数，是数组的索引，通过指针访问数组中的某个元素。在图
20.3
“间接寻址”我们又看到另外一种指针的概念，把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针，通过指针和间接寻址访问变量，这种指针在C语言中可以用一个指针类型的变量表示，例如某程序中定义了以下全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi = &amp;i;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> *pc = &amp;c;</span><br></pre></td></tr></table></figure>
<p>这几个变量的内存布局如下图所示，在初学阶段经常要借助于这样的图来理解指针。</p>
<p><img src="C:\blog\Blog\images\C\pointer.pointer0.png" /></p>
<p>这里的<code>&amp;</code>是取地址运算符（Address
Operator），<code>&amp;i</code>表示取变量<code>i</code>的地址，<code>int *pi = &amp;i;</code>表示定义一个指向<code>int</code>型的指针变量<code>pi</code>，并用<code>i</code>的地址来初始化<code>pi</code>。我们讲过全局变量只能用常量表达式初始化，如果定义<code>int p = i;</code>就错了，因为<code>i</code>不是常量表达式，然而用<code>i</code>的地址来初始化一个指针却没有错，因为<code>i</code>的地址是在编译链接时能确定的，而不需要到运行时才知道，<code>&amp;i</code>是常量表达式。后面两行代码定义了一个字符型变量<code>c</code>和一个指向<code>c</code>的字符型指针<code>pc</code>，注意<code>pi</code>和<code>pc</code>虽然是不同类型的指针变量，但它们的内存单元都占4个字节，因为要保存32位的虚拟地址，同理，在64位平台上指针变量都占8个字节。</p>
<p>我们知道，在同一个语句中定义多个数组，每一个都要有<code>[]</code>号：<code>int a[5], b[5];</code>。同样道理，在同一个语句中定义多个指针变量，每一个都要有<code>*</code>号，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p, *q;</span><br></pre></td></tr></table></figure>
<p>如果写成<code>int* p, q;</code>就错了，这样是定义了一个整型指针<code>p</code>和一个整型变量<code>q</code>，定义数组的<code>[]</code>号写在变量后面，而定义指针的<code>*</code>号写在变量前面，更容易看错。定义指针的<code>*</code>号前后空格都可以省，写成<code>int*p,*q;</code>也算对，但<code>*</code>号通常和类型<code>int</code>之间留空格而和变量名写在一起，这样看<code>int *p, q;</code>就很明显是定义了一个指针和一个整型变量，就不容易看错了。</p>
<p>如果要让<code>pi</code>指向另一个整型变量<code>j</code>，可以重新对<code>pi</code>赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = &amp;j;</span><br></pre></td></tr></table></figure>
<p>如果要改变<code>pi</code>所指向的整型变量的值，比如把变量<code>j</code>的值增加10，可以写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*pi = *pi + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这里的<code>*</code>号是指针间接寻址运算符（Indirection
Operator），<code>*pi</code>表示取指针<code>pi</code>所指向的变量的值，也称为Dereference操作，指针有时称为变量的引用（Reference），所以根据指针找到变量称为Dereference。</p>
<p><code>&amp;</code>运算符的操作数必须是左值，因为只有左值才表示一个内存单元，才会有地址，运算结果是指针类型。<code>*</code>运算符的操作数必须是指针类型，运算结果可以做左值。所以，如果表达式E可以做左值，<code>*&amp;E</code>和<code>E</code>等价，如果表达式E是指针类型，<code>&amp;*E</code>和<code>E</code>等价。</p>
<p>指针之间可以相互赋值，也可以用一个指针初始化另一个指针，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptri = pi;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptri;</span><br><span class="line">ptri = pi;</span><br></pre></td></tr></table></figure>
<p>表示<code>pi</code>指向哪就让<code>ptri</code>也指向哪，本质上就是把变量<code>pi</code>所保存的地址值赋给变量<code>ptri</code>。</p>
<p>用一个指针给另一个指针赋值时要注意，两个指针必须是同一类型的。在我们的例子中，<code>pi</code>是<code>int *</code>型的，<code>pc</code>是<code>char *</code>型的，<code>pi = pc;</code>这样赋值就是错误的。但是可以先强制类型转换然后赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = (<span class="type">int</span> *)pc;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\pointer.pointer1.png"
alt="把char 指针的值赋给int 指针" />
<figcaption aria-hidden="true">把char <em>指针的值赋给int
</em>指针</figcaption>
</figure>
<p>现在<code>pi</code>指向的地址和<code>pc</code>一样，但是通过<code>*pc</code>只能访问到一个字节，而通过<code>*pi</code>可以访问到4个字节，后3个字节已经不属于变量<code>c</code>了，除非你很确定变量<code>c</code>的一个字节和后面3个字节组合而成的<code>int</code>值是有意义的，否则就不应该给<code>pi</code>这么赋值。因此使用指针要特别小心，很容易将指针指向错误的地址，访问这样的地址可能导致段错误，可能读到无意义的值，也可能意外改写了某些数据，使得程序在随后的运行中出错。有一种情况需要特别注意，定义一个指针类型的局部变量而没有初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    ...</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，在堆栈上分配的变量初始值是不确定的，也就是说指针<code>p</code>所指向的内存地址是不确定的，后面用<code>*p</code>访问不确定的地址就会导致不确定的后果，如果导致段错误还比较容易改正，如果意外改写了数据而导致随后的运行中出错，就很难找到错误原因了。像这种指向不确定地址的指针称为“野指针”（Unbound
Pointer），为避免出现野指针，在定义指针变量时就应该给它明确的初值，或者把它初始化为<code>NULL</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NULL</code>在C标准库的头文件<code>stddef.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>
<p>就是把地址0转换成指针类型，称为空指针，它的特殊之处在于，操作系统不会把任何数据保存在地址0及其附近，也不会把地址0~0xfff的页面映射到物理内存，所以任何对地址0的访问都会立刻导致段错误。<code>*p = 0;</code>会导致段错误，就像放在眼前的炸弹一样很容易找到，相比之下，野指针的错误就像埋下地雷一样，更难发现和排除，这次走过去没事，下次走过去就有事。</p>
<p>讲到这里就该讲一下<code>void *</code>类型了。在编程时经常需要一种通用指针，可以转换为任意其它类型的指针，任意其它类型的指针也可以转换为通用指针，最初C语言没有<code>void *</code>类型，就把<code>char *</code>当通用指针，需要转换时就用类型转换运算符<code>()</code>，ANSI在将C语言标准化时引入了<code>void *</code>类型，<code>void *</code>指针与其它类型的指针之间可以隐式转换，而不必用类型转换运算符。注意，只能定义<code>void *</code>指针，而不能定义<code>void</code>型的变量，因为<code>void *</code>指针和别的指针一样都占4个字节，而如果定义<code>void</code>型变量（也就是类型暂时不确定的变量），编译器不知道该分配几个字节给变量。同样道理，<code>void *</code>指针不能直接Dereference，而必须先转换成别的类型的指针再做Dereference。<code>void *</code>指针常用于函数接口，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span> *pv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* *pv = &#x27;A&#x27; is illegal */</span></span><br><span class="line">    <span class="type">char</span> *pchar = pv;</span><br><span class="line">    *pchar = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    func(&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一章讲函数接口时再详细介绍<code>void *</code>指针的用处。</p>
<h2 id="指针类型的参数和返回值">指针类型的参数和返回值</h2>
<p>首先看以下程序：</p>
<p>例 指针参数和返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">swap</span><span class="params">(<span class="type">int</span> *px, <span class="type">int</span> *py)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *px;</span><br><span class="line">    *px = *py;</span><br><span class="line">    *py = temp;</span><br><span class="line">    <span class="keyword">return</span> px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p = swap(&amp;i, &amp;j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now i=%d j=%d *p=%d\n&quot;</span>, i, j, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，调用函数的传参过程相当于用实参定义并初始化形参，<code>swap(&amp;i, &amp;j)</code>这个调用相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *px = &amp;i;</span><br><span class="line"><span class="type">int</span> *py = &amp;j;</span><br></pre></td></tr></table></figure>
<p>所以<code>px</code>和<code>py</code>分别指向<code>main</code>函数的局部变量<code>i</code>和<code>j</code>，在<code>swap</code>函数中读写<code>*px</code>和<code>*py</code>其实是读写<code>main</code>函数的<code>i</code>和<code>j</code>。尽管在<code>swap</code>函数的作用域中访问不到<code>i</code>和<code>j</code>这两个变量名，却可以通过地址访问它们，最终<code>swap</code>函数将<code>i</code>和<code>j</code>的值做了交换。</p>
<p>上面的例子还演示了函数返回值是指针的情况，<code>return px;</code>语句相当于定义了一个临时变量并用<code>px</code>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *tmp = px;</span><br></pre></td></tr></table></figure>
<p>然后临时变量<code>tmp</code>的值成为表达式<code>swap(&amp;i, &amp;j)</code>的值，然后在<code>main</code>函数中又把这个值赋给了<code>p</code>，相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = tmp;</span><br></pre></td></tr></table></figure>
<p>最后的结果是<code>swap</code>函数的<code>px</code>指向哪就让<code>main</code>函数的<code>p</code>指向哪。我们知道<code>px</code>指向<code>i</code>，所以<code>p</code>也指向<code>i</code>。</p>
<h2 id="指针与数组">指针与数组</h2>
<p>先看个例子，有如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *pa = &amp;a[<span class="number">0</span>];</span><br><span class="line">pa++;</span><br></pre></td></tr></table></figure>
<p>首先指针<code>pa</code>指向<code>a[0]</code>的地址，注意后缀运算符的优先级高于单目运算符，所以是取<code>a[0]</code>的地址，而不是取<code>a</code>的地址。然后<code>pa++</code>让<code>pa</code>指向下一个元素（也就是<code>a[1]</code>），由于<code>pa</code>是<code>int *</code>指针，一个<code>int</code>型元素占4个字节，所以<code>pa++</code>使<code>pa</code>所指向的地址加4，注意不是加1。</p>
<p>下面画图理解。从前面的例子我们发现，地址的具体数值其实无关紧要，关键是要说明地址之间的关系（<code>a[1]</code>位于<code>a[0]</code>之后4个字节处）以及指针与变量之间的关系（指针保存的是变量的地址），现在我们换一种画法，省略地址的具体数值，用方框表示存储空间，用箭头表示指针和变量之间的关系。</p>
<figure>
<img src="C:\blog\Blog\images\C\pointer.array.png" alt="指针与数组" />
<figcaption aria-hidden="true">指针与数组</figcaption>
</figure>
<p>既然指针可以用<code>++</code>运算符，当然也可以用<code>+</code>、<code>-</code>运算符，<code>pa+2</code>这个表达式也是有意义的，如上图所示，<code>pa</code>指向<code>a[1]</code>，那么<code>pa+2</code>指向<code>a[3]</code>。事实上，<code>E1[E2]</code>这种写法和<code>(*((E1)+(E2)))</code>是等价的，<code>*(pa+2)</code>也可以写成<code>pa[2]</code>，<code>pa</code>就像数组名一样，其实数组名也没有什么特殊的，<code>a[2]</code>之所以能取数组的第2个元素，是因为它等价于<code>*(a+2)</code>，在第
1 节
“数组的基本概念”讲过数组名做右值时自动转换成指向首元素的指针，所以<code>a[2]</code>和<code>pa[2]</code>本质上是一样的，都是通过指针间接寻址访问元素。由于<code>(*((E1)+(E2)))</code>显然可以写成<code>(*((E2)+(E1)))</code>，所以<code>E1[E2]</code>也可以写成<code>E2[E1]</code>，这意味着<code>2[a]</code>、<code>2[pa]</code>这种写法也是对的，但一般不这么写。另外，由于<code>a</code>做右值使用时和<code>&amp;a[0]</code>是一个意思，所以<code>int *pa = &amp;a[0];</code>通常不这么写，而是写成更简洁的形式<code>int *pa = a;</code>。</p>
<p>在第 1 节
“数组的基本概念”还讲过C语言允许数组下标是负数，现在你该明白为什么这样规定了。在上面的例子中，表达式<code>pa[-1]</code>是合法的，它和<code>a[0]</code>表示同一个元素。</p>
<p>现在猜一下，两个指针变量做比较运算（<code>&gt;、&gt;=、&lt;、&lt;=、==、!=</code>）表示什么意义？两个指针变量做减法运算又表示什么意义？</p>
<p>根据什么来猜？根据第 3 节 “形参和实参”讲过的Rule of Least
Surprise原则。你理解了指针和常数加减的概念，再根据以往使用比较运算的经验，就应该猜到<code>pa + 2 &gt; pa</code>，<code>pa - 1 == a</code>，所以指针之间的比较运算比的是地址，C语言正是这样规定的，不过C语言的规定更为严谨，只有指向同一个数组中元素的指针之间相互比较才有意义，否则没有意义。那么两个指针相减表示什么？<code>pa - a</code>等于几？因为<code>pa - 1 == a</code>，所以<code>pa - a</code>显然应该等于1，指针相减表示两个指针之间相差的元素个数，同样只有指向同一个数组中元素的指针之间相减才有意义。两个指针相加表示什么？想不出来它能有什么意义，因此C语言也规定两个指针不能相加。假如C语言为指针相加也规定了一种意义，那就相当Surprise了，不符合一般的经验。无论是设计编程语言还是设计函数接口或人机界面都是这个道理，应该尽可能让用户根据以往的经验知识就能推断出该系统的基本用法。</p>
<p>在取数组元素时用数组名和用指针的语法一样，但如果把数组名做左值使用，和指针就有区别了。例如<code>pa++</code>是合法的，但<code>a++</code>就不合法，<code>pa = a + 1</code>是合法的，但<code>a = pa + 1</code>就不合法。数组名做右值时转换成指向首元素的指针，但做左值仍然表示整个数组的存储空间，而不是首元素的存储空间，数组名做左值还有一点特殊之处，不支持<code>++</code>、赋值这些运算符，但支持取地址运算符<code>&amp;</code>，所以<code>&amp;a</code>是合法的，我们将在第
7 节 “指向数组的指针与多维数组”介绍这种语法。</p>
<p>在函数原型中，如果参数是数组，则等价于参数是指针的形式，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int *a)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种形式方括号中的数字可以不写，仍然是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a[])</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，之所以规定两种形式是为了给读代码的人提供有用的信息，如果这个参数指向一个元素，通常写成指针的形式，如果这个参数指向一串元素中的首元素，则经常写成数组的形式。</p>
<h2 id="指针与const限定符">指针与const限定符</h2>
<p><code>const</code>限定符和指针结合起来常见的情况有以下几种。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *a;</span><br></pre></td></tr></table></figure>
<p>这两种写法是一样的，<code>a</code>是一个指向<code>const int</code>型的指针，<code>a</code>所指向的内存单元不可改写，所以<code>(*a)++</code>是不允许的，但<code>a</code>可以改写，所以<code>a++</code>是允许的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> a;</span><br></pre></td></tr></table></figure>
<p><code>a</code>是一个指向<code>int</code>型的<code>const</code>指针，<code>*a</code>是可以改写的，但<code>a</code>不允许改写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> a;</span><br></pre></td></tr></table></figure>
<p><code>a</code>是一个指向<code>const int</code>型的<code>const</code>指针，因此<code>*a</code>和<code>a</code>都不允许改写。</p>
<p>指向非<code>const</code>变量的指针或者非<code>const</code>变量的地址可以传给指向<code>const</code>变量的指针，编译器可以做隐式类型转换，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pc = &amp;c;</span><br></pre></td></tr></table></figure>
<p>但是，指向<code>const</code>变量的指针或者<code>const</code>变量的地址不可以传给指向非<code>const</code>变量的指针，以免透过后者意外改写了前者所指向的内存单元，例如对下面的代码编译器会报警告：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *pc = &amp;c;</span><br></pre></td></tr></table></figure>
<p>即使不用<code>const</code>限定符也能写出功能正确的程序，但良好的编程习惯应该尽可能多地使用<code>const</code>，因为：</p>
<p><code>const</code>给读代码的人传达非常有用的信息。比如一个函数的参数是<code>const char *</code>，你在调用这个函数时就可以放心地传给它<code>char *</code>或<code>const char *</code>指针，而不必担心指针所指的内存单元被改写。</p>
<p>尽可能多地使用<code>const</code>限定符，把不该变的都声明成只读，这样可以依靠编译器检查程序中的Bug，防止意外改写数据。</p>
<p><code>const</code>对编译器优化是一个有用的提示，编译器也许会把<code>const</code>变量优化成常量。</p>
<p>在第 3 节
“变量的存储布局”我们看到，字符串字面值通常分配在<code>.rodata</code>段，而在第
4 节
“字符串”提到，字符串字面值类似于数组名，做右值使用时自动转换成指向首元素的指针，这种指针应该是<code>const char *</code>型。我们知道<code>printf</code>函数原型的第一个参数是<code>const char *</code>型，可以把<code>char *</code>或<code>const char *</code>指针传给它，所以下面这些调用都是合法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> str1[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(str1);</span><br><span class="line"><span class="built_in">printf</span>(str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意上面第一行，如果要定义一个指针指向字符串字面值，这个指针应该是<code>const char *</code>型，如果写成<code>char *p = "abcd";</code>就不好了，有隐患，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">...</span><br><span class="line">    *p = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>p</code>指向<code>.rodata</code>段，不允许改写，但编译器不会报错，在运行时会出现段错误。</p>
<h2 id="指针与结构体">指针与结构体</h2>
<p>首先定义一个结构体类型，然后定义这种类型的变量和指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unit</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unit</span> <span class="title">u</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unit</span> *<span class="title">p</span> =</span> &amp;u;</span><br></pre></td></tr></table></figure>
<p>要通过指针<code>p</code>访问结构体成员可以写成<code>(*p).c</code>和<code>(*p).num</code>，为了书写方便，C语言提供了<code>-&gt;</code>运算符，也可以写成<code>p-&gt;c</code>和<code>p-&gt;num</code>。</p>
<h2 id="指向指针的指针与指针数组">指向指针的指针与指针数组</h2>
<p>指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外一个指针变量，称为指向指针的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *pi = &amp;i;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>这样定义之后，表达式<code>*ppi</code>取<code>pi</code>的值，表达式<code>**ppi</code>取<code>i</code>的值。请读者自己画图理解<code>i</code>、<code>pi</code>、<code>ppi</code>这三个变量之间的关系。</p>
<p>很自然地，也可以定义指向“指向指针的指针”的指针，但是很少用到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ***p;</span><br></pre></td></tr></table></figure>
<p>数组中的每个元素可以是基本类型，也可以复合类型，因此也可以是指针类型。例如定义一个数组<code>a</code>由10个元素组成，每个元素都是<code>int *</code>指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>这称为指针数组。<code>int *a[10];</code>和<code>int **pa;</code>之间的关系类似于<code>int a[10];</code>和<code>int *pa;</code>之间的关系：<code>a</code>是由一种元素组成的数组，<code>pa</code>则是指向这种元素的指针。所以，如果<code>pa</code>指向<code>a</code>的首元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> **pa = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>则<code>pa[0]</code>和<code>a[0]</code>取的是同一个元素，唯一比原来复杂的地方在于这个元素是一个<code>int *</code>指针，而不是基本类型。</p>
<p>我们知道<code>main</code>函数的标准原型应该是<code>int main(int argc, char *argv[]);</code>。<code>argc</code>是命令行参数的个数。而<code>argv</code>是一个指向指针的指针，为什么不是指针数组呢？因为前面讲过，函数原型中的<code>[]</code>表示指针而不表示数组，等价于<code>char **argv</code>。那为什么要写成<code>char *argv[]</code>而不写成<code>char **argv</code>呢？这样写给读代码的人提供了有用信息，<code>argv</code>不是指向单个指针，而是指向一个指针数组的首元素。数组中每个元素都是<code>char *</code>指针，指向一个命令行参数字符串。</p>
<p>例 打印命令行参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out a b c</span></span><br><span class="line">argv[0]=./a.out</span><br><span class="line">argv[1]=a</span><br><span class="line">argv[2]=b</span><br><span class="line">argv[3]=c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s a.out printargv</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./printargv d e</span> </span><br><span class="line">argv[0]=./printargv</span><br><span class="line">argv[1]=d</span><br><span class="line">argv[2]=e</span><br></pre></td></tr></table></figure>
<p>注意程序名也算一个命令行参数，所以执行<code>./a.out a b c</code>这个命令时，<code>argc</code>是4，<code>argv</code>如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\pointer.argv.png" alt="argv指针数组" />
<figcaption aria-hidden="true">argv指针数组</figcaption>
</figure>
<p>由于<code>argv[4]</code>是<code>NULL</code>，我们也可以这样循环遍历<code>argv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++)</span><br></pre></td></tr></table></figure>
<p><code>NULL</code>标识着<code>argv</code>的结尾，这个循环碰到<code>NULL</code>就结束，因而不会访问越界，这种用法很形象地称为Sentinel，<code>NULL</code>就像一个哨兵守卫着数组的边界。</p>
<p>在这个例子中我们还看到，如果给程序建立符号链接，然后通过符号链接运行这个程序，就可以得到不同的<code>argv[0]</code>。通常，程序会根据不同的命令行参数做不同的事情，例如<code>ls -l</code>和<code>ls -R</code>打印不同的文件列表，而有些程序会根据不同的<code>argv[0]</code>做不同的事情，例如专门针对嵌入式系统的开源项目Busybox，将各种Linux命令裁剪后集于一身，编译成一个可执行文件busybox，安装时将busybox程序拷到嵌入式系统的/bin目录下，同时在/bin、/sbin、/usr/bin、/usr/sbin等目录下创建很多指向/bin/busybox的符号链接，命名为cp、ls、mv、ifconfig等等，不管执行哪个命令其实最终都是在执行/bin/busybox，它会根据<code>argv[0]</code>来区分不同的命令。</p>
<h2 id="指向数组的指针与多维数组">指向数组的指针与多维数组</h2>
<p>指针可以指向复合类型，上一节讲了指向指针的指针，这一节学习指向数组的指针。以下定义一个指向数组的指针，该数组有10个<code>int</code>元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*a)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>和上一节指针数组的定义<code>int *a[10];</code>相比，仅仅多了一个<code>()</code>括号。如何记住和区分这两种定义呢？我们可以认为<code>[]</code>比<code>*</code>有更高的优先级，如果<code>a</code>先和<code>*</code>结合则表示<code>a</code>是一个指针，如果<code>a</code>先和<code>[]</code>结合则表示<code>a</code>是一个数组。<code>int *a[10];</code>这个定义可以拆成两句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *t;</span><br><span class="line">t a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><code>t</code>代表<code>int *</code>类型，<code>a</code>则是由这种类型的元素组成的数组。<code>int (*a)[10];</code>这个定义也可以拆成两句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> t[<span class="number">10</span>];</span><br><span class="line">t *a;</span><br></pre></td></tr></table></figure>
<p><code>t</code>代表由10个<code>int</code>组成的数组类型，<code>a</code>则是指向这种类型的指针。</p>
<p>现在看指向数组的指针如何使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure>
<p><code>a</code>是一个数组，在<code>&amp;a</code>这个表达式中，数组名做左值，取整个数组的首地址赋给指针<code>pa</code>。注意，<code>&amp;a[0]</code>表示数组<code>a</code>的首元素的首地址，而<code>&amp;a</code>表示数组<code>a</code>的首地址，显然这两个地址的数值相同，但这两个表达式的类型是两种不同的指针类型，前者的类型是<code>int *</code>，而后者的类型是<code>int (*)[10]</code>。<code>*pa</code>就表示<code>pa</code>所指向的数组<code>a</code>，所以取数组的<code>a[0]</code>元素可以用表达式<code>(*pa)[0]</code>。注意到<code>*pa</code>可以写成<code>pa[0]</code>，所以<code>(*pa)[0]</code>这个表达式也可以改写成<code>pa[0][0]</code>，<code>pa</code>就像一个二维数组的名字，它表示什么含义呢？下面把<code>pa</code>和二维数组放在一起做个分析。</p>
<p><code>int a[5][10];</code>和<code>int (*pa)[10];</code>之间的关系同样类似于<code>int a[10];</code>和<code>int *pa;</code>之间的关系：<code>a</code>是由一种元素组成的数组，<code>pa</code>则是指向这种元素的指针。所以，如果<code>pa</code>指向<code>a</code>的首元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*pa)[<span class="number">10</span>] = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>则<code>pa[0]</code>和<code>a[0]</code>取的是同一个元素，唯一比原来复杂的地方在于这个元素是由10个<code>int</code>组成的数组，而不是基本类型。这样，我们可以把<code>pa</code>当成二维数组名来使用，<code>pa[1][2]</code>和<code>a[1][2]</code>取的也是同一个元素，而且<code>pa</code>比<code>a</code>用起来更灵活，数组名不支持赋值、自增等运算，而指针可以支持，<code>pa++</code>使<code>pa</code>跳过二维数组的一行（40个字节），指向<code>a[1]</code>的首地址。</p>
<h2 id="函数类型和函数指针类型">函数类型和函数指针类型</h2>
<p>在C语言中，函数也是一种类型，可以定义指向函数的指针。我们知道，指针变量的内存单元存放一个地址值，而函数指针存放的就是函数的入口地址（位于.text段）。下面看一个简单的例子：</p>
<p>例 函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">say_hello</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*f)(<span class="type">const</span> <span class="type">char</span> *) = say_hello;</span><br><span class="line">    f(<span class="string">&quot;Guys&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析一下变量<code>f</code>的类型声明<code>void (*f)(const char *)</code>，<code>f</code>首先跟<code>*</code>号结合在一起，因此是一个指针。<code>(*f)</code>外面是一个函数原型的格式，参数是<code>const char *</code>，返回值是<code>void</code>，所以<code>f</code>是指向这种函数的指针。而<code>say_hello</code>的参数是<code>const char *</code>，返回值是<code>void</code>，正好是这种函数，因此<code>f</code>可以指向<code>say_hello</code>。注意，<code>say_hello</code>是一种函数类型，而函数类型和数组类型类似，做右值使用时自动转换成函数指针类型，所以可以直接赋给<code>f</code>，当然也可以写成<code>void (*f)(const char *) = &amp;say_hello;</code>，把函数<code>say_hello</code>先取地址再赋给<code>f</code>，就不需要自动类型转换了。</p>
<p>可以直接通过函数指针调用函数，如上面的<code>f("Guys")</code>，也可以先用<code>*f</code>取出它所指的函数类型，再调用函数，即<code>(*f)("Guys")</code>。可以这么理解：函数调用运算符<code>()</code>要求操作数是函数指针，所以<code>f("Guys")</code>是最直接的写法，而<code>say_hello("Guys")</code>或<code>(*f)("Guys")</code>则是把函数类型自动转换成函数指针然后做函数调用。</p>
<p>下面再举几个例子区分函数类型和函数指针类型。首先定义函数类型F：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这种类型的函数不带参数，返回值是<code>int</code>。那么可以这样声明<code>f</code>和<code>g</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F f, g;</span><br></pre></td></tr></table></figure>
<p>相当于声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>下面这个函数声明是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F <span class="title function_">h</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因为函数可以返回<code>void</code>类型、标量类型、结构体、联合体，但不能返回函数类型，也不能返回数组类型。而下面这个函数声明是正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F *<span class="title function_">e</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>函数<code>e</code>返回一个<code>F *</code>类型的函数指针。如果给<code>e</code>多套几层括号仍然表示同样的意思：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F *((e))(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>
<p>但如果把<code>*</code>号也套在括号里就不一样了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*fp)(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>
<p>这样声明了一个函数指针，而不是声明一个函数。<code>fp</code>也可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F *fp;</span><br></pre></td></tr></table></figure>
<p>通过函数指针调用函数和直接调用函数相比有什么好处呢？我们研究一个例子。回顾第
3 节
“数据类型标志”的习题1，由于结构体中多了一个类型字段，需要重新实现<code>real_part</code>、<code>img_part</code>、<code>magnitude</code>、<code>angle</code>这些函数，你当时是怎么实现的？大概是这样吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">real_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (z.t == RECTANGULAR)</span><br><span class="line">        <span class="keyword">return</span> z.a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> z.a * <span class="built_in">cos</span>(z.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在类型字段有两种取值，<code>RECTANGULAR</code>和<code>POLAR</code>，每个函数都要<code>if ... else ...</code>，如果类型字段有三种取值呢？每个函数都要<code>if ... else if ... else</code>，或者<code>switch ... case ...</code>。这样维护代码是不够理想的，现在我用函数指针给出一种实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">rect_real_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">rect_img_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">rect_magnitude</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(z.a * z.a + z.b * z.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">rect_angle</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z.a &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan</span>(z.b / z.a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan</span>(z.b / z.a) + PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pol_real_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.a * <span class="built_in">cos</span>(z.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pol_img_part</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.a * <span class="built_in">sin</span>(z.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pol_magnitude</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">pol_angle</span><span class="params">(<span class="keyword">struct</span> complex_struct z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> z.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> (*real_part_tbl[])(<span class="keyword">struct</span> complex_struct) = &#123; rect_real_part, pol_real_part &#125;;</span><br><span class="line"><span class="type">double</span> (*img_part_tbl[])(<span class="keyword">struct</span> complex_struct) = &#123; rect_img_part, pol_img_part &#125;;</span><br><span class="line"><span class="type">double</span> (*magnitude_tbl[])(<span class="keyword">struct</span> complex_struct) = &#123; rect_magnitude, pol_magnitude &#125;;</span><br><span class="line"><span class="type">double</span> (*angle_tbl[])(<span class="keyword">struct</span> complex_struct) = &#123; rect_angle, pol_angle &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> real_part(z) real_part_tbl[z.t](z)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> img_part(z) img_part_tbl[z.t](z)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> magnitude(z) magnitude_tbl[z.t](z)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> angle(z) angle_tbl[z.t](z)</span></span><br></pre></td></tr></table></figure>
<p>当调用<code>real_part(z)</code>时，用类型字段<code>z.t</code>做索引，从指针数组<code>real_part_tbl</code>中取出相应的函数指针来调用，也可以达到<code>if ... else ...</code>的效果，但相比之下这种实现更好，每个函数都只做一件事情，而不必用<code>if ... else ...</code>兼顾好几件事情，比如<code>rect_real_part</code>和<code>pol_real_part</code>各做各的，互相独立，而不必把它们的代码都耦合到一个函数中。“低耦合，高内聚”（Low
Coupling, High
Cohesion）是程序设计的一条基本原则，这样可以更好地复用现有代码，使代码更容易维护。如果类型字段<code>z.t</code>又多了一种取值，只需要添加一组新的函数，修改函数指针数组，原有的函数仍然可以不加改动地复用。</p>
<h2 id="不完全类型和复杂声明">不完全类型和复杂声明</h2>
<p>在第 1 节
“复合类型与结构体”讲过算术类型、标量类型的概念，现在又学习了几种类型，我们完整地总结一下C语言的类型。下图出自[Standard
C]。</p>
<p><img src="C:\blog\Blog\images\C\pointer.type.gif" /></p>
<p>C语言的类型分为函数类型、对象类型和不完全类型三大类。对象类型又分为标量类型和非标量类型。指针类型属于标量类型，因此也可以做逻辑与、或、非运算的操作数和<code>if</code>、<code>for</code>、<code>while</code>的控制表达式，<code>NULL</code>指针表示假，非NULL指针表示真。不完全类型是暂时没有完全定义好的类型，编译器不知道这种类型该占几个字节的存储空间，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u</span>;</span></span><br><span class="line"><span class="type">char</span> str[];</span><br></pre></td></tr></table></figure>
<p>具有不完全类型的变量可以通过多次声明组合成一个完全类型，比如数组<code>str</code>声明两次：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[];</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>当编译器碰到第一个声明时，认为<code>str</code>是一个不完全类型，碰到第二个声明时<code>str</code>就组合成完全类型了，如果编译器处理到程序文件的末尾仍然无法把<code>str</code>组合成一个完全类型，就会报错。读者可能会想，这个语法有什么用呢？为何不在第一次声明时就把<code>str</code>声明成完全类型？有些情况下这么做有一定的理由，比如第一个声明是写在头文件里的，第二个声明写在.c文件里，这样如果要改数组长度，只改.c文件就行了，头文件可以不用改。</p>
<p>不完全的结构体类型有重要作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t</span> *<span class="title">pt</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> *<span class="title">ps</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct s</code>和<code>struct t</code>各有一个指针成员指向另一种类型。编译器从前到后依次处理，当看到<code>struct s &#123; struct t* pt; &#125;;</code>时，认为<code>struct t</code>是一个不完全类型，<code>pt</code>是一个指向不完全类型的指针，尽管如此，这个指针却是完全类型，因为不管什么指针都占4个字节存储空间，这一点很明确。然后编译器又看到<code>struct t &#123; struct s *ps; &#125;;</code>，这时<code>struct t</code>有了完整的定义，就组合成一个完全类型了，<code>pt</code>的类型就组合成一个指向完全类型的指针。由于<code>struct s</code>在前面有完整的定义，所以<code>struct s *ps;</code>也定义了一个指向完全类型的指针。</p>
<p>这样的类型定义是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">t</span> <span class="title">ot</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> <span class="title">os</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器看到<code>struct s &#123; struct t ot; &#125;;</code>时，认为<code>struct t</code>是一个不完全类型，无法定义成员<code>ot</code>，因为不知道它该占几个字节。所以结构体中可以递归地定义指针成员，但不能递归地定义变量成员，你可以设想一下，假如允许递归地定义变量成员，<code>struct s</code>中有一个<code>struct t</code>，<code>struct t</code>中又有一个<code>struct s</code>，<code>struct s</code>又中有一个<code>struct t</code>，这就成了一个无穷递归的定义。</p>
<p>以上是两个结构体构成的递归定义，一个结构体也可以递归定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">6</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器处理到第一行<code>struct s &#123;</code>时，认为<code>struct s</code>是一个不完全类型，当处理到第三行<code>struct s *next;</code>时，认为<code>next</code>是一个指向不完全类型的指针，当处理到第四行<code>&#125;;</code>时，<code>struct s</code>成了一个完全类型，<code>next</code>也成了一个指向完全类型的指针。类似这样的结构体是很多种数据结构的基本组成单元，如链表、二叉树等，我们将在后面详细介绍。下图示意了由几个<code>struct s</code>结构体组成的链表，这些结构体称为链表的节点（Node）。</p>
<figure>
<img src="C:\blog\Blog\images\C\pointer.linkedlist.png" alt="链表" />
<figcaption aria-hidden="true">链表</figcaption>
</figure>
<p><code>head</code>指针是链表的头指针，指向第一个节点，每个节点的<code>next</code>指针域指向下一个节点，最后一个节点的<code>next</code>指针域为<code>NULL</code>，在图中用0表示。</p>
<p>可以想像得到，如果把指针和数组、函数、结构体层层组合起来可以构成非常复杂的类型，下面看几个复杂的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
<p>这个声明来自<code>signal(2)</code>。<code>sighandler_t</code>是一个函数指针，它所指向的函数带一个参数，返回值为<code>void</code>，<code>signal</code>是一个函数，它带两个参数，一个<code>int</code>参数，一个<code>sighandler_t</code>参数，返回值也是<code>sighandler_t</code>参数。如果把这两行合成一行写，就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>在分析复杂声明时，要借助<code>typedef</code>把复杂声明分解成几种基本形式：</p>
<p><code>T *p;</code>，<code>p</code>是指向<code>T</code>类型的指针。</p>
<p><code>T a[];</code>，<code>a</code>是由<code>T</code>类型的元素组成的数组，但有一个例外，如果<code>a</code>是函数的形参，则相当于<code>T *a;</code></p>
<p><code>T1 f(T2, T3...);</code>，<code>f</code>是一个函数，参数类型是<code>T2</code>、<code>T3</code>等等，返回值类型是<code>T1</code>。</p>
<p>我们分解一下这个复杂声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*(*fp)(<span class="type">void</span> *))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>1、<code>fp</code>和<code>*</code>号括在一起，说明<code>fp</code>是一个指针，指向<code>T1</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*T1(<span class="type">void</span> *))</span>[10];</span><br><span class="line">T1 *fp;</span><br></pre></td></tr></table></figure>
<p>2、<code>T1</code>应该是一个函数类型，参数是<code>void *</code>，返回值是<code>T2</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*T2)</span>[10];</span><br><span class="line"><span class="keyword">typedef</span> T2 <span class="title function_">T1</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line">T1 *fp;</span><br></pre></td></tr></table></figure>
<p>3、<code>T2</code>和<code>*</code>号括在一起，应该也是个指针，指向<code>T3</code>类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T3[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> T3 *T2;</span><br><span class="line"><span class="keyword">typedef</span> T2 <span class="title function_">T1</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line">T1 *fp;</span><br></pre></td></tr></table></figure>
<p>显然，<code>T3</code>是一个<code>int</code>数组，由10个元素组成。分解完毕。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:Makefile基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 19:53:50" itemprop="dateModified" datetime="2025-08-08T19:53:50+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本规则">基本规则</h2>
<p>除了Hello
World这种极简单的程序之外，一般的程序都是由多个源文件编译链接而成的，这些源文件的处理步骤通常用Makefile来管理。Makefile起什么作用呢？我们先看一个例子，这个例子由例
12.3 “用深度优先搜索解迷宫问题”改写而成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">predecessor</span>[<span class="title">MAX_ROW</span>][<span class="title">MAX_COL</span>] =</span> &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="keyword">struct</span> point pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    predecessor[row][col] = pre;</span><br><span class="line">    push(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    push(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = pop();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col, p);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col, p);</span><br><span class="line">        print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (predecessor[p.row][p.col].row != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = predecessor[p.row][p.col];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把堆栈和迷宫的代码分别转移到模块<code>stack.c</code>和<code>maze.c</code>中，<code>main.c</code>包含它们提供的头文件<code>stack.h</code>和<code>maze.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col; &#125; <span class="type">item_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>main.h</code>中定义了一个类型和两个常量，<code>main.c</code>、<code>stack.c</code>和<code>maze.c</code>都要用到这些定义，都要包含这个头文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stack.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">item_t</span> <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">item_t</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">item_t</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* stack.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span> <span class="comment">/* provides definition for item_t */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">item_t</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">item_t</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>例 12.3
“用深度优先搜索解迷宫问题”中的堆栈规定死了只能放<code>char</code>型数据，现在我们做进一步抽象，堆栈中放<code>item_t</code>类型的数据，<code>item_t</code>可以定义为任意类型，只要它能够通过函数的参数和返回值传递并且支持赋值操作就行。这也是一种避免硬编码的策略，<code>stack.c</code>中多次使用<code>item_t</code>类型，要改变它的定义只需改变<code>main.h</code>中的一行代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maze.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maze.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* maze.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAZE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAZE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span> <span class="comment">/* provides defintion for MAX_ROW and MAX_COL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> maze[MAX_ROW][MAX_COL];</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>maze.c</code>中定义了一个<code>maze</code>数组和一个<code>print_maze</code>函数，需要在头文件<code>maze.h</code>中声明，以便提供给<code>main.c</code>使用，注意<code>print_maze</code>的声明可以不加<code>extern</code>，而<code>maze</code>的声明必须加<code>extern</code>。</p>
<p>这些源文件可以这样编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.c stack.c maze.c -o main</span></span><br></pre></td></tr></table></figure>
<p>但这不是个好办法，如果编译之后又对<code>maze.c</code>做了修改，又要把所有源文件编译一遍，即使<code>main.c</code>、<code>stack.c</code>和那些头文件都没有修改也要跟着重新编译。一个大型的软件项目往往由上千个源文件组成，全部编译一遍需要几个小时，只改一个源文件就要求全部重新编译肯定是不合理的。</p>
<p>这样编译也许更好一些：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c main.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c stack.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c maze.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.o stack.o maze.o -o main</span></span><br></pre></td></tr></table></figure>
<p>如果编译之后又对<code>maze.c</code>做了修改，要重新编译只需要做两步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -c maze.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc main.o stack.o maze.o -o main</span></span><br></pre></td></tr></table></figure>
<p>这样又有一个问题，每次编译敲的命令都不一样，很容易出错，比如我修改了三个源文件，可能有一个忘了重新编译，结果编译完了修改没生效，运行时出了Bug还满世界找原因呢。更复杂的问题是，假如我改了<code>main.h</code>怎么办？所有包含<code>main.h</code>的源文件都需要重新编译，我得挨个找哪些源文件包含了<code>main.h</code>，有的还很不明显，例如<code>stack.c</code>包含了<code>stack.h</code>，而后者包含了<code>main.h</code>。可见手动处理这些问题非常容易出错，那有没有自动的解决办法呢？有，就是写一个Makefile文件和源代码放在同一个目录下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">stack.o: stack.c stack.h main.h</span><br><span class="line">    gcc -c stack.c</span><br><span class="line"></span><br><span class="line">maze.o: maze.c maze.h main.h</span><br><span class="line">    gcc -c maze.c</span><br></pre></td></tr></table></figure>
<p>然后在这个目录下运行<code>make</code>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c stack.c</span><br><span class="line">gcc -c maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>make</code>命令会自动读取当前目录下的Makefile文件[33]，完成相应的编译步骤。Makefile由一组规则（Rule）组成，每条规则的格式是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ... </span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>main</code>是这条规则的目标（Target），<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>是这条规则的条件（Prerequisite）。目标和条件之间的关系是：欲更新目标，必须首先更新它的所有条件；所有条件中只要有一个条件被更新了，目标也必须随之被更新。所谓“更新”就是执行一遍规则中的命令列表，命令列表中的每条命令必须以一个<code>Tab</code>开头，注意不能是空格，Makefile的格式不像C语言的缩进那么随意，对于Makefile中的每个以<code>Tab</code>开头的命令，<code>make</code>会创建一个Shell进程去执行它。</p>
<p>对于上面这个例子，<code>make</code>执行如下步骤：</p>
<p>尝试更新Makefile中第一条规则的目标<code>main</code>，第一条规则的目标称为缺省目标，只要缺省目标更新了就算完成任务了，其它工作都是为这个目的而做的。由于我们是第一次编译，<code>main</code>文件还没生成，显然需要更新，但规则说必须先更新了<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个条件，然后才能更新<code>main</code>。</p>
<p>所以<code>make</code>会进一步查找以这三个条件为目标的规则，这些目标文件也没有生成，也需要更新，所以执行相应的命令（<code>gcc -c main.c</code>、<code>gcc -c stack.c</code>和<code>gcc -c maze.c</code>）更新它们。</p>
<p>最后执行<code>gcc main.o stack.o maze.o -o main</code>更新<code>main</code>。</p>
<p>如果没有做任何改动，再次运行<code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: `main&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p><code>make</code>会提示缺省目标已经是最新的了，不需要执行任何命令更新它。再做个实验，如果修改了<code>maze.h</code>（比如加个无关痛痒的空格）再运行<code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p><code>make</code>会自动选择那些受影响的源文件重新编译，不受影响的源文件则不重新编译，这是怎么做到的呢？</p>
<p><code>make</code>仍然尝试更新缺省目标，首先检查目标<code>main</code>是否需要更新，这就要检查三个条件<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>是否需要更新。</p>
<p><code>make</code>会进一步查找以这三个条件为目标的规则，然后发现<code>main.o</code>和<code>maze.o</code>需要更新，因为它们都有一个条件是<code>maze.h</code>，而这个文件的修改时间比<code>main.o</code>和<code>maze.o</code>晚，所以执行相应的命令更新<code>main.o</code>和<code>maze.o</code>。</p>
<p>既然<code>main</code>的三个条件中有两个被更新过了，那么<code>main</code>也需要更新，所以执行命令<code>gcc main.o stack.o maze.o -o main</code>更新<code>main</code>。</p>
<p>现在总结一下Makefile的规则，请读者结合上面的例子理解。如果一条规则的目标属于以下情况之一，就称为需要更新：</p>
<p>目标没有生成。</p>
<p>某个条件需要更新。</p>
<p>某个条件的修改时间比目标晚。</p>
<p>在一条规则被执行之前，规则的条件可能处于以下三种状态之一：</p>
<p>需要更新。能够找到以该条件为目标的规则，并且该规则中目标需要更新。</p>
<p>不需要更新。能够找到以该条件为目标的规则，但是该规则中目标不需要更新；或者不能找到以该条件为目标的规则，并且该条件已经生成。</p>
<p>错误。不能找到以该条件为目标的规则，并且该条件没有生成。</p>
<p>执行一条规则A的步骤如下：</p>
<p>检查它的每个条件P：</p>
<p>如果P需要更新，就执行以P为目标的规则B。之后，无论是否生成文件P，都认为P已被更新。</p>
<p>如果找不到规则B，并且文件P已存在，表示P不需要更新。</p>
<p>如果找不到规则B，并且文件P不存在，则报错退出。</p>
<p>在检查完规则A的所有条件后，检查它的目标T，如果属于以下情况之一，就执行它的命令列表：</p>
<p>文件T不存在。</p>
<p>文件T存在，但是某个条件的修改时间比它晚。</p>
<p>某个条件P已被更新（并不一定生成文件P）。</p>
<p>通常Makefile都会有一个<code>clean</code>规则，用于清除编译过程中产生的二进制文件，保留源文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    @echo &quot;cleanning project&quot;</span><br><span class="line">    -rm main *.o</span><br><span class="line">    @echo &quot;clean completed&quot;</span><br></pre></td></tr></table></figure>
<p>把这条规则添加到我们的Makefile末尾，然后执行这条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span> </span><br><span class="line">cleanning project</span><br><span class="line">rm main *.o</span><br><span class="line">clean completed</span><br></pre></td></tr></table></figure>
<p>如果在<code>make</code>的命令行中指定一个目标（例如<code>clean</code>），则更新这个目标，如果不指定目标则更新Makefile中第一条规则的目标（缺省目标）。</p>
<p>和前面介绍的规则不同，<code>clean</code>目标不依赖于任何条件，并且执行它的命令列表不会生成<code>clean</code>这个文件，刚才说过，只要执行了命令列表就算更新了目标，即使目标并没有生成也算。在这个例子还演示了命令前面加<code>@</code>和<code>-</code>字符的效果：如果<code>make</code>执行的命令前面加了<code>@</code>字符，则不显示命令本身而只显示它的结果；通常<code>make</code>执行的命令如果出错（该命令的退出状态非0）就立刻终止，不再执行后续命令，但如果命令前面加了<code>-</code>号，即使这条命令出错，<code>make</code>也会继续执行后续命令。通常<code>rm</code>命令和<code>mkdir</code>命令前面要加<code>-</code>号，因为<code>rm</code>要删除的文件可能不存在，<code>mkdir</code>要创建的目录可能已存在，这两个命令都有可能出错，但这种错误是应该忽略的。例如上面已经执行过一遍<code>make clean</code>，再执行一遍就没有文件可删了，这时<code>rm</code>会报错，但<code>make</code>忽略这一错误，继续执行后面的<code>echo</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span> </span><br><span class="line">cleanning project</span><br><span class="line">rm main *.o</span><br><span class="line">rm: cannot remove `main&#x27;: No such file or directory</span><br><span class="line">rm: cannot remove `*.o&#x27;: No such file or directory</span><br><span class="line">make: [clean] Error 1 (ignored)</span><br><span class="line">clean completed</span><br></pre></td></tr></table></figure>
<p>读者可以把命令前面的<code>@</code>和<code>-</code>去掉再试试，对比一下结果有何不同。这里还有一个问题，如果当前目录下存在一个文件叫<code>clean</code>会怎么样呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make clean</span></span><br><span class="line">make: `clean&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p>如果存在<code>clean</code>这个文件，<code>clean</code>目标又不依赖于任何条件，<code>make</code>就认为它不需要更新了。而我们希望把<code>clean</code>当作一个特殊的名字使用，不管它存在不存在都要更新，可以添一条特殊规则，把<code>clean</code>声明为一个伪目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这条规则没有命令列表。类似<code>.PHONY</code>这种<code>make</code>内建的特殊目标还有很多，各有不同的用途，详见[GNUmake]。在C语言中要求变量和函数先声明后使用，而Makefile不太一样，这条规则写在<code>clean</code>:规则的后面也行，也能起到声明<code>clean</code>是伪目标的作用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    @echo &quot;cleanning project&quot;</span><br><span class="line">    -rm main *.o</span><br><span class="line">    @echo &quot;clean completed&quot;</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>当然写在前面也行。gcc处理一个C程序分为预处理和编译两个阶段，类似地，<code>make</code>处理Makefile的过程也分为两个阶段：</p>
<p>首先从前到后读取所有规则，建立起一个完整的依赖关系图，例如：</p>
<figure>
<img src="C:\blog\Blog\images\C\make.graph.png"
alt="Makefile的依赖关系图" />
<figcaption aria-hidden="true">Makefile的依赖关系图</figcaption>
</figure>
<p>然后从缺省目标或者命令行指定的目标开始，根据依赖关系图选择适当的规则执行，执行Makefile中的规则和执行C代码不一样，并不是从前到后按顺序执行，也不是所有规则都要执行一遍，例如<code>make</code>缺省目标时不会更新<code>clean</code>目标，因为从上图可以看出，它跟缺省目标没有任何依赖关系。</p>
<p><code>clean</code>目标是一个约定俗成的名字，在所有软件项目的Makefile中都表示清除编译生成的文件，类似这样的约定俗成的目标名字有：</p>
<p><code>all</code>，执行主要的编译工作，通常用作缺省目标。</p>
<p><code>install</code>，执行编译后的安装工作，把可执行文件、配置文件、文档等分别拷到不同的安装目录。</p>
<p><code>clean</code>，删除编译生成的二进制文件。</p>
<p><code>distclean</code>，不仅删除编译生成的二进制文件，也删除其它生成的文件，例如配置文件和格式转换后的文档，执行<code>make distclean</code>之后应该清除所有这些文件，只留下源文件。</p>
<h2 id="隐含规则和模式规则">隐含规则和模式规则</h2>
<p>上一节的Makefile写得中规中矩，比较繁琐，是为了讲清楚基本概念，其实Makefile有很多灵活的写法，可以写得更简洁，同时减少出错的可能。本节我们来看看这样一个例子还有哪些改进的余地。</p>
<p>一个目标依赖的所有条件不一定非得写在一条规则中，也可以拆开写，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure>
<p>就相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">    gcc -c main.c</span><br></pre></td></tr></table></figure>
<p>如果一个目标拆开写多条规则，其中只有一条规则允许有命令列表，其它规则应该没有命令列表，否则<code>make</code>会报警告并且采用最后一条规则的命令列表。</p>
<p>这样我们的例子可以改写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line">stack.o: stack.c</span><br><span class="line">    gcc -c stack.c</span><br><span class="line"></span><br><span class="line">maze.o: maze.c</span><br><span class="line">    gcc -c maze.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这不是比原来更繁琐了吗？现在可以把提出来的三条规则删去，写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>这就比原来简单多了。可是现在<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个目标连编译命令都没有了，怎么编译的呢？试试看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>现在解释一下前三条编译命令是怎么来。如果一个目标在Makefile中的所有规则都没有命令列表，<code>make</code>会尝试在内建的隐含规则（Implicit
Rule）数据库中查找适用的规则。<code>make</code>的隐含规则数据库可以用<code>make -p</code>命令打印，打印出来的格式也是Makefile的格式，包括很多变量和规则，其中和我们这个例子有关的隐含规则有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">OUTPUT_OPTION = -o $@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">CC = cc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default</span></span><br><span class="line">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> commands to execute (built-in):</span></span><br><span class="line">        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</span><br></pre></td></tr></table></figure>
<p><code>#</code>号在Makefile中表示单行注释，就像C语言的<code>//</code>注释一样。<code>CC</code>是一个Makefile变量，用<code>CC = cc</code>定义和赋值，用<code>$(CC)</code>取它的值，其值应该是<code>cc</code>。Makefile变量像C的宏定义一样，代表一串字符，在取值的地方展开。<code>cc</code>是一个符号链接，通常指向gcc，在有些UNIX系统上可能指向另外一种C编译器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> cc</span></span><br><span class="line">/usr/bin/cc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /usr/bin/cc</span></span><br><span class="line">lrwxrwxrwx 1 root root 20 2008-07-04 05:59 /usr/bin/cc -&gt; /etc/alternatives/cc</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /etc/alternatives/cc</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 2008-11-01 09:10 /etc/alternatives/cc -&gt; /usr/bin/gcc</span><br></pre></td></tr></table></figure>
<p><code>CFLAGS</code>这个变量没有定义，<code>$(CFLAGS)</code>展开是空，<code>CPPFLAGS</code>和<code>TARGET_ARCH</code>也是如此。这样<code>$(COMPILE.c)</code>展开应该是<code>cc␣空␣空␣空␣-c</code>，去掉所有的“<code>空</code>”得到<code>cc␣␣␣␣-c</code>，注意中间留下4个空格，所以<code>%.o: %.c</code>规则的命令<code>$(COMPILE.c)␣$(OUTPUT_OPTION)␣$&lt;</code>展开之后是<code>cc␣␣␣␣-c␣-o␣$@␣$&lt;</code>，和上面的编译命令已经很接近了。</p>
<p><code>$@</code>和<code>$&lt;</code>是两个特殊的变量，<code>$@</code>的取值为规则中的目标，<code>$&lt;</code>的取值为规则中的第一个条件。<code>%.o: %.c</code>是一种特殊的规则，称为模式规则（Pattern
Rule）。现在回顾一下整个过程，在我们的Makefile中以<code>main.o</code>为目标的规则都没有命令列表，所以<code>make</code>会查找隐含规则，发现隐含规则中有这样一条模式规则适用，<code>main.o</code>符合<code>%.o</code>的模式，现在<code>%</code>就代表<code>main</code>（称为<code>main.o</code>这个名字的Stem），再替换到<code>%.c</code>中就是<code>main.c</code>。所以这条模式规则相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">    cc    -c -o main.o main.c</span><br></pre></td></tr></table></figure>
<p>随后，在处理<code>stack.o</code>目标时又用到这条模式规则，这时又相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack.o: stack.c</span><br><span class="line">    cc    -c -o stack.o stack.c</span><br></pre></td></tr></table></figure>
<p><code>maze.o</code>也同样处理。这三条规则可以由<code>make</code>的隐含规则推导出来，所以不必写在Makefile中。</p>
<p>先前我们写Makefile都是以目标为中心，一个目标依赖于若干条件，现在换个角度，以条件为中心，Makefile还可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br><span class="line"></span><br><span class="line">main.o stack.o maze.o: main.h</span><br><span class="line">main.o maze.o: maze.h</span><br><span class="line">main.o stack.o: stack.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>我们知道，写规则的目的是让<code>make</code>建立依赖关系图，不管怎么写，只要把所有的依赖关系都描述清楚了就行。对于多目标的规则，<code>make</code>会拆成几条单目标的规则来处理，例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target1 target2: prerequisite1 prerequisite2</span><br><span class="line">    command $&lt; -o $@</span><br></pre></td></tr></table></figure>
<p>这样一条规则相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target1: prerequisite1 prerequisite2</span><br><span class="line">    command prerequisite1 -o target1</span><br><span class="line"></span><br><span class="line">target2: prerequisite1 prerequisite2</span><br><span class="line">    command prerequisite1 -o target2</span><br></pre></td></tr></table></figure>
<p>注意两条规则的命令列表是一样的，但<code>$@</code>的取值不同。</p>
<h2 id="变量">变量</h2>
<p>这一节我们详细看看Makefile中关于变量的语法规则。先看一个简单的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo = $(bar) </span><br><span class="line">bar = Huh? </span><br><span class="line"></span><br><span class="line">all: </span><br><span class="line">    @echo $(foo)</span><br></pre></td></tr></table></figure>
<p>我们执行<code>make</code>将会打出<code>Huh?</code>。当<code>make</code>读到<code>foo = $(bar)</code>时，确定<code>foo</code>的值是<code>$(bar)</code>，但并不立即展开<code>$(bar)</code>，然后读到<code>bar = Huh?</code>，确定<code>bar</code>的值是<code>Huh?</code>，然后在执行规则<code>all:</code>的命令列表时才需要展开<code>$(foo)</code>，得到<code>$(bar)</code>，再展开<code>$(bar)</code>，得到<code>Huh?</code>。因此，虽然<code>bar</code>的定义写在<code>foo</code>之后，<code>$(foo)</code>展开还是能够取到<code>$(bar)</code>的值。</p>
<p>这种特性有好处也有坏处。好处是我们可以把变量的值推迟到后面定义，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt;</span><br><span class="line"></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -O -g</span><br><span class="line">CPPFLAGS = -Iinclude</span><br></pre></td></tr></table></figure>
<p>编译命令可以展开成<code>gcc -O -g -Iinclude -c main.c</code>。通常把<code>CFLAGS</code>定义成一些编译选项，例如<code>-O</code>、<code>-g</code>等，而把<code>CPPFLAGS</code>定义成一些预处理选项，例如<code>-D</code>、<code>-I</code>等。用<code>=</code>号定义变量的延迟展开特性也有坏处，就是有可能写出无穷递归的定义，例如<code>CFLAGS = $(CFLAGS) -O</code>，或者：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = $(B)</span><br><span class="line">B = $(A)</span><br></pre></td></tr></table></figure>
<p>当然，<code>make</code>有能力检测出这样的错误而不会陷入死循环。有时候我们希望<code>make</code>在遇到变量定义时立即展开，可以用<code>:=</code>运算符，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line"></span><br><span class="line">all: </span><br><span class="line">    @echo &quot;-$(y)-&quot;</span><br></pre></td></tr></table></figure>
<p>当<code>make</code>读到<code>y := $(x) bar</code>定义时，立即把<code>$(x)</code>展开，使变量<code>y</code>的取值是<code>foo bar</code>，如果把这两行颠倒过来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := $(x) bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>那么当<code>make</code>读到<code>y := $(x) bar</code>时，<code>x</code>还没有定义，展开为空值，所以<code>y</code>的取值是<code>␣bar</code>，注意<code>bar</code>前面有个空格。一个变量的定义从<code>=</code>后面的第一个非空白字符开始（从<code>$(x)</code>的<code>$</code>开始），包括后面的所有字符，直到注释或换行之前结束。如果要定义一个变量的值是一个空格，可以这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring := </span><br><span class="line">space := $(nullstring) # end of the line</span><br></pre></td></tr></table></figure>
<p><code>nullstring</code>的值为空，<code>space</code>的值是一个空格，后面写个注释是为了增加可读性，如果不写注释就换行，则很难看出<code>$(nullstring)</code>后面有个空格。</p>
<p>还有一个比较有用的赋值运算符是<code>?=</code>，例如<code>foo ?= $(bar)</code>的意思是：如果<code>foo</code>没有定义过，那么<code>?=</code>相当于<code>=</code>，定义<code>foo</code>的值是<code>$(bar)</code>，但不立即展开；如果先前已经定义了<code>foo</code>，则什么也不做，不会给<code>foo</code>重新赋值。</p>
<p><code>+=</code>运算符可以给变量追加值，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o</span><br><span class="line">objects += $(foo)</span><br><span class="line">foo = foo.o bar.o</span><br></pre></td></tr></table></figure>
<p><code>object</code>是用<code>=</code>定义的，<code>+=</code>仍然保持<code>=</code>的特性，<code>objects</code>的值是<code>main.o $(foo)</code>（注意<code>$(foo)</code>前面自动添一个空格），但不立即展开，等到后面需要展开<code>$(objects)</code>时会展开成<code>main.o foo.o bar.o</code>。</p>
<p>再比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects := main.o</span><br><span class="line">objects += $(foo)</span><br><span class="line">foo = foo.o bar.o</span><br></pre></td></tr></table></figure>
<p><code>object</code>是用<code>:=</code>定义的，<code>+=</code>保持<code>:=</code>的特性，<code>objects</code>的值是<code>main.o $(foo)</code>，立即展开得到<code>main.o</code>
（这时<code>foo</code>还没定义），注意<code>main.o</code>后面的空格仍保留。</p>
<p>如果变量还没有定义过就直接用<code>+=</code>赋值，那么<code>+=</code>相当于<code>=</code>。</p>
<p>上一节我们用到了特殊变量<code>$@</code>和<code>$&lt;</code>，这两个变量的特点是不需要给它们赋值，在不同的上下文中它们自动取不同的值。常用的特殊变量有：</p>
<p><code>$@</code>，表示规则中的目标。</p>
<p><code>$&lt;</code>，表示规则中的第一个条件。</p>
<p><code>$?</code>，表示规则中所有比目标新的条件，组成一个列表，以空格分隔。</p>
<p><code>$^</code>，表示规则中的所有条件，组成一个列表，以空格分隔。</p>
<p>例如前面写过的这条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>可以改写成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br></pre></td></tr></table></figure>
<p>这样即使以后又往条件里添加了新的目标文件，编译命令也不需要修改，减少了出错的可能。</p>
<p><code>$?</code>变量也很有用，有时候希望只对更新过的条件进行操作，例如有一个库文件<code>libsome.a</code>依赖于几个目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libsome.a: foo.o bar.o lose.o win.o </span><br><span class="line">    ar r libsome.a $?</span><br><span class="line">    ranlib libsome.a</span><br></pre></td></tr></table></figure>
<p>这样，只有更新过的目标文件才需要重新打包到<code>libsome.a</code>中，没更新过的目标文件原本已经在<code>libsome.a</code>中了，不必重新打包。</p>
<p>在上一节我们看到<code>make</code>的隐含规则数据库中用到了很多变量，有些变量没有定义（例如<code>CFLAGS</code>），有些变量定义了缺省值（例如<code>CC</code>），我们写Makefile时可以重新定义这些变量的值，也可以在缺省值的基础上追加。以下列举一些常用的变量，请读者体会其中的规律。</p>
<p><code>AR</code> 静态库打包命令的名字，缺省值是<code>ar</code>。</p>
<p><code>ARFLAGS</code>
静态库打包命令的选项，缺省值是<code>rv</code>。</p>
<p><code>AS</code> 汇编器的名字，缺省值是<code>as</code>。</p>
<p><code>ASFLAGS</code> 汇编器的选项，没有定义。</p>
<p><code>CC</code> C编译器的名字，缺省值是<code>cc</code>。</p>
<p><code>CFLAGS</code> C编译器的选项，没有定义。</p>
<p><code>CXX</code> C++编译器的名字，缺省值是<code>g++</code>。</p>
<p><code>CXXFLAGS</code> C++编译器的选项，没有定义。</p>
<p><code>CPP</code> C预处理器的名字，缺省值是<code>$(CC) -E</code>。</p>
<p><code>CPPFLAGS</code> C预处理器的选项，没有定义。</p>
<p><code>LD</code> 链接器的名字，缺省值是<code>ld</code>。</p>
<p><code>LDFLAGS</code> 链接器的选项，没有定义。</p>
<p><code>TARGET_ARCH</code> 和目标平台相关的命令行选项，没有定义。</p>
<p><code>OUTPUT_OPTION</code>
输出的命令行选项，缺省值是<code>-o $@</code>。</p>
<p><code>LINK.o</code>
把.o文件链接在一起的命令行，缺省值是<code>$(CC) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>LINK.c</code>
把.c文件链接在一起的命令行，缺省值是<code>$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>LINK.cc</code>
把.cc文件（C++源文件）链接在一起的命令行，缺省值是<code>$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p>
<p><code>COMPILE.c</code>
编译.c文件的命令行，缺省值是<code>$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p>
<p><code>COMPILE.cc</code>
编译.cc文件的命令行，缺省值是<code>$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p>
<p><code>RM</code> 删除命令的名字，缺省值是<code>rm -f</code>。</p>
<h2 id="自动处理头文件的依赖关系">自动处理头文件的依赖关系</h2>
<p>现在我们的Makefile写成这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">all: main</span><br><span class="line"></span><br><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br><span class="line"></span><br><span class="line">main.o: main.h stack.h maze.h</span><br><span class="line">stack.o: stack.h main.h</span><br><span class="line">maze.o: maze.h main.h</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>按照惯例，用<code>all</code>做缺省目标。现在还有一点比较麻烦，在写<code>main.o</code>、<code>stack.o</code>和<code>maze.o</code>这三个目标的规则时要查看源代码，找出它们依赖于哪些头文件，这很容易出错，一是因为有的头文件包含在另一个头文件中，在写规则时很容易遗漏，二是如果以后修改源代码改变了依赖关系，很可能忘记修改Makefile的规则。为了解决这个问题，可以用gcc的<code>-M</code>选项自动生成目标文件和源文件的依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -M main.c</span></span><br><span class="line">main.o: main.c /usr/include/stdio.h /usr/include/features.h \</span><br><span class="line">  /usr/include/sys/cdefs.h /usr/include/bits/wordsize.h \</span><br><span class="line">  /usr/include/gnu/stubs.h /usr/include/gnu/stubs-32.h \</span><br><span class="line">  /usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h \</span><br><span class="line">  /usr/include/bits/types.h /usr/include/bits/typesizes.h \</span><br><span class="line">  /usr/include/libio.h /usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line">  /usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h \</span><br><span class="line">  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h main.h \</span><br><span class="line">  stack.h maze.h</span><br></pre></td></tr></table></figure>
<p><code>-M</code>选项把<code>stdio.h</code>以及它所包含的系统头文件也找出来了，如果我们不需要输出系统头文件的依赖关系，可以用<code>-MM</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -MM *.c</span></span><br><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line">maze.o: maze.c maze.h main.h</span><br><span class="line">stack.o: stack.c stack.h main.h</span><br></pre></td></tr></table></figure>
<p>接下来的问题是怎么把这些规则包含到Makefile中，GNU
make的官方手册建议这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">all: main</span><br><span class="line"></span><br><span class="line">main: main.o stack.o maze.o</span><br><span class="line">    gcc $^ -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    -rm main *.o</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">sources = main.c stack.c maze.c</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.d: %.c</span></span><br><span class="line">    set -e; rm -f $@; \</span><br><span class="line">    $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">    sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">    rm -f $@.$$$$</span><br></pre></td></tr></table></figure>
<p><code>sources</code>变量包含我们要编译的所有.c文件，<code>$(sources:.c=.d)</code>是一个变量替换语法，把<code>sources</code>变量中每一项的.c替换成.d，所以<code>include</code>这一句相当于：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include main.d stack.d maze.d</span><br></pre></td></tr></table></figure>
<p>类似于C语言的<code>#include</code>指示，这里的<code>include</code>表示包含三个文件<code>main.d</code>、<code>stack.d</code>和<code>maze.d</code>，这三个文件也应该符合Makefile的语法。如果现在你的工作目录是干净的，只有.c文件、.h文件和Makefile，运行<code>make</code>的结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">Makefile:13: main.d: No such file or directory</span><br><span class="line">Makefile:13: stack.d: No such file or directory</span><br><span class="line">Makefile:13: maze.d: No such file or directory</span><br><span class="line">set -e; rm -f maze.d; \</span><br><span class="line">    cc -MM  maze.c &gt; maze.d.$$; \</span><br><span class="line">    sed &#x27;s,\(maze\)\.o[ :]*,\1.o maze.d : ,g&#x27; &lt; maze.d.$$ &gt; maze.d; \</span><br><span class="line">    rm -f maze.d.$$</span><br><span class="line">set -e; rm -f stack.d; \</span><br><span class="line">    cc -MM  stack.c &gt; stack.d.$$; \</span><br><span class="line">    sed &#x27;s,\(stack\)\.o[ :]*,\1.o stack.d : ,g&#x27; &lt; stack.d.$$ &gt; stack.d; \</span><br><span class="line">    rm -f stack.d.$$</span><br><span class="line">set -e; rm -f main.d; \</span><br><span class="line">    cc -MM  main.c &gt; main.d.$$; \</span><br><span class="line">    sed &#x27;s,\(main\)\.o[ :]*,\1.o main.d : ,g&#x27; &lt; main.d.$$ &gt; main.d; \</span><br><span class="line">    rm -f main.d.$$</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>一开始找不到.d文件，所以<code>make</code>会报警告。但是<code>make</code>会把<code>include</code>的文件名也当作目标来尝试更新，而这些目标适用模式规则<code>%.d: %c</code>，所以执行它的命令列表，比如生成<code>maze.d</code>的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set -e; rm -f maze.d; \</span><br><span class="line">    cc -MM  maze.c &gt; maze.d.$$; \</span><br><span class="line">    sed &#x27;s,\(maze\)\.o[ :]*,\1.o maze.d : ,g&#x27; &lt; maze.d.$$ &gt; maze.d; \</span><br><span class="line">    rm -f maze.d.$$</span><br></pre></td></tr></table></figure>
<p>注意，虽然在Makefile中这个命令写了四行，但其实是一条命令，<code>make</code>只创建一个Shell进程执行这条命令，这条命令分为5个子命令，用<code>;</code>号隔开，并且为了美观，用续行符<code>\</code>拆成四行来写。执行步骤为：</p>
<p><code>set -e</code>命令设置当前Shell进程为这样的状态：如果它执行的任何一条命令的退出状态非零则立刻终止，不再执行后续命令。</p>
<p>把原来的<code>maze.d</code>删掉。</p>
<p>重新生成<code>maze.c</code>的依赖关系，保存成文件<code>maze.d.1234</code>（假设当前Shell进程的id是1234）。注意，在Makefile中<code>$</code>有特殊含义，如果要表示它的字面意思则需要写两个<code>$</code>，所以Makefile中的四个<code>$</code>传给Shell变成两个<code>$</code>，两个<code>$</code>在Shell中表示当前进程的id，一般用它给临时文件起名，以保证文件名唯一。</p>
<p>这个<code>sed</code>命令比较复杂，就不细讲了，主要作用是查找替换。<code>maze.d.1234</code>的内容应该是<code>maze.o: maze.c maze.h main.h</code>，经过<code>sed</code>处理之后存为<code>maze.d</code>，其内容是<code>maze.o maze.d: maze.c maze.h main.h</code>。</p>
<p>最后把临时文件<code>maze.d.1234</code>删掉。</p>
<p>不管是Makefile本身还是被它包含的文件，只要有一个文件在<code>make</code>过程中被更新了，<code>make</code>就会重新读取整个Makefile以及被它包含的所有文件，现在<code>main.d</code>、<code>stack.d</code>和<code>maze.d</code>都生成了，就可以正常包含进来了（假如这时还没有生成，<code>make</code>就要报错而不是报警告了），相当于在Makefile中添了三条规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d: main.c main.h stack.h maze.h</span><br><span class="line">maze.o maze.d: maze.c maze.h main.h</span><br><span class="line">stack.o stack.d: stack.c stack.h main.h</span><br></pre></td></tr></table></figure>
<p>如果我在<code>main.c</code>中加了一行<code>#include "foo.h"</code>，那么：</p>
<p>1、<code>main.c</code>的修改日期变了，根据规则<code>main.o main.d: main.c main.h stack.h maze.h</code>要重新生成<code>main.o</code>和<code>main.d</code>。生成<code>main.o</code>的规则有两条：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c main.h stack.h maze.h</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.o: %.c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> commands to execute (built-in):</span></span><br><span class="line">        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</span><br></pre></td></tr></table></figure>
<p>第一条是把规则<code>main.o main.d: main.c main.h stack.h maze.h</code>拆开写得到的，第二条是隐含规则，因此执行<code>cc</code>命令重新编译<code>main.o</code>。生成<code>main.d</code>的规则也有两条：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.d: main.c main.h stack.h maze.h</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">.d: %.c</span></span><br><span class="line">    set -e; rm -f $@; \</span><br><span class="line">    $(CC) -MM $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">    sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">    rm -f $@.$$$$</span><br></pre></td></tr></table></figure>
<p>因此<code>main.d</code>的内容被更新为<code>main.o main.d: main.c main.h stack.h maze.h foo.h</code>。</p>
<p>2、由于<code>main.d</code>被Makefile包含，<code>main.d</code>被更新又导致<code>make</code>重新读取整个Makefile，把新的<code>main.d</code>包含进来，于是新的依赖关系生效了。</p>
<h2 id="常用的make命令行选项">常用的make命令行选项</h2>
<p><code>-n</code>选项只打印要执行的命令，而不会真的执行命令，这个选项有助于我们检查Makefile写得是否正确，由于Makefile不是顺序执行的，用这个选项可以先看看命令的执行顺序，确认无误了再真正执行命令。</p>
<p><code>-C</code>选项可以切换到另一个目录执行那个目录下的Makefile，比如先退到上一级目录再执行我们的Makefile（假设我们的源代码都放在testmake目录下）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -C testmake</span></span><br><span class="line">make: Entering directory `/home/akaedu/testmake&#x27;</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc    -c -o stack.o stack.c</span><br><span class="line">cc    -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br><span class="line">make: Leaving directory `/home/akaedu/testmake&#x27;</span><br></pre></td></tr></table></figure>
<p>一些规模较大的项目会把不同的模块或子系统的源代码放在不同的子目录中，然后在每个子目录下都写一个该目录的Makefile，然后在一个总的Makefile中用<code>make -C</code>命令执行每个子目录下的Makefile。例如Linux内核源代码根目录下有Makefile，子目录fs、net等也有各自的Makefile，二级子目录fs/ramfs、net/ipv4等也有各自的Makefile。</p>
<p>在<code>make</code>命令行也可以用<code>=</code>或<code>:=</code>定义变量，如果这次编译我想加调试选项<code>-g</code>，但我不想每次编译都加<code>-g</code>选项，可以在命令行定义<code>CFLAGS</code>变量，而不必修改Makefile编译完了再改回来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make CFLAGS=-g</span></span><br><span class="line">cc -g   -c -o main.o main.c</span><br><span class="line">cc -g   -c -o stack.o stack.c</span><br><span class="line">cc -g   -c -o maze.o maze.c</span><br><span class="line">gcc main.o stack.o maze.o -o main</span><br></pre></td></tr></table></figure>
<p>如果在Makefile中也定义了<code>CFLAGS</code>变量，则命令行的值覆盖Makefile中的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:链表,二叉树和哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-09 19:14:01" itemprop="dateModified" datetime="2025-08-09T19:14:01+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="链表">链表</h2>
<h3 id="单链表">单链表</h3>
<p>图 23.6 “链表”所示的链表即单链表（Single Linked
List），本节我们学习如何创建和操作这种链表。每个链表有一个头指针，通过头指针可以找到第一个节点，每个节点都可以通过指针域找到它的后继，最后一个节点的指针域为<code>NULL</code>，表示没有后继。数组在内存中是连续存放的，而链表在内存中的布局是不规则的，我们知道访问某个数组元素<code>b[n]</code>时可以通过<code>基地址+n×每个元素的字节</code>数得到它地址，或者说数组支持随机访问，而链表是不支持随机访问的，只能通过前一个元素的指针域得知后一个元素的地址，因此只能从头指针开始顺序访问各节点。以下代码实现了单链表的基本操作。</p>
<p>例 单链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linkedlist.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">    link next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span>;</span><br><span class="line">link <span class="title function_">search</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">void</span> (*visit)(link))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(link p)</span>;</span><br><span class="line">link <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linkedlist.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linkedlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> link head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *p);</span><br><span class="line">    p-&gt;item = item;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">search</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;item == key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    head = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    link pre;</span><br><span class="line">    <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pre = head; pre; pre = pre-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;next == p) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">void</span> (*visit)(link))</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    link q, p = head;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free_node(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        link p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linkedlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_item</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;item); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = make_node(<span class="number">10</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = make_node(<span class="number">5</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = make_node(<span class="number">90</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = search(<span class="number">5</span>);</span><br><span class="line">    delete(p);</span><br><span class="line">    free_node(p);</span><br><span class="line">    traverse(print_item);</span><br><span class="line">    destroy();</span><br><span class="line"></span><br><span class="line">    p = make_node(<span class="number">100</span>);</span><br><span class="line">    push(p);</span><br><span class="line">    p = make_node(<span class="number">200</span>);</span><br><span class="line">    push(p);</span><br><span class="line">    p = make_node(<span class="number">250</span>);</span><br><span class="line">    push(p);</span><br><span class="line">    <span class="keyword">while</span> (p = pop()) &#123;</span><br><span class="line">        print_item(p);</span><br><span class="line">        free_node(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时把头指针<code>head</code>初始化为<code>NULL</code>，表示空链表。然后<code>main</code>函数调用<code>make_node</code>创建几个节点，分别调用<code>insert</code>插入到链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    head = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.insert.png"
alt="链表的插入操作" />
<figcaption aria-hidden="true">链表的插入操作</figcaption>
</figure>
<p>正如上图所示，<code>insert</code>函数虽然简单，其中也隐含了一种特殊情况（Special
Case）的处理，当<code>head</code>为<code>NULL</code>时，执行<code>insert</code>操作插入第一个节点之后，<code>head</code>指向第一个节点，而第一个节点的<code>next</code>指针域成为<code>NULL</code>，这很合理，因为它也是最后一个节点。所以空链表虽然是一种特殊情况，却不需要特殊的代码来处理，和一般情况用同样的代码处理即可，这样写出来的代码更简洁，但是在读代码时要想到可能存在的特殊情况。当然，<code>insert</code>函数传进来的参数<code>p</code>也可能有特殊情况，传进来的<code>p</code>可能是<code>NULL</code>，甚至是野指针，本章的函数代码都假定调用者的传进来的参数是合法的，不对参数做特别检查。事实上，对指针参数做检查是不现实的，如果传进来的是<code>NULL</code>还可以检查一下，如果传进来的是野指针，根本无法检查它指向的内存单元是不是合法的，C标准库的函数通常也不做这种检查，例如<code>strcpy(p, NULL)</code>就会引起段错误。</p>
<p>接下来<code>main</code>函数调用<code>search</code>在链表中查找某个节点，如果找到就返回指向该节点的指针，找不到就返回<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">link <span class="title function_">search</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;item == key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>search</code>函数其实也隐含了对于空链表这种特殊情况的处理，如果是空链表则循环体一次都不执行，直接返回<code>NULL</code>。</p>
<p>然后<code>main</code>函数调用<code>delete</code>从链表中摘除用<code>search</code>找到的节点，最后调用<code>free_node</code>释放它的存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    link pre;</span><br><span class="line">    <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pre = head; pre; pre = pre-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;next == p) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.delete.png"
alt="链表的删除操作" />
<figcaption aria-hidden="true">链表的删除操作</figcaption>
</figure>
<p>从上图可以看出，要摘除一个节点需要首先找到它的前趋然后才能做摘除操作，而在单链表中通过某个节点只能找到它的后继而不能找到它的前趋，所以删除操作要麻烦一些，需要从第一个节点开始依次查找要摘除的节点的前趋。delete操作也要处理一种特殊情况，如果要摘除的节点是链表的第一个节点，它是没有前趋的，这种情况要用特殊的代码处理，而不能和一般情况用同样的代码处理。这样很不爽，能不能把这种特殊情况转化为一般情况呢？可以把<code>delete</code>函数改成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    link *pnext;</span><br><span class="line">    <span class="keyword">for</span> (pnext = &amp;head; *pnext; pnext = &amp;(*pnext)-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (*pnext == p) &#123;</span><br><span class="line">            *pnext = p-&gt;next;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.pdelete.png"
alt="消除特殊情况的链表删除操作" />
<figcaption aria-hidden="true">消除特殊情况的链表删除操作</figcaption>
</figure>
<p>定义一个指向指针的指针<code>pnext</code>，在<code>for</code>循环中<code>pnext</code>遍历的是指向链表中各节点的指针域，这样就把<code>head</code>指针和各节点的<code>next</code>指针统一起来了，可以在一个循环中处理。</p>
<p>然后<code>main</code>函数调用<code>traverse</code>函数遍历整个链表，调用<code>destroy</code>函数销毁整个链表。请读者自己阅读这两个函数的代码。</p>
<p>如果限定每次只在链表的头部插入和删除元素，就形成一个LIFO的访问序列，所以在链表头部插入和删除元素的操作实现了堆栈的push和pop操作，<code>main</code>函数的最后几步把链表当成堆栈来操作，从打印的结果可以看到出栈的顺序和入栈是相反的。想一想，用链表实现的堆栈和第
2 节 “堆栈”中用数组实现的堆栈相比有什么优点和缺点？</p>
<h3 id="双向链表">双向链表</h3>
<p>链表的delete操作需要首先找到要摘除的节点的前趋，而在单链表中找某个节点的前趋需要从表头开始依次查找，对于n个节点的链表，删除操作的时间复杂度为O(n)。可以想像得到，如果每个节点再维护一个指向前趋的指针，删除操作就像插入操作一样容易了，时间复杂度为O(1)，这称为双向链表（Doubly
Linked List）。要实现双向链表只需在上一节代码的基础上改动两个地方。</p>
<p>在<code>linkedlist.h</code>中修改链表节点的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">    link prev, next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在linkedlist.c中修改insert和delete函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    <span class="keyword">if</span> (head)</span><br><span class="line">        head-&gt;prev = p;</span><br><span class="line">    head = p;</span><br><span class="line">    p-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;prev)</span><br><span class="line">        p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next)</span><br><span class="line">        p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.doubly.png" alt="双向链表" />
<figcaption aria-hidden="true">双向链表</figcaption>
</figure>
<p>由于引入了<code>prev</code>指针，<code>insert</code>和<code>delete</code>函数中都有一些特殊情况需要用特殊的代码处理，不能和一般情况用同样的代码处理，这非常不爽，如果在表头和表尾各添加一个Sentinel节点（这两个节点只用于界定表头和表尾，不保存数据），就可以把这些特殊情况都转化为一般情况了。</p>
<p>例 带Sentinel的双向链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* doublylinkedlist.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DOUBLYLINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLYLINKEDLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">	link prev, next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span>;</span><br><span class="line">link <span class="title function_">search</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">void</span> (*visit)(link))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(link p)</span>;</span><br><span class="line">link <span class="title function_">dequeue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* doublylinkedlist.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;doublylinkedlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">tailsentinel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">headsentinel</span> =</span> &#123;<span class="number">0</span>, <span class="literal">NULL</span>, &amp;tailsentinel&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">tailsentinel</span> =</span> &#123;<span class="number">0</span>, &amp;headsentinel, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> link head = &amp;headsentinel;</span><br><span class="line"><span class="type">static</span> link tail = &amp;tailsentinel;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *p);</span><br><span class="line">    p-&gt;item = item;</span><br><span class="line">    p-&gt;prev = p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">search</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">for</span> (p = head-&gt;next; p != tail; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;item == key)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next-&gt;prev = p;</span><br><span class="line">    head-&gt;next = p;</span><br><span class="line">    p-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">void</span> (*visit)(link))</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">for</span> (p = head-&gt;next; p != tail; p = p-&gt;next)</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    link q, p = head-&gt;next;</span><br><span class="line">    head-&gt;next = tail;</span><br><span class="line">    tail-&gt;prev = head;</span><br><span class="line">    <span class="keyword">while</span> (p != tail) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        free_node(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    insert(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">dequeue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail-&gt;prev == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        link p = tail-&gt;prev;</span><br><span class="line">        delete(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;doublylinkedlist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_item</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;item); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = make_node(<span class="number">10</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = make_node(<span class="number">5</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = make_node(<span class="number">90</span>);</span><br><span class="line">    insert(p);</span><br><span class="line">    p = search(<span class="number">5</span>);</span><br><span class="line">    delete(p);</span><br><span class="line">    free_node(p);</span><br><span class="line">    traverse(print_item);</span><br><span class="line">    destroy();</span><br><span class="line"></span><br><span class="line">    p = make_node(<span class="number">100</span>);</span><br><span class="line">    enqueue(p);</span><br><span class="line">    p = make_node(<span class="number">200</span>);</span><br><span class="line">    enqueue(p);</span><br><span class="line">    p = make_node(<span class="number">250</span>);</span><br><span class="line">    enqueue(p);</span><br><span class="line">    <span class="keyword">while</span> (p = dequeue()) &#123;</span><br><span class="line">        print_item(p);</span><br><span class="line">        free_node(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.sentinel.png"
alt="带Sentinel的双向链表" />
<figcaption aria-hidden="true">带Sentinel的双向链表</figcaption>
</figure>
<p>这个例子也实现了队列的enqueue和dequeue操作，现在每个节点有了<code>prev</code>指针，可以反过来在head处enqueue而在tail处dequeue了。</p>
<p>现在结合第 5 节
“环形队列”想一想，其实用链表实现环形队列是最自然的，以前基于数组实现环形队列，我们还需要“假想”它是首尾相接的，而如果基于链表实现环形队列，我们本来就可以用指针串成首尾相接的。把上面的程序改成环形链表（Circular
Linked List）也非常简单，只需要把<code>doublylinkedlist.c</code>中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">tailsentinel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">headsentinel</span> =</span> &#123;<span class="number">0</span>, <span class="literal">NULL</span>, &amp;tailsentinel&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">tailsentinel</span> =</span> &#123;<span class="number">0</span>, &amp;headsentinel, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> link head = &amp;headsentinel;</span><br><span class="line"><span class="type">static</span> link tail = &amp;tailsentinel;</span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">sentinel</span> =</span> &#123;<span class="number">0</span>, &amp;sentinel, &amp;sentinel&#125;;</span><br><span class="line"><span class="type">static</span> link head = &amp;sentinel;</span><br></pre></td></tr></table></figure>
<p>再把<code>doublylinkedlist.c</code>中所有的<code>tail</code>替换成<code>head</code>即可，相当于把<code>head</code>和<code>tail</code>合二为一了。</p>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.circular.png"
alt="环形链表" />
<figcaption aria-hidden="true">环形链表</figcaption>
</figure>
<h3 id="静态链表">静态链表</h3>
<p>回想一下我们在例 12.4
“用广度优先搜索解迷宫问题”中使用的数据结构，我把图重新画在下面。</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.bfsqueue.png"
alt="广度优先搜索的队列数据结构" />
<figcaption aria-hidden="true">广度优先搜索的队列数据结构</figcaption>
</figure>
<p>这是一个静态分配的数组，每个数组元素都有<code>row</code>、<code>col</code>和<code>predecessor</code>三个成员，<code>predecessor</code>成员保存一个数组下标，指向数组中的另一个元素，这其实也是链表的一种形式，称为静态链表，例如上图中的第6、4、2、1、0个元素串成一条链表。</p>
<h2 id="二叉树">二叉树</h2>
<h3 id="二叉树的基本概念">二叉树的基本概念</h3>
<p>链表的每个节点可以有一个后继，而二叉树（Binary
Tree）的每个节点可以有两个后继。比如这样定义二叉树的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">    link l, r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样的节点可以组织成下图所示的各种形态。</p>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.binarytree.png"
alt="二叉树的定义和举例" />
<figcaption aria-hidden="true">二叉树的定义和举例</figcaption>
</figure>
<p>二叉树可以这样递归地定义：</p>
<p>就像链表有头指针一样，每个二叉树都有一个根指针（上图中的<code>root</code>指针）指向它。根指针可以是<code>NULL</code>，表示空二叉树，或者</p>
<p>根指针可以指向一个节点，这个节点除了有数据成员之外还有两个指针域，这两个指针域又分别是另外两个二叉树（左子树和右子树）的根指针。</p>
<p>上图举例示意了几种情况。</p>
<p>单节点的二叉树：左子树和右子树都是空二叉树。</p>
<p>只有左子树的二叉树：右子树是空二叉树。</p>
<p>只有右子树的二叉树：左子树是空二叉树。</p>
<p>一般的二叉树：左右子树都不为空。注意右侧由圈和线段组成的简化图示，以后我们都采用这种简化图示法，在圈中标上该节点数据成员的值。</p>
<p>链表的遍历方法是显而易见的：从前到后遍历即可。二叉树是一种树状结构，如何做到把所有节点都走一遍不重不漏呢？有以下几种方法：</p>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.binarytraverse.png"
alt="二叉树的遍历" />
<figcaption aria-hidden="true">二叉树的遍历</figcaption>
</figure>
<p>前序（Pre-order Traversal）、中序（In-order
Traversal）、后序遍历（Post-order
Traversal）和深度优先搜索的顺序类似，层序遍历（Level-order
Traversal）和广度优先搜索的顺序类似。</p>
<p>前序和中序遍历的结果合在一起可以唯一确定二叉树的形态，也就是说根据遍历结果可以构造出二叉树。过程如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.constructbinary.png"
alt="根据前序和中序遍历结果构造二叉树" />
<figcaption
aria-hidden="true">根据前序和中序遍历结果构造二叉树</figcaption>
</figure>
<p>想一想，根据中序和后序遍历结果能否构造二叉树？根据前序和后序遍历结果能否构造二叉树？</p>
<p>例 二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* binarytree.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BINARYTREE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARYTREE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">     link l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> VLR[], <span class="type">unsigned</span> <span class="type">char</span> LVR[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">in_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">post_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(link t)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">depth</span><span class="params">(link t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(link t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* binarytree.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;binarytree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *p);</span><br><span class="line">    p-&gt;item = item;</span><br><span class="line">    p-&gt;l = p-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> VLR[], <span class="type">unsigned</span> <span class="type">char</span> LVR[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    link t;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; VLR[<span class="number">0</span>] != LVR[k]; k++);</span><br><span class="line">    t = make_node(VLR[<span class="number">0</span>]);</span><br><span class="line">    t-&gt;l = init(VLR+<span class="number">1</span>, LVR, k);</span><br><span class="line">    t-&gt;r = init(VLR+<span class="number">1</span>+k, LVR+<span class="number">1</span>+k, n-k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(t);</span><br><span class="line">    pre_order(t-&gt;l, visit);</span><br><span class="line">    pre_order(t-&gt;r, visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">in_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    in_order(t-&gt;l, visit);</span><br><span class="line">    visit(t);</span><br><span class="line">    in_order(t-&gt;r, visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">post_order</span><span class="params">(link t, <span class="type">void</span> (*visit)(link))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    post_order(t-&gt;l, visit);</span><br><span class="line">    post_order(t-&gt;r, visit);</span><br><span class="line">    visit(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(link t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(t-&gt;l) + count(t-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">depth</span><span class="params">(link t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dl, dr;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dl = depth(t-&gt;l);</span><br><span class="line">    dr = depth(t-&gt;r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (dl &gt; dr ? dl : dr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(link t)</span></span><br><span class="line">&#123;</span><br><span class="line">    post_order(t, free_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;binarytree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_item</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> pre_seq[] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> in_seq[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    link root = init(pre_seq, in_seq, <span class="number">7</span>);</span><br><span class="line">    pre_order(root, print_item);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    in_order(root, print_item);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    post_order(root, print_item);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count=%d depth=%d\n&quot;</span>, count(root), depth(root));</span><br><span class="line">    destroy(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序二叉树">排序二叉树</h3>
<p>排序二叉树（BST，Binary Search
Tree）具有这样的性质：对于二叉树中的任意节点，如果它有左子树或右子树，则该节点的数据成员大于左子树所有节点的数据成员，且小于右子树所有节点的数据成员。排序二叉树的中序遍历结果是从小到大排列的，其实上一节的图
26.10 “二叉树的遍历”就是排序二叉树。</p>
<p>例 排序二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bst.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">link</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> item;</span><br><span class="line">     link l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">search</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span>;</span><br><span class="line">link <span class="title function_">insert</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span>;</span><br><span class="line">link <span class="title function_">delete</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(link t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bst.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> link <span class="title function_">make_node</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> item)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *p);</span><br><span class="line">    p-&gt;item = item;</span><br><span class="line">    p-&gt;l = p-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_node</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">search</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;item &gt; key)</span><br><span class="line">        <span class="keyword">return</span> search(t-&gt;l, key);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;item &lt; key)</span><br><span class="line">        <span class="keyword">return</span> search(t-&gt;r, key);</span><br><span class="line">    <span class="comment">/* if (t-&gt;item == key) */</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">insert</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> make_node(key);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;item &gt; key) <span class="comment">/* insert to left subtree */</span></span><br><span class="line">        t-&gt;l = insert(t-&gt;l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* if (t-&gt;item &lt;= key), insert to right subtree */</span></span><br><span class="line">        t-&gt;r = insert(t-&gt;r, key);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link <span class="title function_">delete</span><span class="params">(link t, <span class="type">unsigned</span> <span class="type">char</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    link p;</span><br><span class="line">    <span class="keyword">if</span> (!t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;item &gt; key) <span class="comment">/* delete from left subtree */</span></span><br><span class="line">        t-&gt;l = delete(t-&gt;l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;item &lt; key) <span class="comment">/* delete from right subtree */</span></span><br><span class="line">        t-&gt;r = delete(t-&gt;r, key);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* if (t-&gt;item == key) */</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;l == <span class="literal">NULL</span> &amp;&amp; t-&gt;r == <span class="literal">NULL</span>) &#123; <span class="comment">/* if t is leaf node */</span></span><br><span class="line">            free_node(t);</span><br><span class="line">            t = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;l) &#123; <span class="comment">/* if t has left subtree */</span></span><br><span class="line">            <span class="comment">/* replace t with the rightmost node in left subtree */</span></span><br><span class="line">            <span class="keyword">for</span> (p = t-&gt;l; p-&gt;r; p = p-&gt;r);</span><br><span class="line">            t-&gt;item = p-&gt;item;</span><br><span class="line">            t-&gt;l = delete(t-&gt;l, t-&gt;item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* if t has right subtree */</span></span><br><span class="line">            <span class="comment">/* replace t with the leftmost node in right subtree */</span></span><br><span class="line">            <span class="keyword">for</span> (p = t-&gt;r; p-&gt;l; p = p-&gt;l);</span><br><span class="line">            t-&gt;item = p-&gt;item;</span><br><span class="line">            t-&gt;r = delete(t-&gt;r, t-&gt;item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(link t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t-&gt;item);</span><br><span class="line">        print_tree(t-&gt;l);</span><br><span class="line">        print_tree(t-&gt;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_item</span><span class="params">(link p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, key;</span><br><span class="line">    link root = <span class="literal">NULL</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        root = insert(root, rand() % RANGE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t\\tree&quot;</span>);</span><br><span class="line">    print_tree(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        key = rand() % RANGE;</span><br><span class="line">        <span class="keyword">if</span> (search(root, key)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;delete %d in tree\n&quot;</span>, key);</span><br><span class="line">            root = delete(root, key);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\\tree&quot;</span>);</span><br><span class="line">            print_tree(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">    \tree(83(77(15()(35()()))())(86()(93()())))</span><br><span class="line"></span><br><span class="line">delete 86 in tree</span><br><span class="line">    \tree(83(77(15()(35()()))())(93()()))</span><br><span class="line"></span><br><span class="line">delete 35 in tree</span><br><span class="line">    \tree(83(77(15()())())(93()()))</span><br><span class="line"></span><br><span class="line">delete 93 in tree</span><br><span class="line">    \tree(83(77(15()())())())</span><br><span class="line"></span><br><span class="line">delete 15 in tree</span><br><span class="line">    \tree(83(77()())())</span><br><span class="line"></span><br><span class="line">delete 83 in tree</span><br><span class="line">    \tree(77()())</span><br><span class="line"></span><br><span class="line">delete 77 in tree</span><br><span class="line">    \tree()</span><br></pre></td></tr></table></figure>
<p>程序的运行结果可以用Greg Lee编写的The Tree
Preprocessor（http://www.essex.ac.uk/linguistics/clmt/latex4ling/trees/tree/）转换成树形：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out | ./tree/tree</span></span><br><span class="line">         83</span><br><span class="line">          ___|___</span><br><span class="line">          |     |</span><br><span class="line">          77    86</span><br><span class="line">         _|__  _|__</span><br><span class="line">         |  |  |  |</span><br><span class="line">         15       93</span><br><span class="line">        _|__     _|__</span><br><span class="line">        |  |     |  |</span><br><span class="line">           35</span><br><span class="line">          _|__</span><br><span class="line">          |  |</span><br><span class="line"></span><br><span class="line">delete 86 in tree</span><br><span class="line">         83</span><br><span class="line">          ___|___</span><br><span class="line">          |     |</span><br><span class="line">          77    93</span><br><span class="line">         _|__  _|__</span><br><span class="line">         |  |  |  |</span><br><span class="line">         15</span><br><span class="line">        _|__</span><br><span class="line">        |  |</span><br><span class="line">           35</span><br><span class="line">          _|__</span><br><span class="line">          |  |</span><br><span class="line"></span><br><span class="line">delete 35 in tree</span><br><span class="line">         83</span><br><span class="line">          ___|___</span><br><span class="line">          |     |</span><br><span class="line">          77    93</span><br><span class="line">         _|__  _|__</span><br><span class="line">         |  |  |  |</span><br><span class="line">         15</span><br><span class="line">        _|__</span><br><span class="line">        |  |</span><br><span class="line"></span><br><span class="line">delete 93 in tree</span><br><span class="line">       83</span><br><span class="line">          _|__</span><br><span class="line">          |  |</span><br><span class="line">          77</span><br><span class="line">         _|__</span><br><span class="line">         |  |</span><br><span class="line">         15</span><br><span class="line">        _|__</span><br><span class="line">        |  |</span><br><span class="line"></span><br><span class="line">delete 15 in tree</span><br><span class="line">      83</span><br><span class="line">         _|__</span><br><span class="line">         |  |</span><br><span class="line">         77</span><br><span class="line">        _|__</span><br><span class="line">        |  |</span><br><span class="line"></span><br><span class="line">delete 83 in tree</span><br><span class="line">     77</span><br><span class="line">        _|__</span><br><span class="line">        |  |</span><br><span class="line"></span><br><span class="line">delete 77 in tree</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<p>下图示意了哈希表（Hash Table）这种数据结构。</p>
<figure>
<img src="C:\blog\Blog\images\C\linkedlist.hashtab.png" alt="哈希表" />
<figcaption aria-hidden="true">哈希表</figcaption>
</figure>
<p>如上图所示，首先分配一个指针数组，数组的每个元素是一个链表的头指针，每个链表称为一个槽（Slot）。哪个数据应该放入哪个槽中由哈希函数决定，在这个例子中我们简单地选取哈希函数<code>h(x) = x % 11</code>，这样任意数据<code>x</code>都可以映射成0~10之间的一个数，就是槽的编号，将数据放入某个槽的操作就是链表的插入操作。</p>
<p>如果每个槽里至多只有一个数据，可以想像这种情况下search、insert和delete操作的时间复杂度都是O(1)，但有时会有多个数据被哈希函数映射到同一个槽中，这称为碰撞（Collision），设计一个好的哈希函数可以把数据比较均匀地分布到各个槽中，尽量避免碰撞。如果能把n个数据比较均匀地分布到m个槽中，每个糟里约有n/m个数据，则search、insert和delete和操作的时间复杂度都是O(n/m)，如果n和m的比是常数，则时间复杂度仍然是O(1)。一般来说，要处理的数据越多，构造哈希表时分配的槽也应该越多，所以n和m成正比这个假设是成立的。</p>
<p>请读者自己编写程序构造这样一个哈希表，并实现search、insert和delete操作。</p>
<p>如果用我们学过的各种数据结构来表示n个数据的集合，下表是search、insert和delete操作在平均情况下的时间复杂度比较。</p>
<p>表
各种数据结构的search、insert和delete操作在平均情况下的时间复杂度比较</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>search</th>
<th>insert</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>O(n)，有序数组折半查找是O(lgn)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>排序二叉树</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
</tr>
<tr>
<td>哈希表（n与槽数m成正比）</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:C标准库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-09 18:56:44" itemprop="dateModified" datetime="2025-08-09T18:56:44+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在前面的各章中我们已经见过C标准库的一些用法，总结如下：</p>
<p>我们最常用的是包含<code>stdio.h</code>，使用其中声明的<code>printf</code>函数，这个函数在<code>libc</code>中实现，程序在运行时要动态链接<code>libc</code>共享库。</p>
<p>在第 1 节
“数学函数”中用到了<code>math.h</code>中声明的<code>sin</code>和<code>log</code>函数，使用这些函数需要动态链接<code>libm</code>共享库。</p>
<p>在第 2 节
“数组应用实例：统计随机数”中用到了<code>stdlib.h</code>中声明的<code>rand</code>函数，还提到了这个头文件中定义的<code>RAND_MAX</code>常量，在例
8.5
“剪刀石头布”中用到了<code>stdlib.h</code>中声明的<code>srand</code>函数和<code>time.h</code>中声明的<code>time</code>函数。使用这些函数需要动态链接<code>libc</code>共享库。</p>
<p>在第 2 节
“main函数和启动例程”中用到了<code>stdlib.h</code>中声明的<code>exit</code>函数，使用这个函数需要动态链接<code>libc</code>共享库。</p>
<p>在第 6 节
“折半查找”中用到了<code>assert.h</code>中定义的<code>assert</code>宏，在第
4 节
“其它预处理特性”中我们看到了这个宏的一种实现，它的实现需要调用<code>stdio.h</code>和<code>stdlib.h</code>中声明的函数，所以使用这个宏也需要动态链接<code>libc</code>共享库。</p>
<p>在第 2.4 节
“sizeof运算符与typedef类型声明”中提到了<code>size_t</code>类型在<code>stddef.h</code>中定义，在第
1 节
“指针的基本概念”中提到了<code>NULL</code>指针也在<code>stddef.h</code>中定义。</p>
<p>在第 1 节
“本章的预备知识”中介绍了<code>stdlib.h</code>中声明的<code>malloc</code>和<code>free</code>函数以及<code>string.h</code>中声明的<code>strcpy</code>和<code>strncpy</code>函数，使用这些函数需要动态链接<code>libc</code>共享库。</p>
<p>在第 6 节
“可变参数”中介绍了<code>stdarg.h</code>中定义的<code>va_list</code>类型和<code>va_arg</code>、<code>va_start</code>、<code>va_end</code>等宏定义，并给出了一种实现，这些宏定义的实现并没有调用库函数，所以不依赖于某个共享库，这一点和<code>assert</code>不同。</p>
<p>总结一下，Linux平台提供的C标准库包括：</p>
<p>一组头文件，定义了很多类型和宏，声明了很多库函数。这些头文件放在哪些目录下取决于不同的编译器，在我的系统上，<code>stdarg.h</code>和<code>stddef.h</code>位于/usr/lib/gcc/i486-linux-gnu/4.3.2/include目录下，<code>stdio.h</code>、<code>stdlib.h</code>、<code>time.h</code>、<code>math.h</code>、<code>assert.h</code>位于/usr/include目录下。C99标准定义的头文件有24个，本书只介绍其中最基本、最常用的几个。</p>
<p>一组库文件，提供了库函数的实现。大多数库函数在<code>libc</code>共享库中，有些库函数在另外的共享库中，例如数学函数在<code>libm</code>中。在第
4 节
“共享库”讲过，通常<code>libc</code>共享库是/lib/libc.so.6，而我的系统启用了hwcap机制，<code>libc</code>共享库是/lib/tls/i686/cmov/libc.so.6。</p>
<p>本章介绍另外一些最基本和最常用的库函数（包括一些不属于C标准但在UNIX平台上很常用的函数），写这一章是为了介绍字符串操作和文件操作的基本概念，而不是为了写一本C标准库函数的参考手册，Man
Page已经是一本很好的手册了，读者学完这一章之后在开发时应该查阅Man
Page，而不是把我这一章当参考手册来翻，所以本章不会面面俱到介绍所有的库函数，对于本章讲到的函数有些也不会讲得很细，因为我假定读者经过上一章的学习再结合我讲过的基本概念已经能看懂相关的Man
Page了。很多技术书的作者给自己的书太多定位，既想写成一本入门教程，又想写成一本参考手册，我觉得这样不好，读者过于依赖技术书就失去了看真正的手册的能力。</p>
<h2 id="字符串操作函数">字符串操作函数</h2>
<p>程序按功能划分可分为数值运算、符号处理和I/O操作三类，符号处理程序占相当大的比例，符号处理程序无处不在，编译器、浏览器、Office套件等程序的主要功能都是符号处理。无论多复杂的符号处理都是由各种基本的字符串操作组成的，本节介绍如何用C语言的库函数做字符串初始化、取长度、拷贝、连接、比较、搜索等基本操作。</p>
<h3 id="初始化字符串">初始化字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：<code>s</code>指向哪，返回的指针就指向哪</p>
<p><code>memset</code>函数把<code>s</code>所指的内存地址开始的n个字节都填充为<code>c</code>的值。通常<code>c</code>的值为0，把一块内存区清零。例如定义<code>char buf[10];</code>，如果它是全局变量或静态变量，则自动初始化为0（位于<code>.bss</code>段），如果它是函数的局部变量，则初值不确定，可以用<code>memset(buf, 0, 10)</code>清零，由<code>malloc</code>分配的内存初值也是不确定的，也可以用<code>memset</code>清零。</p>
<h3 id="取字符串的长度">取字符串的长度</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：字符串的长度</p>
<p><code>strlen</code>函数返回<code>s</code>所指的字符串的长度。该函数从<code>s</code>所指的第一个字符开始找<code>'\0'</code>字符，一旦找到就返回，返回的长度不包括<code>'\0'</code>字符在内。例如定义<code>char buf[] = "hello";</code>，则<code>strlen(buf)</code>的值是5，但要注意，如果定义<code>char buf[5] = "hello";</code>，则调用<code>strlen(buf)</code>是危险的，会造成数组访问越界。</p>
<h3 id="拷贝字符串">拷贝字符串</h3>
<p>在第 1 节
“本章的预备知识”中介绍了<code>strcpy</code>和<code>strncpy</code>函数，拷贝以<code>'\0'</code>结尾的字符串，<code>strncpy</code>还带一个参数指定最多拷贝多少个字节，此外，<code>strncpy</code>并不保证缓冲区以<code>'\0'</code>结尾。现在介绍<code>memcpy</code>和<code>memmove</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：<code>dest</code>指向哪，返回的指针就指向哪</p>
<p><code>memcpy</code>函数从<code>src</code>所指的内存地址拷贝n个字节到<code>dest</code>所指的内存地址，和<code>strncpy</code>不同，<code>memcpy</code>并不是遇到<code>'\0'</code>就结束，而是一定会拷贝完n个字节。这里的命名规律是，以<code>str</code>开头的函数处理以<code>'\0'</code>结尾的字符串，而以<code>mem</code>开头的函数则不关心<code>'\0'</code>字符，或者说这些函数并不把参数当字符串看待，因此参数的指针类型是<code>void *</code>而非<code>char *</code>。</p>
<p><code>memmove</code>也是从<code>src</code>所指的内存地址拷贝n个字节到<code>dest</code>所指的内存地址，虽然叫<code>move</code>但其实也是拷贝而非移动。但是和<code>memcpy</code>有一点不同，<code>memcpy</code>的两个参数<code>src</code>和<code>dest</code>所指的内存区间如果重叠则无法保证正确拷贝，而<code>memmove</code>却可以正确拷贝。假设定义了一个数组<code>char buf[20] = "hello world\n";</code>，如果想把其中的字符串往后移动一个字节（变成<code>"hhello world\n"</code>），调用<code>memcpy(buf + 1, buf, 13)</code>是无法保证正确拷贝的：</p>
<p>例 错误的memcpy调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>] = <span class="string">&quot;hello world\n&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + <span class="number">1</span>, buf, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的机器上运行的结果是<code>hhhllooworrd</code>。如果把代码中的<code>memcpy</code>改成<code>memmove</code>则可以保证正确拷贝。<code>memmove</code>可以这样实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *d = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = src;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        temp[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        d[i] = temp[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借助于一个临时缓冲区<code>temp</code>，即使<code>src</code>和<code>dest</code>所指的内存区间有重叠也能正确拷贝。思考一下，如果不借助于临时缓冲区能不能正确处理重叠内存区间的拷贝？</p>
<p>用<code>memcpy</code>如果得到的结果是<code>hhhhhhhhhhhhhh</code>倒不奇怪，可为什么会得到<code>hhhllooworrd</code>这个奇怪的结果呢？根据这个结果猜测的一种可能的实现是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *d = dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = src;</span><br><span class="line">    <span class="type">int</span> *di;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *si;</span><br><span class="line">    <span class="type">int</span> r = n % <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (r--)</span><br><span class="line">        *d++ = *s++;</span><br><span class="line">    di = (<span class="type">int</span> *)d;</span><br><span class="line">    si = (<span class="type">const</span> <span class="type">int</span> *)s;</span><br><span class="line">    n /= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        *di++ = *si++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在32位的x86平台上，每次拷贝1个字节需要一条指令，每次拷贝4个字节也只需要一条指令，<code>memcpy</code>函数的实现尽可能4个字节4个字节地拷贝，因而得到上述结果。</p>
<p>C99的<code>restrict</code>关键字
我们来看一个跟<code>memcpy/memmove</code>类似的问题。下面的函数将两个数组中对应的元素相加，结果保存在第三个数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vector_add</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *x, <span class="type">const</span> <span class="type">double</span> *y, <span class="type">double</span> *result)</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)  </span><br><span class="line">        result[i] = x[i] + y[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个函数要在多处理器的计算机上执行，编译器可以做这样的优化：把这一个循环拆成两个循环，一个处理器计算<code>i</code>值从0到31的循环，另一个处理器计算<code>i</code>值从32到63的循环，这样两个处理器可以同时工作，使计算时间缩短一半。但是这样的编译优化能保证得出正确结果吗？假如<code>result</code>和<code>x</code>所指的内存区间是重叠的，<code>result[0]</code>其实是<code>x[1]</code>，<code>result[i]</code>其实是<code>x[i+1]</code>，这两个处理器就不能各干各的事情了，因为第二个处理器的工作依赖于第一个处理器的最终计算结果，这种情况下编译优化的结果是错的。这样看来编译器是不敢随便做优化了，那么多处理器提供的并行性就无法利用，岂不可惜？为此，C99引入<code>restrict</code>关键字，如果程序员把上面的函数声明为<code>void vector_add(const double *restrict x, const double *restrict y, double *restrict result)</code>，就是告诉编译器可以放心地对这个函数做优化，程序员自己会保证这些指针所指的内存区间互不重叠。</p>
<p>由于<code>restrict</code>是C99引入的新关键字，目前Linux的Man
Page还没有更新，所以都没有<code>restrict</code>关键字，本书的函数原型都取自Man
Page，所以也都没有<code>restrict</code>关键字。但在C99标准中库函数的原型都在必要的地方加了<code>restrict</code>关键字，在C99中<code>memcpy</code>的原型是<code>void *memcpy(void * restrict s1, const void * restrict s2, size_t n);</code>，就是告诉调用者，这个函数的实现可能会做些优化，编译器也可能会做些优化，传进来的指针不允许指向重叠的内存区间，否则结果可能是错的，而<code>memmove</code>的原型是<code>void *memmove(void *s1, const void *s2, size_t n);</code>，没有<code>restrict</code>关键字，说明传给这个函数的指针允许指向重叠的内存区间。在<code>restrict</code>关键字出现之前都是用自然语言描述哪些函数的参数不允许指向重叠的内存区间，例如在C89标准的库函数一章开头提到，本章描述的所有函数，除非特别说明，都不应该接收两个指针参数指向重叠的内存区间，例如调用<code>sprintf</code>时传进来的格式化字符串和结果字符串的首地址相同，诸如此类的调用都是非法的。本书也遵循这一惯例，除非像<code>memmove</code>这样特别说明之外，都表示“不允许”。</p>
<p>关于<code>restrict</code>关键字更详细的解释可以参考[BeganFORTRAN]。</p>
<p>字符串的拷贝也可以用<code>strdup(3)</code>函数，这个函数不属于C标准库，是POSIX标准中定义的，POSIX标准定义了UNIX系统的各种接口，包含C标准库的所有函数和很多其它的系统函数，在第
2 节 “C标准I/O库函数与Unbuffered I/O函数”将详细介绍POSIX标准。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：指向新分配的字符串
这个函数调用<code>malloc</code>动态分配内存，把字符串<code>s</code>拷贝到新分配的内存中然后返回。用这个函数省去了事先为新字符串分配内存的麻烦，但是用完之后要记得调用<code>free</code>释放新字符串的内存。</p>
<h3 id="连接字符串">连接字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：<code>dest</code>指向哪，返回的指针就指向哪</p>
<p><code>strcat</code>把<code>src</code>所指的字符串连接到<code>dest</code>所指的字符串后面，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> d[<span class="number">10</span>] = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(d, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, d, s);</span><br></pre></td></tr></table></figure>
<p>调用<code>strcat</code>函数后，缓冲区<code>s</code>的内容没变，缓冲区<code>d</code>中保存着字符串<code>"foobar"</code>，注意原来<code>"foo"</code>后面的<code>'\0'</code>被连接上来的字符串<code>"bar"</code>覆盖掉了，<code>"bar"</code>后面的<code>'\0'</code>仍保留。</p>
<p><code>strcat</code>和<code>strcpy</code>有同样的问题，调用者必须确保<code>dest</code>缓冲区足够大，否则会导致缓冲区溢出错误。<code>strncat</code>函数通过参数<code>n</code>指定一个长度，就可以避免缓冲区溢出错误。注意这个参数<code>n</code>的含义和<code>strncpy</code>的参数<code>n</code>不同，它并不是缓冲区<code>dest</code>的长度，而是表示最多从<code>src</code>缓冲区中取<code>n</code>个字符（不包括结尾的<code>'\0'</code>）连接到<code>dest</code>后面。如果<code>src</code>中前<code>n</code>个字符没有出现<code>'\0'</code>，则取前<code>n</code>个字符再加一个<code>'\0'</code>连接到<code>dest</code>后面，所以<code>strncat</code>总是保证<code>dest</code>缓冲区以<code>'\0'</code>结尾，这一点又和<code>strncpy</code>不同，<code>strncpy</code>并不保证<code>dest</code>缓冲区以<code>'\0'</code>结尾。所以，提供给<code>strncat</code>函数的<code>dest</code>缓冲区的大小至少应该是<code>strlen(dest)+n+1</code>个字节，才能保证不溢出。</p>
<h3 id="比较字符串">比较字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：负值表示<code>s1</code>小于<code>s2</code>，<code>0</code>表示<code>s1</code>等于<code>s2</code>，正值表示<code>s1</code>大于<code>s2</code></p>
<p><code>memcmp</code>从前到后逐个比较缓冲区<code>s1</code>和<code>s2</code>的前n个字节（不管里面有没有<code>'\0'</code>），如果<code>s1</code>和<code>s2</code>的前n个字节全都一样就返回<code>0</code>，如果遇到不一样的字节，<code>s1</code>的字节比<code>s2</code>小就返回负值，<code>s1</code>的字节比<code>s2</code>大就返回正值。</p>
<p><code>strcmp</code>把<code>s1</code>和<code>s2</code>当字符串比较，在其中一个字符串中遇到<code>'\0'</code>时结束，按照上面的比较准则，<code>"ABC"</code>比<code>"abc"</code>小，<code>"ABCD"</code>比<code>"ABC"</code>大，<code>"123A9"</code>比<code>"123B2"</code>小。</p>
<p><code>strncmp</code>的比较结束条件是：要么在其中一个字符串中遇到<code>'\0'</code>结束（类似于<code>strcmp</code>），要么比较完n个字符结束（类似于<code>memcmp</code>）。例如，<code>strncmp("ABCD", "ABC", 3)</code>的返回值是<code>0</code>，<code>strncmp("ABCD", "ABC", 4)</code>的返回值是正值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：负值表示<code>s1</code>小于<code>s2</code>，<code>0</code>表示<code>s1</code>等于<code>s2</code>，正值表示<code>s1</code>大于<code>s2</code></p>
<p>这两个函数和<code>strcmp/strncmp</code>类似，但在比较过程中忽略大小写，大写字母<code>A</code>和小写字母<code>a</code>认为是相等的。这两个函数不属于C标准库，是POSIX标准中定义的。</p>
<h3 id="搜索字符串">搜索字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：如果找到字符<code>c</code>，返回字符串<code>s</code>中指向字符<code>c</code>的指针，如果找不到就返回<code>NULL</code></p>
<p><code>strchr</code>在字符串<code>s</code>中从前到后查找字符<code>c</code>，找到字符<code>c</code>第一次出现的位置时就返回，返回值指向这个位置，如果找不到字符<code>c</code>就返回<code>NULL</code>。<code>strrchr</code>和<code>strchr</code>类似，但是从右向左找字符<code>c</code>，找到字符<code>c</code>第一次出现的位置就返回，函数名中间多了一个字母<code>r</code>可以理解为Right-to-left。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：如果找到子串，返回值指向子串的开头，如果找不到就返回<code>NULL</code></p>
<p><code>strstr</code>在一个长字符串中从前到后找一个子串（Substring），找到子串第一次出现的位置就返回，返回值指向子串的开头，如果找不到就返回<code>NULL</code>。这两个参数名很形象，在干草堆haystack中找一根针needle，按中文的说法叫大海捞针，显然haystack是长字符串，needle是要找的子串。</p>
<p>搜索子串有一个显而易见的算法，可以用两层的循环，外层循环把haystack中的每一个字符的位置依次假定为子串的开头，内层循环从这个位置开始逐个比较haystack和needle的每个字符是否相同。想想这个算法最多需要做多少次比较？其实有比这个算法高效得多的算法，有兴趣的读者可以参考[算法导论]。</p>
<h3 id="分割字符串">分割字符串</h3>
<p>很多文件格式或协议格式中会规定一些分隔符或者叫界定符（Delimiter），例如/etc/passwd文件中保存着系统的帐号信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>每条记录占一行，也就是说记录之间的分隔符是换行符，每条记录又由若干个字段组成，这些字段包括用户名、密码、用户id、组id、个人信息、主目录、登录Shell，字段之间的分隔符是:号。解析这样的字符串需要根据分隔符把字符串分割成几段，C标准库提供的<code>strtok</code>函数可以很方便地完成分割字符串的操作。tok是Token的缩写，分割出来的每一段字符串称为一个Token。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok_r</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim, <span class="type">char</span> **saveptr)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：返回指向下一个Token的指针，如果没有下一个Token了就返回<code>NULL</code></p>
<p>参数<code>str</code>是待分割的字符串，<code>delim</code>是分隔符，可以指定一个或多个分隔符，<code>strtok</code>遇到其中任何一个分隔符就会分割字符串。看下面的例子。</p>
<p>例 strtok</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;root:x::0:root:/root:/bin/bash:&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line"></span><br><span class="line">    token = strtok(str, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">    <span class="keyword">while</span> ( (token = strtok(<span class="literal">NULL</span>, <span class="string">&quot;:&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">root</span><br><span class="line">x</span><br><span class="line"><span class="number">0</span></span><br><span class="line">root</span><br><span class="line">/root</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>结合这个例子，<code>strtok</code>的行为可以这样理解：冒号是分隔符，把<code>"root:x::0:root:/root:/bin/bash:"</code>这个字符串分隔成<code>"root"</code>、<code>"x"</code>、<code>""</code>、<code>"0"</code>、<code>"root"</code>、<code>"/root"</code>、<code>"/bin/bash"</code>、<code>""</code>等几个Token，但空字符串的Token被忽略。第一次调用要把字符串首地址传给<code>strtok</code>的第一个参数，以后每次调用第一个参数只要传<code>NULL</code>就可以了，<code>strtok</code>函数自己会记住上次处理到字符串的什么位置（显然这是通过<code>strtok</code>函数中的一个静态指针变量记住的）。</p>
<p>用gdb跟踪这个程序，会发现<code>str</code>字符串被<code>strtok</code>不断修改，每次调用<code>strtok</code>把<code>str</code>中的一个分隔符改成<code>'\0'</code>，分割出一个小字符串，并返回这个小字符串的首地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Breakpoint 1 at 0x8048415: file main.c, line 5.</span><br><span class="line">Starting program: /home/akaedu/a.out </span><br><span class="line">main () at main.c:5</span><br><span class="line">5   &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">6       char str[] = &quot;root:x::0:root:/root:/bin/bash:&quot;;</span><br><span class="line">(gdb) </span><br><span class="line">9       token = strtok(str, &quot;:&quot;);</span><br><span class="line">(gdb) display str</span><br><span class="line">1: str = &quot;root:x::0:root:/root:/bin/bash:&quot;</span><br><span class="line">(gdb) n</span><br><span class="line">10      printf(&quot;%s\n&quot;, token);</span><br><span class="line">1: str = &quot;root\000x::0:root:/root:/bin/bash:&quot;</span><br><span class="line">(gdb) </span><br><span class="line">root</span><br><span class="line">11      while ( (token = strtok(NULL, &quot;:&quot;)) != NULL)</span><br><span class="line">1: str = &quot;root\000x::0:root:/root:/bin/bash:&quot;</span><br><span class="line">(gdb) </span><br><span class="line">12          printf(&quot;%s\n&quot;, token);</span><br><span class="line">1: str = &quot;root\000x\000:0:root:/root:/bin/bash:&quot;</span><br><span class="line">(gdb) </span><br><span class="line">x</span><br><span class="line">11      while ( (token = strtok(NULL, &quot;:&quot;)) != NULL)</span><br><span class="line">1: str = &quot;root\000x\000:0:root:/root:/bin/bash:&quot;</span><br></pre></td></tr></table></figure>
<p>刚才提到在<code>strtok</code>函数中应该有一个静态指针变量记住上次处理到字符串中的什么位置，所以不需要每次调用时都把字符串中的当前处理位置传给<code>strtok</code>，但是在函数中使用静态变量是不好的，以后会讲到这样的函数是不可重入的。<code>strtok_r</code>函数则不存在这个问题，它的内部没有静态变量，调用者需要自己分配一个指针变量来维护字符串中的当前处理位置，每次调用时把这个指针变量的地址传给<code>strtok_r</code>的第三个参数，告诉<code>strtok_r</code>从哪里开始处理，<code>strtok_r</code>返回时再把新的处理位置写回到这个指针变量中（这是一个Value-result参数）。<code>strtok_r</code>末尾的<code>r</code>就表示可重入（Reentrant），这个函数不属于C标准库，是在POSIX标准中定义的。关于<code>strtok_r</code>的用法Man
Page上有一个很好的例子：</p>
<p>例 strtok_r</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str1, *str2, *token, *subtoken;</span><br><span class="line">    <span class="type">char</span> *saveptr1, *saveptr2;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s string delim subdelim\n&quot;</span>,</span><br><span class="line">            argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>, str1 = argv[<span class="number">1</span>]; ; j++, str1 = <span class="literal">NULL</span>) &#123;</span><br><span class="line">        token = strtok_r(str1, argv[<span class="number">2</span>], &amp;saveptr1);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s\n&quot;</span>, j, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (str2 = token; ; str2 = <span class="literal">NULL</span>) &#123;</span><br><span class="line">            subtoken = strtok_r(str2, argv[<span class="number">3</span>], &amp;saveptr2);</span><br><span class="line">            <span class="keyword">if</span> (subtoken == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; --&gt; %s\n&quot;</span>, subtoken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out <span class="string">&#x27;a/bbb///cc;xxx:yyy:&#x27;</span> <span class="string">&#x27;:;&#x27;</span> <span class="string">&#x27;/&#x27;</span></span></span><br><span class="line">1: a/bbb///cc</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">a</span></span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">bbb</span></span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">cc</span></span><br><span class="line">2: xxx</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">xxx</span></span><br><span class="line">3: yyy</span><br><span class="line"><span class="meta prompt_"> --&gt; </span><span class="language-bash">yyy</span></span><br></pre></td></tr></table></figure>
<p><code>a/bbb///cc;xxx:yyy:</code>这个字符串有两级分隔符，一级分隔符是<code>:</code>号或<code>;</code>号，把这个字符串分割成<code>a/bbb///cc</code>、<code>xxx</code>、<code>yyy</code>三个子串，二级分隔符是<code>/</code>，只有第一个子串中有二级分隔符，它被进一步分割成<code>a</code>、<code>bbb</code>、<code>cc</code>三个子串。由于<code>strtok_r</code>不使用静态变量，而是要求调用者自己保存字符串的当前处理位置，所以这个例子可以在按一级分隔符分割整个字符串的过程中穿插着用二级分隔符分割其中的每个子串。建议读者用gdb的<code>display</code>命令跟踪<code>argv[1]</code>、<code>saveptr1</code>和<code>saveptr2</code>，以理解<code>strtok_r</code>函数的工作方式。</p>
<p>Man
Page的BUGS部分指出了用<code>strtok</code>和<code>strtok_r</code>函数需要注意的问题：</p>
<p>这两个函数要改写字符串以达到分割的效果</p>
<p>这两个函数不能用于常量字符串，因为试图改写<code>.rodata</code>段会产生段错误</p>
<p>在做了分割之后，字符串中的分隔符就被<code>'\0'</code>覆盖了</p>
<p><code>strtok</code>函数使用了静态变量，它不是线程安全的，必要时应该用可重入的<code>strtok_r</code>函数，以后再详细介绍“可重入”和“线程安全”这两个概念</p>
<h2 id="标准io库函数">标准I/O库函数</h2>
<h3 id="文件的基本概念">文件的基本概念</h3>
<p>我们已经多次用到了文件，例如源文件、目标文件、可执行文件、库文件等，现在学习如何用C标准库对文件进行读写操作，对文件的读写也属于I/O操作的一种，本节介绍的大部分函数在头文件<code>stdio.h</code>中声明，称为标准I/O库函数。</p>
<p>文件可分为文本文件（Text File）和二进制文件（Binary
File）两种，源文件是文本文件，而目标文件、可执行文件和库文件是二进制文件。文本文件是用来保存字符的，文件中的字节都是字符的某种编码（例如ASCII或UTF-8），用<code>cat</code>命令可以查看其中的字符，用vi可以编辑其中的字符，而二进制文件不是用来保存字符的，文件中的字节表示其它含义，例如可执行文件中有些字节表示指令，有些字节表示各Section和Segment在文件中的位置，有些字节表示各Segment的加载地址。</p>
<p>在第 5.1 节
“目标文件”中我们用<code>hexdump</code>命令查看过一个二进制文件。我们再做一个小实验，用vi编辑一个文件<code>textfile</code>，在其中输入<code>5678</code>然后保存退出，用<code>ls -l</code>命令可以看到它的长度是5：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l textfile</span> </span><br><span class="line">-rw-r--r-- 1 akaedu akaedu 5 2009-03-20 10:58 textfile</span><br></pre></td></tr></table></figure>
<p><code>5678</code>四个字符各占一个字节，vi会自动在文件末尾加一个换行符，所以文件长度是5。用<code>od</code>命令查看该文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">od</span> -tx1 -tc -Ax textfile</span> </span><br><span class="line">000000 35 36 37 38 0a</span><br><span class="line">         5   6   7   8  \n</span><br><span class="line">000005</span><br></pre></td></tr></table></figure>
<p><code>-tx1</code>选项表示将文件中的字节以十六进制的形式列出来，每组一个字节，<code>-tc</code>选项表示将文件中的ASCII码以字符形式列出来。和<code>hexdump</code>类似，输出结果最左边的一列是文件中的地址，默认以八进制显示，<code>-Ax</code>选项要求以十六进制显示文件中的地址。这样我们看到，这个文件中保存了5个字符，以ASCII码保存。ASCII码的范围是0~127，所以ASCII码文本文件中每个字节只用到低7位，最高位都是0。以后我们会经常用到<code>od</code>命令。</p>
<p>文本文件是一个模糊的概念。有些时候说文本文件是指用vi可以编辑出来的文件，例如/etc目录下的各种配置文件，这些文件中只包含ASCII码中的可见字符，而不包含像<code>'\0'</code>这种不可见字符，也不包含最高位是1的非ASCII码字节。从广义上来说，只要是专门保存字符的文件都算文本文件，包含不可见字符的也算，采用其它字符编码（例如UTF-8编码）的也算。</p>
<h3 id="fopenfclose">fopen/fclose</h3>
<p>在操作文件之前要用<code>fopen</code>打开文件，操作完毕要用<code>fclose</code>关闭文件。打开文件就是在操作系统中分配一些资源用于保存该文件的状态信息，并得到该文件的标识，以后用户程序就可以用这个标识对文件做各种操作，关闭文件则释放文件在操作系统中占用的资源，使文件的标识失效，用户程序就无法再操作这个文件了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回文件指针，出错返回<code>NULL</code>并设置<code>errno</code></p>
<p><code>path</code>是文件的路径名，<code>mode</code>表示打开方式。如果文件打开成功，就返回一个<code>FILE *</code>文件指针来标识这个文件。以后调用其它函数对文件做读写操作都要提供这个指针，以指明对哪个文件进行操作。<code>FILE</code>是C标准库中定义的结构体类型，其中包含该文件在内核中标识（在第
2 节 “C标准I/O库函数与Unbuffered
I/O函数”将会讲到这个标识叫做文件描述符）、I/O缓冲区和当前读写位置等信息，但调用者不必知道<code>FILE</code>结构体都有哪些成员，我们很快就会看到，调用者只是把文件指针在库函数接口之间传来传去，而文件指针所指的<code>FILE</code>结构体的成员在库函数内部维护，调用者不应该直接访问这些成员，这种编程思想在面向对象方法论中称为封装（Encapsulation）。像<code>FILE *</code>这样的指针称为不透明指针（Opaque
Pointer）或者叫句柄（Handle），<code>FILE *</code>指针就像一个把手（Handle），抓住这个把手就可以打开门或抽屉，但用户只能抓这个把手，而不能直接抓门或抽屉。</p>
<p>下面说说参数<code>path</code>和<code>mode</code>，<code>path</code>可以是相对路径也可以是绝对路径，<code>mode</code>表示打开方式是读还是写。比如<code>fp = fopen("/tmp/file2", "w");</code>表示打开绝对路径/tmp/file2，只做写操作，<code>path</code>也可以是相对路径，比如<code>fp = fopen("file.a", "r");</code>表示在当前工作目录下打开文件<code>file.a</code>，只做读操作，再比如<code>fp = fopen("../a.out", "r");</code>只读打开当前工作目录上一层目录下的<code>a.out</code>，<code>fp = fopen("Desktop/file3", "w");</code>只写打开当前工作目录下子目录Desktop下的<code>file3</code>。相对路径是相对于当前工作目录（Current
Working
Directory）的路径，每个进程都有自己的当前工作目录，Shell进程的当前工作目录可以用<code>pwd</code>命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/akaedu</span><br></pre></td></tr></table></figure>
<p>通常Linux发行版都把Shell配置成在提示符前面显示当前工作目录，例如<code>~$</code>表示当前工作目录是主目录，<code>/etc$</code>表示当前工作目录是<code>/etc</code>。用<code>cd</code>命令可以改变Shell进程的当前工作目录。在Shell下敲命令启动新的进程，则该进程的当前工作目录继承自Shell进程的当前工作目录，该进程也可以调用<code>chdir(2)</code>函数改变自己的当前工作目录。</p>
<p><code>mode</code>参数是一个字符串，由<code>rwatb+</code>六个字符组合而成，<code>r</code>表示读，<code>w</code>表示写，<code>a</code>表示追加（Append），在文件末尾追加数据使文件的尺寸增大。<code>t</code>表示文本文件，<code>b</code>表示二进制文件，有些操作系统的文本文件和二进制文件格式不同，而在UNIX系统中，无论文本文件还是二进制文件都是由一串字节组成，<code>t</code>和<code>b</code>没有区分，用哪个都一样，也可以省略不写。如果省略<code>t</code>和<code>b</code>，<code>rwa+</code>四个字符有以下6种合法的组合：</p>
<p><code>"r"</code> 只读，文件必须已存在</p>
<p><code>"w"</code>
只写，如果文件不存在则创建，如果文件已存在则把文件长度截断（Truncate）为0字节再重新写，也就是替换掉原来的文件内容</p>
<p><code>"a"</code> 只能在文件末尾追加数据，如果文件不存在则创建</p>
<p><code>"r+"</code> 允许读和写，文件必须已存在</p>
<p><code>"w+"</code>
允许读和写，如果文件不存在则创建，如果文件已存在则把文件长度截断为0字节再重新写</p>
<p><code>"a+"</code> 允许读和追加数据，如果文件不存在则创建</p>
<p>在打开一个文件时如果出错，<code>fopen</code>将返回<code>NULL</code>并设置<code>errno</code>，<code>errno</code>稍后介绍。在程序中应该做出错处理，通常这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (fp = fopen(<span class="string">&quot;/tmp/file1&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;error open file /tmp/file1!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如<code>/tmp/file1</code>这个文件不存在，而<code>r</code>打开方式又不会创建这个文件，<code>fopen</code>就会出错返回。</p>
<p>再说说<code>fclose</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回<code>0</code>，出错返回<code>EOF</code>并设置<code>errno</code></p>
<p>把文件指针传给<code>fclose</code>可以关闭它所标识的文件，关闭之后该文件指针就无效了，不能再使用了。如果<code>fclose</code>调用出错（比如传给它一个无效的文件指针）则返回<code>EOF</code>并设置<code>errno</code>，<code>errno</code>稍后介绍，<code>EOF</code>在<code>stdio.h</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* End of file character.</span></span><br><span class="line"><span class="comment">   Some things throughout the library rely on this being -1.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EOF</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EOF (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>它的值是<code>-1</code>。<code>fopen</code>调用应该和<code>fclose</code>调用配对，打开文件操作完之后一定要记得关闭。如果不调用<code>fclose</code>，在进程退出时系统会自动关闭文件，但是不能因此就忽略<code>fclose</code>调用，如果写一个长年累月运行的程序（比如网络服务器程序），打开的文件都不关闭，堆积得越来越多，就会占用越来越多的系统资源。</p>
<h3 id="stdinstdoutstderr">stdin/stdout/stderr</h3>
<p>我们经常用<code>printf</code>打印到屏幕，也用过<code>scanf</code>读键盘输入，这些也属于I/O操作，但不是对文件做I/O操作而是对终端设备做I/O操作。所谓终端（Terminal）是指人机交互的设备，也就是可以接受用户输入并输出信息给用户的设备。在计算机刚诞生的年代，终端是电传打字机和打印机，现在的终端通常是键盘和显示器。终端设备和文件一样也需要先打开后操作，终端设备也有对应的路径名，<code>/dev/tty</code>就表示和当前进程相关联的终端设备（在第
1.1 节
“终端的基本概念”会讲到这叫进程的控制终端）。也就是说，<code>/dev/tty</code>不是一个普通的文件，它不表示磁盘上的一组数据，而是表示一个设备。用<code>ls</code>命令查看这个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /dev/tty</span></span><br><span class="line">crw-rw-rw- 1 root dialout 5, 0 2009-03-20 19:31 /dev/tty</span><br></pre></td></tr></table></figure>
<p>开头的<code>c</code>表示文件类型是字符设备。中间的<code>5</code>,<code>0</code>是它的设备号，主设备号<code>5</code>，次设备号<code>0</code>，主设备号标识内核中的一个设备驱动程序，次设备号标识该设备驱动程序管理的一个设备。内核通过设备号找到相应的驱动程序，完成对该设备的操作。我们知道常规文件的这一列应该显示文件尺寸，而设备文件的这一列显示设备号，这表明设备文件是没有文件尺寸这个属性的，因为设备文件在磁盘上不保存数据，对设备文件做读写操作并不是读写磁盘上的数据，而是在读写设备。UNIX的传统是Everything
is a
file，键盘、显示器、串口、磁盘等设备在<code>/dev</code>目录下都有一个特殊的设备文件与之对应，这些设备文件也可以像普通文件一样打开、读、写和关闭，使用的函数接口是相同的。本书中不严格区分“文件”和“设备”这两个概念，遇到“文件”这个词，读者可以根据上下文理解它是指普通文件还是设备，如果需要强调是保存在磁盘上的普通文件，本书会用“常规文件”（Regular
File）这个词。</p>
<p>那为什么<code>printf</code>和<code>scanf</code>不用打开就能对终端设备进行操作呢？因为在程序启动时（在<code>main</code>函数还没开始执行之前）会自动把终端设备打开三次，分别赋给三个<code>FILE *</code>指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>，这三个文件指针是<code>libc</code>中定义的全局变量，在<code>stdio.h</code>中声明，<code>printf</code>向<code>stdout</code>写，而<code>scanf</code>从<code>stdin</code>读，后面我们会看到，用户程序也可以直接使用这三个文件指针。这三个文件指针的打开方式都是可读可写的，但通常<code>stdin</code>只用于读操作，称为标准输入（Standard
Input），<code>stdout</code>只用于写操作，称为标准输出（Standard
Output），<code>stderr</code>也只用于写操作，称为标准错误输出（Standard
Error），通常程序的运行结果打印到标准输出，而错误提示（例如gcc报的警告和错误）打印到标准错误输出，所以<code>fopen</code>的错误处理写成这样更符合惯例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (fp = fopen(<span class="string">&quot;/tmp/file1&quot;</span>, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Error open file /tmp/file1\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fputs</code>函数将在稍后详细介绍。不管是打印到标准输出还是打印到标准错误输出效果是一样的，都是打印到终端设备（也就是屏幕）了，那为什么还要分成标准输出和标准错误输出呢？以后我们会讲到重定向操作，可以把标准输出重定向到一个常规文件，而标准错误输出仍然对应终端设备，这样就可以把正常的运行结果和错误提示分开，而不是混在一起打印到屏幕了。</p>
<h3 id="errno与perror函数">errno与perror函数</h3>
<p>很多系统函数在错误返回时将错误原因记录在<code>libc</code>定义的全局变量<code>errno</code>中，每种错误原因对应一个错误码，请查阅<code>errno(3)</code>的Man
Page了解各种错误码，<code>errno</code>在头文件<code>errno.h</code>中声明，是一个整型变量，所有错误码都是正整数。</p>
<p>如果在程序中打印错误信息时直接打印<code>errno</code>变量，打印出来的只是一个整数值，仍然看不出是什么错误。比较好的办法是用<code>perror</code>或<code>strerror</code>函数将<code>errno</code>解释成字符串再打印。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p><code>perror</code>函数将错误信息打印到标准错误输出，首先打印参数<code>s</code>所指的字符串，然后打印<code>:</code>号，然后根据当前<code>errno</code>的值打印错误原因。例如：</p>
<p>例 perror</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file abcde&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件<code>abcde</code>不存在，<code>fopen</code>返回<code>-1</code>并设置<code>errno</code>为<code>ENOENT</code>，紧接着<code>perror</code>函数读取<code>errno</code>的值，将<code>ENOENT</code>解释成字符串<code>No such file or directory</code>并打印，最后打印的结果是<code>Open file abcde: No such file or directory</code>。虽然<code>perror</code>可以打印出错误原因，传给<code>perror</code>的字符串参数仍然应该提供一些额外的信息，以便在看到错误信息时能够很快定位是程序中哪里出了错，如果在程序中有很多个<code>fopen</code>调用，每个<code>fopen</code>打开不同的文件，那么在每个<code>fopen</code>的错误处理中打印文件名就很有帮助。</p>
<p>如果把上面的程序改成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file abcde&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno: %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则<code>printf</code>打印的错误号并不是<code>fopen</code>产生的错误号，而是<code>perror</code>产生的错误号。<code>errno</code>是一个全局变量，很多系统函数都会改变它，<code>fopen</code>函数Man
Page中的ERRORS部分描述了它可能产生的错误码，<code>perror</code>函数的Man
Page中没有ERRORS部分，说明它本身不产生错误码，但它调用的其它函数也有可能改变<code>errno</code>变量。大多数系统函数都有一个Side
Effect，就是有可能改变<code>errno</code>变量（当然也有少数例外，比如<code>strcpy</code>），所以一个系统函数错误返回后应该马上检查<code>errno</code>，在检查<code>errno</code>之前不能再调用其它系统函数。</p>
<p><code>strerror</code>函数可以根据错误号返回错误原因字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：错误码<code>errnum</code>所对应的字符串</p>
<p>这个函数返回指向静态内存的指针。以后学线程库时我们会看到，有些函数的错误码并不保存在<code>errno</code>中，而是通过返回值返回，就不能调用<code>perror</code>打印错误原因了，这时<code>strerror</code>就派上了用场：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(strerror(n), <span class="built_in">stderr</span>);</span><br></pre></td></tr></table></figure>
<h3 id="以字节为单位的io函数">以字节为单位的I/O函数</h3>
<p><code>fgetc</code>函数从指定的文件中读一个字节，<code>getchar</code>从标准输入读一个字节，调用<code>getchar()</code>相当于调用<code>fgetc(stdin)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回读到的字节，出错或者读到文件末尾时返回<code>EOF</code>
注意在Man
Page的函数原型中<code>FILE *</code>指针参数有时会起名叫<code>stream</code>，这是因为标准I/O库操作的文件有时也叫做流（Stream），文件由一串字节组成，每次可以读或写其中任意数量的字节，以后介绍TCP协议时会对流这个概念做更详细的解释。</p>
<p>对于<code>fgetc</code>函数的使用有以下几点说明：</p>
<p>要用<code>fgetc</code>函数读一个文件，该文件的打开方式必须是可读的。</p>
<p>系统对于每个打开的文件都记录着当前读写位置在文件中的地址（或者说距离文件开头的字节数），也叫偏移量（Offset）。当文件打开时，读写位置是0，每调用一次<code>fgetc</code>，读写位置向后移动一个字节，因此可以连续多次调用<code>fgetc</code>函数依次读取多个字节。</p>
<p><code>fgetc</code>成功时返回读到一个字节，本来应该是<code>unsigned char</code>型的，但由于函数原型中返回值是<code>int</code>型，所以这个字节要转换成<code>int</code>型再返回，那为什么要规定返回值是<code>int</code>型呢？因为出错或读到文件末尾时<code>fgetc</code>将返回<code>EOF</code>，即<code>-1</code>，保存在<code>int</code>型的返回值中是<code>0xffffffff</code>，如果读到字节<code>0xff</code>，由<code>unsigned char</code>型转换为<code>int</code>型是<code>0x000000ff</code>，只有规定返回值是<code>int</code>型才能把这两种情况区分开，如果规定返回值是<code>unsigned char</code>型，那么当返回值是<code>0xff</code>时无法区分到底是<code>EOF</code>还是字节<code>0xff</code>。如果需要保存<code>fgetc</code>的返回值，一定要保存在<code>int</code>型变量中，如果写成<code>unsigned char c = fgetc(fp);</code>，那么根据<code>c</code>的值又无法区分<code>EOF</code>和<code>0xff</code>字节了。注意，<code>fgetc</code>读到文件末尾时返回<code>EOF</code>，只是用这个返回值表示已读到文件末尾，并不是说每个文件末尾都有一个字节是<code>EOF</code>（根据上面的分析，<code>EOF</code>并不是一个字节）。</p>
<p><code>fputc</code>函数向指定的文件写一个字节，<code>putchar</code>向标准输出写一个字节，调用<code>putchar(c)</code>相当于调用<code>fputc(c, stdout)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回写入的字节，出错返回<code>EOF</code></p>
<p>对于<code>fputc</code>函数的使用也要说明几点：</p>
<p>要用<code>fputc</code>函数写一个文件，该文件的打开方式必须是可写的（包括追加）。</p>
<p>每调用一次<code>fputc</code>，读写位置向后移动一个字节，因此可以连续多次调用<code>fputc</code>函数依次写入多个字节。但如果文件是以追加方式打开的，每次调用<code>fputc</code>时总是将读写位置移到文件末尾然后把要写入的字节追加到后面。</p>
<p>下面的例子演示了这四个函数的用法，从键盘读入一串字符写到一个文件中，再从这个文件中读出这些字符打印到屏幕上。</p>
<p>例 用fputc/fget读写文件和终端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (fp = fopen(<span class="string">&quot;file2&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file file2\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (ch = getchar()) != EOF)</span><br><span class="line">        fputc(ch, fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="keyword">while</span> ( (ch = fgetc(fp)) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从终端设备读有点特殊。当调用<code>getchar()</code>或<code>fgetc(stdin)</code>时，如果用户没有输入字符，<code>getchar</code>函数就阻塞等待，所谓阻塞是指这个函数调用不返回，也就不能执行后面的代码，这个进程阻塞了，操作系统可以调度别的进程执行。从终端设备读还有一个特点，用户输入一般字符并不会使<code>getchar</code>函数返回，仍然阻塞着，只有当用户输入回车或者到达文件末尾时<code>getchar</code>才返回[34]。这个程序的执行过程分析如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">hello（输入hello并回车，这时第一次调用getchar返回，读取字符h存到文件中，然后连续调用getchar五次，读取ello和换行符存到文件中，第七次调用getchar又阻塞了）</span><br><span class="line">hey（输入hey并回车，第七次调用getchar返回，读取字符h存到文件中，然后连续调用getchar三次，读取ey和换行符存到文件中，第11次调用getchar又阻塞了）</span><br><span class="line">（这时输入Ctrl-D，第11次调用getchar返回EOF，跳出循环，进入下一个循环，回到文件开头，把文件内容一个字节一个字节读出来打印，直到文件结束）</span><br><span class="line">hello</span><br><span class="line">hey</span><br></pre></td></tr></table></figure>
<p>从终端设备输入时有两种方法表示文件结束，一种方法是在一行的开头输入<code>Ctrl-D</code>（如果不在一行的开头则需要连续输入两次<code>Ctrl-D</code>），另一种方法是利用Shell的<code>Heredoc</code>语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out &lt;&lt;<span class="string">END</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">hello</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">hey</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">END</span></span></span><br><span class="line">hello</span><br><span class="line">hey</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;END</code>表示从下一行开始是标准输入，直到某一行开头出现<code>END</code>时结束。<code>&lt;&lt;</code>后面的结束符可以任意指定，不一定得是<code>END</code>，只要和输入的内容能区分开就行。</p>
<p>在上面的程序中，第一个<code>while</code>循环结束时<code>fp</code>所指文件的读写位置在文件末尾，然后调用<code>rewind</code>函数把读写位置移到文件开头，再进入第二个<code>while</code>循环从头读取文件内容。</p>
<h3 id="操作读写位置的函数">操作读写位置的函数</h3>
<p>我们在上一节的例子中看到<code>rewind</code>函数把读写位置移到文件开头，本节介绍另外两个操作读写位置的函数，<code>fseek</code>可以任意移动读写位置，<code>ftell</code>可以返回当前的读写位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回<code>0</code>，出错返回<code>-1</code>并设置<code>errno</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回当前读写位置，出错返回<code>-1</code>并设置<code>errno</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p><code>fseek</code>的<code>whence</code>和<code>offset</code>参数共同决定了读写位置移动到何处，<code>whence</code>参数的含义如下：</p>
<p><code>SEEK_SET</code> 从文件开头移动<code>offset</code>个字节</p>
<p><code>SEEK_CUR</code> 从当前位置移动<code>offset</code>个字节</p>
<p><code>SEEK_END</code> 从文件末尾移动<code>offset</code>个字节</p>
<p><code>offset</code>可正可负，负值表示向前（向文件开头的方向）移动，正值表示向后（向文件末尾的方向）移动，如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸，从原来的文件末尾到<code>fseek</code>移动之后的读写位置之间的字节都是0。</p>
<p>先前我们创建过一个文件<code>textfile</code>，其中有五个字节，<code>5678</code>加一个换行符，现在我们拿这个文件做实验。</p>
<p>例 fseek</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">if</span> ( (fp = fopen(<span class="string">&quot;textfile&quot;</span>,<span class="string">&quot;r+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file textfile&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fseek(fp, <span class="number">10</span>, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Seek file textfile&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fputc(<span class="string">&#x27;K&#x27;</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序，然后查看文件<code>textfile</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">od</span> -tx1 -tc -Ax textfile</span> </span><br><span class="line">000000 35 36 37 38 0a 00 00 00 00 00 4b</span><br><span class="line">         5   6   7   8  \n  \0  \0  \0  \0  \0   K</span><br><span class="line">00000b</span><br></pre></td></tr></table></figure>
<p><code>fseek(fp, 10, SEEK_SET)</code>将读写位置移到第10个字节处（其实是第11个字节，从0开始数），然后在该位置写入一个字符<code>K</code>，这样<code>textfile</code>文件就变长了，从第5到第9个字节自动被填充为0。</p>
<h3 id="以字符串为单位的io函数">以字符串为单位的I/O函数</h3>
<p><code>fgets</code>从指定的文件中读一行字符到调用者提供的缓冲区中，<code>gets</code>从标准输入读一行字符到调用者提供的缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功时<code>s</code>指向哪返回的指针就指向哪，出错或者读到文件末尾时返回<code>NULL</code></p>
<p><code>gets</code>函数无需解释，Man
Page的BUGS部分已经说得很清楚了：<code>Never use gets()</code>。<code>gets</code>函数的存在只是为了兼容以前的程序，我们写的代码都不应该调用这个函数。<code>gets</code>函数的接口设计得很有问题，就像<code>strcpy</code>一样，用户提供一个缓冲区，却不能指定缓冲区的大小，很可能导致缓冲区溢出错误，这个函数比<code>strcpy</code>更加危险，<code>strcpy</code>的输入和输出都来自程序内部，只要程序员小心一点就可以避免出问题，而<code>gets</code>读取的输入直接来自程序外部，用户可能通过标准输入提供任意长的字符串，程序员无法避免<code>gets</code>函数导致的缓冲区溢出错误，所以唯一的办法就是不要用它。</p>
<p>现在说说<code>fgets</code>函数，参数<code>s</code>是缓冲区的首地址，<code>size</code>是缓冲区的长度，该函数从<code>stream</code>所指的文件中读取以<code>'\n'</code>结尾的一行（包括<code>'\n'</code>在内）存到缓冲区<code>s</code>中，并且在该行末尾添加一个<code>'\0'</code>组成完整的字符串。</p>
<p>如果文件中的一行太长，<code>fgets</code>从文件中读了<code>size-1</code>个字符还没有读到<code>'\n'</code>，就把已经读到的<code>size-1</code>个字符和一个<code>'\0'</code>字符存入缓冲区，文件中剩下的半行可以在下次调用<code>fgets</code>时继续读。</p>
<p>如果一次<code>fgets</code>调用在读入若干个字符后到达文件末尾，则将已读到的字符串加上<code>'\0'</code>存入缓冲区并返回，如果再次调用<code>fgets</code>则返回<code>NULL</code>，可以据此判断是否读到文件末尾。</p>
<p>注意，对于<code>fgets</code>来说，<code>'\n'</code>是一个特别的字符，而<code>'\0'</code>并无任何特别之处，如果读到<code>'\0'</code>就当作普通字符读入。如果文件中存在<code>'\0'</code>字符（或者说<code>0x00</code>字节），调用<code>fgets</code>之后就无法判断缓冲区中的<code>'\0'</code>究竟是从文件读上来的字符还是由<code>fgets</code>自动添加的结束符，所以<code>fgets</code>只适合读文本文件而不适合读二进制文件，并且文本文件中的所有字符都应该是可见字符，不能有<code>'\0'</code>。</p>
<p><code>fputs</code>向指定的文件写入一个字符串，<code>puts</code>向标准输出写入一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回一个非负整数，出错返回<code>EOF</code></p>
<p>缓冲区<code>s</code>中保存的是以<code>'\0'</code>结尾的字符串，<code>fputs</code>将该字符串写入文件<code>stream</code>，但并不写入结尾的<code>'\0'</code>。与<code>fgets</code>不同的是，<code>fputs</code>并不关心的字符串中的<code>'\n'</code>字符，字符串中可以有<code>'\n'</code>也可以没有<code>'\n'</code>。<code>puts</code>将字符串<code>s</code>写到标准输出（不包括结尾的<code>'\0'</code>），然后自动写一个<code>'\n'</code>到标准输出。</p>
<h3 id="以记录为单位的io函数">以记录为单位的I/O函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：读或写的记录数，成功时返回的记录数等于<code>nmemb</code>，出错或读到文件末尾时返回的记录数小于<code>nmemb</code>，也可能返回<code>0</code></p>
<p><code>fread</code>和<code>fwrite</code>用于读写记录，这里的记录是指一串固定长度的字节，比如一个<code>int</code>、一个结构体或者一个定长数组。参数<code>size</code>指出一条记录的长度，而<code>nmemb</code>指出要读或写多少条记录，这些记录在<code>ptr</code>所指的内存空间中连续存放，共占<code>size * nmemb</code>个字节，<code>fread</code>从文件<code>stream</code>中读出<code>size * nmemb</code>个字节保存到<code>ptr</code>中，而<code>fwrite</code>把<code>ptr</code>中的<code>size * nmemb</code>个字节写到文件<code>stream</code>中。</p>
<p><code>nmemb</code>是请求读或写的记录数，<code>fread</code>和<code>fwrite</code>返回的记录数有可能小于<code>nmemb</code>指定的记录数。例如当前读写位置距文件末尾只有一条记录的长度，调用<code>fread</code>时指定<code>nmemb</code>为<code>2</code>，则返回值为<code>1</code>。如果当前读写位置已经在文件末尾了，或者读文件时出错了，则<code>fread</code>返回<code>0</code>。如果写文件时出错了，则<code>fwrite</code>的返回值小于<code>nmemb</code>指定的值。下面的例子由两个程序组成，一个程序把结构体保存到文件中，另一个程序和从文件中读出结构体。</p>
<p>例 fread/fwrite</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* writerec.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">record</span> <span class="title">array</span>[2] =</span> &#123;&#123;<span class="string">&quot;Ken&quot;</span>, <span class="number">24</span>&#125;, &#123;<span class="string">&quot;Knuth&quot;</span>, <span class="number">28</span>&#125;&#125;;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;recfile&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file recfile&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record), <span class="number">2</span>, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* readrec.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">record</span> <span class="title">array</span>[2];</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;recfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open file recfile&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fread(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> record), <span class="number">2</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name1: %s\tAge1: %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>].name, <span class="built_in">array</span>[<span class="number">0</span>].age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name2: %s\tAge2: %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">1</span>].name, <span class="built_in">array</span>[<span class="number">1</span>].age);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc writerec.c -o writerec</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc readrec.c -o readrec</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./writerec</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">od</span> -tx1 -tc -Ax recfile</span> </span><br><span class="line">000000 4b 65 6e 00 00 00 00 00 00 00 00 00 18 00 00 00</span><br><span class="line">         K   e   n  \0  \0  \0  \0  \0  \0  \0  \0  \0 030  \0  \0  \0</span><br><span class="line">000010 4b 6e 75 74 68 00 00 00 00 00 00 00 1c 00 00 00</span><br><span class="line">         K   n   u   t   h  \0  \0  \0  \0  \0  \0  \0 034  \0  \0  \0</span><br><span class="line">000020</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./readrec</span> </span><br><span class="line">Name1: Ken  Age1: 24</span><br><span class="line">Name2: Knuth    Age2: 28</span><br></pre></td></tr></table></figure>
<p>我们把一个<code>struct record</code>结构体看作一条记录，由于结构体中有填充字节，每条记录占16字节，把两条记录写到文件中共占32字节。该程序生成的<code>recfile</code>文件是二进制文件而非文本文件，因为其中不仅保存着字符型数据，还保存着整型数据24和28（在<code>od</code>命令的输出中以八进制显示为030和034）。注意，直接在文件中读写结构体的程序是不可移植的，如果在一种平台上编译运行<code>writebin.c</code>程序，把生成的<code>recfile</code>文件拷到另一种平台并在该平台上编译运行<code>readbin.c</code>程序，则不能保证正确读出文件的内容，因为不同平台的大小端可能不同（因而对整型数据的存储方式不同），结构体的填充方式也可能不同（因而同一个结构体所占的字节数可能不同，<code>age</code>成员在<code>name</code>成员之后的什么位置也可能不同）。</p>
<h3 id="格式化io函数">格式化I/O函数</h3>
<p>现在该正式讲一下<code>printf</code>和<code>scanf</code>函数了，这两个函数都有很多种形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回格式化输出的字节数（不包括字符串的结尾<code>'\0'</code>），出错返回一个负值</p>
<p><code>printf</code>格式化打印到标准输出，而<code>fprintf</code>打印到指定的文件<code>stream</code>中。<code>sprintf</code>并不打印到文件，而是打印到用户提供的缓冲区<code>str</code>中并在末尾加<code>'\0'</code>，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，用<code>snprintf</code>更好一些，参数<code>size</code>指定了缓冲区长度，如果格式化后的字符串长度超过缓冲区长度，<code>snprintf</code>就把字符串截断到<code>size-1</code>字节，再加上一个<code>'\0'</code>写入缓冲区，也就是说<code>snprintf</code>保证字符串以<code>'\0'</code>结尾。<code>snprintf</code>的返回值是格式化后的字符串长度（不包括结尾的<code>'\0'</code>），如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断。</p>
<p>上面列出的后四个函数在前四个函数名的前面多了个<code>v</code>，表示可变参数不是以<code>...</code>的形式传进来，而是以<code>va_list</code>类型传进来。下面我们用<code>vsnprintf</code>包装出一个类似<code>printf</code>的带格式化字符串和可变参数的函数。</p>
<p>例 实现格式化打印错误的err_sys函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_sys</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = errno;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE+<span class="number">1</span>];</span><br><span class="line">    va_list ap;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">    vsnprintf(buf, MAXLINE, fmt, ap);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf+<span class="built_in">strlen</span>(buf), MAXLINE-<span class="built_in">strlen</span>(buf), <span class="string">&quot;: %s&quot;</span>, strerror(err));</span><br><span class="line">    <span class="built_in">strcat</span>(buf, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stderr</span>);</span><br><span class="line"></span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Usage: ./a.out pathname\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;Line %d - Open file %s&quot;</span>, __LINE__, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Open %s OK\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>err_sys</code>函数，不仅简化了<code>main</code>函数的代码，而且可以把<code>fopen</code>的错误提示打印得非常清楚，有源代码行号，有打开文件的路径名，一看就知道哪里出错了。</p>
<p>现在总结一下<code>printf</code>格式化字符串中的转换说明的有哪些写法。在这里只列举几种常用的格式，其它格式请参考Man
Page。每个转换说明以<code>%</code>号开头，以转换字符结尾，我们以前用过的转换说明仅包含<code>%</code>号和转换字符，例如<code>%d</code>、<code>%s</code>，其实在这两个字符中间还可以插入一些可选项。</p>
<p><code>printf</code>转换说明的可选项</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>八进制前面加0（转换字符为o），十六进制前面加0x（转换字符为x）或0X（转换字符为X）。</td>
<td>printf(“%#x”, 0xff)打印0xff，printf(“%x”, 0xff)打印ff。</td>
</tr>
<tr>
<td>-</td>
<td>格式化后的内容居左，右边可以留空格。</td>
<td>见下面的例子</td>
</tr>
<tr>
<td>宽度</td>
<td>用一个整数指定格式化后的最小长度，如果格式化后的内容没有这么长，可以在左边留空格，如果前面指定了-号就在右边留空格。宽度有一种特别的形式，不指定整数值而是写成一个*号，表示取一个int型参数作为宽度。</td>
<td>printf(“-%10s-”, “hello”)打印-␣␣␣␣␣hello-，printf(“-%-*s-“,
10,”hello”)打印-hello␣␣␣␣␣-。</td>
</tr>
<tr>
<td>.</td>
<td>用于分隔上一条提到的最小长度和下一条要讲的精度。</td>
<td>见下面的例子</td>
</tr>
<tr>
<td>精度</td>
<td>用一个整数表示精度，对于字符串来说指定了格式化后保留的最大长度，对于浮点数来说指定了格式化后小数点右边的位数，对于整数来说指定了格式化后的最小位数。精度也可以不指定整数值而是写成一个*号，表示取下一个int型参数作为精度。</td>
<td>printf(“%.4s”, “hello”)打印hell，printf(“-%6.4d-”,
100)打印-␣␣0100-，printf(“-%<em>.</em>f-”, 8, 4,
3.14)打印-␣␣3.1400-。</td>
</tr>
<tr>
<td>字长</td>
<td>对于整型参数，hh、h、l、ll分别表示是char、short、long、long
long型的字长，至于是有符号数还是无符号数则取决于转换字符；对于浮点型参数，L表示long
double型的字长。</td>
<td>printf(“%hhd”, 255)打印-1。</td>
</tr>
</tbody>
</table>
<p><code>printf</code>的转换字符</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>转换字符</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>d i</td>
<td>取int型参数格式化成有符号十进制表示，如果格式化后的位数小于指定的精度，就在左边补0。</td>
<td>printf(“%.4d”, 100)打印0100。</td>
</tr>
<tr>
<td>o u x X</td>
<td>取unsigned
int型参数格式化成无符号八进制（o）、十进制（u）、十六进制（x或X）表示，x表示十六进制数字用小写abcdef，X表示十六进制数字用大写ABCDEF，如果格式化后的位数小于指定的精度，就在左边补0。</td>
<td>printf(“%#X”, 0xdeadbeef)打印0XDEADBEEF，printf(“%hhu”,
-1)打印255。</td>
</tr>
<tr>
<td>c</td>
<td>取int型参数转换成unsigned char型，格式化成对应的ASCII码字符。</td>
<td>printf(“%c”, 256+‘A’)打印A。</td>
</tr>
<tr>
<td>s</td>
<td>取const char
*型参数所指向的字符串格式化输出，遇到’\0’结束，或者达到指定的最大长度（精度）结束。</td>
<td>printf(“%.4s”, “hello”)打印hell。</td>
</tr>
<tr>
<td>p</td>
<td>取void *型参数格式化成十六进制表示。相当于%#x。</td>
<td>printf(“%p”, main)打印main函数的首地址0x80483c4。</td>
</tr>
<tr>
<td>f</td>
<td>取double型参数格式化成[-]ddd.ddd这样的格式，小数点后的默认精度是6位。</td>
<td>printf(“%f”, 3.14)打印3.140000，printf(“%f”,
0.00000314)打印0.000003。</td>
</tr>
<tr>
<td>e E</td>
<td>取double型参数格式化成[-]d.ddde±dd（转换字符是e）或[-]d.dddE±dd（转换字符是E）这样的格式，小数点后的默认精度是6位，指数至少是两位。</td>
<td>printf(“%e”, 3.14)打印3.140000e+00。</td>
</tr>
<tr>
<td>g G</td>
<td>取double型参数格式化，精度是指有效数字而非小数点后的数字，默认精度是6。如果指数小于-4或大于等于精度就按%e（转换字符是g）或%E（转换字符是G）格式化，否则按%f格式化。小数部分的末尾0去掉，如果没有小数部分，小数点也去掉。</td>
<td>printf(“%g”, 3.00)打印3，printf(“%g”,
0.00001234567)打印1.23457e-05。</td>
</tr>
<tr>
<td>%</td>
<td>格式化成一个%。</td>
<td>printf(“%%”)打印一个%。</td>
</tr>
</tbody>
</table>
<p>我们在第 6 节
“可变参数”讲过可变参数的原理，<code>printf</code>并不知道实际参数的类型，只能按转换说明指出的参数类型从栈帧上取参数，所以如果实际参数和转换说明的类型不符，结果可能会有些意外，上面也举过几个这样的例子。另外，如果<code>s</code>指向一个字符串，用<code>printf(s)</code>打印这个字符串可能得到错误的结果，因为字符串中可能包含<code>%</code>号而被<code>printf</code>当成转换说明，<code>printf</code>并不知道后面没有传其它参数，照样会从栈帧上取参数。所以比较保险的办法是<code>printf("%s", s)</code>。</p>
<p>下面看<code>scanf</code>函数的各种形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：返回成功匹配和赋值的参数个数，成功匹配的参数可能少于所提供的赋值参数，返回<code>0</code>表示一个都不匹配，出错或者读到文件或字符串末尾时返回<code>EOF</code>并设置<code>errno</code></p>
<p><code>scanf</code>从标准输入读字符，按格式化字符串<code>format</code>中的转换说明解释这些字符，转换后赋给后面的参数，后面的参数都是传出参数，因此必须传地址而不能传值。<code>fscanf</code>从指定的文件<code>stream</code>中读字符，而<code>sscanf</code>从指定的字符串<code>str</code>中读字符。后面三个以<code>v</code>开头的函数的可变参数不是以<code>...</code>的形式传进来，而是以<code>va_list</code>类型传进来。</p>
<p>现在总结一下<code>scanf</code>的格式化字符串和转换说明，这里也只列举几种常用的格式，其它格式请参考Man
Page。<code>scanf</code>用输入的字符去匹配格式化字符串中的字符和转换说明，如果成功匹配一个转换说明，就给一个参数赋值，如果读到文件或字符串末尾就停止，或者如果遇到和格式化字符串不匹配的地方（比如转换说明是<code>%d</code>却读到字符<code>A</code>）就停止。如果遇到不匹配的地方而停止，<code>scanf</code>的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续。</p>
<p>格式化字符串中包括：</p>
<p>空格或<code>Tab</code>，在处理过程中被忽略。</p>
<p>普通字符（不包括%），和输入字符中的非空白字符相匹配。输入字符中的空白字符是指空格、<code>Tab</code>、<code>\r</code>、<code>\n</code>、<code>\v</code>、<code>\f</code>。</p>
<p>转换说明，以%开头，以转换字符结尾，中间也有若干个可选项。</p>
<p>转换说明中的可选项有：</p>
<p><code>*</code>号，表示这个转换说明只是用来匹配一段输入字符，但匹配结果并不赋给后面的参数。</p>
<p>用一个整数指定的宽度N。表示这个转换说明最多匹配N个输入字符，或者匹配到输入字符中的下一个空白字符结束。</p>
<p>对于整型参数可以指定字长，有<code>hh</code>、<code>h</code>、<code>l</code>、<code>ll</code>（也可以写成一个<code>L</code>），含义和<code>printf</code>相同。但<code>l</code>和<code>L</code>还有一层含义，当转换字符是<code>e</code>、<code>f</code>、<code>g</code>时，表示赋值参数的类型是<code>float *</code>而非<code>double *</code>，这一点跟<code>printf</code>不同（结合以前讲的类型转换规则思考一下为什么不同），这时前面加上<code>l</code>或<code>L</code>分别表示<code>double *</code>或<code>long double *</code>型。</p>
<p>常用的转换字符有：</p>
<p><code>scanf</code>的转换字符</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>转换字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>匹配十进制整数（开头可以有负号），赋值参数的类型是int *。</td>
</tr>
<tr>
<td>i</td>
<td>匹配整数（开头可以有负号），赋值参数的类型是int
*，如果输入字符以0x或0X开头则匹配十六进制整数，如果输入字符以0开头则匹配八进制整数。</td>
</tr>
<tr>
<td>o u x</td>
<td>匹配八进制、十进制、十六进制整数（开头可以有负号），赋值参数的类型是unsigned
int *。</td>
</tr>
<tr>
<td>c</td>
<td>匹配一串字符，字符的个数由宽度指定，缺省宽度是1，赋值参数的类型是char
*，末尾不会添加’\0’。如果输入字符的开头有空白字符，这些空白字符并不被忽略，而是保存到参数中，要想跳过开头的空白字符，可以在格式化字符串中用一个空格去匹配。</td>
</tr>
<tr>
<td>s</td>
<td>匹配一串非空白字符，从输入字符中的第一个非空白字符开始匹配到下一个空白字符之前，或者匹配到指定的宽度，赋值参数的类型是char
*，末尾自动添加’\0’。</td>
</tr>
<tr>
<td>e f g</td>
<td>匹配符点数（开头可以有负号），赋值参数的类型是float
<em>，也可以指定double </em>或long double *的字长。</td>
</tr>
<tr>
<td>%</td>
<td>转换说明%%匹配一个字符%，不做赋值。</td>
</tr>
</tbody>
</table>
<p>下面几个例子出自[K&amp;R]。第一个例子，读取用户输入的浮点数累加起来。</p>
<p>例 用scanf实现简单的计算器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">/* rudimentary calculator */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> sum, v;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;v) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%.2f\n&quot;</span>, sum += v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要读取<code>25 Dec 1988</code>这样的日期格式，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;25 Dec 1988&quot;</span>;</span><br><span class="line"><span class="type">int</span> day, year;</span><br><span class="line"><span class="type">char</span> monthname[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d %s %d&quot;</span>, &amp;day, monthname, &amp;year);</span><br></pre></td></tr></table></figure>
<p>如果<code>str</code>中的空白字符再多一些，比如<code>" 25 Dec 1998"</code>，仍然可以正确读取。如果格式化字符串中的空格和<code>Tab</code>再多一些，比如<code>"%d %s %d "</code>，也可以正确读取。<code>scanf</code>函数是很强大的，但是要用对了不容易，需要多练习，通过练习体会空白字符的作用。</p>
<p>如果要读取<code>12/25/1998</code>这样的日期格式，就需要在格式化字符串中用<code>/</code>匹配输入字符中的<code>/</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> day, month, year;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d/%d/%d&quot;</span>, &amp;month, &amp;day, &amp;year);</span><br></pre></td></tr></table></figure>
<p><code>scanf</code>把换行符也看作空白字符，仅仅当作字段之间的分隔符，如果输入中的字段个数不确定，最好是先用<code>fgets</code>按行读取，然后再交给<code>sscanf</code>处理。如果我们的程序需要同时识别以上两种日期格式，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), <span class="built_in">stdin</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%d %s %d&quot;</span>, &amp;day, monthname, &amp;year) == <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;valid: %s\n&quot;</span>, line); <span class="comment">/* 25 Dec 1988 form */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sscanf</span>(line, <span class="string">&quot;%d/%d/%d&quot;</span>, &amp;month, &amp;day, &amp;year) == <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;valid: %s\n&quot;</span>, line); <span class="comment">/* mm/dd/yy form */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid: %s\n&quot;</span>, line); <span class="comment">/* invalid form */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c标准库的io缓冲区">C标准库的I/O缓冲区</h3>
<p>用户程序调用C标准I/O库函数读写文件或设备，而这些库函数要通过系统调用把读写请求传给内核（以后我们会看到与I/O相关的系统调用），最终由内核驱动磁盘或设备完成I/O操作。C标准库为每个打开的文件分配一个I/O缓冲区以加速读写操作，通过文件的<code>FILE</code>结构体可以找到这个缓冲区，用户调用读写函数大多数时候都在I/O缓冲区中读写，只有少数时候需要把读写请求传给内核。以<code>fgetc/fputc</code>为例，当用户程序第一次调用<code>fgetc</code>读一个字节时，<code>fgetc</code>函数可能通过系统调用进入内核读1K字节到I/O缓冲区中，然后返回I/O缓冲区中的第一个字节给用户，把读写位置指向I/O缓冲区中的第二个字符，以后用户再调<code>fgetc</code>，就直接从I/O缓冲区中读取，而不需要进内核了，当用户把这1K字节都读完之后，再次调用<code>fgetc</code>时，<code>fgetc</code>函数会再次进入内核读1K字节到I/O缓冲区中。在这个场景中用户程序、C标准库和内核之间的关系就像在第
5 节 “Memory
Hierarchy”中CPU、Cache和内存之间的关系一样，C标准库之所以会从内核预读一些数据放在I/O缓冲区中，是希望用户程序随后要用到这些数据，C标准库的I/O缓冲区也在用户空间，直接从用户空间读取数据比进内核读数据要快得多。另一方面，用户程序调用<code>fputc</code>通常只是写到I/O缓冲区中，这样<code>fputc</code>函数可以很快地返回，如果I/O缓冲区写满了，<code>fputc</code>就通过系统调用把I/O缓冲区中的数据传给内核，内核最终把数据写回磁盘。有时候用户程序希望把I/O缓冲区中的数据立刻传给内核，让内核写回设备，这称为Flush操作，对应的库函数是<code>fflush</code>，<code>fclose</code>函数在关闭文件之前也会做Flush操作。</p>
<p>下图以<code>fgets/fputs</code>示意了I/O缓冲区的作用，使用<code>fgets/fputs</code>函数时在用户程序中也需要分配缓冲区（图中的buf1和buf2），注意区分用户程序的缓冲区和C标准库的I/O缓冲区。</p>
<figure>
<img src="C:\blog\Blog\images\C\stdlib.buffer.png"
alt="C标准库的I/O缓冲区" />
<figcaption aria-hidden="true">C标准库的I/O缓冲区</figcaption>
</figure>
<p>C标准库的I/O缓冲区有三种类型：全缓冲、行缓冲和无缓冲。当用户程序调用库函数做写操作时，不同类型的缓冲区具有不同的特性。</p>
<p>全缓冲 如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。</p>
<p>行缓冲
如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。</p>
<p>无缓冲
用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。</p>
<p>下面通过一个简单的例子证明标准输出对应终端设备时是行缓冲的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序，会发现<code>hello world</code>并没有打印到屏幕上。用<code>Ctrl-C</code>终止它，去掉程序中的<code>while(1);</code>语句再试一次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">hello world$</span><br></pre></td></tr></table></figure>
<p><code>hello world</code>被打印到屏幕上，后面直接跟Shell提示符，中间没有换行。</p>
<p>我们知道<code>main</code>函数被启动代码这样调用：<code>exit(main(argc, argv));</code>。<code>main</code>函数<code>return</code>时启动代码会调用<code>exit</code>，<code>exit</code>函数首先关闭所有尚未关闭的<code>FILE *</code>指针（关闭之前要做Flush操作），然后通过<code>_exit</code>系统调用进入内核退出当前进程[35]。</p>
<p>在上面的例子中，由于标准输出是行缓冲的，<code>printf("hello world");</code>打印的字符串中没有换行符，所以只把字符串写到标准输出的I/O缓冲区中而没有写回内核（写到终端设备），如果敲<code>Ctrl-C</code>，进程是异常终止的，并没有调用<code>exit</code>，也就没有机会Flush
I/O缓冲区，因此字符串最终没有打印到屏幕上。如果把打印语句改成<code>printf("hello world\n");</code>，有换行符，就会立刻写到终端设备，或者如果把<code>while(1);</code>去掉也可以写到终端设备，因为程序退出时会调用<code>exit</code>Flush所有I/O缓冲区。在本书的其它例子中，<code>printf</code>打印的字符串末尾都有换行符，以保证字符串在<code>printf</code>调用结束时就写到终端设备。</p>
<p>我们再做个实验，在程序中直接调用<code>_exit</code>退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果也不会把字符串打印到屏幕上，如果把<code>_exit</code>调用改成<code>exit</code>就可以打印到屏幕上。</p>
<p>除了写满缓冲区、写入换行符之外，行缓冲还有一种情况会自动做Flush操作。如果：</p>
<p>用户程序调用库函数从无缓冲的文件中读取</p>
<p>或者从行缓冲的文件中读取，并且这次读操作会引发系统调用从内核读取数据</p>
<p>那么在读取之前会自动Flush所有行缓冲。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input a line: &quot;</span>);</span><br><span class="line">    fgets(buf, <span class="number">20</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然调用<code>printf</code>并不会把字符串写到设备，但紧接着调用<code>fgets</code>读一个行缓冲的文件（标准输入），在读取之前会自动Flush所有行缓冲，包括标准输出。</p>
<p>如果用户程序不想完全依赖于自动的Flush操作，可以调<code>fflush</code>函数手动做Flush操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回<code>0</code>，出错返回<code>EOF</code>并设置<code>errno</code></p>
<p>对前面的例子再稍加改动：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然字符串中没有换行，但用户程序调用<code>fflush</code>强制写回内核，因此也能在屏幕上打印出字符串。<code>fflush</code>函数用于确保数据写回了内核，以免进程异常终止时丢失数据。作为一个特例，调用<code>fflush(NULL)</code>可以对所有打开文件的I/O缓冲区做Flush操作。</p>
<h2 id="数值字符串转换函数">数值字符串转换函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：转换结果</p>
<p><code>atoi</code>把一个字符串开头可以识别成十进制整数的部分转换成<code>int</code>型，相当于下面要讲的<code>strtol(nptr, (char **) NULL, 10);</code>。例如<code>atoi("123abc")</code>的返回值是<code>123</code>，字符串开头可以有若干空格，例如<code>atoi(" -90.6-")</code>的返回值是<code>-90</code>。如果字符串开头没有可识别的整数，例如<code>atoi("asdf")</code>，则返回<code>0</code>，而<code>atoi("0***")</code>也返回<code>0</code>，根据返回值并不能区分这两种情况，所以使用<code>atoi</code>函数不能检查出错的情况。下面要讲的<code>strtol</code>函数可以设置<code>errno</code>，因此可以检查出错的情况，在严格的场合下应该用<code>strtol</code>，而<code>atoi</code>用起来更简便，所以也很常用。</p>
<p><code>atof</code>把一个字符串开头可以识别成浮点数的部分转换成<code>double</code>型，相当于下面要讲的<code>strtod(nptr, (char **) NULL);</code>。字符串开头可以识别的浮点数格式和C语言的浮点数常量相同，例如<code>atof("31.4 ")</code>的返回值是<code>31.4</code>，<code>atof("3.14e+1AB")</code>的返回值也是<code>31.4</code>。<code>atof</code>也不能检查出错的情况，而<code>strtod</code>可以。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：转换结果，出错时设置<code>errno</code></p>
<p><code>strtol</code>是<code>atoi</code>的增强版，主要体现在这几方面：</p>
<p>不仅可以识别十进制整数，还可以识别其它进制的整数，取决于<code>base</code>参数，比如<code>strtol("0XDEADbeE~~", NULL, 16)</code>返回<code>0xdeadbee</code>的值，<code>strtol("0777~~", NULL, 8)</code>返回<code>0777</code>的值。</p>
<p><code>endptr</code>是一个传出参数，函数返回时指向后面未被识别的第一个字符。例如<code>char *pos; strtol("123abc", &amp;pos, 10);</code>，<code>strtol</code>返回<code>123</code>，<code>pos</code>指向字符串中的字母<code>a</code>。如果字符串开头没有可识别的整数，例如<code>char *pos; strtol("ABCabc", &amp;pos, 10);</code>，则<code>strtol</code>返回<code>0</code>，<code>pos</code>指向字符串开头，可以据此判断这种出错的情况，而这是<code>atoi</code>处理不了的。</p>
<p>如果字符串中的整数值超出<code>long int</code>的表示范围（上溢或下溢），则<code>strtol</code>返回它所能表示的最大（或最小）整数，并设置<code>errno</code>为<code>ERANGE</code>，例如<code>strtol("0XDEADbeef~~", NULL, 16)</code>返回<code>0x7fffffff</code>并设置<code>errno</code>为<code>ERANGE</code>。</p>
<p>回想一下使用<code>fopen</code>的套路<code>if ( (fp = fopen(...)) == NULL) &#123; 读取errno &#125;</code>，<code>fopen</code>在出错时会返回<code>NULL</code>，因此我们知道需要读<code>errno</code>，但<code>strtol</code>在成功调用时也可能返回<code>0x7fffffff</code>，我们如何知道需要读<code>errno</code>呢？最严谨的做法是首先把<code>errno</code>置<code>0</code>，再调用<code>strtol</code>，再查看<code>errno</code>是否变成了错误码。Man
Page上有一个很好的例子：</p>
<p>例 strtol的出错处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="type">char</span> *endptr, *str;</span><br><span class="line">    <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s str [base]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str = argv[<span class="number">1</span>];</span><br><span class="line">    base = (argc &gt; <span class="number">2</span>) ? atoi(argv[<span class="number">2</span>]) : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;    <span class="comment">/* To distinguish success/failure after call */</span></span><br><span class="line">    val = strtol(str, &amp;endptr, base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for various possible errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno == ERANGE &amp;&amp; (val == LONG_MAX || val == LONG_MIN))</span><br><span class="line">        || (errno != <span class="number">0</span> &amp;&amp; val == <span class="number">0</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;strtol&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (endptr == str) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;No digits were found\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we got here, strtol() successfully parsed a number */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strtol() returned %ld\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*endptr != <span class="string">&#x27;\0&#x27;</span>)        <span class="comment">/* Not necessarily an error... */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Further characters after number: %s\n&quot;</span>, endptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strtod</code>是<code>atof</code>的增强版，增强的功能和<code>strtol</code>类似。</p>
<h2 id="分配内存的函数">分配内存的函数</h2>
<p>除了<code>malloc</code>之外，C标准库还提供了另外两个在堆空间分配内存的函数，它们分配的内存同样由<code>free</code>释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回所分配内存空间的首地址，出错返回<code>NULL</code></p>
<p><code>calloc</code>的参数很像<code>fread/fwrite</code>的参数，分配<code>nmemb</code>个元素的内存空间，每个元素占<code>size</code>字节，并且<code>calloc</code>负责把这块内存空间用字节<code>0</code>填充，而<code>malloc</code>并不负责把分配的内存空间清零。</p>
<p>有时候用<code>malloc</code>或<code>calloc</code>分配的内存空间使用了一段时间之后需要改变它的大小，一种办法是调用<code>malloc</code>分配一块新的内存空间，把原内存空间中的数据拷到新的内存空间，然后调用<code>free</code>释放原内存空间。使用<code>realloc</code>函数简化了这些步骤，把原内存空间的指针<code>ptr</code>传给<code>realloc</code>，通过参数<code>size</code>指定新的大小（字节数），<code>realloc</code>返回新内存空间的首地址，并释放原内存空间。新内存空间中的数据尽量和原来保持一致，如果<code>size</code>比原来小，则前<code>size</code>个字节不变，后面的数据被截断，如果<code>size</code>比原来大，则原来的数据全部保留，后面长出来的一块内存空间未初始化（<code>realloc</code>不负责清零）。注意，参数<code>ptr</code>要么是<code>NULL</code>，要么必须是先前调用<code>malloc</code>、<code>calloc</code>或<code>realloc</code>返回的指针，不能把任意指针传给<code>realloc</code>要求重新分配内存空间。作为两个特例，如果调用<code>realloc(NULL, size)</code>，则相当于调用<code>malloc(size)</code>，如果调用<code>realloc(ptr, 0)</code>，<code>ptr</code>不是<code>NULL</code>，则相当于调用<code>free(ptr)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">alloca</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：返回所分配内存空间的首地址，如果<code>size</code>太大导致栈空间耗尽，结果是未定义的</p>
<p>参数<code>size</code>是请求分配的字节数，<code>alloca</code>函数不是在堆上分配空间，而是在调用者函数的栈帧上分配空间，类似于C99的变长数组，当调用者函数返回时自动释放栈帧，所以不需要<code>free</code>。这个函数不属于C标准库，而是在POSIX标准中定义的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:常量,变量和表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 17:27:11" itemprop="dateModified" datetime="2025-08-06T17:27:11+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="hello-world">Hello World</h2>
<p>读者应该已经尝试对Hello
world程序做各种改动看编译运行结果，其中有些改动会导致编译出错，有些改动会影响程序的输出，有些改动则没有任何影响，下面我们总结一下。首先，注释可以跨行，也可以穿插在程序之中，看下面的例子。</p>
<p>例 带更多注释的Hello World</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * comment1</span></span><br><span class="line"><span class="comment"> * main: generate some simple output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="comment">/* comment2 */</span><span class="string">&quot;Hello, world.\n&quot;</span>); <span class="comment">/* comment3 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个注释跨了四行，头尾两行是注释的界定符（Delimiter）<code>/*</code>和<code>*/</code>，中间两行开头的<code>*</code>号（Asterisk）并没有特殊含义，只是为了看起来整齐，这不是语法规则而是大家都遵守的C代码风格（Coding
Style）之一。</p>
<p>使用注释需要注意两点：</p>
<p>注释不能嵌套（Nest）使用，就是说一个注释的文字中不能再出现<code>/*</code>和<code>*/</code>了，例如<code>/* text1 /* text2 */ text3 */</code>是错误的，编译器只把<code>/* text1 /* text2 */</code>看成注释，后面的
<code>text3 */</code>无法解析，因而会报错。</p>
<p>有的C代码中有类似<code>// comment</code>的注释，两个<code>/</code>斜线（Slash）表示从这里直到该行末尾的所有字符都属于注释，这种注释不能跨行，也不能穿插在一行代码中间。这是从C++借鉴的语法，在C99中被标准化。</p>
<p>C语言标准:</p>
<p>C语言的发展历史大致上分为三个阶段：Old Style C、C89和C99。Ken
Thompson和Dennis
Ritchie最初发明C语言时有很多语法和现在最常用的写法并不一样，但为了向后兼容性（Backward
Compatibility），这些语法仍然在C89和C99中保留下来了，本书不详细讲Old
Style
C，但在必要的地方会加以说明。C89是最早的C语言规范，于1989年提出，1990年首先由ANSI（美国国家标准委员会，American
National Standards Institute）推出，后来被接纳为ISO国际标准（ISO/IEC
9899:1990），因而有时也称为C90，最经典的C语言教材[K&amp;R]就是基于这个版本的，C89是目前最广泛采用的C语言标准，大多数编译器都完全支持C89。C99标准（ISO/IEC
9899:1999）是在1999年推出的，加入了许多新特性，但目前仍没有得到广泛支持，在C99推出之后相当长的一段时间里，连gcc也没有完全实现C99的所有特性。C99标准详见[C99]。本书讲C的语法以C99为准，但示例代码通常只使用C89语法，很少使用C99的新特性。</p>
<p>C标准的目的是为了精确定义C语言，而不是为了教别人怎么编程，C标准在表达上追求准确和无歧义，却十分不容易看懂，[Standard
C]和[Standard C
Library]是对C89及其修订版本的阐释（可惜作者没有随C99更新这两本书），比C标准更容易看懂，另外，参考[C99
Rationale]也有助于加深对C标准的理解。</p>
<p>像<code>"Hello, world.\n"</code>这种由双引号（Double
Quote）引起来的一串字符称为字符串字面值（String
Literal），或者简称字符串。注意，程序的运行结果并没有双引号，<code>printf</code>打印出来的只是里面的一串字符<code>Hello, world.</code>，因此双引号是字符串字面值的界定符，夹在双引号中间的一串字符才是它的内容。注意，打印出来的结果也没有<code>\n</code>这两个字符，这是为什么呢？在第
2 节 “自然语言和形式语言”中提到过，C语言规定了一些转义序列（Escape
Sequence），这里的<code>\n</code>并不表示它的字面意思，也就是说并不表示<code>\</code>和<code>n</code>这两个字符本身，而是合起来表示一个换行符（Line
Feed）。例如我们写三条打印语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Goodbye, &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cruel world!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行的结果是第一条语句单独打到第一行，后两条语句都打到第二行。为了节省篇幅突出重点，以后的例子通常省略<code>#include</code>和<code>int main(void) &#123; ... &#125;</code>这些Boilerplate，但读者在练习时需要加上这些构成一个完整的程序才能编译通过。C标准规定的转义字符有以下几种：</p>
<table>
<thead>
<tr>
<th>C标准规定的转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\'</code>单引号<code>'</code>（Single Quote或Apostrophe）</td>
</tr>
<tr>
<td><code>\"</code>双引号<code>"</code></td>
</tr>
<tr>
<td><code>\?</code>问号<code>?</code>（Question Mark）</td>
</tr>
<tr>
<td><code>\\</code>反斜线<code>\</code>（Backslash）</td>
</tr>
<tr>
<td><code>\a</code>响铃（Alert或Bell）</td>
</tr>
<tr>
<td><code>\b</code>退格（Backspace）</td>
</tr>
<tr>
<td><code>\f</code>分页符（Form Feed）</td>
</tr>
<tr>
<td><code>\n</code>换行（Line Feed）</td>
</tr>
<tr>
<td><code>\r</code>回车（Carriage Return）</td>
</tr>
<tr>
<td><code>\t</code>水平制表符（Horizontal Tab）</td>
</tr>
<tr>
<td><code>\v</code>垂直制表符（Vertical Tab）</td>
</tr>
</tbody>
</table>
<p>如果在字符串字面值中要表示单引号和问号，既可以使用转义序列<code>\'</code>和<code>\?</code>，也可以直接用字符<code>'</code>和<code>?</code>，而要表示<code>\</code>或<code>"</code>则必须使用转义序列，因为<code>\</code>字符表示转义而不表示它的字面含义，<code>"</code>表示字符串的界定符而不表示它的字面含义。可见转义序列有两个作用：一是把普通字符转义成特殊字符，例如把字母n转义成换行符；二是把特殊字符转义成普通字符，例如<code>\</code>和<code>"</code>是特殊字符，转义后取它的字面值。</p>
<p>C语言规定了几个控制字符，不能用键盘直接输入，因此采用<code>\</code>加字母的转义序列表示。<code>\a</code>是响铃字符，在字符终端下显示这个字符的效果是PC喇叭发出嘀的一声，在图形界面终端下的效果取决于终端的实现。在终端下显示<code>\b</code>和按下退格键的效果相同。<code>\f</code>是分页符，主要用于控制打印机在打印源代码时提前分页，这样可以避免一个函数跨两页打印。<code>\n</code>和<code>\r</code>分别表示Line
Feed和Carriage Return，这两个词来自老式的英文打字机，Line
Feed是跳到下一行（进纸，喂纸，有个喂的动作所以是feed），Carriage
Return是回到本行开头（Carriage是卷着纸的轴，随着打字慢慢左移，打完一行就一下子移回最右边），如果你看过欧美的老电影应该能想起来这是什么。用老式打字机打完一行之后需要这么两个动作，<code>\r\n</code>，所以现在Windows上的文本文件用<code>\r\n</code>做行分隔符，许多应用层网络协议（如HTTP）也用<code>\r\n</code>做行分隔符，而Linux和各种UNIX上的文本文件只用<code>\n</code>做行分隔符。在终端下显示<code>\t</code>和按下<code>Tab</code>键的效果相同，用于在终端下定位表格的下一列，。<code>\v</code>比较少用，<code>\t</code>比较常用，以后将“水平制表符”简称为“制表符”或<code>Tab</code>。请读者用<code>printf</code>语句试试这几个控制字符的作用。</p>
<p>注意<code>"Goodbye, "</code>末尾的空格，字符串字面值中的空格也算一个字符，也会出现在输出结果中，而程序中别处的空格和<code>Tab</code>多一个少一个往往是无关紧要的，不会对编译的结果产生任何影响，例如不缩进不会影响程序的结果，<code>main</code>后面多几个空格也没影响，但是<code>int</code>和<code>main</code>之间至少要有一个空格分隔开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span>    <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅空格和<code>Tab</code>是无关紧要的，换行也是如此，我甚至可以把整个程序写成一行，但是<code>include</code>必须单独占一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;Hello, world.\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这样也行，但肯定不是好的代码风格，去掉缩进已经很影响可读性了，写成现在这个样子可读性更差。如果编译器说第2行有错误，也很难判断是哪个语句有错误。所以，好的代码风格要求缩进整齐，每个语句一行，适当留空行。</p>
<h2 id="常量">常量</h2>
<p>常量（Constant）是程序中最基本的元素，有字符（Character）常量、整数（Integer）常量、浮点数（Floating
Point）常量和枚举常量。下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;character: %c\ninteger: %d\nfloating point: %f\n&quot;</span>, <span class="string">&#x27;&#125;&#x27;</span>, <span class="number">34</span>, <span class="number">3.14</span>);</span><br></pre></td></tr></table></figure>
<p>字符常量要用单引号括起来，例如上面的<code>'&#125;'</code>，注意单引号只能括一个字符而不能像双引号那样括一串字符，字符常量也可以是一个转义序列，例如<code>'\n'</code>，这时虽然单引号括了两个字符，但实际上只表示一个字符。和字符串字面值中使用转义序列有一点区别，如果在字符常量中要表示双引号<code>"</code>和问号<code>?</code>，既可以使用转义序列<code>\"</code>和<code>\?</code>，也可以直接用字符<code>"</code>和<code>?</code>，而要表示<code>'</code>和<code>\</code>则必须使用转义序列。</p>
<p>计算机中整数和小数的内部表示方式不同，因而在C语言中是两种不同的类型（Type），例如上例的<code>34</code>和<code>3.14</code>，小数在计算机术语中称为浮点数。这个语句的输出结果和<code>Hello world</code>不太一样，字符串<code>"character: %c\ninteger: %d\nfloating point: %f\n"</code>并不是按原样打印输出的，而是输出成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">character: &#125;</span><br><span class="line">integer: <span class="number">34</span></span><br><span class="line">floating point: <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<p><code>printf</code>中的第一个字符串称为格式化字符串（Format
String），它规定了后面几个常量以何种格式插入到这个字符串中，在格式化字符串中%号（Percent
Sign）后面加上字母<code>c、d、f</code>分别表示字符型、整型和浮点型的转换说明（Conversion
Specification），转换说明只在格式化字符串中占个位置，并不出现在最终的打印结果中，这种用法通常叫做占位符（Placeholder）。这也是一种字面意思与真实意思不同的情况，但是转换说明和转义序列又有区别：转义序列是编译时处理的，而转换说明是在运行时调用<code>printf</code>函数处理的。源文件中的字符串字面值是<code>"character: %c\ninteger: %d\nfloating point: %f\n"</code>，<code>\n</code>占两个字符，而编译之后保存在可执行文件中的字符串是<code>character： %c</code>换行<code>integer: %d</code>换行<code>floating point: %f</code>换行，<code>\n</code>已经被替换成一个换行符，而<code>%c</code>不变，然后在运行时这个字符串被传给<code>printf</code>，<code>printf</code>再把其中的<code>%c、%d、%f</code>解释成转换说明。</p>
<p>有时候不同类型的数据很容易弄混，例如<code>"5"、'5'、5</code>，如果你注意了它们的界定符就会很清楚，第一个是字符串字面值，第二个是字符，第三个是整数，看了本章后面几节你就知道为什么一定要严格区分它们之间的差别了。</p>
<h2 id="变量">变量</h2>
<p>变量（Variable）是编程语言最重要的概念之一，变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，比如这次存个字符<code>'a'</code>下次存个字符<code>'b'</code>，正因为变量的值可以随时变所以才叫变量。</p>
<p>常量有不同的类型，因此变量也有不同的类型，变量的类型也决定了它所占的存储空间的大小。例如以下四个语句定义了四个变量<code>fred</code>、<code>bob</code>、<code>jimmy</code>和<code>tom</code>，它们的类型分别是字符型、整型、浮点型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> fred;</span><br><span class="line"><span class="type">int</span> bob;</span><br><span class="line"><span class="type">float</span> jimmy;</span><br><span class="line"><span class="type">double</span> tom;</span><br></pre></td></tr></table></figure>
<p>声明和定义:</p>
<p>C语言中的声明（Declaration）有变量声明、函数声明和类型声明三种。如果一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition），因此定义是声明的一种。在接下来几章的示例代码中变量声明都是要分配存储空间的，因而都是定义，等学到第
2 节
“定义和声明”我们会看到哪些变量声明不分配存储空间因而不是定义。在下一章我们会看到函数的定义和声明也是这样区分的，分配存储空间的函数声明可以称为函数定义。从第
7 章
结构体开始我们会看到类型声明，声明一个类型是不分配存储空间的，但似乎叫“类型定义”听起来也不错，所以在本书中“类型定义”和“类型声明”表示相同的含义。声明和语句类似，也是以;号结尾的，但是在语法上声明和语句是有区别的，语句只能出现在{}括号中，而声明既可以出现在{}中也可以出现在所有{}之外。</p>
<p>浮点型有三种，<code>float</code>是单精度浮点型，<code>double</code>是双精度浮点型，<code>long double</code>是精度更高的浮点型。它们之间的区别和转换规则将在第
15 章
数据类型详解详细介绍，在随后的几章中我们只使用<code>double</code>类型，上一节介绍的常量<code>3.14</code>应该看作<code>double</code>类型的常量，<code>printf</code>的<code>%f</code>也应该看作<code>double</code>型的转换说明。给变量起名不能太随意，上面四个变量的名字就不够好，我们猜不出这些变量是用来存什么的。而像下面这样起名就很好：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> firstletter;</span><br><span class="line"><span class="type">char</span> lastletter;</span><br><span class="line"><span class="type">int</span> hour, minute;</span><br></pre></td></tr></table></figure>
<p>我们可以猜得到这些变量是用来存什么的，前两个变量的取值范围应该是<code>'A'~'Z'</code>或<code>'a'~'z'</code>，变量<code>hour</code>的取值范围应该是<code>0~23</code>，变量<code>minute</code>的取值范围应该是<code>0~59</code>，所以应该给变量起有意义的名字。从这个例子中我们也看到两个相同类型的变量（hour和minute）可以一起声明。</p>
<p>给变量起名有一定的限制，C语言规定必须以字母或下划线<code>_</code>（Underscore）开头，后面可以跟若干个字母、数字、下划线，但不能有其它字符。例如这些是合法的变量名：<code>Abc、__abc__、_123</code>。但这些是不合法的变量名：<code>3abc、ab$</code>。其实这个规则不仅适用于变量名，也适用于所有可以由程序员起名的语法元素，例如以后要讲的函数名、宏定义、结构体成员名等，在C语言中这些统称为标识符（Identifier）。</p>
<p>另外要注意，表示类型的<code>char、int、float、double</code>等虽然符合上述规则，但也不能用作标识符。在C语言中有些单词有特殊意义，不允许用作标识符，这些单词称为关键字（Keyword）或保留字（Reserved
Word）。通常用于编程的文本编辑器都会高亮显示（Highlight）这些关键字，所以只要小心一点通常不会误用作标识符。C99规定的关键字有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>  <span class="keyword">break</span>  <span class="keyword">case</span>  <span class="type">char</span>  <span class="type">const</span>  <span class="keyword">continue</span>  <span class="keyword">default</span>  <span class="keyword">do</span>  <span class="type">double</span></span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">enum</span>  <span class="keyword">extern</span>  <span class="type">float</span>  <span class="keyword">for</span>  <span class="keyword">goto</span>  <span class="keyword">if</span>  <span class="keyword">inline</span>  <span class="type">int</span>  <span class="type">long</span></span><br><span class="line"><span class="keyword">register</span>  <span class="keyword">restrict</span>  <span class="keyword">return</span>  <span class="type">short</span>  <span class="type">signed</span>  <span class="keyword">sizeof</span>  <span class="type">static</span>  <span class="keyword">struct</span>  <span class="keyword">switch</span>  <span class="keyword">typedef</span></span><br><span class="line"><span class="keyword">union</span>  <span class="type">unsigned</span>  <span class="type">void</span>  <span class="keyword">volatile</span>  <span class="keyword">while</span>  <span class="type">_Bool</span>  <span class="type">_Complex</span>  <span class="type">_Imaginary</span></span><br></pre></td></tr></table></figure>
<p>还有一点要注意，一般来说应避免使用以下划线开头的标识符，以下划线开头的标识符只要不和C语言关键字冲突的都是合法的，但是往往被编译器用作一些功能扩展，C标准库也定义了很多以下划线开头的标识符，所以除非你对编译器和C标准库特别清楚，一般应避免使用这种标识符，以免造成命名冲突。</p>
<p>请记住：理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，什么情况不属于这个概念，什么情况虽然属于这个概念但一般推荐的做法（Best
Practice）是要尽量避免这种情况，这才算是真正理解了。</p>
<h2 id="赋值">赋值</h2>
<p>定义了变量之后，我们要把值存到它们所表示的存储空间里，可以用赋值（Assignment）语句实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> firstletter;</span><br><span class="line"><span class="type">int</span> hour, minute;</span><br><span class="line">firstletter = <span class="string">&#x27;a&#x27;</span>;   <span class="comment">/* give firstletter the value &#x27;a&#x27; */</span></span><br><span class="line">hour = <span class="number">11</span>;           <span class="comment">/* assign the value 11 to hour */</span></span><br><span class="line">minute = <span class="number">59</span>;         <span class="comment">/* set minute to 59 */</span></span><br></pre></td></tr></table></figure>
<p>注意变量一定要先声明后使用，编译器必须先看到变量声明，才知道<code>firstletter</code>、<code>hour</code>和<code>minute</code>是变量名，各自代表一块存储空间。另外，变量声明中的类型表明这个变量代表多大的一块存储空间，这样编译器才知道如何读写这块存储空间。还要注意，这里的等号不表示数学里的相等关系，和1+1=2的等号是不同的，这里的等号表示赋值。在数学上不会有i=i+1这种等式成立，而在C语言中表示把变量<code>i</code>的存储空间中的值取出来，再加上<code>1</code>，得到的结果再存回<code>i</code>的存储空间中。再比如，在数学上a=7和7=a是一样的，而在C语言中后者是不合法的。总结一下：定义一个变量，就是分配一块存储空间并给它命名；给一个变量赋值，就是把一个值保存到这块存储空间中。变量的定义和赋值也可以一步完成，这称为变量的初始化（Initialization），例如要达到上面代码的效果也可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> firstletter = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> hour = <span class="number">11</span>, minute = <span class="number">59</span>;</span><br></pre></td></tr></table></figure>
<p>在初始化语句中，等号右边的值叫做Initializer，例如上面的<code>'a'</code>、<code>11</code>和<code>59</code>。注意，初始化是一种特殊的声明，而不是一种赋值语句。就目前来看，先定义一个变量再给它赋值和定义这个变量的同时给它初始化所达到的效果是一样的，C语言的很多语法规则既适用于赋值也适用于初始化，但在以后的学习中你也会了解到它们之间的不同，请在学习过程中注意总结赋值和初始化的相同和不同之处。</p>
<p>如果所赋的值和变量的类型不符会导致编译器报警告或报错（这是一种语义错误），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hour, minute;</span><br><span class="line">hour = <span class="string">&quot;Hello.&quot;</span>;       <span class="comment">/* WRONG ! */</span></span><br><span class="line">minute = <span class="string">&quot;59&quot;</span>;         <span class="comment">/* WRONG !! */</span></span><br></pre></td></tr></table></figure>
<p>注意第3个语句，把<code>"59"</code>赋给<code>minute</code>看起来像是对的，但是类型不对，字符串不能赋给整型变量。</p>
<p>既然可以为变量的存储空间赋值，就应该可以把值取出来用，现在我们取出这些变量的值用<code>printf</code>打印：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current time is %d:%d&quot;</span>, hour, minute);</span><br></pre></td></tr></table></figure>
<p>变量名用在等号左边表示赋值，而用在<code>printf</code>中表示把它的存储空间中的值取出来替换在那里。不同类型的变量所占的存储空间大小是不同的，数据表示方式也不同，变量的最小存储单位是字节（Byte），在C语言中<code>char</code>型变量占一个字节，其它类型的变量占多少字节在不同平台上有不同的规定，将在第
15 章 数据类型详解详细讨论。</p>
<h2 id="表达式">表达式</h2>
<p>常量和变量都可以参与加减乘除运算，例如<code>1+1、hour-1、hour * 60 + minute、minute/60</code>等。这里的<code>+ - * /</code>称为运算符（Operator），而参与运算的常量和变量称为操作数（Operand），上面四个由运算符和操作数所组成的算式称为表达式（Expression）。</p>
<p>和数学上规定的一样，<code>hour * 60 + minute</code>这个表达式应该先算乘再算加，也就是说运算符是有优先级（Precedence）的，<code>*</code>和<code>/</code>是同一优先级，<code>+</code>和<code>-</code>是同一优先级，<code>*</code>和<code>/</code>的优先级高于<code>+</code>和<code>-</code>。对于同一优先级的运算从左到右计算<code>，</code>如果不希望按默认的优先级计算则要加<code>()</code>括号（Parenthesis）。例如<code>(3+4)*5/6</code>应先算<code>3+4</code>，再算<code>*5</code>，再算<code>/6</code>。</p>
<p>前面讲过打印语句和赋值语句，现在我们定义：在任意表达式后面加个<code>;</code>号也是一种语句，称为表达式语句。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hour * <span class="number">60</span> + minute;</span><br></pre></td></tr></table></figure>
<p>这是个合法的语句，但这个语句在程序中起不到任何作用，把<code>hour</code>的值和<code>minute</code>的值取出来加乘，得到的计算结果却没有保存，白算了一通。再比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total_minute;</span><br><span class="line">total_minute = hour * <span class="number">60</span> + minute;</span><br></pre></td></tr></table></figure>
<p>这个语句就很有意义，把计算结果保存在另一个变量<code>total_minute</code>里。事实上等号也是一种运算符，称为赋值运算符，赋值语句就是一种表达式语句，等号的优先级比<code>+</code>和<code>*</code>都低，所以先算出等号右边的结果然后才做赋值操作，整个表达式<code>total_minute = hour * 60 + minute</code>加个<code>;</code>号构成一个语句。</p>
<p>任何表达式都有值和类型两个基本属性。<code>hour * 60 + minute</code>的值是由三个<code>int</code>型的操作数计算出来的，所以这个表达式的类型也是<code>int</code>型。同理，表达式<code>total_minute = hour * 60 + minute</code>的类型也是<code>int</code>，它的值是多少呢？C语言规定等号运算符的计算结果就是等号左边被赋予的那个值，所以这个表达式的值和<code>hour * 60 + minute</code>的值相同，也和<code>total_minute</code>的值相同。</p>
<p>等号运算符还有一个和<code>+ - * /</code>不同的特性，如果一个表达式中出现多个等号，不是从左到右计算而是从右到左计算，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total_minute, total;</span><br><span class="line">total = total_minute = hour * <span class="number">60</span> + minute;</span><br></pre></td></tr></table></figure>
<p>计算顺序是先算<code>hour * 60 + minute</code>得到一个结果，然后算右边的等号，就是把<code>hour * 60 + minute</code>的结果赋给变量<code>total_minute</code>，这个结果同时也是整个表达式<code>total_minute = hour * 60 + minute</code>的值，再算左边的等号，即把这个值再赋给变量<code>total</code>。同样优先级的运算符是从左到右计算还是从右到左计算称为运算符的结合性（Associativity）。<code>+ - * /</code>是左结合的，等号是右结合的。</p>
<p>现在我们总结一下到目前为止学过的语法规则：</p>
<p>表达式 → 标识符 表达式 → 常量 表达式 → 字符串字面值 表达式 → (表达式)
表达式 → 表达式 + 表达式 表达式 → 表达式 - 表达式 表达式 → 表达式 *
表达式 表达式 → 表达式 / 表达式 表达式 → 表达式 = 表达式 语句 → 表达式;
语句 → printf(表达式, 表达式, 表达式, …); 变量声明 → 类型 标识符 =
Initializer, 标识符 = Initializer, …; （=
Initializer的部分可以不写）</p>
<p>注意，本书所列的语法规则都是简化过的，是不准确的，目的是为了便于初学者理解，比如上面所列的语法规则并没有描述运算符的优先级和结合性。完整的C语法规则请参考[C99]的Annex
A。</p>
<p>表达式可以是单个的常量或变量，也可以是根据以上规则组合而成的更复杂的表达式。以前我们用<code>printf</code>打印常量或变量的值，现在可以用<code>printf</code>打印更复杂的表达式的值，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d is %d minutes after 00:00\n&quot;</span>, hour, minute, hour * <span class="number">60</span> + minute);</span><br></pre></td></tr></table></figure>
<p>编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成语法树，然后再根据语法树生成相应的指令。语法树的末端的是一个个Token，每一步展开利用一条语法规则。</p>
<p>根据这些语法规则进一步组合可以写出更复杂的语句，比如在一条语句中完成计算、赋值和打印功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d is %d minutes after 00:00\n&quot;</span>, hour, minute, total_minute = hour * <span class="number">60</span> + minute);</span><br></pre></td></tr></table></figure>
<p>理解组合（Composition）规则是理解语法规则的关键所在，正因为可以根据语法规则任意组合，我们才可以用简单的常量、变量、表达式、语句搭建出任意复杂的程序，以后我们学习新的语法规则时会进一步体会到这一点。从上面的例子可以看出，表达式不宜过度组合，否则会给阅读和调试带来困难。</p>
<p>根据语法规则组合出来的表达式在语义上并不总是正确的，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute + <span class="number">1</span> = hour;</span><br></pre></td></tr></table></figure>
<p>等号左边的表达式要求表示一个存储位置而不是一个值，这是等号运算符和<code>+ - * /</code>运算符的又一个显著不同。有的表达式既可以表示一个存储位置也可以表示一个值，而有的表达式只能表示值，不能表示存储位置，例如<code>minute + 1</code>这个表达式就不能表示存储位置，放在等号左边是语义错误。表达式所表示的存储位置称为左值（lvalue）（允许放在等号左边），而以前我们所说的表达式的值也称为右值（rvalue）（只能放在等号右边）。上面的话换一种说法就是：有的表达式既可以做左值也可以做右值，而有的表达式只能做右值。目前我们学过的表达式中只有变量可以做左值，可以做左值的表达式还有几种，以后会讲到。</p>
<p>我们看一个有意思的例子，如果定义三个变量<code>int a, b, c;</code>，表达式<code>a = b = c</code>是合法的，先求<code>b = c</code>的值，再把这个值赋给<code>a</code>，而表达式<code>(a = b) = c</code>是不合法的，先求<code>(a = b)</code>的值没问题，但<code>(a = b)</code>这个表达式不能再做左值了，因此放在<code>= c</code>的等号左边是错的。</p>
<p>关于整数除法运算有一点特殊之处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hour = <span class="number">11</span>;</span><br><span class="line">minute = <span class="number">59</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d and %d hours\n&quot;</span>, hour, minute / <span class="number">60</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果是<code>11 and 0 hours</code>，也就是说<code>59/60</code>得<code>0</code>，这是因为两个<code>int</code>型操作数相除的表达式仍为<code>int</code>型，只能保存计算结果的整数部分，即使小数部分是<code>0.98</code>也要舍去。</p>
<p>向下取整的运算称为Floor，用数学符号<code>⌊⌋</code>表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。例如：</p>
<p>⌊59/60⌋=0 ⌈59/60⌉=1 ⌊-59/60⌋=-1 ⌈-59/60⌉=0</p>
<p>在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate
toward
Zero），或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。回到先前的例子，要得到更精确的结果可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d hours and %d percent of an hour\n&quot;</span>, hour, minute * <span class="number">100</span> / <span class="number">60</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d and %f hours\n&quot;</span>, hour, minute / <span class="number">60.0</span>);</span><br></pre></td></tr></table></figure>
<p>在第二个<code>printf</code>中，表达式是<code>minute / 60.0</code>，<code>60.0</code>是<code>double</code>型的，<code>/</code>运算符要求左右两边的操作数类型一致，而现在并不一致。C语言规定了一套隐式类型转换规则，在这里编译器自动把左边的<code>minute</code>也转成<code>double</code>型来计算，整个表达式的值也是<code>double</code>型的，在格式化字符串中应该用<code>%f</code>转换说明与之对应。本来编程语言作为一种形式语言要求有简单而严格的规则，自动类型转换规则不仅很复杂，而且使C语言的形式看起来也不那么严格了，C语言这么设计是为了书写程序简便而做的折衷，有些事情编译器可以自动做好，程序员就不必每次都写一堆繁琐的转换代码。然而C语言的类型转换规则非常难掌握，本书的前几章会尽量避免类型转换，到第
3 节 “类型转换”再集中解决这个问题。</p>
<h2 id="字符类型与字符编码">字符类型与字符编码</h2>
<p>字符常量或字符型变量也可以当作整数参与运算，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, <span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果是<code>b</code>。</p>
<p>我们知道，符号在计算机内部也用数字表示，每个字符在计算机内部用一个整数表示，称为字符编码（Character
Encoding），目前最常用的是ASCII码（American Standard Code for
Information
Interchange，美国信息交换标准码），详见ASCII码表。表中每一栏的最后一列是字符，前三列分别是用十进制（Dec）、十六进制（Hx）和八进制（Oct）表示的字符编码，各种进制之间的换算将在第
2 节
“不同进制之间的换算”介绍。从十进制那一列可以看出ASCII码的取值范围是0~127。表中的很多字符是不可见字符（Non-printable
Character）或空白字符（Whitespace）[3]，不能像字母a这样把字符本身填在表中，而是用一个名字来描述该字符，例如CR(carriage
return)、LF(NL line feed，newline)、DEL等等。作为练习，请读者查一查表
2.1 “C标准规定的转义字符”中的字符在ASCII码表中的什么位置。</p>
<p>回到刚才的例子，在ASCII码中字符<code>a</code>是<code>97</code>，字符<code>b</code>是<code>98</code>。计算<code>'a'+1</code>这个表达式，应该按ASCII码把<code>'a'</code>当作整数值<code>97</code>，然后加<code>1</code>，得到<code>98</code>，然后<code>printf</code>把<code>98</code>这个整数值当作ASCII码来解释，打印出相应的字符<code>b</code>。</p>
<p>之前我们说“整型”是指<code>int</code>型，而现在我们知道<code>char</code>型本质上就是整数，只不过取值范围比<code>int</code>型小，所以以后我们把<code>char</code>型和<code>int</code>型统称为整数类型（Integer
Type）或简称整型，以后我们还要学习几种类型也属于整型，将在第 1 节
“整型”详细介绍。</p>
<p>字符<code>'a'~'z'</code>、<code>'A'~'Z'</code>、<code>'0'~'9'</code>的ASCII码都是连续的，因此表达式<code>'a'+25</code>和<code>'z'</code>的值相等，<code>'0'+9</code>和<code>'9'</code>的值也相等。注意<code>'0'~'9'</code>的ASCII码是十六进制的<code>30~39</code>，和整数值<code>0~9</code>是不相等的。</p>
<p>字符也可以用ASCII码转义序列表示，这种转义序列由<code>\</code>加上1<sub>3个八进制数字组成，或者由<code>\x</code>或大写<code>\X</code>加上1</sub>2个十六进制数字组成，可以用在字符常量或字符串字面值中。例如<code>'\0'</code>表示<code>NUL</code>字符（Null
Character），<code>'\11'</code>或<code>'\x9'</code>表示<code>Tab</code>字符，<code>"\11"</code>或<code>"\x9"</code>表示由<code>Tab</code>字符组成的字符串。注意<code>'0'</code>的ASCII码是<code>48</code>，而<code>'\0'</code>的ASCII码是<code>0</code>，两者是不同的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:函数接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-09 17:20:36" itemprop="dateModified" datetime="2025-08-09T17:20:36+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们在第 6 节
“折半查找”讲过，函数的调用者和函数的实现者之间订立了一个契约，在调用函数之前，调用者要为实现者提供某些条件，在函数返回时，实现者要对调用者尽到某些义务。如何描述这个契约呢？首先靠函数接口来描述，即函数名，参数，返回值，只要函数和参数的名字起得合理，参数和返回值的类型定得准确，至于这个函数怎么用，调用者单看函数接口就能猜出八九分了。函数接口并不能表达函数的全部语义，这时文档就起了重要的补充作用，函数的文档该写什么，怎么写，Man
Page为我们做了很好的榜样。</p>
<p>函数接口一旦和指针结合起来就变得异常灵活，有五花八门的用法，但是万变不离其宗，只要像图
23.1
“指针的基本概念”那样画图分析，指针的任何用法都能分析清楚，所以，如果上一章你真正学明白了，本章不用学也能自己领悟出来，之所以写这一章是为了照顾悟性不高的读者。本章把函数接口总结成几类常见的模式，对于每种模式，一方面讲函数接口怎么写，另一方面讲函数的文档怎么写。</p>
<h2 id="本章预备知识">本章预备知识</h2>
<p>这一节介绍本章的范例代码要用的几个C标准库函数。我们先体会一下这几个函数的接口是怎么设计的，Man
Page是怎么写的。其它常用的C标准库函数将在下一章介绍。</p>
<h3 id="strcpy和strncpy">strcpy和strncpy</h3>
<p>从现在开始我们要用到很多库函数，在学习每个库函数时一定要看Man
Page。Man
Page随时都在我们手边，想查什么只要敲一个命令就行，然而很多初学者就是不喜欢看Man
Page，宁可满世界去查书、查资料，也不愿意看Man
Page。据我分析原因有三：</p>
<p>英文不好。那还是先学好了英文再学编程吧，否则即使你把这本书都学透了也一样无法胜任开发工作，因为你没有进一步学习的能力。</p>
<p>Man Page的语言不够友好。Man
Page不像本书这样由浅入深地讲解，而是平铺直叙，不过看习惯了就好了，每个Man
Page都不长，多看几遍自然可以抓住重点，理清头绪。本节分析一个例子，帮助读者把握Man
Page的语言特点。</p>
<p>Man
Page通常没有例子。描述一个函数怎么用，一靠接口，二靠文档，而不是靠例子。函数的用法无非是本章所总结的几种模式，只要把本章学透了，你就不需要每个函数都得有个例子教你怎么用了。</p>
<p>总之，Man
Page是一定要看的，一开始看不懂硬着头皮也要看，为了鼓励读者看Man
Page，本书不会像[K&amp;R]那样把库函数总结成一个附录附在书后面。现在我们来分析strcpy(3)。</p>
<figure>
<img src="C:\blog\Blog\images\C\interface.synopsis.png"
alt="strcpy(3)" />
<figcaption aria-hidden="true">strcpy(3)</figcaption>
</figure>
<p>这个Man
Page描述了两个函数，<code>strcpy</code>和<code>strncpy</code>，敲命令<code>man strcpy</code>或者<code>man strncpy</code>都可以看到这个Man
Page。这两个函数的作用是把一个字符串拷贝给另一个字符串。SYNOPSIS部分给出了这两个函数的原型，以及要用这些函数需要包含哪些头文件。参数<code>dest</code>、<code>src</code>和<code>n</code>都加了下划线，有时候并不想从头到尾阅读整个Man
Page，而是想查一下某个参数的含义，通过下划线和参数名就能很快找到你关心的部分。</p>
<p><code>dest</code>表示Destination，<code>src</code>表示Source，看名字就能猜到是把<code>src</code>所指向的字符串拷贝到<code>dest</code>所指向的内存空间。这一点从两个参数的类型也能看出来，<code>dest</code>是<code>char *</code>型的，而<code>src</code>是<code>const char *</code>型的，说明<code>src</code>所指向的内存空间在函数中只能读不能改写，而<code>dest</code>所指向的内存空间在函数中是要改写的，显然改写的目的是当函数返回后调用者可以读取改写的结果。因此可以猜到<code>strcpy</code>函数是这样用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf);</span><br></pre></td></tr></table></figure>
<p>至于<code>strncpy</code>的参数<code>n</code>是干什么用的，单从函数接口猜不出来，就需要看下面的文档。</p>
<figure>
<img src="C:\blog\Blog\images\C\interface.description.png"
alt="strcpy(3)" />
<figcaption aria-hidden="true">strcpy(3)</figcaption>
</figure>
<p>在文档中强调了<code>strcpy</code>在拷贝字符串时会把结尾的<code>'\0'</code>也拷到<code>dest</code>中，因此保证了<code>dest</code>中是以<code>'\0'</code>结尾的字符串。但另外一个要注意的问题是，<code>strcpy</code>只知道<code>src</code>字符串的首地址，不知道长度，它会一直拷贝到<code>'\0'</code>为止，所以<code>dest</code>所指向的内存空间要足够大，否则有可能写越界，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果没有保证<code>src</code>所指向的内存空间以<code>'\0'</code>结尾，也有可能读越界，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;abcdefghij&quot;</span>, str[<span class="number">4</span>] = <span class="string">&quot;hell&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, str);</span><br></pre></td></tr></table></figure>
<p>因为<code>strcpy</code>函数的实现者通过函数接口无法得知<code>src</code>字符串的长度和<code>dest</code>内存空间的大小，所以“确保不会写越界”应该是调用者的责任，调用者提供的<code>dest</code>参数应该指向足够大的内存空间，“确保不会读越界”也是调用者的责任，调用者提供的<code>src</code>参数指向的内存应该确保以<code>'\0'</code>结尾。</p>
<p>此外，文档中还强调了<code>src</code>和<code>dest</code>所指向的内存空间不能有重叠。凡是有指针参数的C标准库函数基本上都有这条要求，每个指针参数所指向的内存空间互不重叠，例如这样调用是不允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, buf+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><code>strncpy</code>的参数<code>n</code>指定最多从<code>src</code>中拷贝<code>n</code>个字节到<code>dest</code>中，换句话说，如果拷贝到<code>'\0'</code>就结束，如果拷贝到<code>n</code>个字节还没有碰到<code>'\0'</code>，那么也结束，调用者负责提供适当的<code>n</code>值，以确保读写不会越界，比如让<code>n</code>的值等于<code>dest</code>所指向的内存空间的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(buf, <span class="string">&quot;hello world&quot;</span>, <span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>
<p>然而这意味着什么呢？文档中特别用了Warning指出，这意味着<code>dest</code>有可能不是以<code>'\0'</code>结尾的。例如上面的调用，虽然把<code>"hello world"</code>截断到10个字符拷贝至<code>buf</code>中，但<code>buf</code>不是以<code>'\0'</code>结尾的，如果再<code>printf(buf)</code>就会读越界。如果你需要确保<code>dest</code>以<code>'\0'</code>结束，可以这么调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(buf, <span class="string">&quot;hello world&quot;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">buf[<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>strncpy</code>还有一个特性，如果<code>src</code>字符串全部拷完了不足<code>n</code>个字节，那么还差多少个字节就补多少个<code>'\0'</code>，但是正如上面所述，这并不保证<code>dest</code>一定以<code>'\0'</code>结束，当<code>src</code>字符串的长度大于<code>n</code>时，不但不补多余的<code>'\0'</code>，连字符串的结尾<code>'\0'</code>也不拷贝。<code>strcpy(3)</code>的文档已经相当友好了，为了帮助理解，还给出一个<code>strncpy</code>的简单实现。</p>
<figure>
<img src="C:\blog\Blog\images\C\interface.return.png" alt="strcpy(3)" />
<figcaption aria-hidden="true">strcpy(3)</figcaption>
</figure>
<p>函数的Man
Page都有一部分专门讲返回值的。这两个函数的返回值都是<code>dest</code>指针。可是为什么要返回<code>dest</code>指针呢？<code>dest</code>指针本来就是调用者传过去的，再返回一遍<code>dest</code>指针并没有提供任何有用的信息。之所以这么规定是为了把函数调用当作一个指针类型的表达式使用，比如<code>printf("%s\n", strcpy(buf, "hello"))</code>，一举两得，如果<code>strcpy</code>的返回值是<code>void</code>就没有这么方便了。</p>
<p>CONFORMING
TO部分描述了这个函数是遵照哪些标准实现的。<code>strcpy</code>和<code>strncpy</code>是C标准库函数，当然遵照C99标准。以后我们还会看到<code>libc</code>中有些函数属于POSIX标准但并不属于C标准，例如<code>write(2)</code>。</p>
<p>NOTES部分给出一些提示信息。这里指出如何确保<code>strncpy</code>的<code>dest</code>以<code>'\0'</code>结尾，和我们上面给出的代码类似，但由于<code>n</code>是个变量，在执行<code>buf[n - 1]= '\0';</code>之前先检查一下<code>n</code>是否大于0，如果<code>n</code>不大于0，<code>buf[n - 1]</code>就访问越界了，所以要避免。</p>
<figure>
<img src="C:\blog\Blog\images\C\interface.bugs.png" alt="strcpy(3)" />
<figcaption aria-hidden="true">strcpy(3)</figcaption>
</figure>
<p>BUGS部分说明了使用这些函数可能引起的Bug，这部分一定要仔细看。用<code>strcpy</code>比用<code>strncpy</code>更加不安全，如果在调用<code>strcpy</code>之前不仔细检查<code>src</code>字符串的长度就有可能写越界，这是一个很常见的错误，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, str);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>str</code>所指向的字符串有可能超过10个字符而导致写越界，在第 4
节
“段错误”我们看到过，这种写越界可能当时不出错，而在函数返回时出现段错误，原因是写越界覆盖了保存在栈帧上的返回地址，函数返回时跳转到非法地址，因而出错。像buf这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区（Buffer），缓冲区写越界的错误称为缓冲区溢出（Buffer
Overflow）。如果只是出现段错误那还不算严重，更严重的是缓冲区溢出Bug经常被恶意用户利用，使函数返回时跳转到一个事先设好的地址，执行事先设好的指令，如果设计得巧妙甚至可以启动一个Shell，然后随心所欲执行任何命令，可想而知，如果一个用root权限执行的程序存在这样的Bug，被攻陷了，后果将很严重。至于怎样巧妙设计和攻陷一个有缓冲区溢出Bug的程序，有兴趣的读者可以参考[SmashStack]。</p>
<h3 id="malloc和free">malloc和free</h3>
<p>程序中需要动态分配一块内存时怎么办呢？可以像上一节那样定义一个缓冲区数组。这种方法不够灵活，C89要求定义的数组是固定长度的，而程序往往在运行时才知道要动态分配多大的内存，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[?];</span><br><span class="line">    <span class="built_in">strncpy</span>(buf, str, n);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>n</code>是由参数传进来的，事先不知道是多少，那么<code>buf</code>该定义多大呢？在第
1 节
“数组的基本概念”讲过C99引入VLA特性，可以定义<code>char buf[n+1] = &#123;&#125;;</code>，这样可确保<code>buf</code>是以<code>'\0'</code>结尾的。但即使用VLA仍然不够灵活，VLA是在栈上动态分配的，函数返回时就要释放，如果我们希望动态分配一块全局的内存空间，在各函数中都可以访问呢？由于全局数组无法定义成VLA，所以仍然不能满足要求。</p>
<p>其实在第 5 节
“虚拟内存管理”提过，进程有一个堆空间，C标准库函数<code>malloc</code>可以在堆空间动态分配内存，它的底层通过<code>brk</code>系统调用向操作系统申请内存。动态分配的内存用完之后可以用<code>free</code>释放，更准确地说是归还给<code>malloc</code>，这样下次调用<code>malloc</code>时这块内存可以再次被分配。本节学习这两个函数的用法和工作原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>返回值：成功返回所分配内存空间的首地址，出错返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>的参数<code>size</code>表示要分配的字节数，如果分配失败（可能是由于系统内存耗尽）则返回<code>NULL</code>。由于<code>malloc</code>函数不知道用户拿到这块内存要存放什么类型的数据，所以返回通用指针<code>void *</code>，用户程序可以转换成其它类型的指针再访问这块内存。<code>malloc</code>函数保证它返回的指针所指向的地址满足系统的对齐要求，例如在32位平台上返回的指针一定对齐到4字节边界，以保证用户程序把它转换成任何类型的指针都能用。</p>
<p>动态分配的内存用完之后可以用<code>free</code>释放掉，传给<code>free</code>的参数正是先前<code>malloc</code>返回的内存块首地址。举例如下：</p>
<p>例 <code>malloc</code>和<code>free</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">&#125; <span class="type">unit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unit_t</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unit_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;out of memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;number = <span class="number">3</span>;</span><br><span class="line">    p-&gt;msg = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;msg, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number: %d\nmsg: %s\n&quot;</span>, p-&gt;number, p-&gt;msg);</span><br><span class="line">    <span class="built_in">free</span>(p-&gt;msg);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个程序要注意以下几点：</p>
<p><code>unit_t *p = malloc(sizeof(unit_t));</code>这一句，等号右边是<code>void *</code>类型，等号左边是<code>unit_t *</code>类型，编译器会做隐式类型转换，我们讲过<code>void *</code>类型和任何指针类型之间可以相互隐式转换。</p>
<p>虽然内存耗尽是很不常见的错误，但写程序要规范，<code>malloc</code>之后应该判断是否成功。以后要学习的大部分系统函数都有成功的返回值和失败的返回值，每次调用系统函数都应该判断是否成功。</p>
<p><code>free(p);</code>之后，<code>p</code>所指的内存空间是归还了，但是<code>p</code>的值并没有变，因为从<code>free</code>的函数接口来看根本就没法改变<code>p</code>的值，<code>p</code>现在指向的内存空间已经不属于用户，换句话说，<code>p</code>成了野指针，为避免出现野指针，我们应该在<code>free(p);</code>之后手动置<code>p = NULL;</code>。</p>
<p>应该先<code>free(p-&gt;msg)</code>，再<code>free(p)</code>。如果先<code>free(p)</code>，<code>p</code>成了野指针，就不能再通过<code>p-&gt;msg</code>访问内存了。</p>
<p>上面的例子只有一个简单的顺序控制流程，分配内存，赋值，打印，释放内存，退出程序。这种情况下即使不用<code>free</code>释放内存也可以，因为程序退出时整个进程地址空间都会释放，包括堆空间，该进程占用的所有内存都会归还给操作系统。但如果一个程序长年累月运行（例如网络服务器程序），并且在循环或递归中调用<code>malloc</code>分配内存，则必须有<code>free</code>与之配对，分配一次就要释放一次，否则每次循环都分配内存，分配完了又不释放，就会慢慢耗尽系统内存，这种错误称为内存泄漏（Memory
Leak）。另外，<code>malloc</code>返回的指针一定要保存好，只有把它传给free才能释放这块内存，如果这个指针丢失了，就没有办法<code>free</code>这块内存了，也会造成内存泄漏。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>foo</code>函数返回时要释放局部变量<code>p</code>的内存空间，它所指向的内存地址就丢失了，这10个字节也就没法释放了。内存泄漏的Bug很难找到，因为它不会像访问越界一样导致程序运行错误，少量内存泄漏并不影响程序的正确运行，大量的内存泄漏会使系统内存紧缺，导致频繁换页，不仅影响当前进程，而且把整个系统都拖得很慢。</p>
<p>关于<code>malloc</code>和<code>free</code>还有一些特殊情况。<code>malloc(0)</code>这种调用也是合法的，也会返回一个非<code>NULL</code>的指针，这个指针也可以传给<code>free</code>释放，但是不能通过这个指针访问内存。<code>free(NULL)</code>也是合法的，不做任何事情，但是<code>free</code>一个野指针是不合法的，例如先调用<code>malloc</code>返回一个指针<code>p</code>，然后连着调用两次<code>free(p);</code>，则后一次调用会产生运行时错误。</p>
<p>[K&amp;R]的8.7节给出了<code>malloc</code>和<code>free</code>的简单实现，基于环形链表。目前读者还没有学习链表，看那段代码会有点困难，我再做一些简化，图示如下，目的是让读者理解<code>malloc</code>和<code>free</code>的工作原理。<code>libc</code>的实现比这要复杂得多，但基本工作原理也是如此。读者只要理解了基本工作原理，就很容易分析在使用<code>malloc</code>和<code>free</code>时遇到的各种Bug了。</p>
<figure>
<img src="C:\blog\Blog\images\C\interface.malloc.png"
alt="简单的malloc和free实现" />
<figcaption aria-hidden="true">简单的malloc和free实现</figcaption>
</figure>
<p>图中白色背景的框表示<code>malloc</code>管理的空闲内存块，深色背景的框不归<code>malloc</code>管，可能是已经分配给用户的内存块，也可能不属于当前进程，Break之上的地址不属于当前进程，需要通过<code>brk</code>系统调用向内核申请。每个内存块开头都有一个头节点，里面有一个指针字段和一个长度字段，指针字段把所有空闲块的头节点串在一起，组成一个环形链表，长度字段记录着头节点和后面的内存块加起来一共有多长，以8字节为单位（也就是以头节点的长度为单位）。</p>
<p>一开始堆空间由一个空闲块组成，长度为7×8=56字节，除头节点之外的长度为48字节。</p>
<p>调用<code>malloc</code>分配8个字节，要在这个空闲块的末尾截出16个字节，其中新的头节点占了8个字节，另外8个字节返回给用户使用，注意返回的指针<code>p1</code>指向头节点后面的内存块。</p>
<p>又调用<code>malloc</code>分配16个字节，又在空闲块的末尾截出24个字节，步骤和上一步类似。</p>
<p>调用<code>free</code>释放p1所指向的内存块，内存块（包括头节点在内）归还给了<code>malloc</code>，现在<code>malloc</code>管理着两块不连续的内存，用环形链表串起来。注意这时<code>p1</code>成了野指针，指向不属于用户的内存，<code>p1</code>所指向的内存地址在Break之下，是属于当前进程的，所以访问<code>p1</code>时不会出现段错误，但在访问<code>p1</code>时这段内存可能已经被<code>malloc</code>再次分配出去了，可能会读到意外改写数据。另外注意，此时如果通过<code>p2</code>向右写越界，有可能覆盖右边的头节点，从而破坏<code>malloc</code>管理的环形链表，<code>malloc</code>就无法从一个空闲块的指针字段找到下一个空闲块了，找到哪去都不一定，全乱套了。</p>
<p>调用<code>malloc</code>分配16个字节，现在虽然有两个空闲块，各有8个字节可分配，但是这两块不连续，<code>malloc</code>只好通过<code>brk</code>系统调用抬高Break，获得新的内存空间。在[K&amp;R]的实现中，每次调用<code>sbrk</code>函数时申请1024×8=8192个字节，在Linux系统上<code>sbrk</code>函数也是通过<code>brk</code>实现的，这里为了画图方便，我们假设每次调用<code>sbrk</code>申请32个字节，建立一个新的空闲块。</p>
<p>新申请的空闲块和前一个空闲块连续，因此可以合并成一个。在能合并时要尽量合并，以免空闲块越割越小，无法满足大的分配请求。</p>
<p>在合并后的这个空闲块末尾截出24个字节，新的头节点占8个字节，另外16个字节返回给用户。</p>
<p>调用<code>free(p3)</code>释放这个内存块，由于它和前一个空闲块连续，又重新合并成一个空闲块。注意，Break只能抬高而不能降低，从内核申请到的内存以后都归<code>malloc</code>管了，即使调用<code>free</code>也不会还给内核。</p>
<h2 id="传入参数与传出参数">传入参数与传出参数</h2>
<p>如果函数接口有指针参数，既可以把指针所指向的数据传给函数使用（称为传入参数），也可以由函数填充指针所指的内存空间，传回给调用者使用（称为传出参数），例如<code>strcpy</code>的<code>src</code>参数是传入参数，<code>dest</code>参数是传出参数。有些函数的指针参数同时担当了这两种角色，如<code>select(2)</code>的<code>fd_set *</code>参数，既是传入参数又是传出参数，这称为Value-result参数。</p>
<p>传入参数示例：<code>void func(const unit_t *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配p所指的内存空间<br>在p所指的内存空间中保存数据<br>调用函数<br>由于有const限定符，调用者可以确信p所指的内存空间不会被改变</td>
<td>规定指针参数的类型unit_t *<br>读取p所指的内存空间</td>
</tr>
</tbody>
</table>
<p>想一想，如果有函数接口<code>void func(const int p);</code>这里的<code>const</code>有意义吗？</p>
<p>传出参数示例：<code>void func(unit_t *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配p所指的内存空间<br>调用函数<br>读取p所指的内存空间<br></td>
<td>规定指针参数的类型unit_t *<br>在p所指的内存空间中保存数据</td>
</tr>
</tbody>
</table>
<p>Value-result参数示例：<code>void func(unit_t *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配p所指的内存空间<br>在p所指的内存空间保存数据<br>调用函数<br>读取p所指的内存空间<br></td>
<td>规定指针参数的类型unit_t
*<br>读取p所指的内存空间<br>改写p所指的内存空间<br></td>
</tr>
</tbody>
</table>
<p>由于传出参数和Value-result参数的函数接口完全相同，应该在文档中说明是哪种参数。</p>
<p>以下是一个传出参数的完整例子：</p>
<p>例 传出参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* populator.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> POPULATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POPULATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> number;</span><br><span class="line">     <span class="type">char</span> msg[<span class="number">20</span>];</span><br><span class="line">&#125; <span class="type">unit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">set_unit</span><span class="params">(<span class="type">unit_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* populator.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;populator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_unit</span><span class="params">(<span class="type">unit_t</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span>; <span class="comment">/* ignore NULL parameter */</span></span><br><span class="line">     p-&gt;number = <span class="number">3</span>;</span><br><span class="line">     <span class="built_in">strcpy</span>(p-&gt;msg, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;populator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">unit_t</span> u;</span><br><span class="line"></span><br><span class="line">     set_unit(&amp;u);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;number: %d\nmsg: %s\n&quot;</span>, u.number, u.msg);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多系统函数对于指针参数是<code>NULL</code>的情况有特殊规定：如果传入参数是<code>NULL</code>表示取缺省值，例如<code>pthread_create(3)</code>的<code>pthread_attr_t *</code>参数，也可能表示不做特别处理，例如<code>free</code>的参数；如果传出参数是<code>NULL</code>表示调用者不需要传出值，例如<code>time(2)</code>的参数。这些特殊规定应该在文档中写清楚。</p>
<h2 id="两层指针的参数">两层指针的参数</h2>
<p>两层指针也是指针，同样可以表示传入参数、传出参数或者Value-result参数，只不过该参数所指的内存空间应该解释成一个指针变量。用两层指针做传出参数的系统函数也很常见，比如<code>pthread_join(3)</code>的<code>void **</code>参数。下面看一个简单的例子。</p>
<p>例 两层指针做传出参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* redirect_ptr.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REDIRECT_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIRECT_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">get_a_day</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>想一想，这里的参数指针是<code>const char **</code>，有<code>const</code>限定符，却不是传入参数而是传出参数，为什么？如果是传入参数应该怎么表示？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* redirect_ptr.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;redirect_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *msg[] = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_a_day</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">     *pp = msg[i%<span class="number">7</span>];</span><br><span class="line">     i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;redirect_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *firstday = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *secondday = <span class="literal">NULL</span>;</span><br><span class="line">     get_a_day(&amp;firstday);</span><br><span class="line">     get_a_day(&amp;secondday);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\t%s\n&quot;</span>, firstday, secondday);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两层指针作为传出参数还有一种特别的用法，可以在函数中分配内存，调用者通过传出参数取得指向该内存的指针，比如<code>getaddrinfo(3)</code>的<code>struct addrinfo **</code>参数。一般来说，实现一个分配内存的函数就要实现一个释放内存的函数，所以<code>getaddrinfo(3)</code>有一个对应的<code>freeaddrinfo(3)</code>函数。</p>
<p>通过参数分配内存示例：<code>void alloc_unit(unit_t **pp); void free_unit(unit_t *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配pp所指的指针变量的空间<br>调用alloc_unit分配内存<br>读取pp所指的指针变量，通过后者使用alloc_unit分配的内存<br>调用free_unit释放内存<br></td>
<td>规定指针参数的类型unit_t
**<br>alloc_unit分配unit_t的内存并初始化，为pp所指的指针变量赋值<br>free_unit释放在alloc_unit中分配的内存<br></td>
</tr>
</tbody>
</table>
<p>例 通过两层指针参数分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* para_allocator.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PARA_ALLOCATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARA_ALLOCATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> number;</span><br><span class="line">     <span class="type">char</span> *msg;</span><br><span class="line">&#125; <span class="type">unit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">alloc_unit</span><span class="params">(<span class="type">unit_t</span> **)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_unit</span><span class="params">(<span class="type">unit_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* para_allocator.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;para_allocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_unit</span><span class="params">(<span class="type">unit_t</span> **pp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">unit_t</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unit_t</span>));</span><br><span class="line">     <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	  <span class="built_in">printf</span>(<span class="string">&quot;out of memory\n&quot;</span>);</span><br><span class="line">	  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     p-&gt;number = <span class="number">3</span>;</span><br><span class="line">     p-&gt;msg = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(p-&gt;msg, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">     *pp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_unit</span><span class="params">(<span class="type">unit_t</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">free</span>(p-&gt;msg);</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;para_allocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">unit_t</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     alloc_unit(&amp;p);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;number: %d\nmsg: %s\n&quot;</span>, p-&gt;number, p-&gt;msg);</span><br><span class="line">     free_unit(p);</span><br><span class="line">     p = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一下，为什么在<code>main</code>函数中不能直接调用<code>free(p)</code>释放内存，而要调用<code>free_unit(p)</code>？为什么一层指针的函数接口<code>void alloc_unit(unit_t *p);</code>不能分配内存，而一定要用两层指针的函数接口？</p>
<p>总结一下，两层指针参数如果是传出的，可以有两种情况：第一种情况，传出的指针指向静态内存（比如上面的例子），或者指向已分配的动态内存（比如指向某个链表的节点）；第二种情况是在函数中动态分配内存，然后传出的指针指向这块内存空间，这种情况下调用者应该在使用内存之后调用释放内存的函数，调用者的责任是请求分配和请求释放内存，实现者的责任是完成分配内存和释放内存的操作。由于这两种情况的函数接口相同，应该在文档中说明是哪一种情况。</p>
<h2 id="返回值是指针的情况">返回值是指针的情况</h2>
<p>返回值显然是传出的而不是传入的，如果返回值传出的是指针，和上一节通过参数传出指针类似，也分为两种情况：第一种是传出指向静态内存或已分配的动态内存的指针，例如<code>localtime(3)</code>和<code>inet_ntoa(3)</code>，第二种是在函数中动态分配内存并传出指向这块内存的指针，例如<code>malloc(3)</code>，这种情况通常还要实现一个释放内存的函数，所以有和<code>malloc(3)</code>对应的<code>free(3)</code>。由于这两种情况的函数接口相同，应该在文档中说明是哪一种情况。</p>
<p>表 24.5.
返回指向已分配内存的指针示例：<code>unit_t *func(void);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用函数<br>将返回值保存下来以备后用<br></td>
<td>规定返回值指针的类型unit_t *<br>返回一个指针</td>
</tr>
</tbody>
</table>
<p>以下是一个完整的例子。</p>
<p>例 返回指向已分配内存的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ret_ptr.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RET_PTR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET_PTR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">get_a_day</span><span class="params">(<span class="type">int</span> idx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ret_ptr.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ret_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *msg[] = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">get_a_day</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">     <span class="built_in">strcpy</span>(buf, msg[idx]);</span><br><span class="line">     <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ret_ptr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, get_a_day(<span class="number">0</span>), get_a_day(<span class="number">1</span>));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的运行结果是<code>Sunday Monday</code>吗？请读者自己分析一下。</p>
<p>动态分配内存并返回指针示例：<code>unit_t *alloc_unit(void); void free_unit(unit_t *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用alloc_unit分配内存<br>将返回值保存下来以备后用<br>调用free_unit释放内存<br></td>
<td>规定返回值指针的类型unit_t
*<br>alloc_unit分配内存并返回指向该内存的指针<br>free_unit释放由alloc_unit分配的内存<br></td>
</tr>
</tbody>
</table>
<p>以下是一个完整的例子。</p>
<p>例 动态分配内存并返回指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ret_allocator.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RET_ALLOCATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET_ALLOCATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> number;</span><br><span class="line">     <span class="type">char</span> *msg;</span><br><span class="line">&#125; <span class="type">unit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unit_t</span> *<span class="title function_">alloc_unit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_unit</span><span class="params">(<span class="type">unit_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ret_allocator.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ret_allocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unit_t</span> *<span class="title function_">alloc_unit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">unit_t</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unit_t</span>));</span><br><span class="line">     <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;out of memory\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     p-&gt;number = <span class="number">3</span>;</span><br><span class="line">     p-&gt;msg = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">     <span class="built_in">strcpy</span>(p-&gt;msg, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_unit</span><span class="params">(<span class="type">unit_t</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">free</span>(p-&gt;msg);</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ret_allocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">unit_t</span> *p = alloc_unit();</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;number: %d\nmsg: %s\n&quot;</span>, p-&gt;number, p-&gt;msg);</span><br><span class="line">     free_unit(p);</span><br><span class="line">     p = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一下，通过参数分配内存需要两层的指针，而通过返回值分配内存就只需要返回一层的指针，为什么？</p>
<h2 id="回调函数">回调函数</h2>
<p>如果参数是一个函数指针，调用者可以传递一个函数的地址给实现者，让实现者去调用它，这称为回调函数（Callback
Function）。例如<code>qsort(3)</code>和<code>bsearch(3)</code>。</p>
<p>回调函数示例：<code>void func(void (*f)(void *), void *p);</code></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>调用者</th>
<th>实现者</th>
</tr>
</thead>
<tbody>
<tr>
<td>提供一个回调函数，再提供一个准备传给回调函数的参数。<br>把回调函数传给参数f，把准备传给回调函数的参数按void
*类型传给参数p<br></td>
<td>在适当的时候根据调用者传来的函数指针f调用回调函数，将调用者传来的参数p转交给回调函数，即调用f(p);</td>
</tr>
</tbody>
</table>
<p>以下是一个简单的例子。实现了一个<code>repeat_three_times</code>函数，可以把调用者传来的任何回调函数连续执行三次。</p>
<p>例 回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* para_callback.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PARA_CALLBACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARA_CALLBACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">callback_t</span>)</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">repeat_three_times</span><span class="params">(<span class="type">callback_t</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* para_callback.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;para_callback.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">repeat_three_times</span><span class="params">(<span class="type">callback_t</span> f, <span class="type">void</span> *para)</span></span><br><span class="line">&#123;</span><br><span class="line">     f(para);</span><br><span class="line">     f(para);</span><br><span class="line">     f(para);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;para_callback.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">say_hello</span><span class="params">(<span class="type">void</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">count_numbers</span><span class="params">(<span class="type">void</span> *num)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=(<span class="type">int</span>)num; i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">     <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     repeat_three_times(say_hello, <span class="string">&quot;Guys&quot;</span>);</span><br><span class="line">     repeat_three_times(count_numbers, (<span class="type">void</span> *)<span class="number">4</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下前面几节的例子，参数类型都是由实现者规定的。而本例中回调函数的参数按什么类型解释由调用者规定，对于实现者来说就是一个<code>void *</code>指针，实现者只负责将这个指针转交给回调函数，而不关心它到底指向什么数据类型。调用者知道自己传的参数是<code>char *</code>型的，那么在自己提供的回调函数中就应该知道参数要转换成<code>char *</code>型来解释。</p>
<p>回调函数的一个典型应用就是实现类似C++的泛型算法（Generics
Algorithm）。下面实现的<code>max</code>函数可以在任意一组对象中找出最大值，可以是一组<code>int</code>、一组<code>char</code>或者一组结构体，但是实现者并不知道怎样去比较两个对象的大小，调用者需要提供一个做比较操作的回调函数。</p>
<p>例 泛型算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* generics.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GENERICS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GENERICS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">cmp_t</span>)</span><span class="params">(<span class="type">void</span> *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">max</span><span class="params">(<span class="type">void</span> *data[], <span class="type">int</span> num, <span class="type">cmp_t</span> cmp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* generics.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;generics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">max</span><span class="params">(<span class="type">void</span> *data[], <span class="type">int</span> num, <span class="type">cmp_t</span> cmp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="type">void</span> *temp = data[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(cmp(temp, data[i])&lt;<span class="number">0</span>)</span><br><span class="line">           temp = data[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;generics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">     <span class="type">int</span> score;</span><br><span class="line">&#125; <span class="type">student_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp_student</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(((<span class="type">student_t</span> *)a)-&gt;score &gt; ((<span class="type">student_t</span> *)b)-&gt;score)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(((<span class="type">student_t</span> *)a)-&gt;score == ((<span class="type">student_t</span> *)b)-&gt;score)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">student_t</span> <span class="built_in">list</span>[<span class="number">4</span>] = &#123;&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">68</span>&#125;, &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">72</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;Moby&quot;</span>, <span class="number">60</span>&#125;, &#123;<span class="string">&quot;Kirby&quot;</span>, <span class="number">89</span>&#125;&#125;;</span><br><span class="line">     <span class="type">student_t</span> *plist[<span class="number">4</span>] = &#123;&amp;<span class="built_in">list</span>[<span class="number">0</span>], &amp;<span class="built_in">list</span>[<span class="number">1</span>], &amp;<span class="built_in">list</span>[<span class="number">2</span>], &amp;<span class="built_in">list</span>[<span class="number">3</span>]&#125;;</span><br><span class="line">     <span class="type">student_t</span> *pmax = max((<span class="type">void</span> **)plist, <span class="number">4</span>, cmp_student);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s gets the highest score %d\n&quot;</span>, pmax-&gt;name, pmax-&gt;score);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>max</code>函数之所以能对一组任意类型的对象进行操作，关键在于传给<code>max</code>的是指向对象的指针所构成的数组，而不是对象本身所构成的数组，这样<code>max</code>不必关心对象到底是什么类型，只需转给比较函数<code>cmp</code>，然后根据比较结果做相应操作即可，<code>cmp</code>是调用者提供的回调函数，调用者当然知道对象是什么类型以及如何比较。</p>
<p>以上举例的回调函数是被同步调用的，调用者调用<code>max</code>函数，<code>max</code>函数则调用<code>cmp</code>函数，相当于调用者间接调了自己提供的回调函数。在实际系统中，异步调用也是回调函数的一种典型用法，调用者首先将回调函数传给实现者，实现者记住这个函数，这称为注册一个回调函数，然后当某个事件发生时实现者再调用先前注册的函数，比如<code>sigaction(2)</code>注册一个信号处理函数，当信号产生时由系统调用该函数进行处理，再比如<code>pthread_create(3)</code>注册一个线程函数，当发生调度时系统切换到新注册的线程函数中运行，在GUI编程中异步回调函数更是有普遍的应用，例如为某个按钮注册一个回调函数，当用户点击按钮时调用它。</p>
<p>以下是一个代码框架。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* registry.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REGISTRY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTRY_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">registry_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">register_func</span><span class="params">(<span class="type">registry_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* registry.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;registry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">registry_t</span> func;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_func</span><span class="params">(<span class="type">registry_t</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">     func = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">on_some_event</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     func();</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然参数可以是函数指针，返回值同样也可以是函数指针，因此可以有<code>func()();</code>这样的调用。返回函数的函数在C语言中很少见，在一些函数式编程语言（例如LISP）中则很常见，基本思想是把函数也当作一种数据来操作，输入、输出和参与运算，操作函数的函数称为高阶函数（High-order
Function）。</p>
<h2 id="可变参数">可变参数</h2>
<p>到目前为止我们只见过一个带有可变参数的函数<code>printf</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>以后还会见到更多这样的函数。现在我们实现一个简单的<code>myprintf</code>函数：</p>
<p>例 用可变参数实现简单的<code>printf</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">     va_list ap;</span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">     va_start(ap, format);</span><br><span class="line">     <span class="keyword">while</span> (c = *format++) &#123;</span><br><span class="line">      <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line">           <span class="comment">/* char is promoted to int when passed through &#x27;...&#x27; */</span></span><br><span class="line">           <span class="type">char</span> ch = va_arg(ap, <span class="type">int</span>);</span><br><span class="line">           <span class="built_in">putchar</span>(ch);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: &#123;</span><br><span class="line">           <span class="type">char</span> *p = va_arg(ap, <span class="type">char</span> *);</span><br><span class="line">           <span class="built_in">fputs</span>(p, <span class="built_in">stdout</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">           <span class="built_in">putchar</span>(c);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     myprintf(<span class="string">&quot;c\ts\n&quot;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要处理可变参数，需要用C到标准库的<code>va_list</code>类型和<code>va_start</code>、<code>va_arg</code>、<code>va_end</code>宏，这些定义在<code>stdarg.h</code>头文件中。这些宏是如何取出可变参数的呢？我们首先对照反汇编分析在调用<code>myprintf</code>函数时这些参数的内存布局。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    myprintf(&quot;c\ts\n&quot;, &#x27;1&#x27;, &quot;hello&quot;);</span><br><span class="line">80484c5:   c7 44 24 08 b0 85 04    movl   $0x80485b0,0x8(%esp)</span><br><span class="line">80484cc:   08 </span><br><span class="line">80484cd:   c7 44 24 04 31 00 00    movl   $0x31,0x4(%esp)</span><br><span class="line">80484d4:   00 </span><br><span class="line">80484d5:   c7 04 24 b6 85 04 08    movl   $0x80485b6,(%esp)</span><br><span class="line">80484dc:   e8 43 ff ff ff          call   8048424 &lt;myprintf&gt;</span><br></pre></td></tr></table></figure>
<figure>
<img src="C:\blog\Blog\images\C\interface.vaarg.png"
alt="myprintf函数的参数布局" />
<figcaption aria-hidden="true">myprintf函数的参数布局</figcaption>
</figure>
<p>这些参数是从右向左依次压栈的，所以第一个参数靠近栈顶，第三个参数靠近栈底。这些参数在内存中是连续存放的，每个参数都对齐到4字节边界。第一个和第三个参数都是指针类型，各占4个字节，虽然第二个参数只占一个字节，但为了使第三个参数对齐到4字节边界，所以第二个参数也占4个字节。现在给出一个<code>stdarg.h</code>的简单实现，这个实现出自[Standard
C Library]：</p>
<p>例 <code>stdarg.h</code>的一种实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* stdarg.h standard header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STDARG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STDARG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* type definitions */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list;</span><br><span class="line"><span class="comment">/* macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, T) \</span></span><br><span class="line"><span class="meta">    (* (T *)(((ap) += _Bnd(T, 3U)) - _Bnd(T, 3U)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (void)0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, A) \</span></span><br><span class="line"><span class="meta">    (void)((ap) = (char *)&amp;(A) + _Bnd(A, 3U))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Bnd(X, bnd) (sizeof (X) + (bnd) &amp; ~(bnd))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个头文件中的内部宏定义<code>_Bnd(X, bnd)</code>将类型或变量X的长度对齐到<code>bnd+1</code>字节的整数倍，例如<code>_Bnd(char, 3U)</code>的值是4，<code>_Bnd(int, 3U)</code>也是4。</p>
<p>在<code>myprintf</code>中定义的<code>va_list ap;</code>其实是一个指针，<code>va_start(ap, format)</code>使<code>ap</code>指向<code>format</code>参数的下一个参数，也就是指向上图中<code>esp+4</code>的位置。然后<code>va_arg(ap, int)</code>把第二个参数的值按<code>int</code>型取出来，同时使<code>ap</code>指向第三个参数，也就是指向上图中<code>esp+8</code>的位置。然后<code>va_arg(ap, char *)</code>把第三个参数的值按<code>char *</code>型取出来，同时使<code>ap</code>指向更高的地址。<code>va_end(ap)</code>在我们的简单实现中不起任何作用，在有些实现中可能会把<code>ap</code>改写成无效值，C标准要求在函数返回前调用<code>va_end</code>。</p>
<p>如果把<code>myprintf</code>中的<code>char ch = va_arg(ap, int);</code>改成<code>char ch = va_arg(ap, char);</code>，用我们这个<code>stdarg.h</code>的简单实现是没有问题的。但如果改用<code>libc</code>提供的<code>stdarg.h</code>，在编译时会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c</span></span><br><span class="line">main.c: In function ‘myprintf’:</span><br><span class="line">main.c:33: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’</span><br><span class="line">main.c:33: note: (so you should pass ‘int’ not ‘char’ to ‘va_arg’)</span><br><span class="line">main.c:33: note: if this code is reached, the program will abort</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">Illegal instruction</span><br></pre></td></tr></table></figure>
<p>因此要求<code>char</code>型的可变参数必须按<code>int</code>型来取，这是为了与C标准一致，我们在第
3.1 节 “Integer Promotion”讲过Default Argument
Promotion规则，传递<code>char</code>型的可变参数时要提升为<code>int</code>型。</p>
<p>从<code>myprintf</code>的例子可以理解<code>printf</code>的实现原理，<code>printf</code>函数根据第一个参数（格式化字符串）来确定后面有几个参数，分别是什么类型。保证参数的类型、个数与格式化字符串的描述相匹配是调用者的责任，实现者只管按格式化字符串的描述从栈上取数据，如果调用者传递的参数类型或个数不正确，实现者是没有办法避免错误的。</p>
<p>还有一种方法可以确定可变参数的个数，就是在参数列表的末尾传一个Sentinel，例如<code>NULL</code>。<code>execl(3)</code>就采用这种方法确定参数的个数。下面实现一个<code>printlist</code>函数，可以打印若干个传入的字符串。</p>
<p>例 根据Sentinel判断可变参数的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printlist</span><span class="params">(<span class="type">int</span> begin, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">     va_list ap;</span><br><span class="line">     <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">     va_start(ap, begin);</span><br><span class="line">     p = va_arg(ap, <span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">fputs</span>(p, <span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      p = va_arg(ap, <span class="type">char</span>*);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     printlist(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>printlist</code>的第一个参数<code>begin</code>的值并没有用到，但是C语言规定至少要定义一个有名字的参数，因为<code>va_start</code>宏要用到参数列表中最后一个有名字的参数，从它的地址开始找可变参数的位置。实现者应该在文档中说明参数列表必须以<code>NULL</code>结尾，如果调用者不遵守这个约定，实现者是没有办法避免错误的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:深入立即函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 19:25:42" itemprop="dateModified" datetime="2025-08-06T19:25:42+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="return语句">return语句</h2>
<p>之前我们一直在<code>main</code>函数中使用<code>return</code>语句，现在是时候全面深入地学习一下了。在有返回值的函数中，<code>return</code>语句的作用是提供整个函数的返回值，并结束当前函数返回到调用它的地方。在没有返回值的函数中也可以使用<code>return</code>语句，例如当检查到一个错误时提前结束当前函数的执行并返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_logarithm</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Positive numbers only, please.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The log of x is %f&quot;</span>, <span class="built_in">log</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先检查参数<code>x</code>是否大于<code>0</code>，如果<code>x</code>不大于<code>0</code>就打印错误提示，然后提前结束函数的执行返回到调用者，只有当<code>x</code>大于<code>0</code>时才能求对数，在打印了对数结果之后到达函数体的末尾，自然地结束执行并返回。注意，使用数学函数<code>log</code>需要包含头文件<code>math.h</code>，由于<code>x</code>是浮点数，应该与同类型的数做比较，所以写成<code>0.0</code>。</p>
<p>在第 2 节
“if/else语句”中我们定义了一个检查奇偶性的函数，如果是奇数就打印<code>x is odd</code>.，如果是偶数就打印<code>x is even.</code>。事实上这个函数并不十分好用，我们定义一个检查奇偶性的函数往往不是为了打印两个字符串就完了，而是为了根据奇偶性的不同分别执行不同的后续动作。我们可以把它改成一个返回布尔值的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_even</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些人喜欢写成<code>return(1);</code>这种形式也可以，表达式外面套括号表示改变运算符优先级，在这里不起任何作用。我们可以这样调用这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (is_even(i)) &#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* do some other thing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回布尔值的函数是一类非常有用的函数，在程序中通常充当控制表达式，函数名通常带有<code>is</code>或<code>if</code>等表示判断的词，这类函数也叫做谓词（Predicate）。<code>is_even</code>这个函数写得有点啰嗦，<code>x % 2</code>这个表达式本来就有<code>0</code>值或非<code>0</code>值，直接把这个值当作布尔值返回就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_even</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的返回值应该这样理解：函数返回一个值相当于定义一个和返回值类型相同的临时变量并用<code>return</code>后面的表达式来初始化。例如上面的函数调用相当于这样的过程：</p>
<p>int 临时变量 = !(x % 2); 函数退出，局部变量x的存储空间释放; if
(临时变量) { /* 临时变量用完就释放 <em>/ /</em> do something <em>/ }
else { /</em> do some other thing */ }</p>
<p>当<code>if</code>语句对函数的返回值做判断时，函数已经退出，局部变量<code>x</code>已经释放，所以不可能在这时候才计算表达式<code>!(x % 2)</code>的值，表达式的值必然是事先计算好了存在一个临时变量里的，然后函数退出，局部变量释放，<code>if</code>语句对这个临时变量的值做判断。注意，虽然函数的返回值可以看作是一个临时变量，但我们只是读一下它的值，读完值就释放它，而不能往它里面存新的值，换句话说，函数的返回值不是左值，或者说函数调用表达式不能做左值，因此下面的赋值语句是非法的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_even(<span class="number">20</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>在第 3 节 “形参和实参”中讲过，C语言的传参规则是Call by
Value，按值传递，现在我们知道返回值也是按值传递的，即便返回语句写成<code>return x</code>;，返回的也是变量<code>x</code>的值，而非变量<code>x</code>本身，因为变量<code>x</code>马上就要被释放了。</p>
<p>在写带有<code>return</code>语句的函数时要小心检查所有的代码路径（Code
Path）。有些代码路径在任何条件下都执行不到，这称为Dead
Code，例如把&amp;&amp;和||运算符记混了（据我了解初学者犯这个低级错误的不在少数），写出如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> || y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;both x and y are positive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;both x and y are negetive.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x has a different sign from y.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一行<code>printf</code>永远都没机会被执行到，是一行Dead
Code。有Dead
Code就一定有Bug，你写的每一行代码都是想让程序在某种情况下去执行的，你不可能故意写出一行永远不会被执行的代码，如果程序在任何情况下都不会去执行它，说明跟你预想的不一样，要么是你对所有可能的情况分析得不正确，也就是逻辑错误，要么就是像上例这样的笔误，语义错误。还有一些时候，对程序中所有可能的情况分析得不够全面将导致漏掉一些代码路径，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">absolute_value</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数被定义为返回<code>int</code>，就应该在任何情况下都返回<code>int</code>，但是上面这个程序在<code>x==0</code>时安静地退出函数，什么也不返回，C语言对于这种情况会返回什么结果是未定义的，通常返回不确定的值，等学到第
1 节
“函数调用”你就知道为什么了。另外注意这个例子中把<code>-</code>号当负号用而不是当减号用，事实上<code>+</code>号也可以这么用。正负号是单目运算符，而加减号是双目运算符，正负号的优先级和逻辑非运算符相同，比加减的优先级要高。</p>
<p>以上两段代码都不会产生编译错误，编译器只做语法检查和最简单的语义检查，而不检查程序的逻辑[7]。虽然到现在为止你见到了各种各样的编译器错误提示，也许你已经十分讨厌编译器报错了，但很快你就会认识到，如果程序中有错误编译器还不报错，那一定比报错更糟糕。比如上面的绝对值函数，在你测试的时候运行得很好，也许是你没有测到<code>x==0</code>的情况，也许刚好在你的环境中<code>x==0</code>时返回的不确定值就是0，然后你放心地把它集成到一个数万行的程序之中。然后你把这个程序交给用户，起初的几天里相安无事，之后每过几个星期就有用户报告说程序出错，但每次出错的现象都不一样，而且这个错误很难复现，你想让它出现时它就不出现，在你毫无防备时它又突然冒出来了。然后你花了大量的时间在数万行的程序中排查哪里错了，几天之后终于幸运地找到了这个函数的Bug，这时候你就会想，如果当初编译器能报个错多好啊！所以，如果编译器报错了，不要责怪编译器太过于挑剔，它帮你节省了大量的调试时间。另外，在math.h中有一个fabs函数就是求绝对值的，我们通常不必自己写绝对值函数。</p>
<h2 id="增量式开发">增量式开发</h2>
<p>目前为止你看到了很多示例代码，也在它们的基础上做了很多改动并在这个过程中巩固所学的知识。但是如果从头开始编写一个程序解决某个问题，应该按什么步骤来写呢？本节提出一种增量式（Incremental）开发的思路，很适合初学者。</p>
<p>现在问题来了：我们要编一个程序求圆的面积，圆的半径以两个端点的座标(x1,
y1)和(x2,
y2)给出。首先分析和分解问题，把大问题分解成小问题，再对小问题分别求解。这个问题可分为两步：</p>
<p>由两个端点座标求半径的长度，我们知道平面上两点间距离的公式是：</p>
<p>distance = √((x2-x1)2+(y2-y1)2)</p>
<p>括号里的部分都可以用我们学过的C语言表达式来表示，求平方根可以用<code>math.h</code>中的<code>sqrt</code>函数，因此这个小问题全部都可以用我们学过的知识解决。这个公式可以实现成一个函数，参数是两点的座标，返回值是<code>distance</code>。</p>
<p>上一步算出的距离是圆的半径，已知圆的半径之后求面积的公式是：</p>
<p>area = π·radius2</p>
<p>也可以用我们学过的C语言表达式来解决，这个公式也可以实现成一个函数，参数是<code>radius</code>，返回值是<code>area</code>。</p>
<p>首先编写<code>distance</code>这个函数，我们已经明确了它的参数是两点的座标，返回值是两点间距离，可以先写一个简单的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初学者写到这里就已经不太自信了：这个函数定义写得对吗？虽然我是按我理解的语法规则写的，但书上没有和这个一模一样的例子，万一不小心遗漏了什么呢？既然不自信就不要再往下写了，没有一个平稳的心态来写程序很可能会引入Bug。所以在函数定义中插一个<code>return 0.0</code>立刻结束掉它，然后立刻测试这个函数定义得有没有错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;distance is %f\n&quot;</span>, distance(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，运行，一切正常。这时你就会建立起信心了：既然没问题，就不用管它了，继续往下写。在测试时给这个函数的参数是(1.0,
2.0)和(4.0,
6.0)，两点的x座标距离是3.0，y座标距离是4.0，因此两点间距离应该是5.0，你必须事先知道正确答案是5.0，这样你才能测试程序计算的结果对不对。当然，现在函数还没实现，计算结果肯定是不对的。现在我们再往函数里添一点代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">double</span> dy = y2 - y1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dx is %f\ndy is %f\n&quot;</span>, dx, dy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不确定dx和dy这样初始化行不行，那么就此打住，在函数里插一条打印语句把dx和dy的值打出来看看。把它和上面的<code>main</code>函数一起编译运行，由于我们事先知道结果应该是3.0和4.0，因此能够验证程序算得对不对。一旦验证无误，函数里的这句打印就可以撤掉了，像这种打印语句，以及我们用来测试的<code>main</code>函数，都起到了类似脚手架（Scaffold）的作用：在盖房子时很有用，但它不是房子的一部分，房子盖好之后就可以拆掉了。房子盖好之后可能还需要维修、加盖、翻新，又要再加上脚手架，这很麻烦，要是当初不用拆就好了，可是不拆不行，不拆多难看啊。写代码却可以有一个更高明的解决办法：把Scaffolding的代码注释掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">double</span> dy = y2 - y1;</span><br><span class="line">    <span class="comment">/* printf(&quot;dx is %f\ndy is %f\n&quot;, dx, dy); */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果以后出了新的Bug又需要跟踪调试时，还可以把这句重新加进代码中使用。两点的x座标距离和y座标距离都没问题了，下面求它们的平方和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">double</span> dy = y2 - y1;</span><br><span class="line">    <span class="type">double</span> dsquared = dx * dx + dy * dy;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dsquared is %f\n&quot;</span>, dsquared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再编译、运行，看看是不是得25.0。这样的增量式开发非常适合初学者，每写一行代码都编译运行，确保没问题了再写一下行，一方面在写代码时更有信心，另一方面也方便了调试：总是有一个先前的正确版本做参照，改动之后如果出了问题，几乎可以肯定就是刚才改的那行代码出的问题，这样就避免了必须从很多行代码中查找分析到底是哪一行出的问题。在这个过程中<code>printf</code>功不可没，你怀疑哪一行代码有问题，就插一个<code>printf</code>进去看看中间的计算结果，任何错误都可以通过这个办法找出来。以后我们会介绍程序调试工具gdb，它提供了更强大的调试功能帮你分析更隐蔽的错误。但即使有了gdb，<code>printf</code>这个最原始的办法仍然是最直接、最有效的。最后一步，我们完成这个函数：</p>
<p>例 distance函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">double</span> dy = y2 - y1;</span><br><span class="line">    <span class="type">double</span> dsquared = dx * dx + dy * dy;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">sqrt</span>(dsquared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;distance is %f\n&quot;</span>, distance(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编译运行，看看是不是得5.0。随着编程经验越来越丰富，你可能每次写若干行代码再一起测试，而不是像现在这样每写一行就测试一次，但不管怎么样，增量式开发的思路是很有用的，它可以帮你节省大量的调试时间，不管你有多强，都不应该一口气写完整个程序再编译运行，那几乎是一定会有Bug的，到那时候再找Bug就难了。</p>
<p>这个程序中引入了很多临时变量:
<code>dx</code>、<code>dy</code>、<code>dsquared</code>、<code>result</code>，如果你有信心把整个表达式一次性写好，也可以不用临时变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写简洁得多了。但如果写错了呢？只知道是这一长串表达式有错，根本不知道错在哪，而且整个函数就一个语句，插<code>printf</code>都没地方插。所以用临时变量有它的好处，使程序更清晰，调试更方便，而且有时候可以避免不必要的计算，例如上面这一行表达式要把(x2-x1)计算两遍，如果算完(x2-x1)把结果存在一个临时变量dx里，就不需要再算第二遍了。</p>
<p>接下来编写<code>area</code>这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span> radius)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.1416</span> * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出两点的座标求距离，给出半径求圆的面积，这两个子问题都解决了，如何把它们组合起来解决整个问题呢？给出半径的两端点座标(1.0,
2.0)和(4.0,
6.0)求圆的面积，先用<code>distance</code>函数求出半径的长度，再把这个长度传给area函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> radius = distance(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"><span class="type">double</span> result = area(radius);</span><br></pre></td></tr></table></figure>
<p>也可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> result = area(distance(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>));</span><br></pre></td></tr></table></figure>
<p>我们一直把“给出半径的两端点座标求圆的面积”这个问题当作整个问题来看，如果它也是一个更大的程序当中的子问题呢？我们可以把先前的两个函数组合起来做成一个新的函数以便日后使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">area_point</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> area(distance(x1, y1, x2, y2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种组合的思路，不是把distance和area两个函数调用组合起来，而是把那两个函数中的语句组合到一起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">area_point</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> dx = x2 - x1;</span><br><span class="line">    <span class="type">double</span> dy = y2 - y1;</span><br><span class="line">    <span class="type">double</span> radius = <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.1416</span> * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样组合是不理想的。这样组合了之后，原来写的<code>distance</code>和<code>area</code>两个函数还要不要了呢？如果不要了删掉，那么如果有些情况只需要求两点间的距离，或者只需要给定半径长度求圆的面积呢？<code>area_point</code>把所有语句都写在一起，太不灵活了，满足不了这样的需要。如果保留<code>distance</code>和<code>area</code>同时也保留这个<code>area_point</code>怎么样呢？<code>area_point</code>和<code>distance</code>有相同的代码，一旦在<code>distance</code>函数中发现了Bug，或者要升级<code>distance</code>这个函数采用更高的计算精度，那么不仅要修改<code>distance</code>，还要记着修改<code>area_point</code>，同理，要修改<code>area</code>也要记着修改<code>area_point</code>，维护重复的代码是非常容易出错的，在任何时候都要尽量避免。因此，尽可能复用（Reuse）以前写的代码，避免写重复的代码。封装就是为了复用，把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。</p>
<p>解决问题的过程是把大的问题分成小的问题，小的问题再分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）。<code>distance</code>和<code>area</code>是两个底层函数，解决一些很小的问题，而<code>area_point</code>是一个上层函数，上层函数通过调用底层函数来解决更大的问题，底层和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被<code>main</code>函数调用。</p>
<h2 id="递归">递归</h2>
<p>如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。例如：</p>
<p>frabjuous an adjective used to describe something that is
frabjuous.</p>
<p>这只是一个玩笑，如果你在字典上看到这么一个词条肯定要怒了。然而数学上确实有很多概念是用它自己来定义的，比如n的阶乘（Factorial）是这样定义的：n的阶乘等于n乘以n-1的阶乘。如果这样就算定义完了，恐怕跟上面那个词条有异曲同工之妙了：n-1的阶乘是什么？是n-1乘以n-2的阶乘。那n-2的阶乘又是什么？这样下去永远也没完。因此需要定义一个最关键的基础条件（Base
Case）：0的阶乘等于1。</p>
<p>0! = 1 n! = n · (n-1)!</p>
<p>因此，3!=3<em>2!，2!=2</em>1!，1!=1<em>0!=1</em>1=1，正因为有了Base
Case，才不会永远没完地数下去，知道了1!=1我们再反过来算回去，2!=2<em>1!=2</em>1=2，3!=3<em>2!=3</em>2=6。下面用程序来完成这一计算过程，我们要写一个计算阶乘的函数<code>factorial</code>，先把Base
Case这种最简单的情况写进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数n不是0应该<code>return</code>什么呢？根据定义，应该<code>return n*factorial(n-1);</code>，为了下面的分析方便，我们引入几个临时变量把这个语句拆分一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> recurse = factorial(n<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> result = n * recurse;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>factorial</code>这个函数居然可以自己调用自己？是的。自己直接或间接调用自己的函数称为递归函数。这里的<code>factorial</code>是直接调用自己，有些时候函数A调用函数B，函数B又调用函数A，也就是函数A间接调用自己，这也是递归函数。如果你觉得迷惑，可以把<code>factorial(n-1)</code>这一步看成是在调用另一个函数－－另一个有着相同函数名和相同代码的函数，调用它就是跳到它的代码里执行，然后再返回<code>factorial(n-1)</code>这个调用的下一步继续执行。我们以<code>factorial(3)</code>为例分析整个调用过程，如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\factoral(3)example.png"
alt="调用流程" />
<figcaption aria-hidden="true">调用流程</figcaption>
</figure>
<p>图中用实线箭头表示调用，用虚线箭头表示返回，右侧的框表示在调用和返回过程中各层函数调用的存储空间变化情况。</p>
<p><code>main()</code>有一个局部变量<code>result</code>，用一个框表示。</p>
<p>调用<code>factorial(3)</code>时要分配参数和局部变量的存储空间，于是在<code>main()</code>的下面又多了一个框表示<code>factorial(3)</code>的参数和局部变量，其中<code>n</code>已初始化为<code>3</code>。</p>
<p><code>factorial(3)</code>又调用<code>factorial(2)</code>，又要分配<code>factorial(2)</code>的参数和局部变量，于是在<code>main()</code>和<code>factorial(3)</code>下面又多了一个框。第
4 节
“全局变量、局部变量和作用域”讲过，每次调用函数时分配参数和局部变量的存储空间，退出函数时释放它们的存储空间。<code>factorial(3)</code>和<code>factorial(2)</code>是两次不同的调用，<code>factorial(3)</code>的参数<code>n</code>和<code>factorial(2)</code>的参数<code>n</code>各有各的存储单元，虽然我们写代码时只写了一次参数<code>n</code>，但运行时却是两个不同的参数<code>n</code>。并且由于调用<code>factorial(2)</code>时<code>factorial(3)</code>还没退出，所以两个函数调用的参数<code>n</code>同时存在，所以在原来的基础上多画一个框。</p>
<p>依此类推，请读者对照着图自己分析整个调用过程。读者会发现这个过程和前面我们用数学公式计算3!的过程是一样的，都是先一步步展开然后再一步步收回去。</p>
<p>我们看上图右侧存储空间的变化过程，随着函数调用的层层深入，存储空间的一端逐渐增长，然后随着函数调用的层层返回，存储空间的这一端又逐渐缩短，并且每次访问参数和局部变量时只能访问这一端的存储单元，而不能访问内部的存储单元，比如当<code>factorial(2)</code>的存储空间位于末端时，只能访问它的参数和局部变量，而不能访问<code>factorial(3)</code>和<code>main()</code>的参数和局部变量。具有这种性质的数据结构称为堆栈或栈（Stack），随着函数调用和返回而不断变化的这一端称为栈顶，每个函数调用的参数和局部变量的存储空间（上图的每个小方框）称为一个栈帧（Stack
Frame）。操作系统为程序的运行预留了一块栈空间，函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧。</p>
<p>在写一个递归函数时，你如何证明它是正确的？像上面那样跟踪函数的调用和返回过程算是一种办法，但只是<code>factorial(3)</code>就已经这么麻烦了，如果是<code>factorial(100)</code>呢？虽然我们已经证明了<code>factorial(3)</code>是正确的，因为它跟我们用数学公式计算的过程一样，结果也一样，但这不能代替<code>factorial(100)</code>的证明，你怎么办？别的函数你可以跟踪它的调用过程去证明它的正确性，因为每个函数只调用一次就返回了，但是对于递归函数，这么跟下去只会跟得你头都大了。事实上并不是每个函数调用都需要钻进去看的。我们在调用<code>printf</code>时没有钻进去看它是怎么打印的，我们只是相信它能打印，能正确完成它的工作，然后就继续写下面的代码了。在上一节中，我们写了<code>distance</code>和<code>area</code>函数，然后立刻测试证明了这两个函数是正确的，然后我们写<code>area_point</code>时调用了这两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> area(distance(x1, y1, x2, y2));</span><br></pre></td></tr></table></figure>
<p>在写这一句的时候，我们需要钻进<code>distance</code>和<code>area</code>函数中去走一趟才知道我们调用得是否正确吗？不需要，因为我们已经相信这两个函数能正确工作了，也就是相信把座标传给<code>distance</code>它就能返回正确的距离，把半径传给<code>area</code>它就能返回正确的面积，因此调用它们去完成另外一件工作也应该是正确的。这种“相信”称为Leap
of Faith，首先相信一些结论，然后再用它们去证明另外一些结论。</p>
<p>在写<code>factorial(n)</code>的代码时写到这个地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> recurse = factorial(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> result = n * recurse;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这时，如果我们相信<code>factorial(n-1)</code>是正确的，也就是相信传给它<code>n-1</code>它就能返回<code>(n-1)!</code>，那么<code>recurse</code>就是<code>(n-1)!</code>，那么<code>result</code>就是<code>n*(n-1)!</code>，也就是<code>n!</code>，这正是我们要返回的<code>factorial(n)</code>的结果。当然这有点奇怪：我们还没写完<code>factorial</code>这个函数，凭什么要相信<code>factorial(n-1)</code>是正确的？可Leap
of
Faith本身就是Leap（跳跃）的，不是吗？如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。</p>
<p>这么说好像有点儿玄，我们从数学上严格证明一下<code>factorial</code>函数的正确性。刚才说了，<code>factorial(n)</code>的正确性依赖于<code>factorial(n-1)</code>的正确性，只要后者正确，在后者的结果上乘个<code>n</code>返回这一步显然也没有疑问，那么我们的函数实现就是正确的。因此要证明<code>factorial(n)</code>的正确性就是要证明<code>factorial(n-1)</code>的正确性，同理，要证明<code>factorial(n-1)</code>的正确性就是要证明<code>factorial(n-2)</code>的正确性，依此类推下去，最后是：要证明<code>factorial(1)</code>的正确性就是要证明<code>factorial(0)</code>的正确性。而<code>factorial(0)</code>的正确性不依赖于别的函数调用，它就是程序中的一个小的分支<code>return 1;</code>，这个<code>1</code>是我们根据阶乘的定义写的，肯定是正确的，因此<code>factorial(1)</code>的实现是正确的，因此<code>factorial(2)</code>也正确，依此类推，最后<code>factorial(n)</code>也是正确的。其实这就是在中学时学的数学归纳法（Mathematical
Induction），用数学归纳法来证明只需要证明两点：Base
Case正确，递推关系正确。写递归函数时一定要记得写Base
Case，否则即使递推关系正确，整个函数也不正确。如果factorial函数漏掉了Base
Case：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> recurse = factorial(n<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> result = n * recurse;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个函数就会永远调用下去，直到操作系统为程序预留的栈空间耗尽程序崩溃（段错误）为止，这称为无穷递归（Infinite
recursion）。</p>
<p>到目前为止我们只学习了全部C语法的一个小的子集，但是现在应该告诉你：这个子集是完备的，它本身就可以作为一门编程语言了，以后还要学习很多C语言特性，但全部都可以用已经学过的这些特性来代替。也就是说，以后要学的C语言特性会使代码写起来更加方便，但不是必不可少的，现在学的这些已经完全覆盖了第
1 节
“程序和编程语言”讲的五种基本指令了。有的读者会说循环还没讲到呢，是的，循环在下一章才讲，但有一个重要的结论就是递归和循环是等价的，用循环能做的事用递归都能做，反之亦然，事实上有的编程语言（比如某些LISP实现）只有递归而没有循环。计算机指令能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行高级语言写的程序最终也要翻译成指令，指令做不到的事情高级语言写的程序肯定也做不到，虽然高级语言有丰富的语法特性，但也只是比指令写起来更方便而已，能做的事情是一样多的。那么，为什么计算机要设计成这样？在设计时怎么想到计算机应该具备这几样功能，而不是更多或更少的功能？这些要归功于早期的计算机科学家，例如Alan
Turing，他们在计算机还没有诞生的年代就从数学理论上为计算机的设计指明了方向。有兴趣的读者可以参考有关计算理论的教材，例如[IATLC]。</p>
<p>递归绝不只是为解决一些奇技淫巧的数学题[8]而想出来的招，它是计算机的精髓所在，也是编程语言的精髓所在。我们学习在C的语法时已经看到很多递归定义了，例如在第
1 节 “数学函数”讲过的语法规则中，“表达式”就是递归定义的：</p>
<p>表达式 → 表达式(参数列表) 参数列表 → 表达式, 表达式, …</p>
<p>再比如在第 1 节 “if语句”讲过的语规则中，“语句”也是递归定义的：</p>
<p>语句 → if (控制表达式) 语句</p>
<p>可见编译器在解析我们写的程序时一定也用了大量的递归，有关编译器的实现原理可参考[Dragon
Book]。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:循环语句</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-06 19:47:01" itemprop="dateModified" datetime="2025-08-06T19:47:01+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="while语句">while语句</h2>
<p>在第 3 节
“递归”中，我们介绍了用递归求n!的方法，其实每次递归调用都在重复做同样一件事，就是把n乘到(n-1)!上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的。虽然迭代用递归来做就够了，但C语言提供了循环语句使迭代程序写起来更方便。例如<code>factorial</code>用<code>while</code>语句可以写成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = result * n;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>if</code>语句类似，<code>while</code>语句由一个控制表达式和一个子语句组成，子语句可以是由若干条语句组成的语句块。</p>
<p>语句 → while (控制表达式) 语句</p>
<p>如果控制表达式的值为真，子语句就被执行，然后再次测试控制表达式的值，如果还是真，就把子语句再执行一遍，再测试控制表达式的值……这种控制流程称为循环（Loop），子语句称为循环体。如果某次测试控制表达式的值为假，就跳出循环执行后面的<code>return</code>语句，如果第一次测试控制表达式的值就是假，那么直接跳到<code>return</code>语句，循环体一次都不执行。</p>
<p>变量<code>result</code>在这个循环中的作用是累加器（Accumulator），把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结果，由于这个例子是用乘法来累积的，所以<code>result</code>的初值是<code>1</code>，如果用加法累积则<code>result</code>的初值应该是<code>0</code>。变量<code>n</code>是循环变量（Loop
Variable），每次循环要改变它的值，在控制表达式中要测试它的值，这两点合起来起到控制循环次数的作用，在这个例子中<code>n</code>的值是递减的，也有些循环采用递增的循环变量。这个例子具有一定的典型性，累加器和循环变量这两种模式在循环中都很常见。</p>
<p>可见，递归能解决的问题用循环也能解决，但解决问题的思路不一样。用递归解决这个问题靠的是递推关系n!=n·(n-1)!，用循环解决这个问题则更像是把这个公式展开了：n!=n·(n-1)·(n-2)·…·3·2·1。把公式展开了理解会更直观一些，所以有些时候循环程序比递归程序更容易理解。但也有一些公式要展开是非常复杂的甚至是不可能的，反倒是递推关系更直观一些，这种情况下递归程序比循环程序更容易理解。此外还有一点不同：看图
5.2
“factorial(3)的调用过程”，在整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值，没有任何变量的值发生过改变，而上面的循环程序则通过对<code>n</code>和<code>result</code>这两个变量多次赋值来达到同样的目的。前一种思路称为函数式编程（Functional
Programming），而后一种思路称为命令式编程（Imperative
Programming），这个区别类似于第 1 节
“程序和编程语言”讲的Declarative和Imperative的区别。函数式编程的“函数”类似于数学函数的概念，回顾一下第
1 节 “数学函数”所讲的，数学函数是没有Side
Effect的，而C语言的函数可以有Side
Effect，比如在一个函数中修改某个全局变量的值就是一种Side Effect。第 4 节
“全局变量、局部变量和作用域”指出，全局变量被多次赋值会给调试带来麻烦，如果一个函数体很长，控制流程很复杂，那么局部变量被多次赋值也会有同样的问题。因此，不要以为“变量可以多次赋值”是天经地义的，有很多编程语言可以完全采用函数式编程的模式，避免Side
Effect，例如LISP、Haskell、Erlang等。用C语言编程主要还是采用Imperative的模式，但要记住，给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行。所谓“一致的方式”是说应该有一套统一的规则，规定在一段代码中哪里会对某个变量赋值、哪里会读取它的值，比如在第
2.4 节 “errno与perror函数”会讲到访问errno的规则。</p>
<p>递归函数如果写得不小心就会变成无穷递归，同样道理，循环如果写得不小心就会变成无限循环（Infinite
Loop）或者叫死循环。如果<code>while</code>语句的控制表达式永远为真就成了一个死循环，例如<code>while (1) &#123;...&#125;</code>。在写循环时要小心检查你写的控制表达式有没有可能取值为假，除非你故意写死循环（有的时候这是必要的）。在上面的例子中，不管<code>n</code>一开始是几，每次循环都会把<code>n</code>减掉<code>1</code>，<code>n</code>越来越小最后必然等于<code>0</code>，所以控制表达式最后必然取值为假，但如果把<code>n = n - 1;</code>这句漏掉就成了死循环。有的时候是不是死循环并不是那么一目了然：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = n * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>n</code>为正整数，这个循环能跳出来吗？循环体所做的事情是：如果<code>n</code>是偶数，就把<code>n</code>除以<code>2</code>，如果<code>n</code>是奇数，就把<code>n</code>乘<code>3</code>加<code>1</code>。一般来说循环变量要么递增要么递减，可是这个例子中的<code>n</code>一会儿变大一会儿变小，最终会不会变成1呢？可以找个数试试，例如一开始n等于7，每次循环后n的值依次是：7、22、11、34、17、52、26、13、40、20、10、5、16、8、4、2、1。最后n确实等于1了。读者可以再试几个数都是如此，但无论试多少个数也不能代替证明，这个循环有没有可能对某些正整数n是死循环呢？其实这个例子只是给读者提提兴趣，同时提醒读者写循环时要有意识地检查控制表达式。至于这个循环有没有可能是死循环，这是著名的3x+1问题，目前世界上还无人能证明。许多世界难题都是这样的：描述无比简单，连小学生都能看懂，但证明却无比困难。</p>
<h2 id="dowhile语句">do/while语句</h2>
<p><code>do/while</code>语句的语法是：</p>
<p>语句 → do 语句 while (控制表达式);</p>
<p><code>while</code>语句先测试控制表达式的值再执行循环体，而<code>do/while</code>语句先执行循环体再测试控制表达式的值。如果控制表达式的值一开始就是假，<code>while</code>语句的循环体一次都不执行，而<code>do/while</code>语句的循环体仍然要执行一次再跳出循环。其实只要有<code>while</code>循环就足够了，<code>do/while</code>循环和后面要讲的<code>for</code>循环都可以改写成<code>while</code>循环，只不过有些情况下用<code>do/while</code>或<code>for</code>循环写起来更简便，代码更易读。上面的<code>factorial</code>也可以改用<code>do/while</code>循环来写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = result * i;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写循环一定要注意循环即将结束时控制表达式的临界条件是否准确，上面的循环结束条件如果写成<code>i &lt; n</code>就错了，当<code>i == n</code>时跳出循环，最后的结果中就少乘了一个<code>n</code>。虽然变量名应该尽可能起得有意义一些，不过用<code>i、j、k</code>给循环变量起名是很常见的。</p>
<h2 id="for语句">for语句</h2>
<p>前两节我们在<code>while</code>和<code>do/while</code>循环中使用循环变量，其实使用循环变量最见的是<code>for</code>循环这种形式。<code>for</code>语句的语法是：</p>
<p>for (控制表达式1; 控制表达式2; 控制表达式3) 语句</p>
<p>如果不考虑循环体中包含<code>continue</code>语句的情况（稍后介绍<code>continue</code>语句），这个<code>for</code>循环等价于下面的<code>while</code>循环：</p>
<p>控制表达式1; while (控制表达式2) { 语句 控制表达式3; }</p>
<p>从这种等价形式来看，控制表达式1和3都可以为空，但控制表达式2是必不可少的，例如<code>for (;1;) &#123;...&#125;</code>等价于<code>while (1) &#123;...&#125;</code>死循环。C语言规定，如果控制表达式2为空，则认为控制表达式2的值为真，因此死循环也可以写成<code>for (;;) &#123;...&#125;</code>。</p>
<p>上一节<code>do/while</code>循环的例子可以改写成<code>for</code>循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        result = result * i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>++i</code>这个表达式相当于<code>i = i + 1[9]</code>，<code>++</code>称为前缀自增运算符（Prefix
Increment Operator），类似地，<code>--</code>称为前缀自减运算符（Prefix
Decrement
Operator），<code>--i</code>相当于<code>i = i - 1</code>。如果把<code>++i</code>这个表达式看作一个函数调用，除了传入一个参数返回一个值（等于参数值加<code>1</code>）之外，还产生一个Side
Effect，就是把变量<code>i</code>的值增加了<code>1</code>。</p>
<p><code>++</code>和<code>--</code>运算符也可以用在变量后面，例如<code>i++</code>和<code>i--</code>，为了和前缀运算符区别，这两个运算符称为后缀自增运算符（Postfix
Increment Operator）和后缀自减运算符（Postfix Decrement
Operator）。如果把<code>i++</code>这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加1），此外也产生一个Side
Effect，就是把变量<code>i</code>的值增加了<code>1</code>，它和<code>++i</code>的区别就在于返回值不同。同理，<code>--i</code>返回减<code>1</code>之后的值，而<code>i--</code>返回减<code>1</code>之前的值，但这两个表达式都产生同样的Side
Effect，就是把变量<code>i</code>的值减了<code>1</code>。</p>
<p>使用<code>++</code>、<code>--</code>运算符会使程序更加简洁，但也会影响程序的可读性，[K&amp;R]中的示例代码大量运用<code>++</code>、<code>--</code>和其它表达式的组合使得代码非常简洁。为了让初学者循序渐进，在接下来的几章中<code>++</code>、<code>--</code>运算符总是单独组成一个表达式而不跟其它表达式组合，从第
11 章 排序与查找开始将采用[K&amp;R]的简洁风格。</p>
<p>我们看一个有意思的问题：<code>a+++++b</code>这个表达式如何理解？应该理解成<code>a++ ++ +b</code>还是<code>a++ + ++b</code>，还是<code>a + ++ ++b</code>呢？应该按第一种方式理解。编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法Token。把这个表达式从前到后解析，变量名a是一个Token，a后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当作一个Token。再往后解析仍然有两个以上的+号，所以又是一个++运算符。再往后解析只剩一个+号了，是加法运算符。再往后解析是变量名b。词法解析之后进入下一阶段语法解析，a是一个表达式，表达式++还是表达式，表达式再++还是表达式，表达式再+b还是表达式，语法上没有问题。最后编译器会做一些基本的语义分析，这时就有问题了，++运算符要求操作数能做左值，a能做左值所以a++没问题，但表达式a++的值只能做右值，不能再++了，所以最终编译器会报错。</p>
<p>C99规定了一种新的for循环语法，在控制表达式1的位置可以有变量定义。例如上例的循环变量i可以只在for循环中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        result = result * i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这样定义，那么变量i只是for循环中的局部变量而不是整个函数的局部变量，相当于第
1 节
“if语句”讲过的语句块中的局部变量，在循环结束后就不能再使用i这个变量了。这个程序用gcc编译要加上选项-std=c99。这种语法也是从C++借鉴的，考虑到兼容性不建议使用这种写法。</p>
<h2 id="break和continue语句">break和continue语句</h2>
<p>在第 4 节
“switch语句”中我们见到了<code>break</code>语句的一种用法，用来跳出<code>switch</code>语句块，这个语句也可以用来跳出循环体。<code>continue</code>语句也会终止当前循环，和<code>break</code>语句不同的是，<code>continue</code>语句终止当前循环后又回到循环体的开头准备执行下一次循环。对于<code>while</code>循环和<code>do/while</code>循环，执行<code>continue</code>语句之后测试控制表达式，如果值为真则继续执行下一次循环；对于<code>for</code>循环，执行<code>continue</code>语句之后首先计算控制表达式<code>3</code>，然后测试控制表达式<code>2</code>，如果值为真则继续执行下一次循环。例如下面的代码打印1到100之间的素数：</p>
<p>例 求1-100的素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_prime(i))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>is_prime</code>函数从<code>2</code>到<code>n-1</code>依次检查有没有能被<code>n</code>整除的数，如果有就说明<code>n</code>不是素数，立刻跳出循环而不执行<code>i++</code>。因此，如果<code>n</code>不是素数，则循环结束后<code>i</code>一定小于<code>n</code>，如果<code>n</code>是素数，则循环结束后<code>i</code>一定等于<code>n</code>。注意检查临界条件：<code>2</code>应该是素数，如果<code>n</code>是<code>2</code>，则循环体一次也不执行，但<code>i</code>的初值就是<code>2</code>，也等于<code>n</code>，在程序中也判定为素数。其实没有必要从<code>2</code>一直检查到<code>n-1</code>，只要从<code>2</code>检查到<code>⌊sqrt(n)⌋</code>，如果全都不能整除就足以证明<code>n</code>是素数了，请读者想一想为什么。</p>
<p>在主程序中，从<code>1</code>到<code>100</code>依次检查每个数是不是素数，如果不是素数，并不直接跳出循环，而是<code>i++</code>后继续执行下一次循环，因此用<code>continue</code>语句。注意主程序的局部变量<code>i</code>和<code>is_prime</code>中的局部变量<code>i</code>是不同的两个变量，其实在调用<code>is_prime</code>函数时主程序的局部变量<code>i</code>和参数<code>n</code>的值相等。</p>
<h2 id="嵌套循环">嵌套循环</h2>
<p>上一节求素数的例子在循环中调用一个函数，而那个函数里面又有一个循环，这其实是一种嵌套循环。如果把那个函数的代码拿出来写就更清楚了：</p>
<p>例 用嵌套循环求1-100的素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在内循环的循环变量就不能再用<code>i</code>了，而是改用<code>j</code>，原来程序中<code>is_prime</code>函数的参数<code>n</code>现在直接用<code>i</code>代替。在有多层循环或<code>switch</code>嵌套的情况下，<code>break</code>只能跳出最内层的循环或<code>switch</code>，<code>continue</code>也只能终止最内层循环并回到该循环的开头。</p>
<p>用循环也可以打印表格式的数据，比如打印小九九乘法表：</p>
<p>例 打印小九九</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=<span class="number">9</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, i*j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内循环每次打印一个数，数与数之间用两个空格隔开，外循环每次打印一行。结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4  5  6  7  8  9  </span><br><span class="line">2  4  6  8  10  12  14  16  18  </span><br><span class="line">3  6  9  12  15  18  21  24  27  </span><br><span class="line">4  8  12  16  20  24  28  32  36  </span><br><span class="line">5  10  15  20  25  30  35  40  45  </span><br><span class="line">6  12  18  24  30  36  42  48  54  </span><br><span class="line">7  14  21  28  35  42  49  56  63  </span><br><span class="line">8  16  24  32  40  48  56  64  72  </span><br><span class="line">9  18  27  36  45  54  63  72  81</span><br></pre></td></tr></table></figure>
<p>结果有一位数的有两位数的，这个表格很不整齐，如果把打印语句改为<code>printf("%d\t", i*j);</code>就整齐了，所以<code>Tab</code>字符称为制表符。</p>
<h2 id="goto语句和标号">goto语句和标号</h2>
<p>分支、循环都讲完了，现在只剩下最后一种影响控制流程的语句了，就是<code>goto</code>语句，实现无条件跳转。我们知道<code>break</code>只能跳出最内层的循环，如果在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理，就可以用<code>goto</code>语句，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (...)</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (出现错误条件)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">error:</span><br><span class="line">    出错处理;</span><br></pre></td></tr></table></figure>
<p>这里的<code>error:</code>叫做标号（Label），任何语句前面都可以加若干个标号，每个标号的命名也要遵循标识符的命名规则。</p>
<p><code>goto</code>语句过于强大了，从程序中的任何地方都可以无条件跳转到任何其它地方，只要在那个地方定义一个标号就行，唯一的限制是<code>goto</code>只能跳转到同一个函数中的某个标号处，而不能跳到别的函数中[11]。滥用<code>goto</code>语句会使程序的控制流程非常复杂，可读性很差。著名的计算机科学家Edsger
W.
Dijkstra最早指出编程语言中<code>goto</code>语句的危害，提倡取消<code>goto</code>语句。<code>goto</code>语句不是必须存在的，显然可以用别的办法替代，比如上面的代码段可以改写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cond = <span class="number">0</span>; <span class="comment">/* bool variable indicating error condition */</span></span><br><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (出现错误条件) &#123;</span><br><span class="line">            cond = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cond)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cond)</span><br><span class="line">    出错处理;</span><br></pre></td></tr></table></figure>
<p>通常<code>goto</code>语句只用于这种场合，一个函数中任何地方出现了错误条件都可以立即跳转到函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），处理完之后函数返回。比较用<code>goto</code>和不用<code>goto</code>的两种写法，用<code>goto</code>语句还是方便很多。但是除此之外，在任何其它场合都不要轻易考虑使用<code>goto</code>语句。有些编程语言（如C++）中有异常（Exception）处理的语法，可以代替<code>goto</code>和<code>setjmp/longjmp</code>的这种用法。</p>
<p>回想一下，我们在第 4 节
“switch语句”学过<code>case</code>和<code>default</code>后面也要跟冒号（<code>:</code>号，Colon），事实上它们是两种特殊的标号。和标号有关的语法规则如下：</p>
<p>语句 → 标识符: 语句 语句 → case 常量表达式: 语句 语句 → default:
语句</p>
<p>反复应用这些语法规则进行组合可以在一条语句前面添加多个标号，例如在例
4.2
“缺break的switch语句”的代码中，有些语句前面有多个<code>case</code>标号。现在我们再看<code>switch</code>语句的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (控制表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式： 语句列表</span><br><span class="line"><span class="keyword">case</span> 常量表达式： 语句列表</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>： 语句列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&#123;&#125;</code>里面是一组语句列表，其中每个分支的第一条语句带有<code>case</code>或<code>default</code>标号，从语法上来说，<code>switch</code>的语句块和其它分支、循环结构的语句块没有本质区别：</p>
<p>语句 → switch (控制表达式) 语句 语句 → { 语句列表 }</p>
<p>有兴趣的读者可以在网上查找有关Duff’s Device的资料，Duff’s
Device是一段很有意思的代码，正是利用“switch的语句块和循环结构的语句块没有本质区别”这一点实现了一个巧妙的代码优化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AB%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AB%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 16:52:08" itemprop="dateModified" datetime="2025-08-07T16:52:08+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数组的基本概念">数组的基本概念</h2>
<p>数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。例如定义一个由<code>4</code>个<code>int</code>型元素组成的数组<code>count</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>和结构体成员类似，数组<code>count</code>的<code>4</code>个元素的存储空间也是相邻的。结构体成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由<code>4</code>个结构体元素组成的数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125; a[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>也可以定义一个包含数组成员的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">4</span>];</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure>
<p>数组类型的长度应该用一个整数常量表达式来指定。数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由<code>4</code>个<code>int</code>型元素组成的数组<code>count</code>图示如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>整个数组占了<code>4</code>个<code>int</code>型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是0），而框外面的数字是下标，这四个单元分别用<code>count[0]</code>、<code>count[1]</code>、<code>count[2]</code>、<code>count[3]</code>来访问。注意，在定义数组<code>int count[4];</code>时，方括号（Bracket）中的数字<code>4</code>表示数组的长度，而在访问数组时，方括号中的数字表示访问数组的第几个元素。和我们平常数数不同，数组元素是从“第0个”开始数的，大多数编程语言都是这么规定的，所以计算机术语中有Zeroth这个词。这样规定使得访问数组元素非常方便，比如count数组中的每个元素占4个字节，则<code>count[i]</code>表示从数组开头跳过4*i个字节之后的那个存储单元。这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以下语句都是正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count[<span class="number">0</span>] = <span class="number">7</span>;</span><br><span class="line">count[<span class="number">1</span>] = count[<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">++count[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>到目前为止我们学习了五种后缀运算符：后缀<code>++</code>、后缀<code>--</code>、结构体取成员<code>.</code>、数组取下标<code>[]</code>、函数调用<code>()</code>。还学习了五种单目运算符（或者叫前缀运算符）：前缀<code>++</code>、前缀<code>--</code>、正号<code>+</code>、负号<code>-</code>、逻辑非<code>!</code>。在C语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其它运算符的优先级都高，所以上面举例的<code>++count[2]</code>应该看作对<code>count[2]</code>做前缀<code>++</code>运算。</p>
<p>数组下标也可以是表达式，但表达式的值必须是整型的。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">count[i] = count[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C编译器并不检查<code>count[-1]</code>或是<code>count[100]</code>这样的访问越界错误，编译时能顺利通过，所以属于运行时错误。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在第
4 节
“段错误”我们会看到这样的例子）。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。</p>
<p>数组也可以像结构体一样初始化，未赋初值的元素也是用<code>0</code>来初始化，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count[<span class="number">4</span>] = &#123; <span class="number">3</span>, <span class="number">2</span>, &#125;;</span><br></pre></td></tr></table></figure>
<p>则<code>count[0]</code>等于<code>3</code>，
<code>count[1]</code>等于<code>2</code>，后面两个元素等于<code>0</code>。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count[] = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, &#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会根据Initializer有三个元素确定数组的长度为3。利用C99的新特性也可以做Memberwise
Initialization：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count[<span class="number">4</span>] = &#123; [<span class="number">2</span>] = <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>下面举一个完整的例子：</p>
<p>例 定义和访问数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">4</span>] = &#123; <span class="number">3</span>, <span class="number">2</span>, &#125;, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count[%d]=%d\n&quot;</span>, i, count[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子通过循环把数组中的每个元素依次访问一遍，在计算机术语中称为遍历（Traversal）。注意控制表达式<code>i &lt; 4</code>，如果写成<code>i &lt;= 4</code>就错了，因为<code>count[4]</code>是访问越界。</p>
<p>数组和结构体虽然有很多相似之处，但也有一个显著的不同：数组不能相互赋值或初始化。例如这样是错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = a;</span><br></pre></td></tr></table></figure>
<p>相互赋值也是错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<p>既然不能相互赋值，也就不能用数组类型作为函数的参数或返回值。如果写出这样的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a[<span class="number">5</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这样调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">foo(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure>
<p>编译器也不会报错，但这样写并不是传一个数组类型参数的意思。对于数组类型有一条特殊规则：数组类型做右值使用时，自动转换成指向数组首元素的指针。所以上面的函数调用其实是传一个指针类型的参数，而不是数组类型的参数。接下来的几章里有的函数需要访问数组，我们就把数组定义为全局变量给函数访问，等以后讲了指针再使用传参的办法。这也解释了为什么数组类型不能相互赋值或初始化，例如上面提到的<code>a = b</code>这个表达式，<code>a</code>和<code>b</code>都是数组类型的变量，但是<code>b</code>做右值使用，自动转换成指针类型，而左边仍然是数组类型，所以编译器报的错是<code>error: incompatible types in assignment</code>。</p>
<h2 id="数组应用实例统计随机数">数组应用实例：统计随机数</h2>
<p>本节通过一个实例介绍使用数组的一些基本模式。问题是这样的：首先生成一列0~9的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。随机数在某些场合（例如游戏程序）是非常有用的，但是用计算机生成完全随机的数却不是那么容易。计算机执行每一条指令的结果都是确定的，没有一条指令产生的是随机数，调用C标准库得到的随机数其实是伪随机（Pseudorandom）数，是用数学公式算出来的确定的数，只不过这些数看起来很随机，并且从统计意义上也很接近均匀分布（Uniform
Distribution）的随机数。</p>
<p>C标准库中生成伪随机数的是<code>rand</code>函数，使用这个函数需要包含头文件<code>stdlib.h</code>，它没有参数，返回值是一个介于<code>0</code>和<code>RAND_MAX</code>之间的接近均匀分布的整数。<code>RAND_MAX</code>是该头文件中定义的一个常量，在不同的平台上有不同的取值，但可以肯定它是一个非常大的整数。通常我们用到的随机数是限定在某个范围之中的，例如0<sub>9，而不是0</sub>RAND_MAX，我们可以用<code>%</code>运算符将<code>rand</code>函数的返回值处理一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = rand() % <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>完整的程序如下：</p>
<p>例 生成并打印随机数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gen_random</span><span class="params">(<span class="type">int</span> upper_bound)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = rand() % upper_bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_random</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    gen_random(<span class="number">10</span>);</span><br><span class="line">    print_random();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里介绍一种新的语法：用<code>#define</code>定义一个常量。实际上编译器的工作分为两个阶段，先是预处理（Preprocess）阶段，然后才是编译阶段，用gcc的<code>-E</code>选项可以看到预处理之后、编译之前的程序，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -E main.c</span></span><br><span class="line">...（这里省略了很多行stdio.h和stdlib.h的代码）</span><br><span class="line">int a[20];</span><br><span class="line"></span><br><span class="line">void gen_random(int upper_bound)</span><br><span class="line">&#123;</span><br><span class="line"> int i;</span><br><span class="line"> for (i = 0; i &lt; 20; i++)</span><br><span class="line">  a[i] = rand() % upper_bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_random()</span><br><span class="line">&#123;</span><br><span class="line"> int i;</span><br><span class="line"> for (i = 0; i &lt; 20; i++)</span><br><span class="line">  printf(&quot;%d &quot;, a[i]);</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> gen_random(10);</span><br><span class="line"> print_random();</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见在这里预处理器做了两件事情，一是把头文件<code>stdio.h</code>和<code>stdlib.h</code>在代码中展开，二是把<code>#define</code>定义的标识符N替换成它的定义<code>20</code>（在代码中做了三处替换，分别位于数组的定义中和两个函数中）。像<code>#include</code>和<code>#define</code>这种以<code>#</code>号开头的行称为预处理指示（Preprocessing
Directive），我们将在第 21 章
预处理学习其它预处理指示。此外，用<code>cpp main.c</code>命令也可以达到同样的效果，只做预处理而不编译，<code>cpp</code>表示C
preprocessor。</p>
<p>那么用<code>#define</code>定义的常量和第 3 节
“数据类型标志”讲的枚举常量有什么区别呢？首先，<code>define</code>不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义。其次，<code>define</code>定义是在预处理阶段处理的，而枚举是在编译阶段处理的。试试看把第
3 节 “数据类型标志”习题2的程序改成下面这样是什么结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECTANGULAR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLAR 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> RECTANGULAR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, RECTANGULAR, POLAR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，虽然<code>include</code>和<code>define</code>在预处理指示中有特殊含义，但它们并不是C语言的关键字，换句话说，它们也可以用作标识符，例如声明<code>int include;</code>或者<code>void define(int);</code>。在预处理阶段，如果一行以<code>#</code>号开头，后面跟<code>include</code>或<code>define</code>，预处理器就认为这是一条预处理指示，除此之外出现在其它地方的<code>include</code>或<code>define</code>预处理器并不关心，只是当成普通标识符交给编译阶段去处理。</p>
<p>回到随机数这个程序继续讨论，一开始为了便于分析和调试，我们取小一点的数组长度，只生成20个随机数，这个程序的运行结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6</span><br></pre></td></tr></table></figure>
<p>看起来很随机了。但随机性如何呢？分布得均匀吗？所谓均匀分布，应该每个数出现的概率是一样的。在上面的20个结果中，6出现了5次，而4和8一次也没出现过。但这说明不了什么问题，毕竟我们的样本太少了，才20个数，如果样本足够多，比如说100000个数，统计一下其中每个数字出现的次数也许能说明问题。但总不能把100000个数都打印出来然后挨个去数吧？我们需要写一个函数统计每个数字出现的次数。完整的程序如下：</p>
<p>例 统计随机数的分布</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gen_random</span><span class="params">(<span class="type">int</span> upper_bound)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        a[i] = rand() % upper_bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">howmany</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == value)</span><br><span class="line">            ++count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    gen_random(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value\thow many\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, i, howmany(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只要把<code>#define N</code>的值改为<code>100000</code>，就相当于把整个程序中所有用到<code>N</code>的地方都改为<code>100000</code>了。如果我们不这么写，而是在定义数组时直接写成<code>int a[20];</code>，在每个循环中也直接使用20这个值，这称为硬编码（Hard
coding）。如果原来的代码是硬编码的，那么一旦需要把20改成100000就非常麻烦，你需要找遍整个代码，判断哪些20表示这个数组的长度就改为100000，哪些20表示别的数量则不做改动，如果代码很长，这是很容易出错的。所以，写代码时应尽可能避免硬编码，这其实也是一个“提取公因式”的过程，和第
2 节
“数据抽象”讲的抽象具有相同的作用，就是避免一个地方的改动波及到大的范围。这个程序的运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span></span><br><span class="line">value	how many</span><br><span class="line">0	10130</span><br><span class="line">1	10072</span><br><span class="line">2	9990</span><br><span class="line">3	9842</span><br><span class="line">4	10174</span><br><span class="line">5	9930</span><br><span class="line">6	10059</span><br><span class="line">7	9954</span><br><span class="line">8	9891</span><br><span class="line">9	9958</span><br></pre></td></tr></table></figure>
<p>各数字出现的次数都在10000次左右，可见是比较均匀的。</p>
<h2 id="数组应用实例直方图">数组应用实例：直方图</h2>
<p>继续上面的例子。我们统计一列0~9的随机数，打印每个数字出现的次数，像这样的统计结果称为直方图（Histogram）。有时候我们并不只是想打印，更想把统计结果保存下来以便做后续处理。我们可以把程序改成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> howmanyones = howmany(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> howmanytwos = howmany(<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这显然太繁琐了。要是这样的随机数有100个呢？显然这里用数组最合适不过了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, histogram[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    gen_random(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        histogram[i] = howmany(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有意思的是，这里的循环变量<code>i</code>有两个作用，一是作为参数传给<code>howmany</code>函数，统计数字<code>i</code>出现的次数，二是做<code>histogram</code>的下标，也就是“把数字<code>i</code>出现的次数保存在数组<code>histogram</code>的第<code>i</code>个位置”。</p>
<p>尽管上面的方法可以准确地得到统计结果，但是效率很低，这100000个随机数需要从头到尾检查十遍，每一遍检查只统计一种数字的出现次数。其实可以把<code>histogram</code>中的元素当作累加器来用，这些随机数只需要从头到尾检查一遍（Single
Pass）就可以得出结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, histogram[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    gen_random(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        histogram[a[i]]++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先把<code>histogram</code>的所有元素初始化为<code>0</code>，注意使用局部变量的值之前一定要初始化，否则值是不确定的。接下来的代码很有意思，在每次循环中，<code>a[i]</code>就是出现的随机数，而这个随机数同时也是<code>histogram</code>的下标，这个随机数每出现一次就把<code>histogram</code>中相应的元素加<code>1</code>。</p>
<p>把上面的程序运行几遍，你就会发现每次产生的随机数都是一样的，不仅如此，在别的计算机上运行该程序产生的随机数很可能也是这样的。这正说明了这些数是伪随机数，是用一套确定的公式基于某个初值算出来的，只要初值相同，随后的整个数列就都相同。实际应用中不可能使用每次都一样的随机数，例如开发一个麻将游戏，每次运行这个游戏摸到的牌不应该是一样的。因此，C标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数，这个初值称为Seed，可以用<code>srand</code>函数指定Seed。通常我们通过别的途径得到一个不确定的数作为Seed，例如调用<code>time</code>函数得到当前系统时间距1970年1月1日00:00:00[18]的秒数，然后传给<code>srand</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand(time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>然后再调用<code>rand</code>，得到的随机数就和刚才完全不同了。调用<code>time</code>函数需要包含头文件<code>time.h</code>，这里的<code>NULL</code>表示空指针，到第
1 节 “指针的基本概念”再详细解释。</p>
<h2 id="字符串">字符串</h2>
<p>之前我一直对字符串避而不谈，不做详细解释，现在已经具备了必要的基础知识，可以深入讨论一下字符串了。字符串可以看作一个数组，它的每个元素是字符型的，例如字符串<code>"Hello, world.\n"</code>图示如下：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
</tr>
</thead>
<tbody>
<tr>
<td>H</td>
<td>e</td>
<td>l</td>
<td>l</td>
<td>o</td>
<td>,</td>
<td></td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>l</td>
<td>d</td>
<td>.</td>
<td></td>
<td>\0</td>
</tr>
</tbody>
</table>
<p>注意每个字符末尾都有一个字符<code>'\0'</code>做结束符，这里的<code>\0</code>是ASCII码的八进制表示，也就是ASCII码为0的<code>Null</code>字符，在C语言中这种字符串也称为以零结尾的字符串（Null-terminated
String）。数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&quot;Hello, world.\n&quot;</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>但是通过下标修改其中的字符却是不允许的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello, world.\n&quot;</span>[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这行代码会产生编译错误，说字符串字面值是只读的，不允许修改。字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针，在第
3 节
“形参和实参”我们看到<code>printf</code>原型的第一个参数是指针类型，而<code>printf("hello world")</code>其实就是传一个指针参数给<code>printf</code>。</p>
<p>前面讲过数组可以像结构体一样初始化，如果是字符数组，也可以用一个字符串字面值来初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><code>str</code>的后四个元素没有指定，自动初始化为<code>0</code>，即<code>Null</code>字符。注意，虽然字符串字面值<code>"Hello"</code>是只读的，但用它初始化的数组<code>str</code>却是可读可写的。数组<code>str</code>中保存了一串字符，以<code>'\0'</code>结尾，也可以叫字符串。在本书中只要是以<code>Null</code>字符结尾的一串字符都叫字符串，不管是像<code>str</code>这样的数组，还是像<code>"Hello"</code>这样的字符串字面值。</p>
<p>如果用于初始化的字符串字面值比数组还长，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = <span class="string">&quot;Hello, world.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>则数组<code>str</code>只包含字符串的前<code>10</code>个字符，不包含<code>Null</code>字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, world.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>字符串字面值的长度包括<code>Null</code>字符在内一共<code>15</code>个字符，编译器会确定数组<code>str</code>的长度为<code>15</code>。</p>
<p>有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个<code>Null</code>字符的长度，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">14</span>] = <span class="string">&quot;Hello, world.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>则数组<code>str</code>不包含<code>Null</code>字符，并且编译器不会给出警告，[C99
Rationale]说这样规定是为程序员方便，以前的很多编译器都是这样实现的，不管它有理没理，C标准既然这么规定了我们也没办法，只能自己小心了。</p>
<p>补充一点，<code>printf</code>函数的格式化字符串中可以用<code>%s</code>表示字符串的占位符。在学字符数组以前，我们用<code>%s</code>没什么意义，因为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;string: %s\n&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>还不如写成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;string: Hello\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但现在字符串可以保存在一个数组里面，用<code>%s</code>来打印就很有必要了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;string: %s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure>
<p><code>printf</code>会从数组<code>str</code>的开头一直打印到<code>Null</code>字符为止，<code>Null</code>字符本身是Non-printable字符，不打印。这其实是一个危险的信号：如果数组<code>str</code>中没有<code>Null</code>字符，那么<code>printf</code>函数就会访问数组越界，后果可能会很诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。</p>
<h2 id="多维数组">多维数组</h2>
<p>就像结构体可以嵌套一样，数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional
Array）。例如定义并初始化一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>数组<code>a</code>有<code>3</code>个元素，<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>。每个元素也是一个数组，例如<code>a[0]</code>是一个数组，它有两个元素<code>a[0][0]</code>、<code>a[0][1]</code>，这两个元素的类型是<code>int</code>，值分别是<code>1</code>、<code>2</code>，同理，数组<code>a[1]</code>的两个元素是<code>3</code>、<code>4</code>，数组<code>a[2]</code>的两个元素是<code>5</code>、<code>0</code>。如下图所示：</p>
<table>
<thead>
<tr>
<th>概念模型</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>5</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>物理模型</th>
<th>a[0] [0]</th>
<th>a[0] [1]</th>
<th>a[1] [0]</th>
<th>a[1] [1]</th>
<th>a[2] [0]</th>
<th>a[2] [1]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为Row-major方式，而有些编程语言（例如FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为Column-major方式。</p>
<p>多维数组也可以像嵌套结构体一样用嵌套Initializer初始化，例如上面的二维数组也可以这样初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">2</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">        &#123; <span class="number">5</span>, &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>注意，除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度。利用C99的新特性也可以做Memberwise
Initialization，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; [<span class="number">0</span>][<span class="number">1</span>] = <span class="number">9</span>, [<span class="number">2</span>][<span class="number">1</span>] = <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>结构体和数组嵌套的情况也可以做Memberwise Initialization，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex_struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125; a[<span class="number">4</span>] = &#123; [<span class="number">0</span>].x = <span class="number">8.0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="type">int</span> count[<span class="number">4</span>];</span><br><span class="line">&#125; s = &#123; .count[<span class="number">2</span>] = <span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>如果是多维字符数组，也可以嵌套使用字符串字面值做Initializer，例如：</p>
<p>例 多维字符数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_day</span><span class="params">(<span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> days[<span class="number">8</span>][<span class="number">10</span>] = &#123; <span class="string">&quot;&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (day &lt; <span class="number">1</span> || day &gt; <span class="number">7</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Illegal day number!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, days[day]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_day(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
<th>\0</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>o</td>
<td>n</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
</tr>
<tr>
<td>T</td>
<td>u</td>
<td>s</td>
<td>e</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
</tr>
<tr>
<td>W</td>
<td>e</td>
<td>d</td>
<td>n</td>
<td>e</td>
<td>s</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
</tr>
<tr>
<td>T</td>
<td>h</td>
<td>u</td>
<td>r</td>
<td>s</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
</tr>
<tr>
<td>F</td>
<td>r</td>
<td>i</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
</tr>
<tr>
<td>S</td>
<td>a</td>
<td>t</td>
<td>u</td>
<td>r</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
</tr>
<tr>
<td>S</td>
<td>u</td>
<td>n</td>
<td>d</td>
<td>a</td>
<td>y</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
<td>\0</td>
</tr>
</tbody>
</table>
<p>这个程序中定义了一个多维字符数组<code>char days[8][10];</code>，为了使1~7刚好映射到<code>days[1]~days[7]</code>，我们把<code>days[0]</code>空出来不用，所以第一维的长度是<code>8</code>，为了使最长的字符串<code>"Wednesday"</code>能够保存到一行，末尾还能多出一个<code>Null</code>字符的位置，所以第二维的长度是<code>10</code>。</p>
<p>这个程序和例 4.1
“switch语句”的功能其实是一样的，但是代码简洁多了。简洁的代码不仅可读性强，而且维护成本也低，像例
4.1
“switch语句”那样一堆case、printf和break，如果漏写一个break就要出Bug。这个程序之所以简洁，是因为用数据代替了代码。具体来说，通过下标访问字符串组成的数组可以代替一堆case分支判断，这样就可以把每个case里重复的代码（printf调用）提取出来，从而又一次达到了“提取公因式”的效果。这种方法称为数据驱动的编程（Data-driven
Programming），写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择得正确，其它代码自然而然就变得容易理解和维护了，就像这里的printf自然而然就被提取出来了。[人月神话]中说过：“Show
me your flowcharts and conceal your tables, and I shall continue to be
mystified. Show me your tables, and I won’t usually need your
flowcharts; they’ll be obvious.”</p>
<p>最后，综合本章的知识，我们来写一个最简单的小游戏－－剪刀石头布：</p>
<p>例 剪刀石头布</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> gesture[<span class="number">3</span>][<span class="number">10</span>] = &#123; <span class="string">&quot;scissor&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;cloth&quot;</span> &#125;;</span><br><span class="line">    <span class="type">int</span> man, computer, result, ret;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        computer = rand() % <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nInput your gesture (0-scissor 1-stone 2-cloth):\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;man);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">1</span> || man &lt; <span class="number">0</span> || man &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid input! Please input 0, 1 or 2.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your gesture: %s\tComputer&#x27;s gesture: %s\n&quot;</span>, </span><br><span class="line">            gesture[man], gesture[computer]);</span><br><span class="line"></span><br><span class="line">        result = (man - computer + <span class="number">4</span>) % <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You win!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Draw!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You lose!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>0</code>、<code>1</code>、<code>2</code>三个整数分别是剪刀石头布在程序中的内部表示，用户也要求输入<code>0</code>、<code>1</code>或<code>2</code>，然后和计算机随机生成的<code>0</code>、<code>1</code>或<code>2</code>比胜负。这个程序的主体是一个死循环，需要按<code>Ctrl-C</code>退出程序。以往我们写的程序都只有打印输出，在这个程序中我们第一次碰到处理用户输入的情况。我们简单介绍一下<code>scanf</code>函数的用法，到第
2.9 节
“格式化I/O函数”再详细解释。<code>scanf("%d", &amp;man)</code>这个调用的功能是等待用户输入一个整数并回车，这个整数会被<code>scanf</code>函数保存在<code>man</code>这个整型变量里。如果用户输入合法（输入的确实是数字而不是别的字符），则<code>scanf</code>函数返回<code>1</code>，表示成功读入一个数据。但即使用户输入的是整数，我们还需要进一步检查是不是在<code>0~2</code>的范围内，写程序时对用户输入要格外小心，用户有可能输入任何数据，他才不管游戏规则是什么。</p>
<p>和<code>printf</code>类似，<code>scanf</code>也可以用<code>%c</code>、<code>%f</code>、<code>%s</code>等转换说明。如果在传给<code>scanf</code>的第一个参数中用<code>%d</code>、<code>%f</code>或<code>%c</code>表示读入一个整数、浮点数或字符，则第二个参数的形式应该是&amp;运算符加相应类型的变量名，表示读进来的数保存到这个变量中，&amp;运算符的作用是得到一个指针类型，到第
1 节
“指针的基本概念”再详细解释；如果在第一个参数中用%s读入一个字符串，则第二个参数应该是数组名，数组名前面不加&amp;，因为数组类型做右值时自动转换成指针类型，在第
2 节 “断点”有<code>scanf</code>读入字符串的例子。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/C%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">C语言:栈与队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-07 20:02:04" itemprop="dateModified" datetime="2025-08-07T20:02:04+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据结构的概念">数据结构的概念</h2>
<p>数据结构（Data
Structure）是数据的组织方式。程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。以前学过的复合类型也可以看作数据的组织方式，把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。数据的组织方式包含了存储方式和访问方式这两层意思，二者是紧密联系的。例如，数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式，结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访问，而不能按下标访问。</p>
<p>本章主要介绍栈和队列这两种数据结构以及它们的应用。从本章的应用实例可以看出，一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。所以Pascal语言的设计者Niklaus
Wirth提出：算法+数据结构=程序（详见[算法+数据结构=程序]）。</p>
<h2 id="堆栈">堆栈</h2>
<p>在第 3 节
“递归”中我们已经对堆栈这种数据结构有了初步认识。堆栈是一组元素的集合，类似于数组，不同之处在于，数组可以按下标随机访问，这次访问a[5]下次可以访问a[1]，但是堆栈的访问规则被限制为Push和Pop两种操作，Push（入栈或压栈）向栈顶添加元素，Pop（出栈或弹出）则取出当前栈顶的元素，也就是说，只能访问栈顶元素而不能访问栈中其它元素。如果所有元素的类型相同，堆栈的存储也可以用数组来实现，访问操作可以通过函数接口提供。看以下的示例程序。</p>
<p>例 用堆栈实现倒序打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    push(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    push(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    push(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!is_empty())</span><br><span class="line">        <span class="built_in">putchar</span>(pop());</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是<code>cba</code>。运行过程图示如下：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.stack.png"
alt="用堆栈实现倒序打印" />
<figcaption aria-hidden="true">用堆栈实现倒序打印</figcaption>
</figure>
<p>数组<code>stack</code>是堆栈的存储空间，变量<code>top</code>总是保存数组中栈顶的下一个元素的下标，我们说“<code>top</code>总是指向栈顶的下一个元素”，或者把<code>top</code>叫做栈顶指针（Pointer）。在第
2 节 “插入排序”中介绍了Loop
Invariant的概念，可以用它检验循环的正确性，这里的“<code>top</code>总是指向栈顶的下一个元素”其实也是一种Invariant，Push和Pop操作总是维持这个条件不变，这种Invariant描述的对象是一个数据结构而不是一个循环，在DbC中称为Class
Invariant。Pop操作的语义是取出栈顶元素，但上例的实现其实并没有清除原来的栈顶元素，只是把<code>top</code>指针移动了一下，原来的栈顶元素仍然存在那里，这就足够了，因为此后通过Push和Pop操作不可能再访问到已经取出的元素，下次Push操作就会覆盖它。<code>putchar</code>函数的作用是把一个字符打印到屏幕上，和<code>printf</code>的<code>%c</code>作用相同。布尔函数<code>is_empty</code>的作用是防止Pop操作访问越界。这里我们预留了足够大的栈空间（512个元素），其实严格来说Push操作之前也应该检查栈是否满了。</p>
<p>在<code>main</code>函数中，入栈的顺序是<code>'a'</code>、<code>'b'</code>、<code>'c'</code>，而出栈打印的顺序却是<code>'c'</code>、<code>'b'</code>、<code>'a'</code>，最后入栈的<code>'c'</code>最早出来，因此堆栈这种数据结构的特点可以概括为LIFO（Last
In First
Out，后进先出）。我们也可以写一个递归函数做倒序打印，利用函数调用的栈帧实现后进先出：</p>
<p>例 用递归实现倒序打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[LEN]=&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_backward</span><span class="params">(<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(pos == LEN)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">     print_backward(pos+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">putchar</span>(buf[pos]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     print_backward(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你会说，又是堆栈又是递归的，倒序打印一个数组犯得着这么大动干戈吗？写一个简单的循环不就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = LEN<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">putchar</span>(buf[i]);</span><br></pre></td></tr></table></figure>
<p>对于数组来说确实没必要搞这么复杂，因为数组既可以从前向后访问也可以从后向前访问，甚至可以随机访问，但有些数据结构的访问并没有这么自由，下一节你就会看到这样的数据结构。</p>
<h2 id="深度优先搜索">深度优先搜索</h2>
<p>现在我们用堆栈解决一个有意思的问题，定义一个二维数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maze[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。程序如下：</p>
<p>例 用深度优先搜索解迷宫问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col; &#125; <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>[top++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point <span class="title function_">pop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[--top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">predecessor</span>[<span class="title">MAX_ROW</span>][<span class="title">MAX_COL</span>] =</span> &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="keyword">struct</span> point pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    predecessor[row][col] = pre;</span><br><span class="line">    push(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    push(p);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = pop();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col, p);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col, p);</span><br><span class="line">        print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (predecessor[p.row][p.col].row != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = predecessor[p.row][p.col];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">(4, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(2, 4)</span><br><span class="line">(1, 4)</span><br><span class="line">(0, 4)</span><br><span class="line">(0, 3)</span><br><span class="line">(0, 2)</span><br><span class="line">(1, 2)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(0, 0)</span><br></pre></td></tr></table></figure>
<p>这次堆栈里的元素是结构体类型的，用来表示迷宫中一个点的x和y座标。我们用一个新的数据结构保存走迷宫的路线，每个走过的点都有一个前趋（Predecessor）点，表示是从哪儿走到当前点的，比如<code>predecessor[4][4]</code>是座标为(3,
4)的点，就表示从(3, 4)走到了(4,
4)，一开始<code>predecessor</code>的各元素初始化为无效座标(-1,
-1)。在迷宫中探索路线的同时就把路线保存在<code>predecessor</code>数组中，已经走过的点在<code>maze</code>数组中记为2防止重复走，最后找到终点时就根据<code>predecessor</code>数组保存的路线从终点打印到起点。为了帮助理解，我把这个算法改写成伪代码（Pseudocode）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将起点标记为已走过并压栈;</span><br><span class="line"><span class="keyword">while</span> (栈非空) &#123;</span><br><span class="line">    从栈顶弹出一个点p;</span><br><span class="line">    <span class="keyword">if</span> (p这个点是终点)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    否则沿右、下、左、上四个方向探索相邻的点</span><br><span class="line">    <span class="keyword">if</span> (和p相邻的点有路可走，并且还没走过)</span><br><span class="line">        将相邻的点标记为已走过并压栈，它的前趋就是p点;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p点是终点) &#123;</span><br><span class="line">    打印p点的座标;</span><br><span class="line">    <span class="keyword">while</span> (p点有前趋) &#123;</span><br><span class="line">        p点 = p点的前趋;</span><br><span class="line">        打印p点的座标;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    没有路线可以到达终点;</span><br></pre></td></tr></table></figure>
<p>我在<code>while</code>循环的末尾插了打印语句，每探索一步都打印出当前迷宫的状态（标记了哪些点），从打印结果可以看出这种搜索算法的特点是：每次探索完各个方向相邻的点之后，取其中一个相邻的点走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。这称为深度优先搜索（DFS，Depth
First Search）。探索迷宫和堆栈变化的过程如下图所示。</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.dfs.png"
alt="深度优先搜索" />
<figcaption aria-hidden="true">深度优先搜索</figcaption>
</figure>
<p>图中各点的编号表示探索顺序，堆栈中保存的应该是座标，我在画图时为了直观就把各点的编号写在堆栈里了。可见正是堆栈后进先出的性质使这个算法具有了深度优先的特点。如果在探索问题的解时走进了死胡同，则需要退回来从另一条路继续探索，这种思想称为回溯（Backtrack），一个典型的例子是很多编程书上都会讲的八皇后问题。</p>
<p>最后我们打印终点的座标并通过<code>predecessor</code>数据结构找到它的前趋，这样顺藤摸瓜一直打印到起点。那么能不能从起点到终点正向打印路线呢？在上一节我们看到，数组支持随机访问也支持顺序访问，如果在一个循环里打印数组，既可以正向打印也可以反向打印。但<code>predecessor</code>这种数据结构却有很多限制：</p>
<p>不能随机访问一条路线上的任意点，只能通过一个点找到另一个点，通过另一个点再找第三个点，因此只能顺序访问。</p>
<p>每个点只知道它的前趋是谁，而不知道它的后继（Successor）是谁，所以只能反向顺序访问。</p>
<p>可见，有什么样的数据结构就决定了可以用什么样的算法。那为什么不再建一个<code>successor</code>数组来保存每个点的后继呢？从DFS算法的过程可以看出，虽然每个点的前趋只有一个，后继却不止一个，如果我们为每个点只保存一个后继，则无法保证这个后继指向正确的路线。由此可见，有什么样的算法就决定了可以用什么样的数据结构。设计算法和设计数据结构这两件工作是紧密联系的。</p>
<h2 id="队列与广度优先搜索">队列与广度优先搜索</h2>
<p>队列也是一组元素的集合，也提供两种基本操作：Enqueue（入队）将元素添加到队尾，Dequeue（出队）从队头取出元素并返回。就像排队买票一样，先来先服务，先入队的人也是先出队的，这种方式称为FIFO（First
In First Out，先进先出），有时候队列本身也被称为FIFO。</p>
<p>下面我们用队列解决迷宫问题。程序如下：</p>
<p>例 用广度优先搜索解迷宫问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ROW 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COL 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col, predecessor; &#125; <span class="built_in">queue</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">struct</span> point p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>[tail++] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point <span class="title function_">dequeue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>[head++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> head == tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maze[MAX_ROW][MAX_COL] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_maze</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_COL; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maze[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">visit_point</span> =</span> &#123; row, col, head<span class="number">-1</span> &#125;;</span><br><span class="line">    maze[row][col] = <span class="number">2</span>;</span><br><span class="line">    enqueue(visit_point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span> =</span> &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    maze[p.row][p.col] = <span class="number">2</span>;</span><br><span class="line">    enqueue(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        p = dequeue();</span><br><span class="line">        <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span>  <span class="comment">/* goal */</span></span><br><span class="line">            &amp;&amp; p.col == MAX_COL - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.col+<span class="number">1</span> &lt; MAX_COL     <span class="comment">/* right */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col+<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.row+<span class="number">1</span> &lt; MAX_ROW     <span class="comment">/* down */</span></span><br><span class="line">            &amp;&amp; maze[p.row+<span class="number">1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row+<span class="number">1</span>, p.col);</span><br><span class="line">        <span class="keyword">if</span> (p.col<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* left */</span></span><br><span class="line">            &amp;&amp; maze[p.row][p.col<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row, p.col<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.row<span class="number">-1</span> &gt;= <span class="number">0</span>          <span class="comment">/* up */</span></span><br><span class="line">            &amp;&amp; maze[p.row<span class="number">-1</span>][p.col] == <span class="number">0</span>)</span><br><span class="line">            visit(p.row<span class="number">-1</span>, p.col);</span><br><span class="line">            print_maze();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.row == MAX_ROW - <span class="number">1</span> &amp;&amp; p.col == MAX_COL - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        <span class="keyword">while</span> (p.predecessor != <span class="number">-1</span>) &#123;</span><br><span class="line">            p = <span class="built_in">queue</span>[p.predecessor];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>, p.row, p.col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No path!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">0 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 0 0 0 0 </span><br><span class="line">0 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 0 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">0 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 0 1 0 </span><br><span class="line">2 2 2 0 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 0 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 0 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 0 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 0 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 0 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 0 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 0 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 0 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 0 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">2 1 2 2 2 </span><br><span class="line">2 1 2 1 2 </span><br><span class="line">2 2 2 2 2 </span><br><span class="line">2 1 1 1 2 </span><br><span class="line">2 2 2 1 2 </span><br><span class="line">*********</span><br><span class="line">(4, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(2, 4)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 2)</span><br><span class="line">(2, 1)</span><br><span class="line">(2, 0)</span><br><span class="line">(1, 0)</span><br><span class="line">(0, 0)</span><br></pre></td></tr></table></figure>
<p>其实仍然可以像例 12.3
“用深度优先搜索解迷宫问题”一样用predecessor数组表示每个点的前趋，但我想换一种更方便的数据结构，直接在每个点的结构体中加一个成员表示前趋：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span> <span class="type">int</span> row, col, predecessor; &#125; <span class="built_in">queue</span>[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>变量<code>head</code>和<code>tail</code>是队头和队尾指针，<code>head</code>总是指向队头，<code>tail</code>总是指向队尾的下一个元素。每个点的<code>predecessor</code>成员也是一个指针，指向它的前趋在<code>queue</code>数组中的位置。如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.bfsqueue.png"
alt="广度优先搜索的队列数据结构" />
<figcaption aria-hidden="true">广度优先搜索的队列数据结构</figcaption>
</figure>
<p>为了帮助理解，我把这个算法改写成伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将起点标记为已走过并入队;</span><br><span class="line"><span class="keyword">while</span> (队列非空) &#123;</span><br><span class="line">    出队一个点p;</span><br><span class="line">    <span class="keyword">if</span> (p这个点是终点)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    否则沿右、下、左、上四个方向探索相邻的点</span><br><span class="line">    <span class="keyword">if</span> (和p相邻的点有路可走，并且还没走过)</span><br><span class="line">        将相邻的点标记为已走过并入队，它的前趋就是刚出队的p点;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p点是终点) &#123;</span><br><span class="line">    打印p点的座标;</span><br><span class="line">    <span class="keyword">while</span> (p点有前趋) &#123;</span><br><span class="line">        p点 = p点的前趋;</span><br><span class="line">        打印p点的座标;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    没有路线可以到达终点;</span><br></pre></td></tr></table></figure>
<p>从打印的搜索过程可以看出，这个算法的特点是沿各个方向同时展开搜索，每个可以走通的方向轮流往前走一步，这称为广度优先搜索（BFS，Breadth
First Search）。探索迷宫和队列变化的过程如下图所示。</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.bfs.png"
alt="广度优先搜索" />
<figcaption aria-hidden="true">广度优先搜索</figcaption>
</figure>
<p>广度优先是一种步步为营的策略，每次都从各个方向探索一步，将前线推进一步，图中的虚线就表示这个前线，队列中的元素总是由前线的点组成的，可见正是队列先进先出的性质使这个算法具有了广度优先的特点。广度优先搜索还有一个特点是可以找到从起点到终点的最短路径，而深度优先搜索找到的不一定是最短路径，比较本节和上一节程序的运行结果可以看出这一点，想一想为什么。</p>
<h2 id="环形队列">环形队列</h2>
<p>比较例 12.3 “用深度优先搜索解迷宫问题”的栈操作和例 12.4
“用广度优先搜索解迷宫问题”的队列操作可以发现，栈操作的<code>top</code>指针在Push时增大而在Pop时减小，栈空间是可以重复利用的，而队列的<code>head</code>、<code>tail</code>指针都在一直增大，虽然前面的元素已经出队了，但它所占的存储空间却不能重复利用。在例
12.4
“用广度优先搜索解迷宫问题”的解法中，出队的元素仍然有用，保存着走过的路径和每个点的前趋，但大多数程序并不是这样使用队列的，一般情况下出队的元素就不再有保存价值了，这些元素的存储空间应该回收利用，由此想到把队列改造成环形队列（Circular
Queue）：把<code>queue</code>数组想像成一个圈，<code>head</code>和<code>tail</code>指针仍然是一直增大的，当指到数组末尾时就自动回到数组开头，就像两个人围着操场赛跑，沿着它们跑的方向看，从<code>head</code>到<code>tail</code>之间是队列的有效元素，从<code>tail</code>到<code>head</code>之间是空的存储位置，如果<code>head</code>追上<code>tail</code>就表示队列空了，如果<code>tail</code>追上<code>head</code>就表示队列的存储空间满了。如下图所示：</p>
<figure>
<img src="C:\blog\Blog\images\C\stackqueue.circular.png"
alt="环形队列" />
<figcaption aria-hidden="true">环形队列</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
