<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Minecraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Minecraft/" class="post-title-link" itemprop="url">Minecraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-19 19:50:11" itemprop="dateModified" datetime="2026-01-19T19:50:11+08:00">2026-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Game/" itemprop="url" rel="index"><span itemprop="name">Game</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="光影">光影</h2>
<p>下载对应版本的Optifine, 下载完成后打开java文件,
然后直接安装到<code>C:\Users\XQ\AppData\Roaming\.minecraft</code>文件夹下面,
然后打开游戏, 就可以看见光影的选项了.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Python%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Python%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Python基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-27 17:47:13" itemprop="dateModified" datetime="2026-01-27T17:47:13+08:00">2026-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装">安装</h2>
<h3 id="python解释器的安装">Python解释器的安装</h3>
<p>进入Python官网, 找到需要的版本,
点击<code>Download Windows installer(64-bit)</code>, 安装完成后,
点击exe文件,
注意要勾选上<code>Add Python to PATH</code>和<code>Install Python for all users</code>.</p>
<p>我下载的版本是Python 3.13, 放在C盘根目录下,
也就是文件夹<code>Python313</code>, 如果需要多版本共存,
那么下载的其他版本也要放在C盘根目录下,
比如<code>Python311, Python310</code>等.</p>
<p>如果忘记勾选添加环境变量, 可以自己手动修改: 右键点击”此电脑”,
点击”属性”, 点击”高级系统设置”, 点击”环境变量”, 找到系统变量里面的PATH,
打开后添加两个路径<code>C:\Python313</code>和<code>C:\Python313\Scripts\</code>,
对于其他的版本也这样操作. 设置完成后, 可以按下<code>Win+R</code>,
输入cmd, 输入<code>Python --version</code>就可以看到当前的版本信息了.
输入<code>python</code>, 就可以运行Python了.</p>
<p>如果要切换多个版本的解释器, 那么就<code>C:\Python313</code>目录下,
添加一个<code>Python.exe</code>的副本, 命名为<code>Python313.exe</code>,
对于其他版本也这样操作. 然后在命令行窗口,
输入<code>Python313/Python311/Python310 --version</code>,
就可以分别看见不同版本的信息了.</p>
<h3 id="vs-code-python配置">VS Code + Python配置</h3>
<p>在插件栏搜索Python, 直接安装Python插件.</p>
<p>下载好之后, 可以新建一个py文件, 在右下角可以看到解释器相应的版本,
点击可以切换. 写好代码后点击右上角的三角符号就可以运行了.</p>
<p>运行时, 我们可以看到运行的终端是powershell,
点击上面的小加号旁边的箭头, 可以切换运行终端为Git bash, Command
Prompt等其他终端, 然后把之前的powershell删掉即可.</p>
<h2 id="getting-started">Getting Started</h2>
<h3 id="first-program">First Program</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代码规范">代码规范</h3>
<p>代码的规范化, 搜索Python PEPs, 就可以看到相应的规范文档了,
一般情况下, 我们遵守PEP8. 在插件栏中搜索autopep8, 安装好这个插件后,
点击”查看”, 点击”命令面板”, 输入”format document”,
就可以自动把代码规范化了.</p>
<h2 id="基本类型">基本类型</h2>
<p>整数, 浮点数, 布尔代数<code>True/False</code>,
字符串<code>"Hello, world!"</code>(可以使用单引号或者双引号,
也可以使用三个双引号输入多行字符串).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(course))</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(course[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>:])</span><br><span class="line"><span class="built_in">print</span>(course[:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(course[:])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;Python \&quot; \&#x27; \\ \nProgramming&quot;</span></span><br><span class="line"><span class="built_in">print</span>(course)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="string">&quot;Siyuan&quot;</span></span><br><span class="line">last = <span class="string">&quot;Lei&quot;</span></span><br><span class="line">full1 = first + <span class="string">&quot; &quot;</span> + last</span><br><span class="line">full2 = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">full3 = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">len</span>(first)&#125;</span> <span class="subst">&#123;<span class="number">2</span> + <span class="number">2</span>&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(full1)</span><br><span class="line"><span class="built_in">print</span>(full2)</span><br><span class="line"><span class="built_in">print</span>(full3)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;   python programming!   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(course.upper())</span><br><span class="line"><span class="built_in">print</span>(course.lower())</span><br><span class="line"><span class="built_in">print</span>(course.title())</span><br><span class="line"><span class="built_in">print</span>(course.strip())</span><br><span class="line"><span class="built_in">print</span>(course.rstrip())</span><br><span class="line"><span class="built_in">print</span>(course.lstrip())</span><br><span class="line"><span class="built_in">print</span>(course.find(<span class="string">&quot;pro&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(course.replace(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pro&quot;</span> <span class="keyword">in</span> course)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pro&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> course)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">floating_number = <span class="number">1.2</span></span><br><span class="line">imaginary_number = <span class="number">3</span> + <span class="number">9j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> + <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> - <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> * <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> // <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> % <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> ** <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">x = x + <span class="number">3</span></span><br><span class="line">x += <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">2.6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">4.5</span>))</span><br><span class="line"><span class="built_in">print</span>(math.ceil(<span class="number">2.2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&quot;x: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x))</span><br><span class="line">y = <span class="built_in">int</span>(x) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x: <span class="subst">&#123;x&#125;</span>, y: <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(-<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;False&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;B&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bag&quot;</span> &gt; <span class="string">&quot;apple&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bag&quot;</span> == <span class="string">&quot;BAG&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="控制流">控制流</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperature = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> temperature &gt; <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is warm&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Drink water&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> temperature &gt; <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is nice&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is cold&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line">message = <span class="string">&quot;Eligible&quot;</span> <span class="keyword">if</span> age &gt;= <span class="number">18</span> <span class="keyword">else</span> <span class="string">&quot;Not eligible&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">high_income = <span class="literal">False</span></span><br><span class="line">good_credit = <span class="literal">True</span></span><br><span class="line">student = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (high_income <span class="keyword">or</span> good_credit) <span class="keyword">and</span> (<span class="keyword">not</span> student):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eligible&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not eligible&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">18</span>&lt;= age &lt;<span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;eligible&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, number)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, number + <span class="number">1</span>, (number + <span class="number">1</span>) * <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, i, i * <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, j)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, j, j * <span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">successful = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> successful:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Successful&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt 3 times and failed&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;Python&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">    number //= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> command.lower() != <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ECHO&quot;</span>, command)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ECHO&quot;</span>, command)</span><br><span class="line">    <span class="keyword">if</span> command.lower() == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hi, <span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Wick&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Siyuan&quot;</span>, <span class="string">&quot;Lei&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">message = get_greeting(<span class="string">&quot;Siyuan&quot;</span>)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;content.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">file.write(message)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">number, by</span>):</span><br><span class="line">    <span class="keyword">return</span> number + by</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">2</span>, by=<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span>  <span class="title function_">increment</span>(<span class="params">number, by = <span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> number + by</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">3</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">*numbers</span>):</span><br><span class="line">    total = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        total *= number</span><br><span class="line">    <span class="keyword">return</span>(total)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(multiply(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_user</span>(<span class="params">**user</span>):</span><br><span class="line">    <span class="built_in">print</span>(user)</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;age&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;gender&quot;</span>])</span><br><span class="line"></span><br><span class="line">save_user(<span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;Siyuan&quot;</span>, age=<span class="number">20</span>, gender=<span class="string">&quot;Female&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="调试">调试</h2>
<p>将.py文件放入一个文件夹中, 比如<code>Python Code</code>,
然后把这个文件放进VS Code的工作区. 在VS Code的左边一栏点击Debug选项,
点击齿轮形状的选项, 然后就会出现一个<code>launch.json</code>的文件,
关闭它, 然后就可以开始Debug了.</p>
<p>先设置一个断点, 按下<code>F5</code>进入调试模式,
这时程序从断点处执行, 按下<code>F10</code>执行下一条语句,
如果这一条语句里面有函数的调用, 就可以按下<code>F11</code>进入该函数,
在函数内部按<code>F10</code>可以单步执行.</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="列表">列表</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">matrix = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">zeros = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(zeros)</span><br><span class="line">combined = zeros + letters</span><br><span class="line"><span class="built_in">print</span>(combined)</span><br><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">chars = <span class="built_in">list</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(chars))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers[:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">19</span>]</span><br><span class="line">first, second, third, *other1 = numbers</span><br><span class="line"><span class="built_in">print</span>(first)</span><br><span class="line"><span class="built_in">print</span>(second)</span><br><span class="line"><span class="built_in">print</span>(third)</span><br><span class="line"><span class="built_in">print</span>(other1)</span><br><span class="line"></span><br><span class="line">one, *other2, last = numbers</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(one)</span><br><span class="line"><span class="built_in">print</span>(other2)</span><br><span class="line"><span class="built_in">print</span>(last)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">enumerate</span>(letters):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(letters):</span><br><span class="line">    <span class="built_in">print</span>(index, letter)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line">letters.append(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.insert(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"></span><br><span class="line">letters.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.remove(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"><span class="keyword">del</span> letters[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.clear()</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(letters.count(<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.count(<span class="string">&quot;d&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.index(<span class="string">&quot;a&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">78</span>, <span class="number">54</span>, <span class="number">3</span>, <span class="number">10</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">new_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(new_numbers)</span><br><span class="line">new_numbers = <span class="built_in">sorted</span>(numbers, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(new_numbers)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_item</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">items.sort(key=sort_item)</span><br><span class="line"><span class="built_in">print</span>(items)</span><br><span class="line"></span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> items:items[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(items)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">price = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    price.append(items[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(price)</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">map</span>(<span class="keyword">lambda</span> items: items[<span class="number">1</span>], items)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">filter</span>(<span class="keyword">lambda</span> items: items[<span class="number">1</span>]&gt;=<span class="number">10</span>, items)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">prices = [item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> items]</span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span> = [item <span class="keyword">for</span> item <span class="keyword">in</span> items <span class="keyword">if</span> item[<span class="number">1</span>]&gt;=<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">new_list = <span class="built_in">zip</span>(<span class="string">&quot;abc&quot;</span>, list1, list2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(new_list))</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列">栈和队列</h3>
<h3 id="tuples">Tuples</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chars = <span class="built_in">tuple</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>) * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">x, y, z = z, x, y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;z:&quot;</span>, z)</span><br></pre></td></tr></table></figure>
<h3 id="向量array">向量Array</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">numbers = array(<span class="string">&quot;i&quot;</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h3 id="集合set">集合set</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line">uniques = <span class="built_in">set</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(uniques)</span><br><span class="line"></span><br><span class="line">second = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">second.add(<span class="number">6</span>)</span><br><span class="line">second.remove(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">len</span>(second)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">second = &#123;<span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(first | second)</span><br><span class="line"><span class="built_in">print</span>(first &amp; second)</span><br><span class="line"><span class="built_in">print</span>(first - second)</span><br><span class="line"><span class="built_in">print</span>(first ^ second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> first:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="字典">字典</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">point = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">point = <span class="built_in">dict</span>(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(point[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">point[<span class="string">&quot;z&quot;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(point)</span><br><span class="line"><span class="built_in">print</span>(point.get(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(point.get(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">del</span> point[<span class="string">&quot;x&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> point:</span><br><span class="line">    <span class="built_in">print</span>(key, point[key])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> point.items():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> point.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = &#123;x: x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure>
<h3 id="生成元">生成元</h3>
<h3 id="解包算符">解包算符</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(*numbers)</span><br><span class="line"></span><br><span class="line">values = [*<span class="built_in">range</span>(<span class="number">5</span>), *<span class="string">&quot;Hello&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"></span><br><span class="line">first = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">second = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">10</span>, <span class="string">&quot;y&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">combined = &#123;**first, **second, <span class="string">&quot;z&quot;</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(combined)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">RISC-V体系结构编程与实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 13:16:24" itemprop="dateModified" datetime="2025-08-08T13:16:24+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/RISC-V/" itemprop="url" rel="index"><span itemprop="name">RISC-V</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="实验环境搭建">实验环境搭建</h2>
<p>在VMware中安装完Ubuntu Linux 20.04
系统后,打开终端,可以通过如下命令安装需要的软件包:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt update -y</span></span><br><span class="line"></span><br><span class="line">[sudo] siyuanlei 的密码： 123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt install net-tools libncurses5-dev libssl-dev build-essential openssl qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu git bison flex bc vim universal-ctags cscope gdb-multiarch libsdl2-dev libreadline-dev</span></span><br></pre></td></tr></table></figure>
<p>我们再克隆GitHub上的<code>runninglinuxkernel/riscv_ programming_ practice</code>仓库到当前目录下,在Linux系统中,使用<code>git clone</code>命令克隆的GitHub仓库默认会保存在当前工作目录下具体位置取决于你执行命令时所在的目录:</p>
<ol type="1">
<li>默认存储位置:如果你没有切换目录就直接执行<code>git clone</code>,仓库会保存在当前用户的主目录(/home/你的用户名/),例如：/home/ubuntu/riscv_programming_practice/</li>
<li>如果你先切换了目录再执行克隆,仓库会保存在你切换后的目录,例如:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp  # 先切换到 /tmp 目录</span><br><span class="line">git clone https://github.com/xxx/yyy.git  # 仓库会保存在 /tmp/yyy/</span><br></pre></td></tr></table></figure>
<p>下面我们进行克隆</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Git</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install git -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆仓库</span></span><br><span class="line">git clone https://github.com/runninglinuxkernel/riscv_programming_practice.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 chapter2</span></span><br><span class="line">cd riscv_programming_practice/chapter2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录内容（验证）</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h3 id="实验2-1输出welcome-to-risc-v">实验2-1:输出”Welcome to
RISC-V!”</h3>
<p>在Linux主机中安装相关工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt-get install qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu build-essential git bison flex libssl-dev</span></span><br></pre></td></tr></table></figure>
<p>下面我们在QEMU上运行BenOS</p>
<p>我们首先在Linux主机上使用make命令编译BenOS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">export</span> board=qemu</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
<p>想要编译可以在QEMU模拟器上运行的可执行二进制文件,需要先设置<code>board=qemu</code>.</p>
<p>直接输入<code>make run</code>命令并运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlk@master:benos$ make run</span><br></pre></td></tr></table></figure>
<p>我们可以看到QEMU输出”Welcome
RISC-V!“.要关闭QEMU,可以按下<code>Ctrl+A</code>键,松开后再快速按下<code>X</code>键.</p>
<h3 id="实验2-2单步调试benos和mysbi">实验2-2:单步调试BenOS和MySBI</h3>
<p>使用<code>make debug</code>命令在终端启动QEMU虚拟机的gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make debug</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用如下命令启动gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-riscv64 -nographic -machine virt -m 128M -bios mysbi.bin -kernel benos.elf -S -s</span></span><br></pre></td></tr></table></figure>
<p>在另一个终端使用如下命令启动GDB工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gdb-multiarch --tui benos.elf</span></span><br></pre></td></tr></table></figure>
<p>在GDB命令行中执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Linux%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Linux%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Linux入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-10 18:50:30" itemprop="dateModified" datetime="2025-08-10T18:50:30+08:00">2025-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作为计算机科学家，我们都知道计算机最擅长帮助我们完成重复性的工作。
但是我们却常常忘记这一点也适用于我们使用计算机的方式，而不仅仅是利用计算机程序去帮我们求解问题。
在从事与计算机相关的工作时，我们有很多触手可及的工具可以帮助我们更高效的解决问题。
但是我们中的大多数人实际上只利用了这些工具中的很少一部分，我们常常只是死记硬背一些如咒语般的命令，
或是当我们卡住的时候，盲目地从网上复制粘贴一些命令。</p>
<p>本课程意在帮你解决这一问题。</p>
<p>我们希望教会您如何挖掘现有工具的潜力，并向您介绍一些新的工具。也许我们还可以促使您想要去探索（甚至是去开发）更多的工具。
我们认为这是大多数计算机科学相关课程中缺少的重要一环。</p>
<h2 id="the-shell">The Shell</h2>
<h3 id="shell-是什么">shell 是什么？</h3>
<p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是
AR/VR 都已经无处不在。 这些交互接口可以覆盖 80%
的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。
为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p>
<p>几乎所有您能够接触到的平台都支持某种形式的
shell，有些甚至还提供了多种 shell
供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p>
<p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。
这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开
shell 提示符（您输入指令的地方），您首先需要打开 终端
。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p>
<h3 id="使用-shell">使用 shell</h3>
<p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$</span><br></pre></td></tr></table></figure>
<p>这是 shell 最主要的文本接口。它告诉你，你的主机名是
<code>missing</code> 并且您当前的工作目录（”current working
directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。
<code>$</code> 符号表示您现在的身份不是 root
用户（稍后会介绍）。在这个提示符中，您可以输入 命令 ，命令最终会被 shell
解析。最简单的命令是执行一个程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$ </span><br></pre></td></tr></table></figure>
<p>这里，我们执行了 <code>date</code>
这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell
等待我们输入其他命令。我们可以在执行命令的同时向程序传递 参数 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数
<code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell
基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为
My Photos
的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号
<code>\</code> 进行处理（<code>My\ Photos</code>）。</p>
<p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或
<code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell
是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在
shell 中执行命令时，您实际上是在执行一段 shell
可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是
shell 所了解的编程关键字，那么它会去咨询 环境变量
<code>$PATH</code>，它会列出当 shell
接到某条指令时，进行程序搜索的路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行
<code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 :
所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是
可执行程序，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用
<code>which</code> 程序。我们也可以绕过
<code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p>
<h3 id="在-shell-中导航">在 shell 中导航</h3>
<p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用
<code>/</code> 分割，而在 Windows 上是 <code>\</code>。路径
<code>/</code>
代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在 Windows
上每个盘都有一个根目录（例如： <code>C:\</code>）。
我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以
<code>/</code> 开头，那么它是一个 绝对路径，其他的都是 相对路径
。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用
<code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code>
命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code>
表示上级目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ cd /home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ pwd</span><br><span class="line">/</span><br><span class="line">missing:/$ cd ./home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd missing</span><br><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ ../../bin/echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell
提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p>
<p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p>
<p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls</span><br><span class="line">missing:~$ cd ..</span><br><span class="line">missing:/home$ ls</span><br><span class="line">missing</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>除非我们利用第一个参数指定目录，否则 <code>ls</code>
会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以
<code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用
<code>-h</code> 或 <code>--help</code>
标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code>
的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l                         use a long listing format</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l /home</span><br><span class="line">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure>
<p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符
<code>d</code> 表示 <code>missing</code>
是一个目录。然后接下来的九个字符，每三个字符构成一组。
（<code>rwx</code>）.
它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>）
以及其他所有人具有的权限。其中 <code>-</code>
表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code>
文件夹
（例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code>
目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code>
权限，也就是说任何人都可以执行这些程序。</p>
<p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如
<code>mv</code>（用于重命名或移动文件）、
<code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p>
<p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试
<code>man</code>
这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用
<code>q</code> 可以退出该程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ man ls</span><br></pre></td></tr></table></figure>
<h3 id="在程序间创建连接">在程序间创建连接</h3>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。
当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。
通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。
但是，我们也可以重定向这些流！</p>
<p>最简单的重定向是 <code>&lt; file</code> 和
<code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（
pipes ），我们能够更好的利用文件重定向。 <code>|</code>
操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure>
<p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p>
<h3 id="一个功能全面又强大的工具">一个功能全面又强大的工具</h3>
<p>对于大多数的类 Unix
系统，有一类用户是非常特殊的，那就是：根用户（root user）。
您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。
通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。
取而代之的是我们会在需要的时候使用 <code>sudo</code>
命令。顾名思义，它的作用是让您可以以 su（super user 或 root
的简写）的身份执行一些操作。 当您遇到拒绝访问（permission
denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p>
<p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code>
文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code>
文件则暴露了一些内核（kernel）参数。
因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。注意
Windows 和 macOS 没有这个文件</p>
<p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code>
文件中，它位于</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/backlight</span><br></pre></td></tr></table></figure>
<p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> find -L /sys/class/backlight -maxdepth 2 -name <span class="string">&#x27;*brightness*&#x27;</span></span></span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /sys/class/backlight/thinkpad_screen</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">echo</span> 3 &gt; brightness</span></span><br><span class="line">An error occurred while redirecting file &#x27;brightness&#x27;</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure>
<p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了
<code>sudo</code> 命令！关于
shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和
<code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。
<code>echo</code> 等程序并不知道 <code>|</code>
的存在，它们只知道从自己的输入输出流中进行读写。
回到上面更改屏幕亮度命令执行的报错，为了能让 <code>sudo echo</code>
命令输出的亮度值写入 <code>brightness</code> 文件， shell
(权限为当前用户) 会先尝试打开 <code>brightness</code> 文件，但此时操作
shell 的不是根（root）用户，所以系统拒绝了这个打开操作，提示无权限。</p>
<p>明白这一点后，我们可以这样操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 | <span class="built_in">sudo</span> <span class="built_in">tee</span> brightness</span></span><br></pre></td></tr></table></figure>
<p>此时打开 <code>/sys</code> 文件的是 <code>tee</code>
这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。
这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种 LED
的状态（路径可能会有所不同）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 1 | <span class="built_in">sudo</span> <span class="built_in">tee</span> /sys/class/leds/input6::scrolllock/brightness</span></span><br></pre></td></tr></table></figure>
<h2 id="shell-工具和脚本">Shell 工具和脚本</h2>
<p>我们将会展示 bash 作为脚本语言的一些基础操作，以及几种最常用的 shell
工具。</p>
<h3 id="shell-脚本">Shell 脚本</h3>
<p>到目前为止，我们已经学习了如何在 shell
中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p>
<p>shell 脚本的复杂性进一步提高。</p>
<p>大多数 shell
都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell
脚本与其他脚本语言不同之处在于，shell 脚本针对 shell
所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是
shell
脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于
bash 脚本，因为它最流行，应用更为广泛。</p>
<p>在 bash 中为变量赋值的语法是
<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。
需要注意的是，<code>foo = bar</code>
（使用空格隔开）是不能正确工作的，因为解释器会调用程序 <code>foo</code>
并将 <code>=</code> 和 <code>bar</code> 作为参数。 总的来说，在 shell
脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆，请务必多加检查。</p>
<p>Bash 中的字符串通过 <code>'</code> 和 <code>"</code>
分隔符来定义，但是它们的含义并不相同。以 <code>'</code>
定义的字符串为原义字符串，其中的变量不会被转义，而 <code>"</code>
定义的字符串会将变量值进行替换。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 bar</span></span><br><span class="line">echo &#x27;$foo&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 <span class="variable">$foo</span></span></span><br></pre></td></tr></table></figure>
<p>和其他大多数的编程语言一样，<code>bash</code> 也支持 <code>if</code>,
<code>case</code>, <code>while</code> 和 <code>for</code>
这些控制流关键字。同样地， <code>bash</code>
也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用
<code>cd</code> 进入该文件夹。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>$1</code>
是脚本的第一个参数。与其他脚本语言不同的是，<code>bash</code>
使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举了其中一些变量，更完整的列表可以参考
这里。</p>
<p><code>$0</code> - 脚本名 <code>$1</code> 到 <code>$9</code> -
脚本的参数。 <code>$1</code> 是第一个参数，依此类推。 <code>$@</code> -
所有参数 <code>$#</code> - 参数个数 <code>$?</code> - 前一个命令的返回值
<code>$$</code> - 当前脚本的进程识别码 <code>!!</code> -
完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用
<code>sudo !!</code> 再尝试一次。 <code>$_</code> -
上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下
<code>Esc</code> 之后键入 . 来获取这个值。</p>
<p>命令通常使用 <code>STDOUT</code> 来返回输出值，使用
<code>STDERR</code>
来返回错误及错误码，便于脚本以更加友好的方式报告错误。
返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值 0
表示正常执行，其他所有非 0 的返回值都表示有错误发生。</p>
<p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和
<code>||</code>（或操作符）使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路
运算符（short-circuiting） 同一行的多个命令可以用 <code>;</code>
分隔。程序 <code>true</code> 的返回码永远是
<code>0</code>，<code>false</code> 的返回码永远是
<code>1</code>。让我们看几个例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false || echo &quot;Oops, fail&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Oops, fail</span></span><br><span class="line"></span><br><span class="line">true || echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">true &amp;&amp; echo &quot;Things went well&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Things went well</span></span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo &quot;Will not be printed&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">false ; echo &quot;This will always run&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This will always run</span></span><br></pre></td></tr></table></figure>
<p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过
命令替换（command substitution）实现。</p>
<p>当您通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code>
这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行
<code>for file in $(ls)</code> ，shell 首先将调用 <code>ls</code>
，然后遍历得到的这些返回值。还有一个冷门的类似特性是 进程替换（process
substitution）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code>
并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code>
替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN
传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code>
会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</p>
<p>说了很多，现在该看例子了，下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用
<code>grep</code> 搜索字符串
<code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # 如果模式没有找到，则grep退出状态为 1</span><br><span class="line">    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在条件语句中，我们比较 <code>$?</code> 是否等于 0。 Bash
实现了许多类似的比较操作，您可以查看 test 手册。 在 bash
中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号
<code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容
<code>sh</code>。</p>
<p>当执行脚本时，我们经常需要提供形式类似的参数。bash
使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为
shell 的 通配（globbing）</p>
<p>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code>
和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件
<code>foo</code>, <code>foo1</code>, <code>foo2</code>,
<code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>
这条命令会删除 <code>foo1</code> 和 <code>foo2</code> ，而
<code>rm foo*</code> 则会删除除了 <code>bar</code> 之外的所有文件。
花括号 <code>&#123;&#125;</code> -
当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会展开为</span></span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以结合通配使用</span></span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会移动所有 *.py 和 *.sh 文件</span></span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面命令会创建 foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h 这些文件</span></span><br><span class="line">touch &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较文件夹 foo 和 bar 中包含文件的不同</span></span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">---</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt; y</span></span><br></pre></td></tr></table></figure>
<p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 shellcheck
这样的工具可以帮助你定位 sh/bash 脚本中的错误。</p>
<p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段
Python 脚本，作用是将输入的参数倒序输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/local/bin/python</span></span><br><span class="line">import sys</span><br><span class="line">for arg in reversed(sys.argv[1:]):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure>
<p>内核知道去用 python 解释器而不是 shell
命令来运行这段脚本，是因为脚本的开头第一行的 shebang。</p>
<p>在 <code>shebang</code> 行中使用 <code>env</code>
命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。env
会利用我们第一节讲座中介绍过的 <code>PATH</code> 环境变量来进行定位。
例如，使用了 <code>env</code> 的 shebang 看上去是这样的
<code>#!/usr/bin/env python</code>。</p>
<p>shell 函数和脚本有如下一些不同点：</p>
<p>函数只能与 shell
使用相同的语言，脚本可以使用任意语言。因此在脚本中包含
<code>shebang</code> 是很重要的。
函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
函数会在当前的 shell
环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用
export 将环境变量导出，并将值传递给环境变量。
与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell
脚本中往往也会包含它们自己的函数定义。</p>
<h3 id="shell-工具">Shell 工具</h3>
<h4 id="查看命令如何使用">查看命令如何使用</h4>
<p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如
<code>ls -l</code>, <code>mv -i</code> 和
<code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？
一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow
出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p>
<p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加
<code>-h</code> 或 <code>--help</code>
标记。另外一个更详细的方法则是使用 <code>man</code>
命令。<code>man</code>
命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>例如，<code>man rm</code> 会输出命令 <code>rm</code>
的说明，同时还有其标记列表，包括之前我们介绍过的 <code>-i</code>。
事实上，目前我们给出的所有命令的说明链接，都是网页版的 Linux
命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过
<code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。
TLDR pages
是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p>
<p>例如，自己就常常在 tldr 上搜索 <code>tar</code> 和
<code>ffmpeg</code> 的用法。</p>
<h4 id="查找文件">查找文件</h4>
<p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类 UNIX
系统都包含一个名为 <code>find</code> 的工具，它是 shell
上用于查找文件的绝佳工具。<code>find</code>
命令会递归地搜索符合条件的文件，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure>
<p>除了列出所寻找的文件之外，<code>find</code>
还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除全部扩展名为.tmp 的文件</span></span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找全部的 PNG 文件并将其转换为 JPG</span></span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure>
<p>尽管 <code>find</code>
用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式
<code>PATTERN</code> 的文件，您需要执行
<code>find -name '*PATTERN*'</code>
(如果您希望模式匹配时是不区分大小写，可以使用 <code>-iname</code>
选项)</p>
<p>您当然可以使用 alias 设置别名来简化上述操作，但 shell
的哲学之一便是寻找（更好用的）替代方案。 记住，shell
最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p>
<p>例如，<code>fd</code>
就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code>
的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持
unicode 并且我认为它的语法更符合直觉。以模式 <code>PATTERN</code>
搜索的语法是 <code>fd PATTERN</code>。</p>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code>
已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <code>locate</code> 了。 <code>locate</code> 使用一个由
<code>updatedb</code> 负责更新的数据库，在大多数系统中
<code>updatedb</code> 都会通过 <code>cron</code>
每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code>
和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>
则只能通过文件名。 这里 有一个更详细的对比。</p>
<h4 id="查找代码">查找代码</h4>
<p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p>
<p>为了实现这一点，很多类 UNIX 的系统都提供了 <code>grep</code>
命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 shell
工具，我们会在后续的数据清理课程中深入的探讨它。</p>
<p><code>grep</code>
有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有
<code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code>
将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说，
<code>grep -C 5</code>
会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code>
会递归地进入子目录并搜索所有的文本文件。</p>
<p>但是，我们有很多办法可以对 <code>grep -R</code>
进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p>
<p>因此也出现了很多它的替代品，包括 ack, ag 和
rg。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep
(<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>
<p>与 <code>find</code>/<code>fd</code>
一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p>
<h4 id="查找-shell-命令">查找 shell 命令</h4>
<p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用 shell
的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p><code>history</code> 命令允许您以程序员的方式来访问 shell
中输入的历史命令。这个命令会在标准输出中打印 shell
中的历史命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给
<code>grep</code> 进行模式搜索。 <code>history | grep find</code>
会打印包含 find 子串的命令。</p>
<p>对于大多数的 shell 来说，您可以使用 <code>Ctrl+R</code>
对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code>
后您可以输入子串来进行匹配，查找历史命令行。</p>
<p>反复按下就会在所有搜索结果中循环。在 zsh
中，使用方向键上或下也可以完成这项工作。</p>
<p><code>Ctrl+R</code> 可以配合 fzf 使用。<code>fzf</code>
是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p>
<p>另外一个和历史命令相关的技巧我喜欢称之为 基于历史的自动补全。
这一特性最初是由 fish shell
创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前的 shell
命令进行补全。这一功能在 zsh
中也可以使用，它可以极大的提高用户体验。</p>
<p>你可以修改 shell history
的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell
记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。
为此你需要在 <code>.bashrc</code> 中添加
<code>HISTCONTROL=ignorespace</code> 或者向 <code>.zshrc</code> 添加
<code>setopt HIST_IGNORE_SPACE</code>。
如果你不小心忘了在前面加空格，可以通过编辑 <code>.bash_history</code> 或
<code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
<h4 id="文件夹导航">文件夹导航</h4>
<p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置
alias，使用 ln -s
创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用
fasd 和 autojump 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 frecency
对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，<code>fasd</code>
使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如，
如果您经常访问 <code>/home/user/files/cool_project</code>
目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于
autojump，则使用 <code>j cool</code> 代替即可。</p>
<p>还有一些更复杂的工具可以用来概览目录结构，例如 <code>tree</code>,
<code>broot</code> 或更加完整的文件管理器，例如 <code>nnn</code> 或
<code>ranger</code>。</p>
<h2 id="编辑器vim">编辑器Vim</h2>
<p>写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具（例如微软的
Word 与 Visual Studio Code）。</p>
<p>作为程序员，我们大部分时间都花在代码编辑上，所以花点时间掌握某个适合自己的编辑器是非常值得的。通常学习使用一个新的编辑器包含以下步骤：</p>
<p>阅读教程（比如这节课以及我们为您提供的资源）
坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）
随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有
如果您能够遵循上述步骤，并且坚持使用新的编辑器完成您所有的文本编辑任务，那么学习一个复杂的代码编辑器的过程一般是这样的：头两个小时，您会学习到编辑器的基本操作，例如打开和编辑文件、保存与退出、浏览缓冲区。当学习时间累计达到
20
个小时之后，您使用新编辑器的效率应该已经和使用老编辑器一样快。在此之后，其益处开始显现：有了足够的知识和肌肉记忆后，使用新编辑器将大大节省你的时间。而现代文本编辑器都是些复杂且强大的工具，永远有新东西可学：学的越多，效率越高。</p>
<h3 id="该学哪个编辑器">该学哪个编辑器？</h3>
<p>程序员们对自己正在使用的文本编辑器通常有着 非常强的执念。</p>
<p>现在最流行的编辑器是什么？Stack Overflow
的调查（这个调查可能并不如我们想象的那样客观，因为 Stack Overflow
的用户并不能代表所有程序员）显示，Visual Studio Code
是目前最流行的代码编辑器。而 Vim 则是最流行的基于命令行的编辑器。</p>
<h4 id="vim">Vim</h4>
<p>这门课的所有教员都使用 Vim 作为编辑器。Vim 有着悠久历史；它始于 1976
年的 Vi 编辑器，到现在还在 不断开发中。Vim
有很多聪明的设计思想，所以很多其他工具也支持 Vim 模式（比如，140
万人安装了 Vim emulation for VS code）。即使你最后使用 其他编辑器，Vim
也值得学习。</p>
<p>由于不可能在 50 分钟内教授 Vim 的所有功能，我们会专注于解释 Vim
的设计哲学，教你基础知识，
并展示一部分高级功能，然后给你掌握这个工具所需要的资源。</p>
<h3 id="vim的哲学">Vim的哲学</h3>
<p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以，Vim
是一个 多模态 编辑 器：它对于插入文字和操纵文字有不同的模式。Vim
是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim
的接口本身也是一个程序语言：键入操作（以及其助记名）
是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim
甚至避免用 上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h3 id="编辑模式">编辑模式</h3>
<p>Vim
的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p>
<p>正常模式：在文件中四处移动光标进行修改 插入模式：插入文本
替换模式：替换文本 可视化模式（一般，行，块）：选中文本块
命令模式：用于执行命令</p>
<p>在不同的操作模式下，键盘敲击的含义也不同。比如，<code>x</code>
在插入模式会插入字母 <code>x</code>，但是在正常模式
会删除当前光标所在的字母，在可视模式下则会删除选中文块。</p>
<p>在默认设置下，Vim 会在左下角显示当前的模式。Vim
启动时的默认模式是正常模式。通常你会把大部分
时间花在正常模式和插入模式。</p>
<p>你可以按下
<code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入
<code>i</code> 进入插入 模式，<code>R</code>
进入替换模式，<code>v</code> 进入可视（一般）模式，<code>V</code>
进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作
<code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<p>因为你会在使用 Vim 时大量使用 <code>&lt;ESC&gt;</code>
键，所以可以考虑把大小写锁定键重定义成 <code>&lt;ESC&gt;</code> 键。</p>
<h3 id="基本操作">基本操作</h3>
<h4 id="插入文本">插入文本</h4>
<p>在正常模式，键入 <code>i</code> 进入插入模式。现在 Vim
跟很多其他的编辑器一样，直到你键入 <code>&lt;ESC&gt;</code>
返回正常模式。你只需要掌握这一点和上面介绍的所有基础知识就可以使用 Vim
来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p>
<h4 id="缓存-标签页-窗口">缓存， 标签页， 窗口</h4>
<p>Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim
会话包含一系列标签页，每个标签页包含
一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是，
缓存和窗口不是一一对应的关系；窗口只是缓冲区的视图。一个缓存可以在 多个
窗口打开，甚至在同一
个标签页内的多个窗口打开。这个功能其实很好用，比如可以查看同一个文件的不同部分。</p>
<p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p>
<h4 id="命令行">命令行</h4>
<p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入
<code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。
这个模式有很多功能，包括打开，保存，关闭文件，以及 退出 Vim。</p>
<p><code>:q</code> 退出（关闭窗口） <code>:w</code> 保存（写）
<code>:wq</code> 保存然后退出 <code>:e &#123;文件名&#125;</code> 打开要编辑的文件
<code>:ls</code> 显示打开的缓存 <code>:help &#123;标题&#125;</code> 打开帮助文档
<code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档
<code>:help w</code> 打开 <code>w</code> 移动的帮助文档</p>
<h3 id="vim-的接口其实是一种编程语言">Vim 的接口其实是一种编程语言</h3>
<p>Vim 最重要的设计思想是 Vim
的界面本身是一个程序语言。键入操作（以及他们的助记名）
本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p>
<h4 id="移动">移动</h4>
<p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim
里面移动也被称为 “名词”， 因为它们指向文字块。</p>
<p>基本移动: <code>hjkl</code> （左， 下， 上， 右） 词： <code>w</code>
（下一个词）， <code>b</code> （词初）， <code>e</code> （词尾） 行：
<code>0</code> （行初）， <code>^</code> （第一个非空格字符），
<code>$</code> （行尾） 屏幕： <code>H</code> （屏幕首行），
<code>M</code> （屏幕中间）， <code>L</code> （屏幕底部） 翻页：
<code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻） 文件：
<code>gg</code> （文件头）， <code>G</code> （文件尾） 行数：
<code>:&#123;行数&#125;&lt;CR&gt;</code> 或者 <code>&#123;行数&#125;G</code> ({行数}为行数)
杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）
查找： <code>f&#123;字符&#125;</code>， <code>t&#123;字符&#125;</code>，
<code>F&#123;字符&#125;</code>， <code>T&#123;字符&#125;</code> 查找/到 向前/向后
在本行的{字符} <code>,</code> / <code>;</code> 用于导航匹配 搜索:
<code>/&#123;正则表达式&#125;</code>, <code>n</code> / <code>N</code>
用于导航匹配</p>
<h4 id="选择">选择</h4>
<p>可视化模式:</p>
<p>可视化：<code>v</code> 可视化行： <code>V</code>
可视化块：<code>Ctrl+v</code></p>
<p>可以用移动命令来选中。</p>
<h4 id="编辑">编辑</h4>
<p>所有你需要用鼠标做的事，
你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim
的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”，
因为动词可以施动于名词。</p>
<p><code>i</code> 进入插入模式 但是对于操纵/编辑文本，不单想用退格键完成
<code>O</code> / <code>o</code> 在之上/之下插入行
<code>d&#123;移动命令&#125;</code> 删除 {移动命令} 例如，<code>dw</code> 删除词,
<code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。
<code>c&#123;移动命令&#125;</code> 改变 {移动命令} 例如，<code>cw</code> 改变词
比如 <code>d&#123;移动命令&#125;</code> 再 <code>i</code> <code>x</code>
删除字符（等同于 <code>dl</code>） <code>s</code> 替换字符（等同于
<code>xi</code>） 可视化模式 + 操作 选中文字, <code>d</code> 删除 或者
<code>c</code> 改变 <code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做
<code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code>
也会复制） <code>p</code> 粘贴 更多值得学习的: 比如 <code>~</code>
改变字符的大小写</p>
<h4 id="计数">计数</h4>
<p>你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。</p>
<p><code>3w</code> 向后移动三个词 <code>5j</code> 向下移动 5 行
<code>7dw</code> 删除 7 个词</p>
<h4 id="修饰语">修饰语</h4>
<p>你可以用修饰语改变“名词”的意义。修饰语有
<code>i</code>，表示“内部”或者“在内”，和 <code>a</code>，
表示“周围”。</p>
<p><code>ci(</code> 改变当前括号内的内容 <code>ci[</code>
改变当前方括号内的内容 <code>da'</code> 删除一个单引号字符串，
包括周围的单引号</p>
<h3 id="演示">演示</h3>
<p>这里是一个有问题的 fizz buzz 实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fizz_buzz(limit):</span><br><span class="line">    for i in range(limit):</span><br><span class="line">        if i % 3 == 0:</span><br><span class="line">            print(&#x27;fizz&#x27;)</span><br><span class="line">        if i % 5 == 0:</span><br><span class="line">            print(&#x27;fizz&#x27;)</span><br><span class="line">        if i % 3 and i % 5:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    fizz_buzz(10)</span><br></pre></td></tr></table></figure>
<p>我们会修复以下问题：</p>
<p>主函数没有被调用 从 0 而不是 1 开始 在 15 的整数倍的时候在不同行打印
“fizz” 和 “buzz” 在 5 的整数倍的时候打印 “fizz” 采用硬编码的参数 10
而不是从命令控制行读取参数</p>
<p>主函数没有被调用 <code>G</code> 文件尾 <code>o</code>
向下打开一个新行 输入 “if name …”</p>
<p>从 0 而不是 1 开始 搜索 <code>/range</code> <code>ww</code>
向后移动两个词 <code>i</code> 插入文字， “1, “ <code>ea</code> 在 limit
后插入， “+1”</p>
<p>在新的一行 “fizzbuzz” <code>jj$i</code> 插入文字到行尾 加入 “,
end=’’” <code>jj.</code> 重复第二个打印 <code>jjo</code> 在 if 打开一行
加入 “else: print()”</p>
<p>fizz fizz <code>ci'</code> 变到 fizz</p>
<p>命令控制行参数 <code>ggO</code> 向上打开 “import sys”
<code>/10</code> <code>ci(</code> to “int(sys.argv[1])”
展示详情请观看课程视频。比较上面用 Vim
的操作和你可能使用其他程序的操作。 值得一提的是 Vim
需要很少的键盘操作，允许你编辑的速度跟上你思维的速度。</p>
<h3 id="自定义-vim">自定义 Vim</h3>
<p>Vim 由一个位于 <code>~/.vimrc</code> 的文本配置文件（包含 Vim
脚本命令）。你可能会启用很多基本 设置。</p>
<p>我们提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为它修复了一些
Vim 默认设置奇怪行为。 在 这儿 下载我们的设置，然后将它保存成
~/.vimrc.</p>
<p>Vim
能够被重度自定义，花时间探索自定义选项是值得的。你可以参考其他人的在
GitHub 上共享的设置文件，比如，你的授课人的 Vim 设置 (Anish, Jon (uses
neovim), Jose)。
有很多好的博客文章也聊到了这个话题。尽量不要复制粘贴别人的整个设置文件，
而是阅读和理解它，然后采用对你有用的部分。</p>
<h3 id="扩展-vim">扩展 Vim</h3>
<p>Vim 有很多扩展插件。跟很多互联网上已经过时的建议相反，你 不 需要在
Vim 使用一个插件 管理器（从 Vim 8.0
开始）。你可以使用内置的插件管理系统。只需要创建一个
<code>~/.vim/pack/vendor/start/</code>
的文件夹，然后把插件放到这里（比如通过 <code>git clone</code>）。</p>
<p>以下是一些我们最爱的插件：</p>
<p>ctrlp.vim: 模糊文件查找 ack.vim: 代码搜索 nerdtree: 文件浏览器
vim-easymotion: 魔术操作</p>
<p>我们尽量避免在这里提供一份冗长的插件列表。你可以查看讲师们的开源的配置文件
(Anish, Jon (使用了 neovim), Jose) 来看看我们使用的其他插件。 浏览 Vim
Awesome 来了解一些很棒的插件。 这个话题也有很多博客文章：搜索 “best Vim
plugins”。</p>
<h3 id="其他程序的-vim-模式">其他程序的 Vim 模式</h3>
<p>很多工具提供了 Vim 模式。这些 Vim
模式的质量参差不齐；取决于具体工具，有的提供了 很多酷炫的 Vim
功能，但是大多数对基本功能支持的很好。</p>
<h4 id="shell">Shell</h4>
<p>如果你是一个 Bash 用户，用 <code>set -o vi</code>。如果你用
Zsh：<code>bindkey -v</code>。Fish 用
<code>fish_vi_key_bindings</code>。另外，不管利用什么 shell，你可以
<code>export EDITOR=vim</code>。
这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。
例如，<code>git</code> 会使用这个编辑器来编辑 commit 信息。</p>
<h4 id="readline">Readline</h4>
<p>很多程序使用 GNU Readline 库来作为 它们的命令控制行界面。Readline
也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code>
添加如下行开启：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure>
<p>比如，在这个设置下，Python REPL 会支持 Vim 快捷键。</p>
<h4 id="其他">其他</h4>
<p>甚至有 Vim 的网页浏览快捷键 browsers, 受欢迎的有 用于 Google Chrome
的 Vimium 和用于 Firefox 的 Tridactyl。 你甚至可以在 Jupyter notebooks
中用 Vim 快捷键。 这个列表 中列举了支持类 vim 键位绑定的软件。</p>
<h3 id="vim-进阶">Vim 进阶</h3>
<p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你，但是你
可以在使用中学习。一个好的对策是: 当你在使用你的编辑器的时候感觉
“一定有更好的方法来做这个”， 那么很可能真的有：上网搜寻一下。</p>
<h4 id="搜索和替换">搜索和替换</h4>
<p><code>:s</code> （替换）命令（文档）。</p>
<p><code>%s/foo/bar/g</code> 在整个文件中将 foo 全局替换成 bar</p>
<p><code>%s/\[.*\](\(.*\))/\1/g</code> 将有命名的 Markdown
链接替换成简单 URLs</p>
<h4 id="多窗口">多窗口</h4>
<p>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口
同一个缓存可以在多个窗口中显示。</p>
<h4 id="宏">宏</h4>
<p><code>q&#123;字符&#125;</code> 来开始在寄存器 <code>&#123;字符&#125;</code> 中录制宏
<code>q</code> 停止录制 <code>@&#123;字符&#125;</code> 重放宏 宏的执行遇错误会停止
<code>&#123;计数&#125;@&#123;字符&#125;</code> 执行一个宏{计数}次 宏可以递归 首先用
<code>q&#123;字符&#125;q</code> 清除宏 录制该宏，用 <code>@&#123;字符&#125;</code>
来递归调用该宏 （在录制完成之前不会有任何操作） 例子：将 xml 转成 json
(file) 一个有 “name” / “email” 键对象的数组 用一个 Python 程序？ 用 sed
/ 正则表达式 <code>g/people/d</code> <code>%s/&lt;person&gt;/&#123;/g</code>
<code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code> … Vim
命令 / 宏 <code>ggdd</code>, <code>Gdd</code> 删除第一行和最后一行
格式化最后一个元素的宏 （寄存器 <code>e</code>） 跳转到有
<code>&lt;name&gt;</code> 的行
<code>qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q</code> 格式化一个
的宏 跳转到有 <code>&lt;person&gt;</code> 的行
<code>qpS&#123;&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS&#125;,&lt;ESC&gt;q</code>
格式化一个 标签然后转到另外一个 的宏 跳转到有
<code>&lt;person&gt;</code> 的行 <code>qq@pjq</code> 执行宏到文件尾
<code>999@q</code> 手动移除最后的 , 然后加上 <code>[</code> 和
<code>]</code> 分隔符</p>
<h2 id="数据整理">数据整理</h2>
<p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式?
肯定有过，对吧！
这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p>
<p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p>
<p>例如这样一条命令
<code>journalctl | grep -i intel</code>，它会找到所有包含
intel（不区分大小写）的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含
intel
的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p>
<p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br></pre></td></tr></table></figure>
<p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl | grep sshd</span><br></pre></td></tr></table></figure>
<p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的
<code>grep</code> 程序！ <code>ssh</code>
太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论
<code>ssh</code>
的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver &#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27; | less</span><br></pre></td></tr></table></figure>
<p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。
<code>less</code>
为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh myserver <span class="string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> &gt; ssh.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ssh.log</span></span><br></pre></td></tr></table></figure>
<p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下
<code>sed</code> 这个非常强大的工具。</p>
<p><code>sed</code> 是一个基于文本编辑器 <code>ed</code> 构建的
“流编辑器” 。在 <code>sed</code>
中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是
<code>s</code>，即 替换 命令，例如我们可以这样写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed &#x27;s/.*Disconnected from //&#x27;</span><br></pre></td></tr></table></figure>
<p>上面这段命令中，我们使用了一段简单的
正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code>
命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中
<code>REGEX</code> 部分是我们需要使用的正则表达式，而
<code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习：
<code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是）
<code>/</code> 开始和结束。大多数的 ASCII
字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的“特殊”含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p>
<p><code>.</code> 除换行符之外的 “任意单个字符” <code>*</code>
匹配前面字符零次或多次 <code>+</code> 匹配前面字符一次或多次
<code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code>
中的任意一个 <code>(RX1|RX2)</code> 任何能够匹配 <code>RX1</code> 或
<code>RX2</code> 的结果 <code>^</code> 行首 <code>$</code> 行尾</p>
<p><code>sed</code>
的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加
<code>\</code> 才能使其具有特殊含义。或者，您也可以添加 <code>-E</code>
选项来支持这些匹配。</p>
<p>回过头我们再看
<code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含
“Disconnected from”
的字符串。这也正是我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将
“Disconnected from” 作为自己的用户名会怎样呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure>
<p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code>
在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure>
<p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给
<code>*</code> 或 <code>+</code> 增加一个 <code>?</code>
后缀使其变成非贪婪模式，但是很可惜 <code>sed</code>
并不支持该后缀。不过，我们可以切换到 perl
的命令行模式，该模式支持编写这样的正则表达式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe &#x27;s/.*?Disconnected from //&#x27;</span><br></pre></td></tr></table></figure>
<p>让我们回到 <code>sed</code>
命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code>
是最常见的工具。<code>sed</code>
还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code>
本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p>
<p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p>
<p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配
一整行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//&#x27;</span><br></pre></td></tr></table></figure>
<p>让我们借助正则表达式在线调试工具 regex debugger
来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的“user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code>
会匹配任意非空且不包含空格的序列）。紧接着后面匹配单“port”和它后面的一串数字，以及可能存在的后缀
<code>[preauth]</code>，最后再匹配行尾。</p>
<p>注意，这样做的话，即使用户名是“Disconnected
from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p>
<p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名
保留 下来。对此，我们可以使用“捕获组（capture
groups）”来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如
<code>\1</code>、 <code>\2</code>、<code>\3</code>
等等，因此可以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></pre></td></tr></table></figure>
<p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章
e-mail address，匹配电子邮箱可一点
也不简单。网络上还有很多关于如何匹配电子邮箱地址的
讨论。人们还为其编写了 测试用例 及
测试矩阵。您甚至可以编写一个用于判断一个数 是否为质数 的正则表达式。</p>
<p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p>
<h3 id="回到数据整理">回到数据整理</h3>
<p>OK，现在我们有如下表达式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br></pre></td></tr></table></figure>
<p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用
<code>i</code> 命令)，打印特定的行 (使用 <code>p</code>
命令)，基于索引选择特定行等等。详情请见 <code>man sed</code>!</p>
<p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br></pre></td></tr></table></figure>
<p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code>
会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br></pre></td></tr></table></figure>
<p><code>sort -n</code>
会按照数字顺序对输入进行排序（默认情况下是按照字典序排序
<code>-k1,1</code>
则表示“仅基于以空格分割的第一列进行排序”。<code>,n</code>
部分表示“仅排序到第 n
个部分”，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p>
<p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code>
来代替 <code>tail</code>。或者使用 <code>sort -r</code>
来进行倒序排序。</p>
<p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | awk &#x27;&#123;print $2&#125;&#x27; | paste -sd,</span><br></pre></td></tr></table></figure>
<p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD
<code>paste</code> 使用。</p>
<p>我们可以利用 <code>paste</code>
命令来合并行(<code>-s</code>)，并指定一个分隔符进行分割
(<code>-d</code>)，那 <code>awk</code> 的作用又是什么呢？</p>
<h3 id="awk-另外一种编辑器">awk – 另外一种编辑器</h3>
<p><code>awk</code>
其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code>
可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p>
<p>首先， <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code>
程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。
在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到
<code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code>
的域分隔符（默认是空格，可以通过 <code>-F</code>
来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p>
<p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以
<code>c</code> 开头，以 <code>e</code>
结尾，并且仅尝试过一次登录的用户。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| awk &#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27; | wc -l</span><br></pre></td></tr></table></figure>
<p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code>
指定了一个匹配模式串（也就是 <code>&#123;...&#125;</code>
前面的那部分内容）。该匹配要求文本的第一部分需要等于 1（这部分刚好是
<code>uniq -c</code>
得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用
<code>wc -l</code> 统计输出结果的行数。</p>
<p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN &#123; rows = 0 &#125;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 == 1 &amp;&amp; <span class="variable">$2</span> ~ /^c[^ ]*e$/ &#123; rows += <span class="variable">$1</span> &#125;</span></span><br><span class="line">END &#123; print rows &#125;</span><br></pre></td></tr></table></figure>
<p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（
<code>END</code>
则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃
<code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以
解决所有问题。至于怎么做，就留给读者们做课后练习吧。</p>
<h3 id="分析数据">分析数据</h3>
<p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| paste -sd+ | bc -l</span><br></pre></td></tr></table></figure>
<p>下面这种更加复杂的表达式也可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;2*($(data | paste -sd+))&quot; | bc -l</span><br></pre></td></tr></table></figure>
<p>您可以通过多种方式获取统计数据。如果已经安装了 R
语言，<code>st</code> 是个不错的选择：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | awk &#x27;&#123;print $1&#125;&#x27; | R --slave -e &#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span><br></pre></td></tr></table></figure>
<p>R 也是一种编程语言，它非常适合被用来进行数据分析和
绘制图表。这里我们不会讲的特别详细， 您只需要知道 <code>summary</code>
可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用
R 语言就可以得到我们想要的统计数据。</p>
<p>如果您希望绘制一些简单的图表， <code>gnuplot</code>
可以帮助到您：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep &quot;Disconnected from&quot;</span><br><span class="line"> | sed -E &#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span><br><span class="line"> | sort | uniq -c</span><br><span class="line"> | sort -nk1,1 | tail -n10</span><br><span class="line"> | gnuplot -p -e &#x27;set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="利用数据整理来确定参数">利用数据整理来确定参数</h3>
<p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合
<code>xargs</code> 即可实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain list | grep nightly | grep -vE &quot;nightly-x86&quot; | sed &#x27;s/-x86.*//&#x27; | xargs rustup toolchain uninstall</span><br></pre></td></tr></table></figure>
<h3 id="整理二进制数据">整理二进制数据</h3>
<p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用
ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过 SSH
将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -</span><br><span class="line"> | convert - -colorspace gray -</span><br><span class="line"> | gzip</span><br><span class="line"> | ssh mymachine &#x27;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="命令行环境">命令行环境</h2>
<p>当您使用 shell
进行工作时，可以使用一些方法改善您的工作流，本节课我们就来讨论这些方法。</p>
<p>我们已经使用 shell
一段时间了，但是到目前为止我们的关注点主要集中在使用不同的命令上面。现在，我们将会学习如何同时执行多个不同的进程并追踪它们的状态、如何停止或暂停某个进程以及如何使进程在后台运行。</p>
<p>我们还将学习一些能够改善您的 shell
及其他工具的工作流的方法，这主要是通过定义别名或基于配置文件对其进行配置来实现的。这些方法都可以帮您节省大量的时间。例如，仅需要执行一些简单的命令，我们就可以在所有的主机上使用相同的配置。我们还会学习如何使用
SSH 操作远端机器。</p>
<h3 id="任务控制">任务控制</h3>
<p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用
<code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用
<code>Ctrl-C</code>
来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p>
<h4 id="结束进程">结束进程</h4>
<p>您的 shell 会使用 UNIX
提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种
软件中断。</p>
<p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个
<code>SIGINT</code> 信号到进程。</p>
<p>下面这个 Python 程序向您展示了捕获信号 <code>SIGINT</code>
并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用
<code>SIGQUIT</code> 信号，通过输入 <code>Ctrl-\</code>
可以发送该信号。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line">import signal, time</span><br><span class="line"></span><br><span class="line">def handler(signum, time):</span><br><span class="line">    print(&quot;\nI got a SIGINT, but I am not stopping&quot;)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    time.sleep(.1)</span><br><span class="line">    print(&quot;\r&#123;&#125;&quot;.format(i), end=&quot;&quot;)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>
<p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次
<code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code>
是我们在终端输入 <code>Ctrl</code> 时的表示形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python sigint.py</span></span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></table></figure>
<p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code>
都常常用来发出和终止程序相关的请求。<code>SIGTERM</code>
则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用
<code>kill</code> 命令, 它的语法是：
<code>kill -TERM &lt;PID&gt;</code>。</p>
<h4 id="暂停和后台执行进程">暂停和后台执行进程</h4>
<p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code>
会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送
<code>SIGTSTP</code> 信号，<code>SIGTSTP</code> 是 Terminal Stop
的缩写（即 <code>terminal</code> 版本的 SIGSTOP）。</p>
<p>我们可以使用 <code>fg</code> 或 <code>bg</code>
命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p>
<p><code>jobs</code>
命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid
引用这些任务（也可以用 <code>pgrep</code> 找出
pid）。更加符合直觉的操作是您可以使用百分号 +
任务编号（<code>jobs</code>
会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用
<code>$!</code> 这一特殊参数。</p>
<p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code>
后缀可以让命令在直接在后台运行，这使得您可以直接在 shell
中继续做其他操作，不过它此时还是会使用 shell
的标准输出，这一点有时会比较恼人（这种情况可以使用 shell
重定向处理）。</p>
<p>让已经在运行的进程转到后台运行，您可以键入 <code>Ctrl-Z</code>
，然后紧接着再输入
<code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号
<code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用
<code>nohup</code>（一个用来忽略 <code>SIGHUP</code>
的封装）来运行程序。针对已经运行的程序，可以使用 <code>disown</code>
。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p>
<p>下面这个简单的会话中展示来了些概念的应用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 1000</span></span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> <span class="built_in">sleep</span> 2000 &amp;</span></span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">bg</span> %1</span></span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -STOP %1</span></span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %1</span></span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -SIGHUP %2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> %2</span></span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">jobs</span></span></span><br></pre></td></tr></table></figure>
<p><code>SIGKILL</code>
是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p>
<p>您可以输入 <code>man signal</code> 或使用 <code>kill -l</code>
来获取更多关于信号的信息。</p>
<h3 id="终端多路复用">终端多路复用</h3>
<p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p>
<p>像 <code>tmux</code>
这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个
shell 会话进行交互。</p>
<p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p>
<p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code>
和其他类似技巧的使用。</p>
<p>现在最流行的终端多路器是 <code>tmux</code>。<code>tmux</code>
是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p>
<p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似
<code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下
<code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code>
中对象的继承结构如下：</p>
<p>会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口</p>
<p><code>tmux</code> 开始一个新的会话 <code>tmux new -s NAME</code>
以指定名称开始一个新的会话 <code>tmux ls</code> 列出当前所有会话 在
<code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离
<code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code>
来指定具体的会话</p>
<p>窗口 -
相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分</p>
<p><code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用
<code>&lt;C-d&gt;</code> 关闭 <code>&lt;C-b&gt; N</code> 跳转到第 N
个窗口，注意每个窗口都是有编号的 <code>&lt;C-b&gt; p</code>
切换到前一个窗口 <code>&lt;C-b&gt; n</code> 切换到下一个窗口
<code>&lt;C-b&gt; ,</code> 重命名当前窗口 <code>&lt;C-b&gt; w</code>
列出当前所有窗口</p>
<p>面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个
shell</p>
<p><code>&lt;C-b&gt; "</code> 水平分割 <code>&lt;C-b&gt; %</code>
垂直分割 <code>&lt;C-b&gt; &lt;方向&gt;</code>
切换到指定方向的面板，<方向> 指的是键盘上的方向键
<code>&lt;C-b&gt; z</code> 切换当前面板的缩放 <code>&lt;C-b&gt; [</code>
开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分
<code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</p>
<h3 id="别名">别名</h3>
<p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell
都支持设置别名。shell 的别名相当于一个长命令的缩写，shell
会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias alias_name=&quot;command_to_alias arg1 arg2&quot;</span><br></pre></td></tr></table></figure>
<p>注意， <code>=</code> 两边是没有空格的，因为 <code>alias</code>
是一个 shell 命令，它只接受一个参数。</p>
<p>别名有许多很方便的特性:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建常用命令的缩写</span></span><br><span class="line">alias ll=&quot;ls -lh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">能够少输入很多</span></span><br><span class="line">alias gs=&quot;git status&quot;</span><br><span class="line">alias gc=&quot;git commit&quot;</span><br><span class="line">alias v=&quot;vim&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手误打错命令也没关系</span></span><br><span class="line">alias sl=ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新定义一些命令行的默认行为</span></span><br><span class="line">alias mv=&quot;mv -i&quot;           # -i prompts before overwrite</span><br><span class="line">alias mkdir=&quot;mkdir -p&quot;     # -p make parent dirs as needed</span><br><span class="line">alias df=&quot;df -h&quot;           # -h prints human readable format</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">别名可以组合使用</span></span><br><span class="line">alias la=&quot;ls -A&quot;</span><br><span class="line">alias lla=&quot;la -l&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在忽略某个别名</span></span><br><span class="line">\ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者禁用别名</span></span><br><span class="line">unalias la</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取别名的定义</span></span><br><span class="line">alias ll</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会打印 ll=<span class="string">&#x27;ls -lh&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，在默认情况下 shell
并不会保存别名。为了让别名持续生效，您需要将配置放进 shell
的启动文件里，像是 <code>.bashrc</code> 或
<code>.zshrc</code>，下一节我们就会讲到。</p>
<h3 id="配置文件dotfiles">配置文件（Dotfiles）</h3>
<p>很多程序的配置都是通过纯文本格式的被称作 点文件
的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 . 开头，例如
<code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code>
并不会显示它们）。</p>
<p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell
程序会读取很多文件以加载其配置项。根据 shell
本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。</p>
<p>对于 <code>bash</code> 来说，在大多数系统下，您可以通过编辑
<code>.bashrc</code> 或 <code>.bash_profile</code>
来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p>
<p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似
<code>export PATH="$PATH:/path/to/program/bin"</code>
的命令，这样才能确保这些程序能够被 shell 找到。</p>
<p>还有一些其他的工具也可以通过 点文件 进行配置：</p>
<p><code>bash</code> - <code>~/.bashrc, ~/.bash_profile</code>
<code>git</code> - <code>~/.gitconfig</code> <code>vim</code> -
<code>~/.vimrc</code> 和 <code>~/.vim</code> 目录 <code>ssh</code> -
<code>~/.ssh/config</code> <code>tmux</code> -
<code>~/.tmux.conf</code></p>
<p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其
符号链接 到需要的地方。这么做有如下好处：</p>
<p>安装简单:
如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；
可移植性: 您的工具在任何地方都以相同的配置工作 同步:
在一处更新配置文件，可以同步到其他所有地方 变更追踪:
您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的
配置文件中需要放些什么？您可以通过在线文档和 帮助手册
了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的
dotfiles 仓库 —— 其中最受欢迎的那些可以在 这里
找到（我们建议您不要直接复制别人的配置）。这里
也有一些非常有用的资源。</p>
<p>本课程的老师们也在 GitHub 上开源了他们的配置文件： Anish, Jon,
Jose.</p>
<h4 id="可移植性">可移植性</h4>
<p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者
shell
是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p>
<p>有一些技巧可以轻松达成这些目的。如果配置文件 if
语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell
可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用和 shell 相关的配置时先检查当前 shell 类型</span></span><br><span class="line">if [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then &#123;do_something&#125;; fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">您也可以针对特定的设备进行配置</span></span><br><span class="line">if [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then &#123;do_something&#125;; fi</span><br></pre></td></tr></table></figure>
<p>如果配置文件支持 include
功能，您也可以多加利用。例如：<code>~/.gitconfig</code>
可以这样编写：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure>
<p>然后我们可以在日常使用的设备上创建配置文件
<code>~/.gitconfig_local</code>
来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p>
<p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在
<code>bash</code> 和 <code>zsh</code>
中同时启用一些别名，您可以把它们写在 <code>.aliases</code>
里，然后在这两个 shell 里应用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test <span class="keyword">if</span> ~/.aliases exists and <span class="built_in">source</span> it</span></span><br><span class="line">if [ -f ~/.aliases ]; then</span><br><span class="line">    source ~/.aliases</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="远端设备">远端设备</h3>
<p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全
shell（SSH）。和其他工具一样，SSH
也是可以高度定制的，也值得我们花时间学习它。</p>
<p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure>
<p>这里我们尝试以用户名 <code>foo</code> 登录服务器
<code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如
<code>bar.mit.edu</code>），也可以使用 IP 指定（例如
<code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh
配置文件使我们可以用类似 <code>ssh bar</code>
这样的命令来登录服务器。</p>
<h4 id="执行命令">执行命令</h4>
<p><code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。
<code>ssh foobar@server ls</code> 可以直接在用 foobar 的命令下执行
<code>ls</code> 命令。 想要配合管道来使用也可以，
<code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端
<code>ls</code> 的输出而
<code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地
<code>ls</code> 输出的结果进行查询。</p>
<h4 id="ssh-密钥">SSH 密钥</h4>
<p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是
<code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>)
等效于您的密码，所以一定要好好保存它。</p>
<h4 id="密钥生成">密钥生成</h4>
<p>使用 <code>ssh-keygen</code> 命令可以生成一对密钥：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>
<p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用
<code>ssh-agent</code> 或 <code>gpg-agent</code>
，这样就不需要每次都输入该密码了。</p>
<p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了 这里
介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行
<code>ssh-keygen -y -f /path/to/key</code>.</p>
<h4 id="基于密钥的认证机制">基于密钥的认证机制</h4>
<p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code>
来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh/id_ed25519.pub | ssh foobar@remote &#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span><br></pre></td></tr></table></figure>
<p>如果支持 <code>ssh-copy-id</code>
的话，可以使用下面这种更简单的解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure>
<h4 id="通过-ssh-复制文件">通过 SSH 复制文件</h4>
<p>使用 ssh 复制文件有很多方法：</p>
<p><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code>
命令，然后通过这样的方法利用标准输入实现
<code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<code>tee</code>
命令会将标准输出写入到一个文件； <code>scp</code>
：当需要拷贝大量的文件或目录时，使用 <code>scp</code>
命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；
<code>rsync</code> 对 <code>scp</code>
进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于
<code>--partial</code> 标记实现断点续传。<code>rsync</code> 的语法和
<code>scp</code> 类似；</p>
<h4 id="端口转发">端口转发</h4>
<p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用
<code>localhost:PORT</code> 或
<code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p>
<p>此时就需要进行
端口转发。端口转发有两种，一种是本地端口转发和远程端口转发</p>
<p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行
Jupyter notebook 并监听 <code>8888</code> 端口。 然后，建立从本地端口
<code>9999</code> 的转发，使用
<code>ssh -L 9999:localhost:8888 foobar@remote_server</code>
。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p>
<h4 id="ssh-配置">SSH 配置</h4>
<p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias my_server=&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span><br></pre></td></tr></table></figure>
<p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在配置文件中也可以使用通配符</span></span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></table></figure>
<p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似
<code>scp</code>、<code>rsync</code> 和 <code>mosh</code>
的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p>
<p>注意，<code>~/.ssh/config</code>
文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p>
<p>服务器侧的配置通常放在
<code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh
端口、开启 X11 转发等等。 您也可以为每个用户单独指定配置。</p>
<h4 id="杂项">杂项</h4>
<p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。Mosh（即
mobile shell ）对 ssh
进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p>
<p>有时将一个远端文件夹挂载到本地会比较方便， sshfs
可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p>
<h3 id="shell-框架">Shell &amp; 框架</h3>
<p>在 shell 工具和脚本那节课中我们已经介绍了 <code>bash</code>
shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认
shell。但是，它并不是唯一的选项。</p>
<p>例如，<code>zsh</code> shell 是 bash
的超集并提供了一些方便的功能：</p>
<p>智能替换, <code>**</code> 行内替换/通配符扩展 拼写纠错 更好的 tab
补全和选择 路径展开 (<code>cd /u/lo/b</code> 会被展开为
<code>/usr/local/bin</code>)</p>
<p>框架 也可以改进您的 shell。比较流行的通用框架包括 prezto 或
oh-my-zsh。还有一些更精简的框架，它们往往专注于某一个特定功能，例如 zsh
语法高亮 或 zsh 历史子串查询。 像 fish 这样的 shell
包含了很多用户友好的功能，其中一些特性包括：</p>
<p>向右对齐 命令语法高亮 历史子串查询 基于手册页面的选项补全
更智能的自动补全 提示符主题</p>
<p>需要注意的是，使用这些框架可能会降低您 shell
的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。</p>
<h3 id="终端模拟器">终端模拟器</h3>
<p>和自定义 shell 一样，花点时间选择适合您的 终端模拟器
并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间
比较 的信息）</p>
<p>您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：</p>
<p>字体选择 彩色主题 快捷键 标签页/面板支持 回退配置 性能（像 Alacritty
或者 kitty 这种比较新的终端，它们支持 GPU 加速）。</p>
<h2 id="版本控制git">版本控制(Git)</h2>
<p>版本控制系统 (VCSs)
是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS
通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了顶级目录中所有的文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p>
<p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p>
<p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p>
<p>当前模块是谁编写的？
这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？
最近的 1000 个版本中，何时/为什么导致了单元测试失败？
尽管版本控制系统有很多， 其事实上的标准则是 Git 。</p>
<p>因为 Git 接口的抽象泄漏（leaky
abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git
可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p>
<p>尽管 Git
的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍
Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git
的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p>
<h3 id="git-的数据模型">Git 的数据模型</h3>
<p>进行版本控制的方法很多。Git
拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p>
<h4 id="快照">快照</h4>
<p>Git
将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在
Git 的术语里，文件被称作 Blob
对象（数据对象），也就是一组数据。目录则被称之为“树”，它将名字与 Blob
对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure>
<p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个
blob 对象 “bar.txt”），以及一个 blob 对象 “baz.txt”。</p>
<h4 id="历史记录建模关联快照">历史记录建模：关联快照</h4>
<p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过出于种种原因，Git
并没有采用这样的模型。</p>
<p>在 Git
中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表
Git
中的每个快照都有一系列的“父辈”，也就是其之前的一系列快照。注意，快照具有多个“父辈”而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p>
<p>在 Git
中，这些快照被称为“提交”。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^</span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>
<p>上面是一个 ASCII 码构成的简图，其中的 o 表示一次提交（快照）。</p>
<p>箭头指向了当前提交的父辈（这是一种“在…之前”，而不是“在…之后”的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;----  o </span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure>
<p>Git
中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p>
<h4 id="数据模型及其伪代码表示">数据模型及其伪代码表示</h4>
<p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parents: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种简洁的历史模型。</p>
<h4 id="对象和内存寻址">对象和内存寻址</h4>
<p>Git 中的对象可以是 blob、树或提交：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure>
<p>Git 在储存数据时，所有的对象都会基于它们的 SHA-1 哈希 进行寻址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store(object):</span><br><span class="line">    id = sha1(object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load(id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure>
<p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p>
<p>例如，上面 例子中的树（可以通过
<code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code>
来进行可视化），看上去是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure>
<p>树本身会包含一些指向其他内容的指针，例如 <code>baz.txt (blob)</code>
和 <code>foo</code> (树)。如果我们用
<code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看
baz.txt 的内容，会得到以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure>
<h4 id="引用">引用</h4>
<p>现在，所有的快照都可以通过它们的 SHA-1
哈希值来标记了。但这也太不方便了，谁也记不住一串 40
位的十六进制字符。</p>
<p>针对这一问题，Git
的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code>
引用通常会指向主分支的最新一次提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference(name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference(name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference(name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load(references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load(name_or_id)</span><br></pre></td></tr></table></figure>
<p>这样，Git 就可以使用诸如 “master”
这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p>
<p>有一个细节需要我们注意，
通常情况下，我们会想要知道“我们当前所在位置”，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的“父辈”）。在
Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p>
<h4 id="仓库">仓库</h4>
<p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和
<code>引用</code>。</p>
<p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的
<code>git</code>
命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p>
<p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如“丢弃未提交的修改和将
‘master’ 引用指向提交 <code>5d83f9e</code>
时，有什么命令可以完成该操作（针对这个具体问题，您可以使用
<code>git checkout master; git reset --hard 5d83f9e</code>）</p>
<h3 id="暂存区">暂存区</h3>
<p>Git
中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p>
<p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “创建快照”
的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但
Git
不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复
bug 相关的代码而丢弃所有的打印语句。</p>
<p>Git 处理这些场景的方法是使用一种叫做 “暂存区（staging
area）”的机制，它允许您指定下次快照中要包括那些改动。</p>
<h3 id="git-的命令行接口">Git 的命令行接口</h3>
<p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 Pro
Git 中文版 或可以观看本讲座的视频来学习。</p>
<h4 id="基础">基础</h4>
<p><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息
<code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为
<code>.git</code> 的目录下 <code>git status</code>: 显示当前的仓库状态
<code>git add &lt;filename&gt;</code>: 添加文件到暂存区
<code>git commit</code>: 创建一个新的提交 如何编写 良好的提交信息!
为何要 编写良好的提交信息 <code>git log</code>: 显示历史日志
<code>git log --all --graph --decorate</code>:
可视化历史记录（有向无环图） <code>git diff &lt;filename&gt;</code>:
显示与暂存区文件的差异
<code>git diff &lt;revision&gt; &lt;filename&gt;</code>:
显示某个文件两个版本之间的差异
<code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</p>
<h4 id="分支和合并">分支和合并</h4>
<p><code>git branch</code>: 显示分支
<code>git branch &lt;name&gt;</code>: 创建分支
<code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支 相当于
<code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code>
<code>git merge &lt;revision&gt;</code>: 合并到当前分支
<code>git mergetool</code>: 使用工具来处理合并冲突
<code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</p>
<h4 id="远端操作">远端操作</h4>
<p><code>git remote</code>: 列出远端
<code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端
<code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>:
将对象传送至远端并更新远端引用
<code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>:
创建本地和远端分支的关联关系 <code>git fetch</code>: 从远端获取对象/索引
<code>git pull</code>: 相当于 <code>git fetch; git merge</code>
<code>git clone</code>: 从远端下载仓库</p>
<h4 id="撤销">撤销</h4>
<p><code>git commit --amend</code>: 编辑提交的内容或信息
<code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件
<code>git checkout -- &lt;file&gt;</code>: 丢弃修改
<code>git restore</code>: git2.32 版本后取代 git reset
进行许多撤销操作</p>
<h3 id="git-高级操作">Git 高级操作</h3>
<p><code>git config</code>: Git 是一个 高度可定制的 工具
<code>git clone --depth=1</code>: 浅克隆（shallow
clone），不包括完整的版本历史信息 <code>git add -p</code>: 交互式暂存
<code>git rebase -i</code>: 交互式变基 <code>git blame</code>:
查看最后修改某行的人 <code>git stash</code>:
暂时移除工作目录下的修改内容 <code>git bisect</code>:
通过二分查找搜索历史记录 <code>.gitignore</code>: 指定
故意不追踪的文件</p>
<h3 id="杂项-1">杂项</h3>
<p>图形用户界面: Git 的 图形用户界面客户端
有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口
Shell 集成: 将 Git 状态集成到您的 shell 中会非常方便。(zsh, bash)。Oh My
Zsh 这样的框架中一般已经集成了这一功能 编辑器集成: 和上面一条类似，将
Git 集成到编辑器中好处多多。fugitive.vim 是 Vim 中集成 Git 的常用插件
工作流:
我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例
( 有 很多 不同的 处理方法) GitHub: Git 并不等同于 GitHub。 在 GitHub
中您需要使用一个被称作 拉取请求（pull request）
的方法来向其他项目贡献代码 其他 Git 提供商: GitHub 并不是唯一的。还有像
GitLab 和 BitBucket 这样的平台。</p>
<h2 id="调试及性能分析">调试及性能分析</h2>
<p>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。</p>
<p>让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的
bug 和程序性能问题。</p>
<h3 id="调试代码">调试代码</h3>
<h4 id="打印调试法与日志">打印调试法与日志</h4>
<p>“最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句” — Brian
Kernighan, Unix 新手入门。</p>
<p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p>
<p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p>
<p>您可以将日志写入文件、socket
或者甚至是发送到远端服务器而不仅仅是标准输出；
日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR
等），这使您可以根据需要过滤日志；
对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。
这里 是一个包含日志的例程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Raw output as with just prints</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py <span class="built_in">log</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log formatted output</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py <span class="built_in">log</span> ERROR</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Print only ERROR levels and above</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python logger.py color</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Color formatted output</span></span><br></pre></td></tr></table></figure>
<p>有很多技巧可以使日志的可读性变得更好，我最喜欢的一个是技巧是对其进行着色。到目前为止，您应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p>
<p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 ANSI escape
codes，它是一系列的特殊字符，可以使您的 shell
改变输出结果的颜色。例如，执行
<code>echo -e "\e[38;2;255;0;0mThis is red\e[0m"</code>
会打印红色的字符串：<code>This is red</code> 。只要您的终端支持
真彩色。如果您的终端不支持真彩色（例如 MacOS 的
Terminal.app），您可以使用支持更加广泛的 16
色，例如：<code>”\e[31; 1mThis is red\e[0m “</code>。</p>
<p>下面这个脚本向您展示了如何在终端中打印多种颜色（只要您的终端支持真彩色）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line">for R in $(seq 0 20 255); do</span><br><span class="line">    for G in $(seq 0 20 255); do</span><br><span class="line">        for B in $(seq 0 20 255); do</span><br><span class="line">            printf &quot;\e[38;2;$&#123;R&#125;;$&#123;G&#125;;$&#123;B&#125;m█\e[0m&quot;;</span><br><span class="line">        done</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="第三方日志系统">第三方日志系统</h4>
<p>如果您正在构建大型软件系统，您很可能会使用到一些依赖，有些依赖会作为程序单独运行。如
Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p>
<p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p>
<p>幸运的是，大多数的程序都会将日志保存在您的系统中的某个地方。对于 UNIX
系统来说，程序的日志通常存放在 <code>/var/log</code>。例如， NGINX web
服务器就将其日志存放于 <code>/var/log/nginx</code>。</p>
<p>目前，系统开始使用 system
log，您所有的日志都会保存在这里。大多数（但不是全部的）Linux
系统都会使用
<code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code>
会将日志以某种特殊格式存放于 <code>/var/log/journal</code>，您可以使用
<code>journalctl</code> 命令显示这些消息。</p>
<p>类似地，在 macOS 系统中是
<code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用
<code>log show</code> 显示。</p>
<p>对于大多数的 UNIX 系统，您也可以使用 <code>dmesg</code>
命令来读取内核的日志。</p>
<p>如果您希望将日志加入到系统日志中，您可以使用 <code>logger</code> 这个
shell 程序。下面这个例子显示了如何使用 <code>logger</code>
并且如何找到能够将其存入系统日志的条目。</p>
<p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger &quot;Hello Logs&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On macOS</span></span><br><span class="line">log show --last 1m | grep Hello</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On Linux</span></span><br><span class="line">journalctl --since &quot;1m ago&quot; | grep Hello</span><br></pre></td></tr></table></figure>
<p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p>
<p>如果您发现您需要对 <code>journalctl</code> 和 <code>log show</code>
的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像
<code>lnav</code>
这样的工具，它为日志文件提供了更好的展现和浏览方式。</p>
<h4 id="调试器">调试器</h4>
<p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p>
<p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p>
<p>当到达某一行时将程序暂停； 一次一条指令地逐步执行程序；
程序崩溃后查看变量的值； 满足特定条件时暂停程序； 其他高级功能。</p>
<p>很多编程语言都有自己的调试器。Python 的调试器是 <code>pdb</code>.</p>
<p>下面对 <code>pdb</code> 支持的命令进行简单的介绍：</p>
<p>l(ist) - 显示当前行附近的 11 行或继续执行之前的显示； s(tep) -
执行当前行，并在第一个可能的地方停止； n(ext) -
继续执行直到当前函数的下一条语句或者 return 语句； b(reak) -
设置断点（基于传入的参数）； p(rint) -
在当前上下文对表达式求值并打印结果。还有一个命令是 pp ，它使用
<code>pprint</code> 打印； r(eturn) - 继续执行直到当前函数返回； q(uit)
- 退出调试器。</p>
<p>让我们使用 <code>pdb</code> 来修复下面的 Python
代码（参考讲座视频）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(arr):</span><br><span class="line">    n = len(arr)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if arr[j] &gt; arr[j+1]:</span><br><span class="line">                arr[j] = arr[j+1]</span><br><span class="line">                arr[j+1] = arr[j]</span><br><span class="line">    return arr</span><br><span class="line"></span><br><span class="line">print(bubble_sort([4, 2, 1, 8, 7, 6]))</span><br></pre></td></tr></table></figure>
<p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code>
shell 执行命令。 <code>ipdb</code> 是一种增强型的 <code>pdb</code>
，它使用 <code>IPython</code> 作为 REPL 并开启了 tab
补全、语法高亮、更好的回溯和更好的内省，同时还保留了 <code>pdb</code>
模块相同的接口。</p>
<p>对于更底层的编程语言，您可能需要了解一下 <code>gdb</code> (
以及它的改进版 <code>pwndbg</code>) 和 <code>lldb</code>。</p>
<p>它们都对类 C
语言的调试进行了优化，它允许您探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p>
<h4 id="专门工具">专门工具</h4>
<p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用
系统调用。有一些命令可以帮助您追踪您的程序执行的系统调用。在 Linux
中可以使用 <code>strace</code> ，在 macOS 和 BSD 中可以使用
<code>dtrace</code>。<code>dtrace</code>
用起来可能有些别扭，因为它使用的是它自有的 D
语言，但是我们可以使用一个叫做 <code>dtruss</code> 的封装使其具有和
<code>strace</code> 类似的接口</p>
<p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code>
来显示 <code>ls</code> 执行时，对 <code>stat</code>
系统调用进行追踪对结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On Linux</span></span><br><span class="line">sudo strace -e lstat ls -l &gt; /dev/null</span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On macOS</span></span><br><span class="line">sudo dtruss -t lstat64_extended ls -l &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>有些情况下，我们需要查看网络数据包才能定位问题。像
<code>tcpdump</code> 和 Wireshark
这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。</p>
<p>对于 web 开发， Chrome/Firefox
的开发者工具非常方便，功能也很强大：</p>
<p>源码 -查看任意站点的 HTML/CSS/JS 源码； 实时地修改 HTML, CSS, JS 代码
-
修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）；
Javascript shell - 在 JS REPL 中执行命令； 网络 - 分析请求的时间线；
存储 - 查看 Cookies 和本地应用存储。</p>
<h4 id="静态分析">静态分析</h4>
<p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。
这种情况下 静态分析
工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p>
<p>下面这段 Python 代码中存在几个问题。 首先，我们的循环变量
<code>foo</code> 覆盖了之前定义的函数
<code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了
<code>baz</code>，因此当程序完成 <code>sleep</code>
(一分钟)后，执行到这一行的时候便会崩溃。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> foo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(foo)</span><br><span class="line">bar = <span class="number">1</span></span><br><span class="line">bar *= <span class="number">0.2</span></span><br><span class="line">time.sleep(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(baz)</span><br></pre></td></tr></table></figure>
<p>静态分析工具可以发现此类的问题。当我们使用 <code>pyflakes</code>
分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<code>mypy</code>
则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code>
会经过我们 <code>bar</code> 起初是一个 <code>int</code> ，然后变成了
<code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyflakes foobar.py</span></span><br><span class="line">foobar.py:6: redefinition of unused &#x27;foo&#x27; from line 3</span><br><span class="line">foobar.py:11: undefined name &#x27;baz&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mypy foobar.py</span></span><br><span class="line">foobar.py:6: error: Incompatible types in assignment (expression has type &quot;int&quot;, variable has type &quot;Callable[[], Any]&quot;)</span><br><span class="line">foobar.py:9: error: Incompatible types in assignment (expression has type &quot;float&quot;, variable has type &quot;int&quot;)</span><br><span class="line">foobar.py:11: error: Name &#x27;baz&#x27; is not defined</span><br><span class="line">Found 3 errors in 1 file (checked 1 source file)</span><br></pre></td></tr></table></figure>
<p>在 shell 工具那一节课的时候，我们介绍了
<code>shellcheck</code>，这是一个类似的工具，但它是应用于 shell
脚本的。</p>
<p>大多数的编辑器和 IDE
都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。
这个过程通常称为 code linting
。风格检查或安全检查的结果同样也可以进行相应的显示。</p>
<p>在 vim 中，有 <code>ale</code> 或 <code>syntastic</code>
可以帮助您做同样的事情。 在 Python 中， <code>pylint</code> 和
<code>pep8</code> 是两种用于进行风格检查的工具，而 <code>bandit</code>
工具则用于检查安全相关的问题。</p>
<p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：Awesome
Static Analysis (您也许会对 Writing 一节感兴趣) 。对于 linters
则可以参考这个列表： Awesome Linters。</p>
<p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python
的 <code>black</code>、用于 Go 语言的 <code>gofmt</code>、用于 Rust 的
<code>rustfmt</code> 或是用于 JavaScript, HTML 和 CSS 的
<code>prettier</code>
。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。
尽管您可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读您的代码，也可以方便您阅读它的代码。</p>
<h3 id="性能分析">性能分析</h3>
<p>即使您的代码能够像您期望的一样运行，但是如果它消耗了您全部的 CPU
和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大 O
标记法，但却没教给我们如何找到程序中的热点。 鉴于
过早的优化是万恶之源，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。</p>
<h4 id="计时">计时</h4>
<p>和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了
Python 的 <code>time</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure>
<p>不过，执行时间（wall clock
time）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。
对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间 +
系统时间代表了您的进程所消耗的实际 CPU （更详细的解释可以参照
这篇文章）。</p>
<p>真实时间 Real -
从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待
I/O 或网络）； 用户时间 User - CPU 执行用户代码所花费的时间； 系统时间
Sys - CPU 执行系统内核代码所花费的时间。</p>
<p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加
<code>time</code>
前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 2s
多才完成，但是进程仅花费了 15ms 的 CPU 用户时间和 12ms 的 CPU
内核时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> curl https://missing.csail.mit.edu &amp;&gt; /dev/null</span></span><br><span class="line">real    0m2.561s</span><br><span class="line">user    0m0.015s</span><br><span class="line">sys     0m0.012s</span><br></pre></td></tr></table></figure>
<h4 id="性能分析工具profilers">性能分析工具（profilers）</h4>
<h5 id="cpu">CPU</h5>
<p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU
性能分析工具。 CPU 性能分析工具有两种：
追踪分析器（tracing）及采样分析器（sampling）。 追踪分析器
会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考
这篇 介绍性的文章。</p>
<p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在
IDE 中，但是本节课我们会专注于这些命令行工具本身。</p>
<p>在 Python 中，我们使用 <code>cProfile</code>
模块来分析每次函数调用所消耗的时间。
在下面的例子中，我们实现了一个基础的 <code>grep</code> 命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern, file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(file)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f.readlines()):</span><br><span class="line">            pattern = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">            <span class="keyword">match</span> = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, line), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    times = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    pattern = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">            grep(pattern, file)</span><br></pre></td></tr></table></figure>
<p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO
消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到
for 循环外面来改进性能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -m cProfile -s tottime grep.py 1000 <span class="string">&#x27;^(import|\s*def)[^,]*$&#x27;</span> *.py</span></span><br><span class="line"></span><br><span class="line">[omitted program output]</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">   8000    0.266    0.000    0.292    0.000 &#123;built-in method io.open&#125;</span><br><span class="line">   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)</span><br><span class="line">  17000    0.101    0.000    0.101    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">   8000    0.100    0.000    0.129    0.000 &#123;method &#x27;readlines&#x27; of &#x27;_io._IOBase&#x27; objects&#125;</span><br><span class="line">  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)</span><br><span class="line">  93000    0.069    0.000    0.069    0.000 &#123;method &#x27;search&#x27; of &#x27;_sre.SRE_Pattern&#x27; objects&#125;</span><br><span class="line">  93000    0.030    0.000    0.141    0.000 re.py:231(compile)</span><br><span class="line">  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)</span><br><span class="line">      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)</span><br><span class="line"></span><br><span class="line">[omitted lines]</span><br></pre></td></tr></table></figure>
<p>关于 Python 的 <code>cProfile</code>
分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p>
<p>更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是
行分析器 的工作。例如，下面这段 Python
代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部
URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个装饰器会告诉行分析器 </span></span><br><span class="line"><span class="comment"># 我们想要分析这个函数</span></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_urls</span>():</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line">    s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_urls()</span><br></pre></td></tr></table></figure>
<p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过
2500
行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用
<code>line_profiler</code>，它会基于行来显示时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kernprof -l -v a.py</span></span><br><span class="line">Wrote profile results to urls.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 0.636188 s</span><br><span class="line">File: a.py</span><br><span class="line">Function: get_urls at line 5</span><br><span class="line"></span><br><span class="line">Line #  Hits         Time  Per Hit   % Time  Line Contents</span><br><span class="line">==============================================================</span><br><span class="line"> 5                                           @profile</span><br><span class="line"> 6                                           def get_urls():</span><br><span class="line"> 7         1     613909.0 613909.0     96.5      response = requests.get(&#x27;https://missing.csail.mit.edu&#x27;)</span><br><span class="line"> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, &#x27;lxml&#x27;)</span><br><span class="line"> 9         1          2.0      2.0      0.0      urls = []</span><br><span class="line">10        25        685.0     27.4      0.1      for url in s.find_all(&#x27;a&#x27;):</span><br><span class="line">11        24         33.0      1.4      0.0          urls.append(url[&#x27;href&#x27;])</span><br></pre></td></tr></table></figure>
<h5 id="内存">内存</h5>
<p>像 C 或者 C++
这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的
Bug，我们可以使用类似 Valgrind 这样的工具来检查内存泄漏问题。</p>
<p>对于 Python
这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p>
<p>下面这个例子及其输出，展示了 memory-profiler
是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -m memory_profiler example.py</span></span><br><span class="line">Line #    Mem usage  Increment   Line Contents</span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       return a</span><br></pre></td></tr></table></figure>
<h5 id="事件分析">事件分析</h5>
<p>在我们使用 <code>strace</code>
调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<code>perf</code>
命令将 CPU
的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p>
<p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache
locality）、大量的页错误（page
faults）或活锁（livelocks）。下面是关于常见命令的简介：</p>
<p><code>perf list</code> - 列出可以被 pref 追踪的事件；
<code>perf stat COMMAND ARG1 ARG2</code> -
收集与某个进程或指令相关的事件；
<code>perf record COMMAND ARG1 ARG2</code> -
记录命令执行的采样信息并将统计数据储存在 <code>perf.data</code> 中；
<code>perf report</code> - 格式化并打印 <code>perf.data</code>
中的数据。</p>
<h5 id="可视化">可视化</h5>
<p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p>
<p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是
火焰图，火焰图会在 Y 轴显示函数调用关系，并在 X
轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪。</p>
<p>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。
在 Python 中您可以使用 <code>pycallgraph</code> 来生成这些图片。</p>
<h5 id="资源监控">资源监控</h5>
<p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p>
<p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU
占用、内存使用、网络、磁盘使用等。</p>
<p>通用监控 - 最流行的工具要数 <code>htop</code>, 了，它是
<code>top</code> 的改进版。<code>htop</code>
可以显示当前运行进程的多种统计信息。<code>htop</code>
有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、
<code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。
还可以留意一下 <code>glances</code>
，它的实现类似但是用户界面更好。如果需要合并测量全部的进程，
<code>dstat</code>
是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如
I/O、网络、 CPU 利用率、上下文切换等等； I/O 操作 - <code>iotop</code>
可以显示实时 I/O
占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；
磁盘使用 - <code>df</code> 可以显示每个分区的信息，而 <code>du</code>
则可以显示当前目录下每个文件的磁盘使用情况（ d isk u
sage）。<code>-h</code> 选项可以使命令以对人类（h
uman）更加友好的格式显示数据；<code>ncdu</code> 是一个交互性更好的
<code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；
内存使用 - <code>free</code> 可以显示系统当前空闲的内存。内存也可以使用
<code>htop</code> 这样的工具来显示； 打开文件 - <code>lsof</code>
可以列出被进程打开的文件信息。
当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；
网络连接和配置 - <code>ss</code>
能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code>
常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用
<code>ip</code> 命令。注意，<code>netstat</code> 和
<code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。 网络使用 -
<code>nethogs</code> 和 <code>iftop</code>
是非常好的用于对网络占用进行监控的交互式命令行工具。</p>
<p>如果您希望测试一下这些工具，您可以使用 <code>stress</code>
命令来为系统人为地增加负载。</p>
<h5 id="专用工具">专用工具</h5>
<p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。
类似 <code>hyperfine</code>
这样的命令行可以帮您快速进行基准测试。例如，我们在 shell
工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替
<code>find</code>。我们这里可以用 <code>hyperfine</code>
来比较一下它们。</p>
<p>例如，下面的例子中，我们可以看到 <code>fd</code> 比 <code>find</code>
要快 20 倍。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hyperfine --warmup 3 <span class="string">&#x27;fd -e jpg&#x27;</span> <span class="string">&#x27;find . -iname &quot;*.jpg&quot;&#x27;</span></span></span><br><span class="line">Benchmark #1: fd -e jpg</span><br><span class="line">  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]</span><br><span class="line">  Range (min … max):    44.2 ms …  60.1 ms    56 runs</span><br><span class="line"></span><br><span class="line">Benchmark #2: find . -iname &quot;*.jpg&quot;</span><br><span class="line">  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]</span><br><span class="line">  Range (min … max):    0.975 s …  1.287 s    10 runs</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">  &#x27;fd -e jpg&#x27; ran</span><br><span class="line">   21.89 ± 2.33 times faster than &#x27;find . -iname &quot;*.jpg&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p>和 debug
一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。</p>
<h2 id="元编程">元编程</h2>
<p>我们这里说的 “元编程（metaprogramming）”
是什么意思呢？好吧，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于
流程
，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。在您还是学生的时候，这些东西看上去似乎对您来说没那么重要，不过当您开始实习或走进社会的时候，您将会接触到大型的代码库，本节课讲授的这些东西也会变得随处可见。必须要指出的是，“元编程”
也有 “用于操作程序的程序”
之含义，这和我们今天讲座所介绍的概念是完全不同的。</p>
<h3 id="构建系统">构建系统</h3>
<p>如果您使用 LaTeX
来编写论文，您需要执行哪些命令才能编译出您想要的论文呢？执行基准测试、绘制图表然后将其插入论文的命令又有哪些？或者，如何编译本课程提供的代码并执行测试呢？</p>
<p>对于大多数系统来说，不论其是否包含代码，都会包含一个
“构建过程”。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，您并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p>
<p>这些工具通常被称为
“构建系统”，而且这些工具还不少。如何选择工具完全取决于您当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的。您需要定义
依赖、目标 和
规则。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。</p>
<p><code>make</code>
是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于 UNIX
的系统中。<code>make</code>
并不完美，但是对于中小型项目来说，它已经足够好了。当您执行
<code>make</code> 时，它会去参考当前目录下名为 <code>Makefile</code>
的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">paper.pdf: paper.tex plot-data.png</span><br><span class="line">    pdflatex paper.tex</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">plot-%</span><span class="language-bash">.png: %.dat plot.py</span></span><br><span class="line">    ./plot.py -i $*.dat -o $@</span><br></pre></td></tr></table></figure>
<p>这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。或者，换句话说，冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段命令。在
<code>make</code> 中，第一条指令还指明了构建的目的，如果您使用不带参数的
<code>make</code>，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p>
<p>规则中的 <code>%</code>
是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是
<code>plot-foo.png</code>， <code>make</code> 会去寻找
<code>foo.dat</code> 和 <code>plot.py</code>
作为依赖。现在，让我们看看如果在一个空的源码目录中执行 <code>make</code>
会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;paper.tex&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p><code>make</code> 会告诉我们，为了构建出
<code>paper.pdf</code>，它需要
<code>paper.tex</code>，但是并没有一条规则能够告诉它如何构建该文件。让我们构建它吧！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;plot-data.png&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure>
<p>哟，有意思，我们是 有 构建 <code>plot-data.png</code>
的规则的，但是这是一条模式规则。因为源文件 <code>data.dat</code>
并不存在，因此 <code>make</code> 就会告诉您它不能构建
<code>plot-data.png</code>，让我们创建这些文件：</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> cat paper.tex</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=0.65]&#123;plot-data.png&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br><span class="line"><span class="built_in">$</span> cat plot.py</span><br><span class="line"><span class="params">#</span>!/usr/bin/env python</span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add<span class="built_in">_</span>argument(&#x27;-i&#x27;, type=argparse.FileType(&#x27;r&#x27;))</span><br><span class="line">parser.add<span class="built_in">_</span>argument(&#x27;-o&#x27;)</span><br><span class="line">args = parser.parse<span class="built_in">_</span>args()</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(args.i)</span><br><span class="line">plt.plot(data[:, 0], data[:, 1])</span><br><span class="line">plt.savefig(args.o)</span><br><span class="line"><span class="built_in">$</span> cat data.dat</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 8</span><br></pre></td></tr></table></figure>
<p>当我们执行 make 时会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">./plot.py -i data.dat -o plot-data.png</span><br><span class="line">pdflatex paper.tex</span><br><span class="line">... lots of output ...</span><br></pre></td></tr></table></figure>
<p>看！PDF ！</p>
<p>如果再次执行 <code>make</code> 会怎样？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: &#x27;paper.pdf&#x27; is up to date.</span><br></pre></td></tr></table></figure>
<p>什么事情都没做！为什么？好吧，因为它什么都不需要做。<code>make</code>
检查出所有之前构建的目标仍然与其列出的依赖项保持最新状态。让我们试试修改
<code>paper.tex</code> 后再重新执行 <code>make</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">pdflatex paper.tex</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意 <code>make</code> 并 没有 重新构建
<code>plot.py</code>，因为没必要；<code>plot-data.png</code>
的所有依赖都没有发生改变。</p>
<h3 id="依赖管理">依赖管理</h3>
<p>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序（例如
<code>python</code>）、系统包（例如
<code>openssl</code>）或相关编程语言的库（例如
<code>matplotlib</code>）。 现在，大多数的依赖可以通过某些 软件仓库
来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如
Ubuntu 系统下面有 Ubuntu 软件包仓库，您可以通过 <code>apt</code>
这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python
库， Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。</p>
<p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如
版本控制。大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个
版本号。通常看上去像 8.1.3 或
64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p>
<p>这样还并不理想！如果我们发布了一项和安全相关的升级，它并 没有
影响到任何公开接口（API），但是处于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是
语义版本号，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：</p>
<p>如果新的版本没有改变 API，请将补丁号递增； 如果您添加了 API
并且该改动是向后兼容的，请将次版本号递增； 如果您修改了 API
但是它并不向后兼容，请将主版本号递增。</p>
<p>这么做有很多好处。现在如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的
，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是
<code>1.3.7</code>，那么使用
<code>1.3.8</code>、<code>1.6.1</code>，甚至是 <code>1.3.0</code>
都是可以的。如果版本号是 <code>2.2.4</code>
就不一定能用了，因为它的主版本号增加了。我们可以将 Python
的版本号作为语义版本号的一个实例。您应该知道，Python 2 和 Python 3
的代码是不兼容的，这也是为什么 Python 的主版本号改变的原因。类似的，使用
Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。</p>
<p>使用依赖管理系统的时候，您可能会遇到锁文件（lock
files）这一概念。锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含
bug）。还有一种极端的依赖锁定叫做
vendoring，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。</p>
<h3 id="持续集成系统">持续集成系统</h3>
<p>随着您接触到的项目规模越来越大，您会发现修改代码之后还有很多额外的工作要做。您可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到
pypi，执行测试套件等等。或许您希望每次有人提交代码到 GitHub
的时候，他们的代码风格被检查过并执行过某些基准测试？如果您有这方面的需求，那么请花些时间了解一下持续集成。</p>
<p>持续集成（Continuous integration），或者叫做 CI
是一种雨伞术语（umbrella
term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样
CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis
CI、Azure Pipelines 和 GitHub
Actions。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI
提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</p>
<p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages
在每次 master 有代码更新时，会执行 Jekyll
博客软件，然后使您的站点可以通过某个 GitHub
域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用
git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p>
<h4 id="测试简介">测试简介</h4>
<p>多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：</p>
<p>测试套件（Test suite）：所有测试的统称。 单元测试（Unit
test）：一种“微型测试”，用于对某个封装的特性进行测试。
集成测试（Integration
test）：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能
协同 工作。 回归测试（Regression
test）：一种实现特定模式的测试，用于保证之前引起问题的 bug
不会再次出现。 模拟（Mocking）:
使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接”
或 “模拟硬盘”。</p>
<h2 id="安全和密码学">安全和密码学</h2>
<p>我们将关注比如散列函数、密钥生成函数、对称/非对称密码体系这些安全和密码学的概念是如何应用于前几节课所学到的工具（Git
和 SSH）中的。</p>
<p>如果你不是密码学的专家，请不要
试图创造或者修改加密算法。从事和计算机系统安全相关的工作同理。</p>
<p>这节课将对一些基本的概念进行简单（但实用）的说明。
虽然这些说明不足以让你学会如何 设计
安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</p>
<h3 id="熵">熵</h3>
<p>熵 (Entropy) 是不确定性的度量，这很有用，可以用来决定密码的强度。</p>
<p>“correcthorsebatterystaple” 这个密码比 “Tr0ub4dor&amp;3”
更安全——可是熵是如何量化安全性的呢？</p>
<p>熵的单位是 比特。对于一个均匀分布的随机离散变量，熵等于
<code>log_2(所有可能的个数，即 n)</code>。 扔一次硬币的熵是 1
比特。掷一次（六面）骰子的熵大约为 2.58 比特。</p>
<p>一般我们认为攻击者了解密码的模型（最小长度，最大长度，可能包含的字符种类等），但是不了解某个密码是如何随机选择的——
比如 掷骰子。</p>
<p>使用多少比特的熵取决于应用的威胁模型。 大约 40
比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。
而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如 80
比特或更多)。</p>
<h3 id="散列函数">散列函数</h3>
<p>密码散列函数 (Cryptographic hash function)
可以将任意大小的数据映射为一个固定大小的输出。除此之外，还有一些其他特性。
一个散列函数的大概规范如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt;  (N对于该函数固定)</span><br></pre></td></tr></table></figure>
<p>SHA-1 是 Git 中使用的一种散列函数， 它可以将任意大小的输入映射为一个
160 比特（可被 40 位十六进制数表示）的输出。 下面我们用
<code>sha1sum</code> 命令来测试 SHA1 对几个字符串的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;hello&#x27;</span> | <span class="built_in">sha1sum</span></span></span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">printf</span> <span class="string">&#x27;Hello&#x27;</span> | <span class="built_in">sha1sum</span></span> </span><br><span class="line">f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0</span><br></pre></td></tr></table></figure>
<p>抽象地讲，散列函数可以被认为是一个不可逆，且看上去随机（但具确定性）的函数
（这就是 散列函数的理想模型）。 一个散列函数拥有以下特性：</p>
<p>确定性：对于不变的输入永远有相同的输出。 不可逆性：对于
<code>hash(m) = h</code>，难以通过已知的输出 <code>h</code>
来计算出原始输入 <code>m</code>。
目标碰撞抵抗性/弱无碰撞：对于一个给定输入 <code>m_1</code>，难以找到
<code>m_2 != m_1</code> 且 <code>hash(m_1) = hash(m_2)</code>。
碰撞抵抗性/强无碰撞：难以找到一组满足 <code>hash(m_1) = hash(m_2)</code>
的输入 <code>m_1, m_2</code>（该性质严格强于目标碰撞抵抗性）。</p>
<p>注：虽然 SHA-1 还可以用于特定用途，但它已经 不再被认为
是一个强密码散列函数。 你可参照 密码散列函数的生命周期
这个表格了解一些散列函数是何时被发现弱点及破解的。
请注意，针对应用推荐特定的散列函数超出了本课程内容的范畴。
如果选择散列函数对于你的工作非常重要，请先系统学习信息安全及密码学。</p>
<h4 id="密码散列函数的应用">密码散列函数的应用</h4>
<p>Git 中的内容寻址存储(Content-addressed storage)：散列函数
是一个宽泛的概念（存在非密码学的散列函数），那么 Git
为什么要特意使用密码散列函数？ 文件的信息摘要(Message digest)：像 Linux
ISO
这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。
官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。
用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。
承诺机制(Commitment scheme)： 假设我希望承诺一个值，但之后再透露它——
比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的“扔一次硬币”。
我可以选择一个值 <code>r = random()</code>，并和你分享它的哈希值
<code>h = sha256(r)</code>。
这时你可以开始猜硬币的正反：我们一致同意偶数 <code>r</code>
代表正面，奇数 <code>r</code> 代表反面。 你猜完了以后，我告诉你值
<code>r</code> 的内容，得出胜负。同时你可以使用 <code>sha256(r)</code>
来检查我分享的哈希值 <code>h</code> 以确认我没有作弊。</p>
<h3 id="密钥生成函数">密钥生成函数</h3>
<p>密钥生成函数 (Key Derivation Functions)
作为密码散列函数的相关概念，被应用于包括生成固定长度，可以使用在其他密码算法中的密钥等方面。
为了对抗穷举法攻击，密钥生成函数通常较慢。</p>
<h4 id="密钥生成函数的应用">密钥生成函数的应用</h4>
<p>从密码生成可以在其他加密算法中使用的密钥，比如对称加密算法（见下）。
存储登录凭证时不可直接存储明文密码。
正确的方法是针对每个用户随机生成一个 盐 <code>salt = random()</code>，
并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值
<code>KDF(password + salt)</code>。
在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值
<code>KDF(input + salt)</code>，并与存储的哈希值对比。</p>
<h3 id="对称加密">对称加密</h3>
<p>说到加密，可能你会首先想到隐藏明文信息。对称加密使用以下几个方法来实现这个功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; key  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出明文)</span><br></pre></td></tr></table></figure>
<p>加密方法 <code>encrypt()</code> 输出的密文 <code>ciphertext</code>
很难在不知道 <code>key</code> 的情况下得出明文 <code>plaintext</code>。
解密方法 <code>decrypt()</code>
有明显的正确性。因为功能要求给定密文及其密钥，解密方法必须输出明文：<code>decrypt(encrypt(m, k), k) = m</code>。</p>
<p>AES 是现在常用的一种对称加密系统。</p>
<h4 id="对称加密的应用">对称加密的应用</h4>
<p>加密不信任的云服务上存储的文件。对称加密和密钥生成函数配合起来，就可以使用密码加密文件：
将密码输入密钥生成函数生成密钥
<code>key = KDF(passphrase)</code>，然后存储
<code>encrypt(file, key)</code>。</p>
<h3 id="非对称加密">非对称加密</h3>
<p>非对称加密的“非对称”代表在其环境中，使用两个具有不同功能的密钥：
一个是私钥(private key)，不向外公布；另一个是公钥(public
key)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。
非对称加密使用以下几个方法来实现加密/解密(encrypt/decrypt)，以及签名/验证(sign/verify)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; (public key, private key)  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (输出明文)</span><br><span class="line"></span><br><span class="line">sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (生成签名)</span><br><span class="line">verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool  (验证签名是否是由和这个公钥相关的私钥生成的)</span><br></pre></td></tr></table></figure>
<p>非对称的加密/解密方法和对称的加密/解密方法有类似的特征。
信息在非对称加密中使用 公钥 加密， 且输出的密文很难在不知道 私钥
的情况下得出明文。 解密方法 <code>decrypt()</code> 有明显的正确性。
给定密文及私钥，解密方法一定会输出明文：
<code>decrypt(encrypt(m, public key), private key) = m</code>。</p>
<p>对称加密和非对称加密可以类比为机械锁。
对称加密就好比一个防盗门：只要是有钥匙的人都可以开门或者锁门。
非对称加密好比一个可以拿下来的挂锁。你可以把打开状态的挂锁（公钥）给任何一个人并保留唯一的钥匙（私钥）。这样他们将给你的信息装进盒子里并用这个挂锁锁上以后，只有你可以用保留的钥匙开锁。</p>
<p>签名/验证方法具有和书面签名类似的特征。 在不知道 私钥
的情况下，不管需要签名的信息为何，很难计算出一个可以使
<code>verify(message, signature, public key)</code> 返回为真的签名。
对于使用私钥签名的信息，验证方法验证和私钥相对应的公钥时一定返回为真：
<code>verify(message, sign(message, private key), public key) = true</code>。</p>
<h4 id="非对称加密的应用">非对称加密的应用</h4>
<p>PGP 电子邮件加密：用户可以将所使用的公钥在线发布，比如：PGP
密钥服务器或 Keybase。任何人都可以向他们发送加密的电子邮件。
聊天加密：像 Signal 和 Keybase 使用非对称密钥来建立私密聊天。
软件签名：Git 支持用户对提交(commit)和标签(tag)进行 GPG
签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。</p>
<h4 id="密钥分发">密钥分发</h4>
<p>非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。</p>
<p>Signal 的信任模型是，信任用户第一次使用时给出的身份(trust on first
use)，同时支持用户线下(out-of-band)、面对面交换公钥（Signal 里的 safety
number）。</p>
<p>PGP 使用的是
信任网络。简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，比如对比证件。验证无误后，信任网络的成员使用私钥对我的公钥进行签名。这样我就成为了信任网络的一部分。只要我使用签名过的公钥所对应的私钥就可以证明“我是我”。</p>
<p>Keybase 主要使用 社交网络证明 (social
proof)，和一些别的精巧设计。</p>
<p>每个信任模型有它们各自的优点：我们（讲师）更倾向于 Keybase
使用的模型。</p>
<h3 id="案例分析">案例分析</h3>
<h4 id="密码管理器">密码管理器</h4>
<p>每个人都应该尝试使用密码管理器，比如 KeePassXC、pass 和
1Password)。</p>
<p>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，并使用你指定的主密码配合密钥生成函数来对称加密它们。</p>
<p>你只需要记住一个复杂的主密码，密码管理器就可以生成很多复杂度高且不会重复使用的密码。密码管理器通过这种方式降低密码被猜出的可能，并减少网站信息泄露后对其他网站密码的威胁。</p>
<h4 id="两步验证双因子验证">两步验证（双因子验证）</h4>
<p>两步验证（2FA）要求用户同时使用密码（“你知道的信息”）和一个身份验证器（“你拥有的物品”，比如
YubiKey）来消除密码泄露或者 钓鱼攻击 的威胁。</p>
<h4 id="全盘加密">全盘加密</h4>
<p>对笔记本电脑的硬盘进行全盘加密是防止因设备丢失而信息泄露的简单且有效方法。
Linux 的cryptsetup + LUKS， Windows 的 BitLocker，或者 macOS 的
FileVault 都使用一个由密码保护的对称密钥来加密盘上的所有信息。</p>
<h4 id="聊天加密">聊天加密</h4>
<p>Signal 和 Keybase 使用非对称加密对用户提供端到端 （End-to-end）
安全性。</p>
<p>获取联系人的公钥非常关键。为了保证安全性，应使用线下方式验证 Signal
或者 Keybase 的用户公钥，或者信任 Keybase 用户提供的社交网络证明。</p>
<h4 id="ssh">SSH</h4>
<p>我们在 之前的一堂课 讨论了 SSH 和 SSH
密钥的使用。那么我们今天从密码学的角度来分析一下它们。</p>
<p>当你运行 <code>ssh-keygen</code>
命令，它会生成一个非对称密钥对：公钥和私钥
<code>(public_key, private_key)</code>。
生成过程中使用的随机数由系统提供的熵决定。这些熵可以来源于硬件事件(hardware
events)等。 公钥最终会被分发，它可以直接明文存储。
但是为了防止泄露，私钥必须加密存储。<code>ssh-keygen</code>
命令会提示用户输入一个密码，并将它输入密钥生成函数
产生一个密钥。最终，<code>ssh-keygen</code>
使用对称加密算法和这个密钥加密私钥。</p>
<p>在实际运用中，当服务器已知用户的公钥（存储在
<code>.ssh/authorized_keys</code> 文件中，一般在用户 HOME
目录下），尝试连接的客户端可以使用非对称签名来证明用户的身份——这便是
挑战应答方式。
简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。
服务器随后使用 <code>.ssh/authorized_keys</code>
文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效证明试图登录的用户持有所需的私钥。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/VMware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/VMware/" class="post-title-link" itemprop="url">VMware</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-28 19:35:24" itemprop="dateModified" datetime="2025-10-28T19:35:24+08:00">2025-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="vmware的安装">VMware的安装</h2>
<p>在百度网盘中下载好, 打开exe文件安装, 安装完成后输入密钥.</p>
<h2 id="linux操作系统的安装">Linux操作系统的安装</h2>
<p>假设电脑中已经安装了VMware,我们只需要进入Linux官方网站,可以看到网站中有Ubuntu,CentOS等操作系统,以Ubuntu为例,点击Download
Ubuntu,可以看到有很多版本,我们选择桌面版,点击Download Ubuntu
Desktop,然后下载想要的版本,这里以ubuntu-20.04.6-desktop-amd64.iso为例,下载好之后我们可以得到后缀为.iso的光盘映像文件.</p>
<p>打开VMware,点击”创建新的虚拟机-&gt;下一步”,在”安装程序光盘映像文件(iso)(M):“一栏中选择刚刚下载好的Ubuntu
iso文件,再点击”下一步”,用户名,密码等选项可以随便填,这里用户名填写siyuanlei,密码填写123456,点击”下一步”,给虚拟机命名Ubuntu
20.04,点击”下一步”,设置磁盘大小,点击”下一步”,取消勾选”创建后开启此虚拟机”,点击”完成”.</p>
<p>创建完成后,点击”编辑虚拟机设置”,可以更改内存,处理器数量以及每个处理器的内核数量等</p>
<p>设置完成后点击”开启此虚拟机”,打开后,选择”Try or Install
Ubuntu”,然后按回车,就会出现Ubuntu安装界面.根据自己需求设置即可.</p>
<h2 id="ic617618的安装">IC617/618的安装</h2>
<p>打开已经下载好的镜像文件<code>IC618.vms</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">第一章:Verilog HDL数字集成电路设计方法概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 05:46:54" itemprop="dateModified" datetime="2026-01-15T05:46:54+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2
id="数字集成电路的发展和设计方法的演变">数字集成电路的发展和设计方法的演变</h2>
<p>几十个逻辑门的小规模集成电路(Small Scale Integrated,
SSI)–&gt;单芯片数千万个逻辑门的极大规模集成电路(Ultra Large Scale
Integrated, ULSI), 单芯片可以集成几十亿只晶体管.</p>
<h2 id="集成电路的发展">集成电路的发展</h2>
<h3 id="第一次变革时期">第一次变革时期</h3>
<p>20世纪70年代, 是以加工制造为主导的IC(Integrated
Circuit)产业发展的初级阶段, 主流产品是微处理器(Micro Processor Unit,
MPU), 存储器以及标准通用逻辑电路. 这一时期, IC整合原件厂(Integrated
Device Manufacturer, IDM)在IC市场中充当主要角色,
设计只作为附属部门而存在. 芯片设计和半导体工艺密切相关, 设计以人工为主,
计算机辅助为辅(Computer Aided Design,
CAD)系统只作为数据处理和图形编程。</p>
<h3 id="第二次变革时期">第二次变革时期</h3>
<p>20世纪80年代, 标准工艺加工线(Foundry)公司和IC设计公司共同发展,
主流产品是MPU, 微控制器(Micro Control Unit,
MCU)以及专用IC(Application-Specific IC, ASIC).
这时Foundry和IC设计公司相结合的方式开始成为集成电路产业发展的新模式.
IC产业开始进入以客户为 导向的阶段. 超大规模集成电路(Very Large Scale
Integrated, VLSI)开始成为主流芯片; 电子设计自动化(Eletronic Design
Automation, EDA) 快速发展, 设计过程和生产工艺可以各自独立存在,
没有生产线的IC设计公司(Fabless)和设计部门纷纷建立并快速发展,
同时以制造业为主的Foundry 工厂也迅速发展. 1987年,
全球第一个Foundry工厂————台积电成立,
其创始人张忠谋被誉为”芯片加工之父”.</p>
<h3 id="第三次变革时期">第三次变革时期</h3>
<p>20世纪90年代, IC产业的”四业”(设计业, 制造业, 封装业, 测试业)开始分离,
功能强大的通用性中央处理器(Central Processing Unit,
CPU)和信号处理器(Digital Signal Processing, DSP)成为产业新的增长点.</p>
<p>进入21世纪, 首先CMOS模拟技术的发展使得数模混合单芯片集成技术迅速发展,
在设计和成本方面体现了巨大优势. 其次, 应用需求使得储存器在USLI
芯片中的作业越来越明显, 高密度存储器及其SoC设计成为设计的焦点. 再次,
大规模多内核处理器结构成为通用型芯片和SoC芯片的主流设计方式.</p>
<p>在设计方法方面, 采用功能复用的IP(Intelligent Property)的设计方式,
成为IC设计和商业化的一种主要方式, 极大提高了ULSI芯片的设计效率和
可扩展性.</p>
<h2 id="ip核">IP核</h2>
<p>IP核是具有知识产权核的集成电路芯核总称, 是经过反复验证的,
具有特定功能的宏模块, 与芯片制作工艺无关,
可以移植到不同的半导体工艺中.</p>
<p>到了SoC阶段,
向用户提供IP核服务已经成为可编程逻辑器件提供商的重要任务.
在SoC芯片的设计生产过程中, 芯片的生产厂家只需根据设计需要购入
相应功能的IP核, 再将这些IP核按照设计需要进行组合,
即可完成所需功能的设计.</p>
<p><strong>软核</strong>经过功能验证, 5000门以上的可综合Verilog
HDL或VHDL模型. 软核通常与设计方法和电路所采用的工艺无关,
具有很强的可综合性和可重用性. 由软核构成的器件称为虚拟器件,
通过EDA综合工具可以把它和其他数字逻辑电路结合起来, 构成新的功能电路;</p>
<p><strong>固核</strong>在FPGA器件上, 经过综合验证,
大于5000门的电路网表文件;</p>
<p><strong>硬核</strong>在ASIC器件上, 经过验证正确的,
大于5000门的电路结构版图掩模.</p>
<p>其中软核是可读性较高的可综合HDL实现, 因此其可维护性和可重用性较高,
更加灵活和简便. 固核和硬核是针对不同平台的功能单元, 性能稳定,
不易修改.</p>
<h2 id="verilog-hdl在数字集成电路设计流程中的作用">Verilog
HDL在数字集成电路设计流程中的作用</h2>
<p>一般的数字集成电路设计流程如下:</p>
<p>总体方案————&gt;系统建模————&gt;RTL编码————&gt;功能验证————&gt;综合————&gt;时序验证————&gt;物理综合/布局布线————&gt;物理验证————&gt;原型建立和测试————&gt;工艺实现</p>
<p>数字集成电路和FPGA设计过程总体可以分成4个阶段</p>
<p><strong>第一阶段</strong>是<strong>系统设计阶段</strong>,
包括总体方案和系统建模.
<strong>第二阶段</strong>是<strong>数字电路设计和代码编写阶段</strong>,
即RTL代码编写阶段.
<strong>第三阶段</strong>是<strong>电路验证阶段</strong>,
包括对硬件描述语言的程序代码的功能验证和经过EDA综合工具之后的时序验证两个部分.
<strong>第四阶段</strong>是集成电路的<strong>后端设计阶段</strong>,
主要通过EDA工具和进行物理综合, 布局布线, 物理验证, 原型建立和测试,
最终交付工艺实现.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/SUSY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/SUSY/" class="post-title-link" itemprop="url">Notes on Supersymmetry</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-15 00:54:15" itemprop="dateModified" datetime="2025-07-15T00:54:15+08:00">2025-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">物理</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%A9%E7%90%86/%E8%B6%85%E5%AF%B9%E7%A7%B0/" itemprop="url" rel="index"><span itemprop="name">超对称</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="weyl-spinors">Weyl Spinors</h2>
<h3
id="brief-review-of-the-dirac-equation-and-of-some-matrix-properties">Brief
Review of the Dirac Equation and of Some Matrix Properties</h3>
<p>Dirac Equation:</p>
<p><span class="math display">\[\gamma^\mu P_\mu\Psi=m\Psi~~\rm{or}~~
\not{\rm{P}}\Psi=m\Psi(\rm{use~Feynman&#39;s~slash~notation})\]</span></p>
<p>Here, <span class="math inline">\(P_\mu\)</span> represents the
differential operator <span
class="math inline">\(i\partial_\mu\)</span>. Throughout this note we
use natural unit, in which <span
class="math inline">\(c=\hbar=1\)</span>.</p>
<p>Dirac Lagrangian:</p>
<p><span class="math display">\[\mathcal{L}=\overline{\Psi}(\gamma^\mu
P_\mu-m)\Psi\]</span></p>
<p>where the bar over the spinor denotes the Dirac adjoint <span
class="math inline">\(\overline{\Psi}=\Psi^\dagger\gamma^0\)</span>.</p>
<p>Dirac matrix:</p>
<p>There are several different representations for the Dirac matrix
<span class="math inline">\(\gamma^0\)</span> and <span
class="math inline">\(\vec{\gamma}\)</span>. We choose
representation</p>
<p><span class="math display">\[\gamma^0=\begin{pmatrix}
    0 &amp; \boldsymbol{1}\\
    \boldsymbol{1}&amp;0
\end{pmatrix}~~\vec{\gamma}=\begin{pmatrix}
    0&amp; -\vec{\sigma}\\
    \vec{\sigma}&amp;0\\
\end{pmatrix}\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{1}\)</span> stands for
the <span class="math inline">\(2\times 2\)</span> identity matrix.
These can be used to define <span
class="math inline">\(\gamma^\mu=(\gamma^0,\vec{\gamma})\)</span>. The
corresponding quatity with a covariant index is defined as <span
class="math inline">\(\gamma_\mu=\eta_{\mu\nu}\gamma^\nu=(\gamma^0,-\vec{\gamma})\)</span>,
where <span
class="math inline">\(\eta_{\mu\nu}=\rm{diag}(1,-1,-1,-1)\)</span>.</p>
<p>For <span class="math inline">\(\gamma_5\)</span>, we choose the
chiral or Weyl representation</p>
<p><span class="math display">\[\gamma_5=\begin{pmatrix}
    \boldsymbol{1}&amp;0\\
    0&amp;-\boldsymbol{1}
\end{pmatrix}\]</span></p>
<p>Pauli matrices:</p>
<p><span class="math display">\[\sigma^1=\begin{pmatrix}
    0&amp;1\\
    1&amp;0\\
\end{pmatrix}~~~~
\sigma^2=\begin{pmatrix}
    0&amp;-i\\
    i&amp;0\\
\end{pmatrix}~~~~
\sigma^3=\begin{pmatrix}
    1&amp;0\\
    0&amp;-1
\end{pmatrix}\]</span></p>
<p>They have the follwing properties:</p>
<ol type="1">
<li>They are hermitian, i.e., <span
class="math inline">\((\sigma^i)^\dagger=\sigma^i\)</span></li>
<li>The product of any two Pauli matrix is given by <span
class="math inline">\(\sigma^i\sigma^j=\boldsymbol{1}\delta^{ij}+i\epsilon^{ijk}\sigma^k\)</span></li>
<li>The commutator of two Pauli matrices is <span
class="math inline">\([\sigma^1,\sigma^j]=2i\epsilon^{ijk}\sigma^k\)</span></li>
<li>The anticommutator of two Pauli matries is <span
class="math inline">\(\{\sigma^i,\sigma^j\}=2\delta^{ij}\boldsymbol{1}\)</span></li>
<li><span
class="math inline">\(\sigma^2\vec{\sigma}^T=-\vec{\sigma}\sigma^2,~~\sigma^2\vec{\sigma}^*=-\vec{\sigma}\sigma^2\)</span></li>
</ol>
<h3 id="weyl-versus-dirac-spinors">Weyl versus Dirac Spinors</h3>
<p>We now wirte the four-component Dirac spinor in terms of
two-component spinors:</p>
<p><span class="math display">\[\Psi=\begin{pmatrix}
    \eta\\
    \chi
\end{pmatrix}\]</span></p>
<p>where the two-component spinors are called Weyl spinors. The reason
it makes sense to decompose a Dirac spinor this way is that, as we will
see, <span class="math inline">\(\eta\)</span> and <span
class="math inline">\(\chi\)</span> transform independently under
Lorentz transformations, i.e., they don’t mix. The technical way to
express this is to say that a Dirac spinor forms a reducible
representationpf the Lorentz group, whereas the Weyl spinors form
irreducible representations.</p>
<p>Note that setting either <span class="math inline">\(\eta\)</span> or
<span class="math inline">\(\chi\)</span> equal to zero in a Dirac
spinor yields eigenstates of <span
class="math inline">\(\gamma_5\)</span>:</p>
<p><span class="math display">\[\gamma_5\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}=+\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}~~~~\gamma_5\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}=-\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}\]</span></p>
<p>The eigenvalue of <span class="math inline">\(\gamma_5\)</span> is
called the chirality of the spinor, so we say that the upper
two-component spinor <span class="math inline">\(\eta\)</span> has a
chirality of <span class="math inline">\(+1\)</span> and <span
class="math inline">\(\chi\)</span> has a chirality of <span
class="math inline">\(-1\)</span>. A Weyl spinor with positive chirality
is sometimes referred to as a right-chiral spinor, and a Weyl spinor
with negative chirality is referred to as a right-chiral spinor.</p>
<p>However, some references replace the adjectives right-chiral and
left-chiral by right-handed and left-handed, but in general, knowing the
chirality doesn’t tell us the handedness of a particle.</p>
<p>We will discuss how the handedness, or to be more technical, the
helicity of a spinor is defined.</p>
<p>The key point is to make here is that the notions of chirality and
the helicity of a spinor coincide only when a particle is massless. For
a massive particle, both the left-chiral and the right-chiral states
are, in general, linear combinations of left-handed and right-handed
states.</p>
<p>It’s chirality that tells us how a spinor behaves under Lorentz
transformations. For a massive spinor, it’s the chirality that specifies
what representation of the Lorentz group it belongs to, not its
helicity, so we will care more about chirality than about helicity.</p>
<p>It is convenint to introduce the operators <span
class="math inline">\(P_R\)</span> and <span
class="math inline">\(P_L\)</span>, which, when applied to a fuul Dirac
spinor, project out the right-chiral and left-chiral Weyl spinors:</p>
<p><span class="math display">\[P_R\Psi=P_R\begin{pmatrix}
    \eta\\
    \chi\\
\end{pmatrix}=\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}~~~~P_L\Psi=P_L\begin{pmatrix}
    \eta\\
    \chi\\
\end{pmatrix}=\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}\]</span></p>
<p>The explicit representations of these opeartors are obviously</p>
<p><span class="math display">\[P_R=\begin{pmatrix}
    \boldsymbol{1}&amp;0\\
    0&amp;0
\end{pmatrix}=\frac{\boldsymbol{1}+\gamma_5}{2}~~~~P_L=\begin{pmatrix}
    0&amp;0\\
    0&amp;\boldsymbol{1}
\end{pmatrix}=\frac{\boldsymbol{1}-\gamma_5}{2}\]</span></p>
<p>If we substitute <span class="math inline">\(\Psi=\begin{pmatrix}
    \eta\\
    \chi
\end{pmatrix}\)</span> to the Dirac equation, we can obtain two coupled
equations for the Weyl spinors:</p>
<p><span class="math display">\[\begin{aligned}
    (E\boldsymbol{1}-\vec{\sigma}\cdot\vec{p})\eta=m\chi\\
    (E\boldsymbol{1}+\vec{\sigma}\cdot\vec{p})\chi=m\eta
\end{aligned}\]</span></p>
<p>Now we introduce some useful notations:</p>
<p><span
class="math display">\[\sigma^\mu=(\boldsymbol{1},\vec{\sigma}),~~\overline{\sigma}^\mu=(1,-\vec{\sigma})\]</span></p>
<p>we can check that they have the following properties:</p>
<ol type="1">
<li><span
class="math inline">\(\sigma^2(\sigma^\mu)^T\sigma^2=\overline{\sigma}^\mu,~~\sigma^2(\overline{\sigma}^\mu)^T\sigma^2=\sigma^\mu\)</span></li>
<li><span
class="math inline">\(\sigma^2\sigma^\mu\sigma^2=(\overline{\sigma}^\mu)^T,~~\sigma^2\overline{\sigma}^\mu\sigma^2=(\sigma^\mu)^T\)</span></li>
<li><span
class="math inline">\(\sigma^\mu\overline{\sigma}^\nu+\sigma^\nu\overline{\sigma}^\mu=2\eta^{\mu\nu}\boldsymbol{1}\)</span></li>
<li><span
class="math inline">\(\overline{\sigma}^\mu\sigma^\nu+\overline{\sigma}^\nu\sigma^\mu=2\eta^{\mu\nu}\boldsymbol{1}\)</span></li>
<li><span class="math inline">\(\gamma^\mu=\begin{pmatrix}
0&amp;\overline{\sigma}^\mu\\
\sigma^\mu&amp;0
\end{pmatrix}\)</span></li>
</ol>
<p>So the two coupled equations may be written as</p>
<p><span class="math display">\[\begin{aligned}
    P_\mu\sigma^\mu\eta=m\chi\\
    P_\mu\overline{\sigma}^\mu\chi=m\eta\\
\end{aligned}\]</span></p>
<p>and we can also write the Dirac lagrangianin terms of Weyl
spinors:</p>
<p><span class="math display">\[\mathcal{L}=\eta^\dagger\sigma^\mu
i\partial_\mu\eta+\chi^\dagger\overline{\sigma}^\mu
i\partial_\mu\chi-m\eta^\dagger\chi-m\chi^\dagger\eta\]</span></p>
<p>Note that despide the fact that <span
class="math inline">\(\sigma^\mu\)</span> and <span
class="math inline">\(\overline{\sigma}^\mu\)</span> carry a Lorentz
index, they are not themselves four-vectors (for the same reason that
<span class="math inline">\(\gamma^\mu\)</span> is not a four-vector).
However, we can form quantities with well-defined Lorentz properties by
sandwiching them between Weyl spinors.</p>
<h3 id="helicity">Helicity</h3>
<p>For massless particles, the two equations for Weyl spinors decouple
to give:</p>
<p><span class="math display">\[\begin{aligned}
    (E\boldsymbol{1}-\vec{\sigma}\cdot\vec{p})\eta=0\\
    (E\boldsymbol{1}+\vec{\sigma}\cdot\vec{p})\chi=0
\end{aligned}~~\Rightarrow~~\begin{aligned}
    \frac{\vec{\sigma}\cdot\vec{p}}{|\vec{p}|}\eta=\eta\\
    \frac{\vec{\sigma}\cdot\vec{p}}{|\vec{p}|}\chi=-\chi
\end{aligned}\]</span></p>
<p>where we have set <span class="math inline">\(E=|\vec{p}|\)</span>,
which is valid for massless particles. We see that for a massless
particle, the Dirac equation breaks up into two independent equations
acting on two defferent two-component spinors. These two equations are
known as the Weyl equations.</p>
<p>If we multiply those equations by <span
class="math inline">\(\hbar/2\)</span> and use the fact that <span
class="math inline">\(\hbar\vec{\sigma}/2\)</span> is the spin operator
<span class="math inline">\(\vec{S}\)</span>, we get</p>
<p><span
class="math display">\[\vec{S}\cdot\hat{p}\eta=\frac{\hbar}{2}\eta~~~~\vec{S}\cdot\hat{p}\chi=-\frac{\hbar}{2}\chi\]</span></p>
<p>The operator <span class="math inline">\(\vec{S}\cdot\hat{p}\)</span>
is called the helicity operator, and the corresponding eigenvalue is the
helicity of the state. This eigenvalue corresponds to the component of
the spin along the direction of the motion of the particle. We see that,
in massless limit, thw Weyl spinors are eigenstates of the helicity
operator.</p>
<h3 id="lorentz-transformations-and-invariants">Lorentz Transformations
and Invariants</h3>
<p>The infinitesimal transformations of the two Weyl spinors are:</p>
<p><span class="math display">\[\begin{aligned}
    \eta\rightarrow\eta&#39;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)\eta\\
    \chi\rightarrow\chi&#39;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)\chi\\
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\vec{\epsilon}\)</span> is the
infinitesimal rotation vector (the direction of <span
class="math inline">\(\vec{\epsilon}\)</span> gives the axis of
rotation, and its magnitude gives the amount of rotation), and <span
class="math inline">\(\vec{\beta}\)</span> is the infinitesimal boost
parameter.</p>
<p>This transformations show that the left-chiral and right-chiral
spinors transform independently under Lorentz transformations. They are
therefore inequivalent irreducible representations of the Lorentz group
and are the fundamental “building blocks” from which any other spinor
representation can be constructed. Because Lorentz algebra is equivalent
to the algebra <span
class="math inline">\(\mathfrak{su}(2)\times\mathfrak{su}(2)\)</span>,
all representations can be labeled by two numbers that are multiples of
one-half. The two fundamental representations then are described by the
quantum numbers <span class="math inline">\((\frac{1}{2},0)\)</span> and
<span class="math inline">\((0,\frac{1}{2})\)</span>, which describe the
left-chiral and right-chiral spinors respectively. By the way, even
though the algebra acting on the Weyl spinors is <span
class="math inline">\(\mathfrak{su}(2)\times\mathfrak{su}(2)\)</span>,
the group under which they transform is not <span
class="math inline">\(SO(2)\times SO(2)\)</span> but instead <span
class="math inline">\(SL(2,\mathbb{C})\)</span>, the universal covering
group of the Lorentz group <span
class="math inline">\(SO(3,1)\)</span>.</p>
<p>Now consider the kinetic term of the Dirac lagrangian <span
class="math inline">\(\overline{\Psi}\gamma^\mu P_\mu\Psi\)</span>.
Since this is invariant and <span class="math inline">\(P_\mu\)</span>
is a four-vector, the quantity <span
class="math inline">\(\overline{\Psi}\gamma^\mu\Psi\)</span> must
transform as a four-vector, so we find that</p>
<p><span
class="math display">\[\overline{\Psi}\gamma^\mu\Psi=\eta^\dagger\sigma^\mu\eta+\chi^\dagger\overline{\sigma}^\mu\chi\]</span></p>
<p>transform as a four-vector under Lorentz transformations, and it
turns out that each term on the right separately transform as a
four-vector.</p>
<h3 id="building-more-lorentz-invariants-out-of-weyl-spinors">Building
More Lorentz Invariants Out of Weyl Spinors</h3>
<p>First we consider <span class="math inline">\(\chi^{\dagger
T}\)</span>, we find that it transforms as</p>
<p><span class="math display">\[\begin{aligned}
   \chi^{\dagger T}\rightarrow (\chi^{\dagger
T})&#39;=(\chi&#39;)^{\dagger T}
&amp;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)^*\chi^{\dagger
T}\\
    &amp;=\left(\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}^*+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}^*\right)\chi^{\dagger
T}
\end{aligned}\]</span></p>
<p>This doesn’t transform like a right-chiral spinor. Now we use the
equation <span
class="math inline">\(\sigma^2\vec{\sigma}^*=-\vec{\sigma}\sigma^2\)</span>
and consider</p>
<p><span class="math display">\[\begin{aligned}
   i\sigma^2\chi^{\dagger T}\rightarrow (i\sigma^2\chi^{\dagger T})&#39;
&amp;=(i\sigma^2)^*\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)^*\chi^{\dagger
T}\\
    &amp;=(i\sigma^2)\left(\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}^*+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}^*\right)\chi^{\dagger
T}\\
    &amp;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)i\sigma^2\chi^{\dagger
T}
\end{aligned}\]</span></p>
<p>which is the transformation of right-chiral spinor! Since the
expression <span class="math inline">\(\eta^\dagger\chi\)</span> is
invariant under Lorentz tranformations and <span
class="math inline">\(i\sigma^2\chi^{\dagger T}\)</span> transforms like
<span class="math inline">\(\eta\)</span>, we can know that the
following expression is also invariant:</p>
<p><span class="math display">\[\begin{aligned}
    (i\sigma^2\chi^{\dagger
T})^T\chi&amp;=\chi^T(i\sigma^2)^\dagger\chi\\
    &amp;=\chi^T(-i\sigma^2)\chi
\end{aligned}\]</span></p>
<p>We also know that <span
class="math inline">\(\chi^\dagger\eta\)</span> is invariant, we obtain
a second invariant containing only left-chiral spinors:</p>
<p><span class="math display">\[\chi^\dagger i\sigma\chi^{\dagger
T}\]</span></p>
<p>Similarly, it’s easy to check that <span
class="math inline">\(-i\sigma^2\eta^{\dagger T}\)</span> transforms
like a left-chiral spinor.</p>
<p>Define the matrix <span class="math inline">\(A\)</span> as</p>
<p><span
class="math display">\[A=\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>so we have</p>
<p><span
class="math display">\[A^\dagger=\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma},~~A^{-1}=\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>In turn, this implies</p>
<p><span
class="math display">\[(A^{-1})^\dagger=(A^\dagger)^{-1}=\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>We can write:</p>
<p><span class="math display">\[\begin{aligned}
    \eta&amp;\rightarrow A\eta\\
    i\sigma^2\chi^{\dagger T}&amp;\rightarrow A(i\sigma^2\chi^{\dagger
T})\\
    \chi&amp;\rightarrow (A^\dagger)^{-1}\chi\\
    -i\sigma^2\eta^{\dagger T}&amp;\rightarrow
(A^\dagger)^{-1}(-i\sigma\eta^{\dagger T})
\end{aligned}\]</span></p>
<p>This gives eight combinations, but it turns out that only six of
those are independent, which be taken to be</p>
<p><span class="math display">\[\boxed{\begin{aligned}
    -\chi^T i\sigma^2\chi~~~~&amp;\chi^\dagger i\sigma^2\chi^{\dagger
T}\\
    \chi^\dagger \eta~~~~&amp;\eta^\dagger\chi\\
    -\eta i\sigma^2\eta^{\dagger T}~~~~&amp;\eta^Ti\sigma^2\eta
\end{aligned}}\]</span></p>
<h3 id="invariants-containing-lorentz-indeces">Invariants Containing
Lorentz Indeces</h3>
<p>We have seen, by looking at the Dirac equation written in terms of
Weyl spinors, that <span class="math inline">\(\sigma^\mu
i\partial_\mu\eta\)</span> transforms like a left-chiral spinor and
<span class="math inline">\(\overline{\sigma}^\mu
i\partial_\mu\chi\)</span> transforms like a right-chiral spinor.</p>
<p>To build Lorentz invariants containing derivatives, we simply have to
use the expressions in the box above with the <span
class="math inline">\(\chi\)</span> appearing in those equations
replaced by <span class="math inline">\(\sigma^\mu
i\partial_\mu\eta\)</span> or the <span
class="math inline">\(\eta\)</span> replaced by <span
class="math inline">\(\overline{\sigma}^\mu
i\partial_\mu\chi\)</span>.</p>
<p>As examples, we have</p>
<p><span class="math display">\[\begin{aligned}
    \chi^\dagger\eta&amp;\rightarrow \chi^\dagger\overline{\sigma}^\mu
i\partial_\mu \chi\\
    \eta^\dagger\chi&amp;\rightarrow(\overline{\sigma}^\mu
i\partial_\mu\chi)^\dagger\chi=-i(\partial_\mu\chi^\dagger)\overline{\sigma}^\mu\chi
\end{aligned}\]</span></p>
<p>As part of a lagrangian density, however, an integration by parts can
be used to show that the terms above are equivalent to each other after
discarding a surface term. We will always assume that the surface terms
vanish so that we may write</p>
<p><span class="math display">\[\int \mathrm{d}^4xA\partial_\mu
B=-\int\mathrm{d}^4x(\partial_\mu A)B\]</span></p>
<h3 id="introduce-a-new-notation">Introduce a New Notation</h3>
<p>In practice, SUSY theorists work almost exclusively with left-chiral
spinors, even when considering supersymmetric extensions of the standard
model, so we really only need to focus on the two invariants built out
of a left-chiral spinor:</p>
<p><span class="math display">\[\chi^\dagger i\sigma^2\chi^{\dagger
T},~~\chi^T(-i\sigma^2)\chi\]</span></p>
<p>We define two new types of spinor dot products between left-chiral
Weyl spinors:</p>
<p><span
class="math display">\[\chi\cdot\chi=\chi^T(-i\sigma^2)\chi,~~\overline{\chi}\cdot\overline{\chi}=\chi^\dagger
i\sigma^2\chi^{\dagger T}\]</span></p>
<h2 id="the-physics-of-weyl-majorana-and-dirac-spinors">The Physics of
Weyl, Majorana, and Dirac Spinors</h2>
<p>Supersymmetric theories are often written in terms of Majorana
spinors, instead of Weyl spinors or Dirac spinors.</p>
<h3 id="charge-conjugation-and-antiparticles-for-dirac-spinors">Charge
Conjugation and Antiparticles for Dirac Spinors</h3>
<p>Charge conjugation is the operation that turns a field describing a
certain particle into a field describing the corresponding
antiparticle.</p>
<p>Consider a Dirac spinor corresponding to a certain particle <span
class="math inline">\(p\)</span>:</p>
<p><span class="math display">\[\Psi_p=\begin{pmatrix}
    \eta_p\\
    \chi_p
\end{pmatrix}\]</span></p>
<p>The antiparticle spinor is obtained by applying the
charge-conjugation operator to the particle state, we may write</p>
<p><span
class="math display">\[\Psi_p^c=\Psi_{\overline{p}}=\begin{aligned}
    \eta_{\overline{p}}\\
    \chi_{\overline{p}}
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(c\)</span> denotes charge
conjugation.</p>
<h2 id="the-supersymmetric-charges-and-their-algebra">The Supersymmetric
Charges and Their Algebra</h2>
<p>When a lagrangian is observed to possess some continuous symmetry,
the natural thing to do is to find the charges generating the symmetry,
also called the generators of the symmetry. Actually, as we will see,
what really matters is the algebra obeyed by the charges, i.e., the
commutation or anticommutation rules, not the charges themselves (as an
aside, when the algebra involves anticommutators, it is often referred
to as a graded Lie algebra).</p>
<h3 id="charges-general-discussion">Charges: General Discussion</h3>
<p>We firet consider a scalar field operator <span
class="math inline">\(\phi\)</span>. If a certain transformation is a
symmetry of the theory, it must leave unchanged the expectation value
<span class="math inline">\(\langle a|\phi|b\rangle\)</span>. Let us
focus now on spacetime transformations, and we have <span
class="math inline">\(\langle a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|\phi(x)|b\rangle\)</span>. We now introduce a new field operator <span
class="math inline">\(\phi&#39;\)</span> that we define by <span
class="math inline">\(\langle a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|\phi&#39;(x&#39;)|b\rangle\)</span>, so we get <span
class="math inline">\(\langle a|\phi&#39;(x&#39;)|b\rangle=\langle
a|\phi(x)|b\rangle\)</span>, thus <span
class="math inline">\(\phi&#39;(x&#39;)=\phi(x)\)</span>. This is
exactly how a scalar field behaves under a Lorentz transformation. We
write <span class="math inline">\(x&#39;=x-\delta x\)</span>, so we have
<span class="math inline">\(\phi&#39;(x-\delta x)=\phi(x)\)</span> or
<span class="math inline">\(\phi&#39;(x)=\phi(x+\delta x)\)</span>.</p>
<p>We now consider a field operator <span
class="math inline">\(\mathcal{F}\)</span> that transforms under some
representations of the Lorentz group (a vector, a spinor, etc.). Then we
have <span class="math inline">\(\langle
a&#39;|\mathcal{F}(x)|b&#39;\rangle=S(\Lambda)\langle
a|\mathcal{F}(x)|b\rangle\)</span>, where <span
class="math inline">\(S(\Lambda)\)</span> is the Lorentz transformation
matrix corresponding to the representation of the field operator.
Correspondingly, we have <span
class="math inline">\(\mathcal{F}&#39;(x)=S(\Lambda)\mathcal{F}(x+\delta
x)\)</span>.</p>
<p>Physically meaningful transformations preserve the norm of states and
therefore can be written in the form of unitary operators (or
antiunitary operators in the case of time inversal), namely, operators
satisfying <span class="math inline">\(U^\dagger=U^{-1}\)</span>. We
will take the transformation of states to be</p>
<p><span class="math display">\[|a\rangle\rightarrow
|a&#39;\rangle=U^\dagger|a\rangle,~~|b\rangle\rightarrow
|b&#39;\rangle=U^\dagger|b\rangle\]</span></p>
<p>We now have <span class="math inline">\(\langle
a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|U\phi(x&#39;)U^\dagger|b\rangle=\langle
a|\phi&#39;(x&#39;)|b\rangle\)</span>, which implies <span
class="math inline">\(\phi&#39;(x)=U\phi(x)U^\dagger\)</span>.</p>
<p>Now we are ready to introduce the charges generating the
transformations. Assume that the transformation we are interested in are
parametrized by a set of <span class="math inline">\(n\)</span>
infinitesimal parameters <span
class="math inline">\(\epsilon_1,\epsilon_2,\cdots,\epsilon_n\)</span>,
in which case there are necessarily <span
class="math inline">\(n\)</span> charges <span
class="math inline">\(Q_1,Q_2,\cdots,Q_n\)</span>. The charges are
defined through</p>
<p><span class="math display">\[U=\exp(\pm i\epsilon_iQ_i)=\exp(\pm
i\epsilon\cdot Q)\]</span></p>
<p>We get</p>
<p><span class="math display">\[\begin{aligned}
    \phi&#39;(x)&amp;\approx(1+\pm i\epsilon\cdot Q)\phi(x)(1\mp
i\epsilon\cdot Q)\\
            &amp;=\phi(x)\pm i\epsilon\cdot Q\phi(x)\mp
i\phi(x)\epsilon\cdot Q\\
            &amp;=\phi(x)\pm i[\epsilon\cdot Q,\phi(x)]
\end{aligned}\]</span></p>
<p>Let’s define <span
class="math inline">\(\delta\phi(x)=\phi&#39;(x)-\phi(x)\)</span>, we
obtain a very useful result:</p>
<p><span class="math display">\[\pm[\epsilon\cdot
Q,\phi]=-i\delta\phi\]</span></p>
<p>where the sign on the left-hand side is the same sign as the argument
of the exponential in the operator <span
class="math inline">\(U\)</span>.</p>
<p>In the case of spacetime symmetries, for a scalar field, we have
<span class="math inline">\(\delta\phi=\phi(x+\delta
x)-\phi(x)\)</span>, for a general field <span
class="math inline">\(\mathcal{F}\)</span>, we have instead <span
class="math inline">\(\delta\mathcal{F}(x)=S(\Lambda)\mathcal{F}(x+\delta
x)-\mathcal{F}(x)\)</span>.</p>
<p>As a simple example, consider a lagrangian density that is a function
of a single real scalar field <span
class="math inline">\(\mathcal{L}(\phi)\)</span>. The action <span
class="math inline">\(S=i\int \mathrm{d}^4x\mathcal{L}\)</span> is
obviously invariant under a transformation of the field</p>
<p><span class="math display">\[\phi(x^\mu)\rightarrow
\phi&#39;(x^\mu)=\phi(x^\mu+a^\mu)\]</span></p>
<p>where <span class="math inline">\(a^\mu\)</span> is a
constant-displacement four-vector. Therefore</p>
<p><span
class="math display">\[\delta\phi(x^\mu)=\phi(x^\mu+a^\mu)-\phi(x^\mu)\approx
a^\mu\partial_\mu\phi\]</span></p>
<p>Since there are four parameters, the four <span
class="math inline">\(a_\mu\)</span>, we introduce four charges that we
suggestively call <span class="math inline">\(P^\mu\)</span>, and write
the unitary operator as</p>
<p><span class="math display">\[U=\exp(ia^\mu P_\mu)\]</span></p>
<p>so we get</p>
<p><span
class="math display">\[a^\mu[P_\mu,\phi]=-ia^\mu\partial_\mu\phi\Rightarrow
[P_\mu,\phi]=-i\partial_\mu\phi\]</span></p>
<p>We next consider Lorentz transformation <span
class="math inline">\(x^\mu\rightarrow \Lambda^\mu_\nu x^\nu\)</span>,
for an infinitesimal transformation, we may write</p>
<p><span class="math display">\[\begin{aligned}
    \Lambda^\mu_\nu x^\nu&amp;\approx x^\mu+\omega^\mu_\nu x^\nu\\
                         &amp;=x^\mu+\omega^{\mu\nu}x_\nu
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\omega^{\mu\nu}\)</span> is
antisymmetric, <span
class="math inline">\(\omega^{\mu\nu}=-\omega^{\nu\mu}\)</span>.</p>
<p>We write the unitary operator implementing Lorentz transformation on
a scalar field as</p>
<p><span
class="math display">\[U=\exp\left(-\frac{i}{2}\omega^{\mu\nu}M_{\mu\nu}\right)\]</span></p>
<p>where the charges <span class="math inline">\(M^{\mu\nu}\)</span> are
also antisymmetric.</p>
<p>The transformation og the field is given by <span
class="math inline">\(\delta\phi=\phi(x+\omega^{\mu\nu}x_\nu)-\phi(x^\mu)\)</span>,
and <span
class="math inline">\(\delta\phi=\frac{1}{2}\omega^{\mu\nu}(x_\nu\partial_\mu-x_\mu\partial_\nu)\phi\)</span>,
so we have</p>
<p><span
class="math display">\[[M_{\mu\nu},\phi]=i(x_\nu\partial_\nu-x_\mu\partial_\nu)\phi\]</span></p>
<p>We finally consider the <span class="math inline">\(U(1)\)</span>
transformation <span class="math inline">\(\phi\rightarrow
e^{i\alpha}\phi\)</span> with <span
class="math inline">\(\alpha\)</span> being a constant parameter, in
this case, <span class="math inline">\(\delta\phi=i\alpha\phi\)</span>.
Writing <span class="math inline">\(U=\exp(i\alpha Q)\)</span>, we
have</p>
<p><span class="math display">\[[Q,\phi]=\phi\]</span></p>
<h3
id="explict-representations-of-the-charges-and-the-charge-algebra">Explict
Representations of the Charges and the Charge Algebra</h3>
<p>The first strategy thet one can work out the algebra of the charges
are the following steps:</p>
<p><span class="math display">\[\rm{Field~ transformations}\Rightarrow
\rm{currents}\Rightarrow\rm{charges~as~quantum~fields}\Rightarrow\rm{algebra}\]</span></p>
<p>It consists of building a set of currents <span
class="math inline">\(J_\mu^i\)</span> associated with the symmetry from
which the corresponding charges are found by integrating over space
thezeroth component of the currents:</p>
<p><span
class="math display">\[Q^i=\int\mathrm{d}^3xJ_0^i(\vec{x},t)\]</span></p>
<p>It is important to note that in this approach, the charges (and the
currents) are themselves quantum field operators. The algebra of the
charges then can be found using the equal time commutation relations of
the fields present in the theory.</p>
<p>In the case of spacetime symmetries, there is a second explict
representation of the charges available: as differential operators (not
quantum field operators) acting on the fields. The differential operator
representation of the charge is defined via</p>
<p><span class="math display">\[\begin{aligned}
    \phi(x&#39;)&amp;=\exp(\pm i\epsilon_i\hat{Q}_i)\phi(x)\\
            &amp;\approx\phi(x)\pm i\epsilon_i\hat{Q}_i\phi(x)
\end{aligned}\]</span></p>
<p>We first consider <span class="math inline">\(U=\exp(-ia^\mu
\hat{P}_\mu)\)</span>, we have <span
class="math inline">\(\phi(x)+a^\mu\partial_\mu\phi(x)=\phi(x)-ia^\mu\hat{P}_\mu\phi(x)\)</span>,
which leads to</p>
<p><span class="math display">\[\hat{P}_\mu=i\partial_\mu\]</span></p>
<p>For the differential operators <span
class="math inline">\(\hat{M}_{\mu\nu}\)</span> on a scalar field, we
have</p>
<p><span
class="math display">\[\phi(x&#39;)=\exp\left(\frac{i}{2}\omega^{\mu\nu}\hat{M}_{\mu\nu}\right)\phi\]</span></p>
<p>we can prove that</p>
<p><span
class="math display">\[\hat{M}_{\mu\nu}=i(x_\mu\partial_\nu-x_\nu\partial_\mu)\]</span></p>
<p>Finally, we can use the representations of the operators <span
class="math inline">\(P^\mu\)</span> and <span
class="math inline">\(M^{\mu\nu}\)</span> as differential operators to
show that they obey the so-called Poincare algebra:</p>
<p><span class="math display">\[\begin{aligned}
    [P_\mu,P_\nu]&amp;=0\\
    [M_{\mu\nu},P_\lambda]&amp;=i(\eta_{\nu\lambda}P_\mu-\eta_{\lambda\mu}P_{\nu})\\
    [M_{\mu\nu},M_{\rho\sigma}]&amp;=i(\eta_{\nu\rho}M_{\mu\sigma}-\eta_{\nu\sigma}M_{\mu\rho}-\eta_{\mu\rho}M_{\nu\sigma}+\eta_{\mu\sigma}M_{\nu\rho})
\end{aligned}\]</span></p>
<h3 id="finding-the-algebra-without-the-explicit-charges">Finding the
Algebra Without the Explicit Charges</h3>
<p>In this section, all the charges have to be thought of as quantum
field operators, not differential operators.</p>
<p>We first consider two successive transformations applied to a field
<span class="math inline">\(\phi\)</span>: the first transformation with
parameters <span class="math inline">\(\alpha_i\)</span>, followed by
the second tranformation with parameters <span
class="math inline">\(\beta_j\)</span>. We have:</p>
<p><span class="math display">\[\begin{aligned}
    U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger&amp;=\exp(i\beta\cdot Q)\exp(i\alpha\cdot
Q)\phi\exp(-i\alpha\cdot Q)\exp(-i\beta\cdot Q)\\
    &amp;\approx \phi+i[\beta\cdot Q,\phi]+i[\alpha\cdot
Q,\phi]-[\beta\cdot Q,[\alpha\cdot Q,\phi]]+\cdots
\end{aligned}\]</span></p>
<p>We write</p>
<p><span class="math display">\[U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger=\delta_\beta\delta_\alpha\phi\]</span></p>
<p>Consider</p>
<p><span
class="math display">\[\delta_\beta\delta_\alpha\phi-\delta_\alpha\delta_\beta\phi\]</span></p>
<p>which is equal to</p>
<p><span class="math display">\[U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger- U_\alpha U_\beta\phi  U_\beta^\dagger
U_\alpha^\dagger\approx -[\beta\cdot Q,[\alpha\cdot
Q,\phi]]+[\alpha\cdot Q,[\beta\cdot Q,\phi]]\]</span></p>
<p>If we expand this out, being careful about the order of all the
quantities involved, we find that half the terms cancel out, leaving</p>
<p><span
class="math display">\[\delta_\beta\delta_\alpha\phi-\delta_\alpha\delta_\beta\phi=[[\alpha\cdot
Q,\beta\cdot Q],\phi]\]</span></p>
<h3 id="the-susy-algebra">The SUSY Algebra</h3>
<p>There is the two-component spinor <span
class="math inline">\(\zeta\)</span> and its complex conjugate <span
class="math inline">\(\zeta^*\)</span> for a total of four parameters.
We therefore need four charges <span
class="math inline">\(Q_1,Q_2,Q_1^\dagger,Q_2^\dagger\)</span>, which we
can group into a Weyl spinor, that we will call <span
class="math inline">\(Q\)</span>, and its hermitian conjugate <span
class="math inline">\(Q^\dagger\)</span>. These SUSY charges are also
referred to as supercharges.</p>
<p>We choose to make <span class="math inline">\(Q\)</span> a
left-chiral spinor, so we have</p>
<p><span
class="math display">\[Q\cdots\zeta=Q(-i\sigma^2)\zeta,~~\overline{Q}\cdot\overline{\zeta}=Q^\dagger
i\sigma^2\zeta^*\]</span></p>
<p>(recall that <span class="math inline">\(\zeta\)</span> is not a
quantum field operator, so we write <span
class="math inline">\(\zeta^{\dagger T}\)</span> simply as <span
class="math inline">\(\zeta^*\)</span>).</p>
<p>The unitary operator <span class="math inline">\(U\)</span>
generating SUSY transformations therefore is given by</p>
<p><span
class="math display">\[U_\zeta=\exp(iQ\cdot\zeta+i\overline{Q}\cdot\overline{\zeta})\]</span></p>
<p>We get</p>
<p><span class="math display">\[\begin{aligned}
    [Q\cdot\zeta+\overline{Q}\cdot\overline{\zeta},\phi]&amp;=-i\zeta\cdot\chi\\
    [Q\cdot\zeta+\overline{Q}\cdot\overline{\zeta},\chi]&amp;=-i(\partial_\mu\phi)\sigma^\mu\sigma^2\zeta^*\\
\end{aligned}\]</span></p>
<p>which implies</p>
<p><span class="math display">\[\begin{aligned}
    [Q\cdot\zeta,\phi]&amp;=-i\zeta\cdot\chi\\
    [\overline{Q}\cdot\overline{\zeta},\chi]&amp;=-i(\partial_\mu\phi)\sigma^\mu\sigma^2\zeta^*\\
    [\overline{Q}\cdot\overline{\zeta},\phi]&amp;=[Q\cdot\zeta,\chi]=0
\end{aligned}\]</span></p>
<h2 id="applications-of-the-susy-algebra">Applications of the SUSY
Algebra</h2>
<h3
id="classification-of-states-using-the-algebra-review-of-the-poincare-group">Classification
of States Using the Algebra: Review of the Poincare Group</h3>
<p>We first briefly review some basic representations og the Poincare
group on one particle states.</p>
<p>Casimir operator are operators that commute with all the generators
of the group. These operators are of key importance in building
representations because their eigenvalues can be used to classify the
representations of the group. One Casimir operator of the Poincare group
is the squared momentum generator <span class="math inline">\(P^\mu
P_\mu\)</span>, and this obviously commutes with the momentum
generators. The eigenvalue of <span class="math inline">\(P^\mu
P_\mu\)</span> is <span class="math inline">\(m^2\)</span>, which is
therefore one of the parameters used to classify one-particle
states.</p>
<p>The second Casimir operator is build out of the so-called
Pauli-Lubanski operator <span class="math inline">\(W_\mu\)</span>,
defined as</p>
<p><span
class="math display">\[W^\mu=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu\]</span></p>
<p>where <span
class="math inline">\(\epsilon^{\mu\nu\rho\sigma}\)</span> is the
totally antisymmetric Levi-Civita symbol in four dimensions. We will use
the normalization <span
class="math inline">\(\epsilon_{0123}=1\)</span>, which implies <span
class="math inline">\(\epsilon^{0123}=-1\)</span>. With this
normalization, it’s clear that <span
class="math inline">\(\epsilon^{0ijk}=-\epsilon^{ijk}\)</span>.</p>
<p>Note that we have</p>
<p><span class="math display">\[W^\mu
P_\mu=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu
P_\mu=0\]</span></p>
<p>which is obvious beacuse <span class="math inline">\(P_\nu
P_\mu\)</span> is symmetric. But it is not as obvious that <span
class="math inline">\(P_\mu W^\mu\)</span> is also equal to zero, and we
have <span class="math inline">\([P_\mu,W^\mu]=0\)</span>.</p>
<p>With some effort, one can show that <span class="math inline">\(W^\mu
W_\mu\)</span> also commutes with all the generators of the Poincare
group, so it is our second Casimir operator.</p>
<p>To uncover the physicial signification of the Pauli-Lubanski
operator, consider first massive particles. In that case, we can choose
to work in the rest frame of the particle, where its four-momentum is
simply <span class="math inline">\(p^\mu=p_\mu=(m,\vec{0})\)</span>, so
we have</p>
<p><span
class="math display">\[P_\mu|p\rangle=P_0|p\rangle=m|p\rangle\]</span></p>
<p>Let us now apply the Pauli-Lubanski operator to this state</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu|p\rangle&amp;=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu|p\rangle\\
    &amp;=\frac{1}{2}\epsilon^{\mu
0\rho\sigma}M_{\rho\sigma}P_0|p\rangle\\
    &amp;=\frac{m}{2}\epsilon^{\mu 0\rho\sigma}M_{\rho\sigma}|p\rangle\\
\end{aligned}\]</span></p>
<p>We can essily see that</p>
<p><span class="math display">\[W^0|p\rangle=0\]</span></p>
<p>and</p>
<p><span class="math display">\[\begin{aligned}
    W^i|p\rangle&amp;=\frac{m}{2}\epsilon^{i0jk}M_{jk}|p\rangle\\
    &amp;=-\frac{m}{2}\epsilon^{0ijk}M_{jk}|p\rangle\\
    &amp;=\frac{m}{2}\epsilon^{ijk}M_{jk}|p\rangle\\
\end{aligned}\]</span></p>
<p>It turns out that the operator <span
class="math inline">\(frac{1}{2}\epsilon^{ijk}M_{jk}\)</span> is simply
the total angular momentum of the particle, i.e.,</p>
<p><span
class="math display">\[\frac{1}{2}\epsilon^{ijk}M_{jk}=L^i+S^i\]</span></p>
<p>We therefore have</p>
<p><span
class="math display">\[W^i|p\rangle=m(S^i+L^i)|p\rangle\]</span></p>
<p>which, in the rest frame, reduced to</p>
<p><span class="math display">\[W^i|p\rangle=mS^i|p\rangle\]</span></p>
<p>So the Casimir operator <span class="math inline">\(W_\mu
W^\mu\)</span> acting on this state gives</p>
<p><span class="math display">\[W_\mu W^\mu|p\rangle=W^0
W^0|p\rangle-W^iW^i|p\rangle=-m^2\vec{S}^2|p\rangle=-m^2s(s+1)|p\rangle\]</span></p>
<p>We now see that the second porperty that can be used to specify the
masssive representation of the Lorentz group is the spin (or total
angular momentum, if we are not working in the rest frame).</p>
<p>To classify all these possible states of a massive particle at rest,
we need a complete set of commuting observables. In addition to the
four-momentum squared (whose eigenvalue is <span
class="math inline">\(m^2\)</span>) and the square of the spin, we also
may use the component of the spin along the z axis, <span
class="math inline">\(S_z\)</span>, because this operator obviously
commutes with <span class="math inline">\(P_\mu P^\mu\)</span> and with
<span class="math inline">\(\vec{S}^2\)</span>. Note that</p>
<p><span class="math display">\[W^3=m(L_z+S_z)\]</span></p>
<p>which, in the rest frame of the particle, reduces to <span
class="math inline">\(W^3=mS_z\)</span>.</p>
<p>Therefore, massive states are labeled in their rest frame by three
quantum numbers: <span class="math inline">\(p,s,s_z\)</span>, with</p>
<p><span class="math display">\[\begin{aligned}
    P^\mu|p,s,s_z\rangle&amp;=m|p,s,s_z\rangle\\
    W_\mu W^\mu|p,s,s_z\rangle&amp;=-m^2\vec{S}^2|p,s,s_z\rangle\\
    &amp;=-m^2s(s+1)|p,s,s_z\rangle\\
    \frac{W^3}{m}|p,s,s_z\rangle&amp;=S_z|p,s,s_z\rangle=s_z|p,s,s_z\rangle
\end{aligned}\]</span></p>
<p>As we know from quantum mechanics, <span
class="math inline">\(s_z\)</span> may take <span
class="math inline">\(2s+1\)</span> values, ranging from <span
class="math inline">\(-s\)</span> to <span
class="math inline">\(+s\)</span> in integer steps.</p>
<p>Now consider massless particles. In this case, we cannot go to the
rest frame of the particle, but we may choose to work in a frame where
the four-momentum is given by</p>
<p><span class="math display">\[p^\mu=(E,0,0,E)\]</span></p>
<p>We will denote the corresponding stste by <span
class="math inline">\(|p\rangle_0\)</span>. We then have</p>
<p><span class="math display">\[\begin{aligned}
    P^\mu|p\rangle_0&amp;=(P^0,P^1,P^2,P^3)|p\rangle_0\\
                    &amp;=(E,0,0,E)|p\rangle_0
\end{aligned}\]</span></p>
<p>or</p>
<p><span class="math display">\[\begin{aligned}
    &amp;P^1|p\rangle_0=P^2|p\rangle_0=0\\
    &amp;P^0|p\rangle_0=P^3|p\rangle_0=E|p\rangle_0
\end{aligned}\]</span></p>
<p>We can write <span
class="math inline">\(P^\mu|p\rangle_0=(P^3,0,0,P^3)|p\rangle_0\)</span>.</p>
<p>It turns out that like <span class="math inline">\(P^\mu P_\mu, W^\mu
W_\mu\)</span> gives zero when acting on a massless one-particle state.
The proof can be found in Wigner’s original paper. The fact that <span
class="math inline">\(W^\mu W_\mu\)</span> gives zero when applied to a
one-particle massless state, together with <span
class="math inline">\(W^\mu P_\mu=0\)</span>, implies that when acting
on such a state, the operator <span class="math inline">\(W^\mu\)</span>
is proportional to the four-momentum operator</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=hP^\mu|p\rangle_0\]</span></p>
<p>Now we prove this, consider</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu
P_\mu|p\rangle_0&amp;=(W^0P^0-W^1P^1-W^2P^2-W^3P^3)|p\rangle_0\\
    &amp;=(W^0P^0-W^3P^3)|p\rangle_0\\
    &amp;=E(W^0-W^3)|p\rangle_0=0
\end{aligned}\]</span></p>
<p>so we conclude that</p>
<p><span
class="math display">\[W^0|p\rangle_0=W^3|p\rangle_0\]</span></p>
<p>Using this we have</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu W_\mu&amp;=(W^0W_0-W^1W_1-W^2W_2-W^3W_3)|p\rangle_0\\
               &amp;=-(W^1W_1+W^2W_2)|p\rangle_0=0
\end{aligned}\]</span></p>
<p>so we obtain</p>
<p><span
class="math display">\[W^1|p\rangle_0=W^2|p\rangle_0=0\]</span></p>
<p>Therefore, when acting on the state, the action of the operator <span
class="math inline">\(W^\mu\)</span> reduces to</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=(W^3,0,0,W^3)|p\rangle_0\]</span></p>
<p>From <span class="math inline">\([P_\mu,W^\mu]=0\)</span> we know
that <span class="math inline">\(W^3\)</span> commutes with <span
class="math inline">\(P^3\)</span>, so we may take <span
class="math inline">\(|p\rangle_0\)</span> to be a common eigenstate of
these two operators. This implise that we may write</p>
<p><span
class="math display">\[W^3|p\rangle_0=hP^3|p\rangle_0\]</span></p>
<p>Using <span
class="math inline">\(P^\mu|p\rangle_0=(P^3,0,0,P^3)|p\rangle_0\)</span>
and <span
class="math inline">\(W^\mu|p\rangle_0=(W^3,0,0,W^3)|p\rangle_0\)</span>
we can conclude that</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=hP^\mu|p\rangle_0\]</span></p>
<p>as we had set out to prove.</p>
<p>To find out what the constant <span class="math inline">\(h\)</span>
represents, we consider</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu|p\rangle_0&amp;=(hE,0,0,hE)|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~~W^3|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow E(S_z+L_z)|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~Es_z|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~~~~~~~~~~~~h&amp;=s_z
\end{aligned}\]</span></p>
<p>Since our state has its momentum along the z direction, we may
write</p>
<p><span class="math display">\[h=\vec{s}\cdot\hat{p}\]</span></p>
<p>which is nothing other than the helicity of the perticle.</p>
<p>So massless representations of the Lorentz group are therefore
completely specified by only two numbers: their energy (which then
specifies their four-momentum) and their helicity <span
class="math inline">\(h\)</span>. The reason we don’t have <span
class="math inline">\(2s+1\)</span> states lies in <span
class="math inline">\(W^1|p\rangle_0=W^2|p\rangle_0=0\)</span>, which
reveals that we do not have any ladder operators to change the z
component of the spin. Therefore, there is only one spin state.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第三章:Verilog HDL程序设计语句和描述方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 06:25:45" itemprop="dateModified" datetime="2026-01-15T06:25:45+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据流建模">数据流建模</h2>
<p>数据流建模只有一种方式, 就是<strong>连续赋值语句</strong>,
连续赋值语句<strong>只能对wire赋值</strong>,
<strong>不能对reg赋值</strong>.</p>
<p>连续赋值语句包括显式连续赋值语句和隐式连续赋值语句,
通常使用显式连续赋值语句, 其格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> &lt;range&gt; &lt;name&gt;;<span class="comment">//声明wire型变量，定义位宽和连线名</span></span><br><span class="line"><span class="keyword">assign</span> #&lt;delay&gt;&lt;name&gt; = 表达式;<span class="comment">//delay是从表达式内信号发生变化的时刻到wire型变量取值被更新时的时间延迟</span></span><br></pre></td></tr></table></figure>
<p>隐式赋值语句为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;net_declaration&gt;&lt;drive_strength&gt;&lt;range&gt;#&lt;delay&gt;&lt;name&gt;=assignment expression;</span><br></pre></td></tr></table></figure>
<p>注意<code>&lt;drive_strength&gt;</code>只能在隐式赋值语句中被指定,
用来对连线型变量受到的驱动强度进行指定.
例如<code>wire(weak0, strong1)out=in1&amp;in2</code>表示给<code>out</code>赋<code>0</code>时的驱动强度为<code>weak</code>,
赋<code>1</code>时的驱动强度为<code>strong</code>. 如果赋值驱动强度缺省,
那么默认为<code>(strong1, strong0)</code>.</p>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>连续赋值语句只能对<code>wire</code>赋值,
不能对<code>reg</code>赋值;</li>
<li>在连续赋值语句中, 只要赋值语句右边表达式发生变化,
则表达式立即被计算然后赋给左边的<code>wire</code>型变量(如果没有定义延时量),
这种特性正是组合逻辑电路的特点;</li>
<li>连续赋值语句不能出现在过程块中;</li>
<li>多个连续赋值语句是并行关系;</li>
<li>数据流建模所有变量均为<code>wire</code>型.</li>
</ul>
<h2 id="行为级建模">行为级建模</h2>
<p>行为级建模就是从电路外部特性进行描述, 和C语言类似,
行为描述模块称为描述体</p>
<p><strong>描述体 = 过程块 + 连续赋值语句</strong> <strong>过程块 =
过程语句(initial、always) +
语句块(过程赋值语句、高级程序语句)</strong></p>
<p>行为级建模所有变量均为<code>reg</code>型,
包括过程语句(<code>initial</code>，<code>always</code>),
语句块(<code>begin-end</code>, <code>fork-join</code>),
赋值语句(阻塞或非阻塞), 条件分支语句(<code>if-else</code>,
<code>case</code>), 循环语句(<code>forever</code>, <code>repeat</code>,
<code>while</code>, <code>for</code>)等,
这里面只有过程连续赋值语句(<code>assign-deassign</code>,
<code>force-release</code>)可以对<code>wire</code>型变量赋值.</p>
<h3 id="过程语句initial和always">过程语句：initial和always</h3>
<p>过程语句具有很强的功能, 大多数高级程序语句都是在过程中使用的.
它既可以描述时序逻辑电路, 也可以描述组合逻辑电路.
采用过程语句进行程序设计时, 需要遵循一定的设计要求和规范.</p>
<p>在信号的形式定义方面, 无论是时序还是组合逻辑电路,
在过程语句(<code>initial</code>和<code>always</code>)中,
被赋值的变量必须是<code>reg</code>类型的.</p>
<p>在敏感事件列表方面:</p>
<p>对于<strong>组合电路</strong>,
需要把<strong>全部的输入信号</strong>列入敏感事件列表.</p>
<p>对于<strong>时序电路</strong>,
需要把<strong>时间信号</strong><code>clk</code>和<strong>部分输入信号</strong>列入敏感事件列表.</p>
<h4 id="initial的用法">initial的用法</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          语句<span class="number">1</span>;</span><br><span class="line">          语句<span class="number">2</span>;</span><br><span class="line">          ...;</span><br><span class="line">          语句n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>initial</code>过程块在仿真时从模拟0时刻开始执行, 只执行一次.
在执行完以后该<code>initial</code>过程块就被挂起, 不再执行.
如果一个模块中存在多个<code>initial</code>过程块,
那么每个<code>initial</code>过程块都是从0时刻开始并行执行的.
<code>initial</code>过程块内部的多条行为语句可以是顺序执行,
也可以是并行执行.</p>
<p><code>initial</code>过程语句通常用于仿真模块中对激励向量的描述,
或用于给寄存器赋初值.</p>
<h4 id="always的用法">always的用法</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(&lt;敏感事件列表&gt;)</span><br><span class="line">    语句块;</span><br></pre></td></tr></table></figure>
<p>敏感事件列表就是触发条件, 当敏感事件列表中的变量改变时,
语句块立即执行. 因此, 敏感事件列表中必须列出影响块内取值的所有信号.
若有两个或者两个以上的信号,
则它们之间可以用<code>or</code>或者<code>,</code>来连接.
敏感信号可以分为两种类型, 一种是边沿敏感型, 另一种是电平敏感型.
对于时序电路, 事件通常是由时钟边沿触发的.
<code>posedge</code>和<code>negedge</code>分别表示信号的上升沿和下降沿.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(a <span class="keyword">or</span> b);</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst);</span><br></pre></td></tr></table></figure>
<h4 id="例子">例子</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> initial_tb1;</span><br><span class="line">    <span class="keyword">reg</span> A,B,C;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        A=<span class="number">0</span>;B=<span class="number">1</span>;C=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> A=<span class="number">1</span>;B=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> A=<span class="number">0</span>;C=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> B=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> B=<span class="number">0</span>;C=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//initial语句代码例1，可以用modelsim仿真</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> initial_tb2;</span><br><span class="line">    <span class="keyword">reg</span> S1;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        S1=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> S1=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span> S1=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">50</span>  S1=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//initial语句代码例2，可以用modelsim仿真</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4_1 (out,in0,in1,in2,in3,sel);</span><br><span class="line">    <span class="keyword">input</span>           in0,in1,in2,in3;</span><br><span class="line">    <span class="keyword">input</span>   [<span class="number">1</span>:<span class="number">0</span>]   sel;</span><br><span class="line">    <span class="keyword">output</span>          out;</span><br><span class="line">    <span class="keyword">reg</span>             out;</span><br><span class="line">        <span class="keyword">always</span> @(in0 <span class="keyword">or</span> in1 <span class="keyword">or</span> in2 <span class="keyword">or</span> in3 <span class="keyword">or</span> sel)<span class="comment">//只要括号里面的信号发生改变，就会执行下面的语句块</span></span><br><span class="line">            <span class="keyword">case</span> (sel)</span><br><span class="line">                <span class="number">2&#x27;b00</span>: out=in0;</span><br><span class="line">                <span class="number">2&#x27;b01</span>: out=in1;</span><br><span class="line">                <span class="number">2&#x27;b10</span>: out=in2;</span><br><span class="line">                <span class="number">2&#x27;b11</span>: out=in3;</span><br><span class="line">                <span class="keyword">default</span>:  out=<span class="number">2&#x27;bx</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现4选1数据选择器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter1 (out,data,load,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]    data;</span><br><span class="line">    <span class="keyword">input</span>           load,clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (!rst)       out=<span class="number">8&#x27;h00</span>;<span class="comment">//注意这是同步清零，因为只有在clk上升时，rst信号才有效</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(load)   out=data;</span><br><span class="line">            <span class="keyword">else</span>            out=out+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现同步置数，同步清零计数器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter2 (rst,clk,out);</span><br><span class="line">    <span class="keyword">input</span>           clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)<span class="comment">//这是异步清零</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(!rst)    out=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>        out=out+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现异步清零计数器,异步清零的触发信号rst放在always@的括号里面,这样,只要rst发生变化,就会发生清零.</span></span><br></pre></td></tr></table></figure>
<h3 id="语句块">语句块</h3>
<p>在过程语句中, 如果语句数<strong>超过一条</strong>时, 就要采用语句块.
用<code>begin-end</code>和<code>fork-join</code>将一组行为打包起来.</p>
<h4 id="串行语句块和并行语句块">串行语句块和并行语句块</h4>
<p>串行语句块的关键字是<code>begin</code>和<code>end</code>,
其中的语句按照串行方式顺序执行, 既可以用于可综合电路,
也可以用于仿真测试程序.</p>
<p>串行语句块的特点是:</p>
<ol type="1">
<li>串行语句块中的每条指令语句依据块中的排列顺序<strong>依次逐条执行</strong>.
每条语句的延迟时间都是相对于前一条语句执行结束的时间.</li>
<li>串行语句块的起始时间就是第一条语句开始执行的时间,
结束时间就是最后一条语句执行结束的时间.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb1;</span><br><span class="line">    <span class="keyword">reg</span> wave;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">           wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">        #T wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">        #T wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用begin和end串行语句块生成一个波形</span></span><br></pre></td></tr></table></figure>
<p>并行语句块的关键字是<code>fork</code>和<code>join</code>,
其中的语句并行执行, 只能用于仿真测试程序, 不能用于可综合电路程序.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb2;</span><br><span class="line">    <span class="keyword">reg</span> wave;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">               wave=<span class="number">0</span>;</span><br><span class="line">        #T     wave=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(2*T)</span> wave=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(3*T)</span> wave=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(4*T)</span> wave=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(5*T)</span> wave=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用fork和join并行语句块生成一个波形，这个波形和上面是一样的</span></span><br></pre></td></tr></table></figure>
<h3 id="过程赋值语句">过程赋值语句</h3>
<p>过程块中的赋值语句就是过程赋值语句,
过程性赋值是指在<code>initial</code>和<code>always</code>语句内的赋值,
即只能对<code>reg</code>类型的变量赋值.</p>
<p>对于多个位宽的<code>reg</code>类型变量,
还可以对其中的一位或者几位进行赋值. 对于存储器类型的,
则只能通过选定的地址单元, 对某个字进行赋值.
还可以将前面各类变量拼接起来进行赋值.</p>
<h4 id="阻塞和非阻塞赋值语句">阻塞和非阻塞赋值语句</h4>
<p>过程赋值语句包括阻塞和非阻塞赋值语句两种,
这两种赋值语句只针对串行语句块而言.</p>
<h5 id="阻塞赋值语句">阻塞赋值语句</h5>
<p>阻塞赋值语句用<code>=</code>进行赋值, 有如下特点:</p>
<ol type="1">
<li>一个语句块中有多条阻塞赋值语句时, 如果前面的赋值语句没有完成,
则后面的语句就不能执行;</li>
<li>在串行语句块(<code>begin-end</code>)中,
各条阻塞语句将按照排列顺序依次执行;
在并行语句块(<code>fork-join</code>)中, 各条阻塞语句同时执行;</li>
<li>对于一条阻塞赋值语句, 先计算等号右边的值,
然后立即赋给左边的变量.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> block1 (din,clk,out1,out2);</span><br><span class="line">    <span class="keyword">input</span>   din,clk;</span><br><span class="line">    <span class="keyword">output</span>  out1,out2;</span><br><span class="line">    <span class="keyword">reg</span>     out1,out2;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out1=din;</span><br><span class="line">        out2=out1;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阻塞赋值语句，din的值先传给out1，然后out1的值再传给out2，最终结果是out2=out1=din</span></span><br></pre></td></tr></table></figure>
<h5 id="非阻塞赋值语句">非阻塞赋值语句</h5>
<p>非阻塞赋值语句用<code>&lt;=</code>进行赋值, 有如下特点:</p>
<ol type="1">
<li>一个语句块中有多条非阻塞赋值语句时,
后面语句的执行不会受到前面语句的限制;</li>
<li>在串行语句块(<code>begin-end</code>)中,
各条非阻塞语句的执行没有先后之分, 各条语句并行执行;</li>
<li>对于一条非阻塞赋值语句, 先计算等号右边的值, 然后等待延迟时间结束,
再赋给左边的变量.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> non_block1 (din,clk,out1,out2);</span><br><span class="line">    <span class="keyword">input</span>   din,clk;</span><br><span class="line">    <span class="keyword">output</span>  out1,out2;</span><br><span class="line">    <span class="keyword">reg</span>  out1,out2;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out1&lt;=din;</span><br><span class="line">        out2&lt;=out1;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//非阻塞赋值语句，在同一时刻，din的值传给out1，out1的值传给out2，最终结果是out2=原来的out1，out1=din</span></span><br></pre></td></tr></table></figure>
<h3 id="过程连续赋值语句">过程连续赋值语句</h3>
<p>前面已经讲过, 连续赋值(<code>assign</code>,
显式和隐式)只能对<code>wire</code>型变量赋值,
而过程语句(<code>initial</code>, <code>always</code>,
阻塞和非阻塞)只能对<code>reg</code>型变量赋值.
而过程连续赋值语句则可以在<code>initial</code>和<code>always</code>语句块中对<code>wire</code>和<code>reg</code>类型变量进行赋值.</p>
<p>过程连续赋值语句也有两种:</p>
<ol type="1">
<li>赋值语句和重新赋值语句(<code>assign</code>,
<code>deassign</code>);</li>
<li>强制, 释放语句(<code>force</code>, <code>release</code>).</li>
</ol>
<p>注意过程连续赋值语句不能对<code>reg</code>型变量进行位操作.</p>
<h4 id="赋值语句和重新赋值语句">赋值语句和重新赋值语句</h4>
<p>格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> &lt;<span class="keyword">reg</span>型变量&gt;=&lt;赋值表达式&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deassign</span> &lt;<span class="keyword">reg</span>型变量&gt;;</span><br></pre></td></tr></table></figure>
<p>赋值语句<code>assign</code>此时对<code>reg</code>型变量赋值,
此后该<code>reg</code>型变量一直保持被赋的值,
直到遇到<code>deassgin</code>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> assign_dff(d,clr,clk,q);</span><br><span class="line">    <span class="keyword">input</span>  d,clr,clk;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q;</span><br><span class="line">    <span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!clr) <span class="keyword">assign</span> q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>     <span class="keyword">deassign</span> q;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) q=d;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">/*当clr=0时，reg型变量q通过赋值语句被赋值为0，这时无论clk怎么变化，q始终等于0；</span></span><br><span class="line"><span class="comment">当clr=1时，q的强制赋值为0被解除，所以可以随着clk的变化将d赋给q*/</span></span><br></pre></td></tr></table></figure>
<h4 id="强制和释放语句">强制和释放语句</h4>
<p>格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">force</span> &lt;<span class="keyword">wire</span>型或<span class="keyword">reg</span>型变量&gt;=&lt;赋值表达式&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">release</span> &lt;<span class="keyword">wire</span>型或<span class="keyword">reg</span>型变量&gt;;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>force</code>的优先级高于<code>assign</code>;</li>
<li>当<code>force</code>对<code>reg</code>型变量进行赋值时,
<code>reg</code>型变量的当前值被<code>force</code>赋给它的值覆盖,
且不再改变, 直到遇到<code>release</code>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> force_release (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>  a,b;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    <span class="keyword">and</span>(out,a,b);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">force</span> out=a|b;</span><br><span class="line">        #<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">release</span> out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//注意，在测试的0时刻，and和initial同时生效，但是force语句强制使out=a|b,5个时间单位之后，out被释放，此时and起作用，out=a&amp;b。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> release_tb;</span><br><span class="line">    <span class="keyword">reg</span> a,b;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    force_release U1(a,b,out);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="条件分支语句">条件分支语句</h3>
<p>条件分支语句包括<code>if</code>, <code>case</code>语句</p>
<h4 id="if">if</h4>
<p><code>if</code>语句的格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式<span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span>(条件表达式) 语句块;</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span>(条件表达式) 语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>          语句块<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">格式<span class="number">3</span>:</span><br><span class="line"><span class="keyword">if</span>      (条件表达式<span class="number">1</span>)  语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)  语句块<span class="number">2</span>;</span><br><span class="line">    ...;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n)  语句块n;</span><br><span class="line"><span class="keyword">else</span>                  语句块n+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>只有当<code>if</code>后面的条件表达式为1时才执行后面的语句块.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2_1 (a,b,sel,out);</span><br><span class="line">    <span class="keyword">input</span>   a,b,sel;</span><br><span class="line">    <span class="keyword">output</span>  out;</span><br><span class="line">    <span class="keyword">reg</span>     out;</span><br><span class="line">    <span class="keyword">always</span> @(a,b,sel) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(sel) out=a;</span><br><span class="line">        <span class="keyword">else</span>    out=b;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是二选一数据选择器，当sel=1时，输出a；当sel=0时，输出b</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> compare_a_b (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>           a,b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">1</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(a,b) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)       out=<span class="number">2&#x27;b01</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==b) out=<span class="number">2&#x27;b10</span>;</span><br><span class="line">        <span class="keyword">else</span>          out=<span class="number">2&#x27;b11</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是数字比较器</span></span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<p>case语句的格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(控制表达式)</span><br><span class="line">      值<span class="number">1</span>:     语句块<span class="number">1</span>;</span><br><span class="line">      值<span class="number">2</span>:     语句块<span class="number">2</span>;</span><br><span class="line">      ...;</span><br><span class="line">      值n:     语句块n;</span><br><span class="line">      <span class="keyword">default</span>: 语句块n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>原理：当<code>case</code>后面括号里的<code>控制表达式</code>的值和<code>值i(i=1~n)</code>相等时,
就执行对应<code>语句块i</code>.
如果控制表达式的值和<code>值i(i=1~n)</code>都不相等时,
就执行<code>default</code>里面的<code>语句块n+1</code>. 注意,
当用<code>case</code>语句对控制表达式和其后的值进行比较时,
必须是一种全等的比较. 真值表如下:</p>
<table>
<thead>
<tr>
<th><code>case</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> BCD_decoder(in,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]    in;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">6</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(in) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(in)</span><br><span class="line">        <span class="number">4&#x27;b0000</span>:out=<span class="number">7&#x27;b1111110</span>;</span><br><span class="line">        <span class="number">4&#x27;b0001</span>:out=<span class="number">7&#x27;b0110000</span>;</span><br><span class="line">        <span class="number">4&#x27;b0010</span>:out=<span class="number">7&#x27;b1101101</span>;</span><br><span class="line">        <span class="number">4&#x27;b0011</span>:out=<span class="number">7&#x27;b1111001</span>;</span><br><span class="line">        <span class="number">4&#x27;b0100</span>:out=<span class="number">7&#x27;b0110011</span>;</span><br><span class="line">        <span class="number">4&#x27;b0101</span>:out=<span class="number">7&#x27;b1011011</span>;</span><br><span class="line">        <span class="number">4&#x27;b0110</span>:out=<span class="number">7&#x27;b1011111</span>;</span><br><span class="line">        <span class="number">4&#x27;b0111</span>:out=<span class="number">7&#x27;b1110000</span>;</span><br><span class="line">        <span class="number">4&#x27;b1000</span>:out=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">        <span class="number">4&#x27;b1001</span>:out=<span class="number">7&#x27;b1111011</span>;   </span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是一个BCD数码管译码，见教材P51</span></span><br></pre></td></tr></table></figure>
<p>除了<code>case</code>外, 还有<code>casez</code>, <code>casex</code>,
真值表如下:</p>
<table>
<thead>
<tr>
<th><code>casez</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>casex</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="循环语句">循环语句</h3>
<p>循环语句包括<code>forever</code>, <code>repeat</code>,
<code>while</code>, <code>for</code>语句</p>
<h4 id="forever">forever</h4>
<p><code>forever</code>的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forever</span> 语句块;</span><br></pre></td></tr></table></figure>
<p><code>forever</code>不能单独出现在程序中,
必须放在<code>initial</code>语句块里面,
这样<code>forever</code>就可以从0时刻开始无限循环执行其后面的语句块下去,
除非遇到<code>$finish</code>.</p>
<p>如果需要从<code>finish</code>中退出,
则需要使用<code>disable</code>语句.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> forever_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">50</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用forever生成时钟信号，每50个时间单位翻转一次，即100个时间单位为一个周期</span></span><br></pre></td></tr></table></figure>
<h4 id="repeat">repeat</h4>
<p><code>repeat</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span>&lt;循环次数表达式&gt;</span><br><span class="line">  语句块;</span><br></pre></td></tr></table></figure>
<p>循环次数表达式可以是一个常数, 一个变量, 或者是一个信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> repeat_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) </span><br><span class="line">          #<span class="number">25</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用repeat生成时钟信号</span></span><br></pre></td></tr></table></figure>
<h4 id="while">while</h4>
<p><code>while</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式) 语句块;</span><br></pre></td></tr></table></figure>
<p>在每一次执行<code>while</code>循环体之前,
都需要先判断条件表达式是否等于1, 如果是1, 就执行后面的语句块; 如果不是1,
就不执行.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> while_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        #<span class="number">50</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用while生成时钟信号</span></span><br></pre></td></tr></table></figure>
<h4 id="for">for</h4>
<p><code>for</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初值:循环条件:循环变量增值) 语句块;</span><br></pre></td></tr></table></figure>
<p>先给循环变量赋初值, 然后判断循环条件是否为1, 若为1则执行语句块,
随后变量自增, 继续判断循环条件是否为1, 直至当循环条件为0.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> for_clk;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">integer</span> i;      <span class="comment">//整型变量就是这么用的，就是用来给for循环计数</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i=i+<span class="number">1</span>)</span><br><span class="line">        #<span class="number">50</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用for生成时钟信号，注意这里循环条件一直是1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_register1 (Q,D,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>        D,rst,clk;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst) Q&lt;=<span class="number">8&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">else</span>      Q&lt;=&#123;Q[<span class="number">6</span>:<span class="number">0</span>],D&#125;;<span class="comment">//把后七位向前移动一位，空出来的一位留给D</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用if语句实现8位移位寄存器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_register2 (Q,D,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>        D,rst,clk;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst) Q&lt;=<span class="number">8&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">7</span>;i&gt;<span class="number">0</span>;i=i-<span class="number">1</span>) Q[i]&lt;=Q[i-<span class="number">1</span>];<span class="comment">//把后七位向前移动一位，最后一位留给D</span></span><br><span class="line">            Q[<span class="number">0</span>]&lt;=D;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用for循环实现8位移位寄存器</span></span><br></pre></td></tr></table></figure>
<h2 id="结构化建模">结构化建模</h2>
<p>结构化建模包括</p>
<ol type="1">
<li>模块级建模: 调用用户之前设计的<code>module</code>;</li>
<li>门级建模: 调用Verilog HDL内部的基本门级原件;</li>
<li>开关级建模: 调用Verilog HDL内部的基本开关级原件.</li>
</ol>
<h3 id="模块级建模">模块级建模</h3>
<h4 id="模块调用">模块调用</h4>
<p>模块调用的基本方式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名&lt;参数值列表&gt; 实例名(端口名列表);</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>“模块名”是用户已经写好的<code>module</code>的名字;
“参数值列表”基本没用过;</li>
<li>“实例名”是<code>module</code>被调用到当前程序的标志,
一般命名为<code>U1, U2, ...</code>等;</li>
<li>“端口名列表”是被调用模块的端口对应, 后面会细说.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and_2 (a,b,c);</span><br><span class="line">    <span class="keyword">input</span>  a,b;</span><br><span class="line">    <span class="keyword">output</span> c;</span><br><span class="line">    <span class="keyword">assign</span> c=a&amp;b;  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这里先定义一个二输入与门的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="keyword">logic</span> (in1,in2,q);</span><br><span class="line">    <span class="keyword">input</span>  in1,in2;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    and_2 U1(in1,in2,q);<span class="comment">//这是模块实例语句，U1是实例名，调用了上面写的二输入与门，其中in1，in2分别对应输入a，b；q对应输出c</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//简单模块调用</span></span><br></pre></td></tr></table></figure>
<h4 id="阵列调用">阵列调用</h4>
<p>阵列调用格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名[阵列左边界,阵列右边界](端口名列表)</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND (andout,ina,inb);</span><br><span class="line">    <span class="keyword">input</span>  ina,inb;</span><br><span class="line">    <span class="keyword">output</span> andout;</span><br><span class="line">    <span class="keyword">assign</span> andout=ina&amp;inb;  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是一个二输入与门的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ex_arrey (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>]a,b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>]out;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>]out;  </span><br><span class="line">    AND AND_ARREY[<span class="number">15</span>:<span class="number">0</span>](out,a,b);<span class="comment">//该语句对模块AND进行阵列调用，[15:0]表明调用了16次</span></span><br><span class="line">    <span class="comment">/*这个代码相当于</span></span><br><span class="line"><span class="comment">    AND AND_ARREY15(out[15],a[15],b[15]);</span></span><br><span class="line"><span class="comment">    AND AND_ARREY14(out[14],a[14],b[14]);</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    AND AND_ARREY1(out[1],a[1],b[1]);</span></span><br><span class="line"><span class="comment">    AND AND_ARREY0(out[0],a[0],b[0]);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阵列调用</span></span><br></pre></td></tr></table></figure>
<h4 id="模块端口对应方式">模块端口对应方式</h4>
<p><strong>端口位置对应方式</strong>的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名(&lt;信号名<span class="number">1</span>&gt;,&lt;信号名<span class="number">2</span>&gt;,...,&lt;信号名n&gt;);</span><br></pre></td></tr></table></figure>
<p>注意这种对应方式需要把括号里面信号的顺序和用户定义的<code>module</code>的端口顺序依次对应.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> halfadder (a,b,s,c);</span><br><span class="line">    <span class="keyword">input</span> a,b;</span><br><span class="line">    <span class="keyword">output</span> s,c;</span><br><span class="line">    <span class="keyword">assign</span> s=a^b;<span class="comment">//异或，s是本位 </span></span><br><span class="line">    <span class="keyword">assign</span> c=a&amp;b;<span class="comment">//c是进位</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fulladder (p,q,ci,co,sum);</span><br><span class="line">    <span class="keyword">input</span> p,q,ci;</span><br><span class="line">    <span class="keyword">output</span> co,sum;</span><br><span class="line">    <span class="keyword">wire</span> w1,w2,w3;</span><br><span class="line">    halfadder U1(p,q,w1,w2);</span><br><span class="line">    halfadder U2(ci,w1,sum,w3);</span><br><span class="line">    <span class="keyword">or</span> U3(co,w2,w3); </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//全加器模块，见教材P58</span></span><br></pre></td></tr></table></figure>
<p><strong>端口名对应</strong>方式(更常用)的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名(.端口名<span class="number">1</span>&lt;信号名<span class="number">1</span>&gt;,.端口名<span class="number">2</span>&lt;信号名<span class="number">2</span>&gt;,.端口名<span class="number">3</span>&lt;信号名<span class="number">3</span>&gt;,.端口名<span class="number">4</span>&lt;信号名<span class="number">4</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>这种方式将端口的对应方式直观地呈现出来, 排列顺序可以随意</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Dff(d,clk,clr,q);</span><br><span class="line">    <span class="keyword">input</span> d,clk,clr;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> clr) <span class="keyword">begin</span><span class="comment">//敏感条件：clk上升沿，clr下降沿</span></span><br><span class="line">        <span class="keyword">if</span> (!clr) q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>      q=d;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//D触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shifter_D (din,clock,clear,out);</span><br><span class="line">    <span class="keyword">input</span>  din,clock,clear;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]out;</span><br><span class="line">    Dff U1(<span class="variable">.q</span>(out[<span class="number">0</span>]),<span class="variable">.d</span>(din),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U2(<span class="variable">.q</span>(out[<span class="number">1</span>]),<span class="variable">.d</span>(out[<span class="number">0</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U3(<span class="variable">.q</span>(out[<span class="number">2</span>]),<span class="variable">.d</span>(out[<span class="number">1</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U4(<span class="variable">.q</span>(out[<span class="number">3</span>]),<span class="variable">.d</span>(out[<span class="number">2</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    <span class="comment">/*当clock上升沿到来时，U1~U4执行，把din的值赋给out[0]，把out[0]的值赋给out[1]，把out[1]的值赋给out[2],把out[2]的值赋给out[3],这几条同时执行;</span></span><br><span class="line"><span class="comment">    当clear下降沿到来时，out[0]~out[3]全部清零*/</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用D触发器构成四位移位寄存器</span></span><br></pre></td></tr></table></figure>
<h3 id="门级建模">门级建模</h3>
<h4 id="verilog-hdl基本门级元件类型">Verilog HDL基本门级元件类型</h4>
<p>Verilog HDL内置26个基本元件, 其中14个是门级原件, 12个为开关级元件,
见下表</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>元件</th>
</tr>
</thead>
<tbody>
<tr>
<td>多输入门(基本门), 第一个端口是输出端口, 后面的全是输入端口</td>
<td><code>and, nand, or, nor, xor, xnor</code></td>
</tr>
<tr>
<td>多输出门(基本门), 最后一个端口是输入端口, 前面的全是输出端口</td>
<td><code>buf, not</code></td>
</tr>
<tr>
<td>允许定义驱动强度(三态门)</td>
<td><code>bufif0, bufif1, notif0, notif1</code></td>
</tr>
<tr>
<td>无驱动强度(MOS开关)</td>
<td><code>nmos, pmos, cmos, rnmos, rpmos, rcmos</code></td>
</tr>
<tr>
<td>无驱动强度(双向开关)</td>
<td><code>tran, tranif0, tranif1, rtran, rtranif0, rtranif1</code></td>
</tr>
<tr>
<td>允许定义驱动强度(上拉,下拉电阻)</td>
<td><code>pullup, pulldown</code></td>
</tr>
</tbody>
</table>
<h4 id="门级模块调用">门级模块调用</h4>
<p><strong>多输入门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;输出端口&gt;,&lt;输入端口<span class="number">1</span>&gt;,&lt;输入端口<span class="number">2</span>&gt;,...,&lt;输入端口n&gt;);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> A1(out1,in1,in2,in3);</span><br><span class="line"><span class="keyword">or</span> O2(a,b,c,d);</span><br><span class="line"><span class="keyword">xor</span> X1(x_out,p1,p2);</span><br></pre></td></tr></table></figure>
<p><strong>多输出门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;输出端口<span class="number">1</span>&gt;,&lt;输出端口<span class="number">2</span>&gt;,...,&lt;输出端口n&gt;,&lt;输入端口&gt;);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> NOT_1(out1,out2,in);</span><br><span class="line"><span class="keyword">buf</span> BUF_1(bufout1,bufout2,bufout3,bufin);</span><br></pre></td></tr></table></figure>
<p><strong>三态门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;数据输出端口&gt;, &lt;数据输入端口&gt;, &lt;控制输入端口&gt;);</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bufif1</span> BF1(data_bus, mem_data, enable);</span><br><span class="line"><span class="keyword">bufif0</span> BF0(a, b, c);</span><br><span class="line"><span class="keyword">notif1</span> NT1(out, in, ctrl);</span><br><span class="line"><span class="keyword">notif1</span> NT0(addr, a_bus, select);</span><br></pre></td></tr></table></figure>
<p>例: 调用门级元件实现2线-4线译码器</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decoder2_4(in0, in1, en, out0, out1, out2, out3);</span><br><span class="line">    <span class="keyword">input</span>  in0, in1, en;</span><br><span class="line">    <span class="keyword">output</span> out0, out1, out2, out3;</span><br><span class="line">    <span class="keyword">wire</span>   wire1, wire2;<span class="comment">//中间变量定义成wire类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span>  U1(wire1, in0);</span><br><span class="line">         U2(wire2, in1);<span class="comment">//非门, 输出为wire, 输入为in</span></span><br><span class="line">    <span class="keyword">nand</span> U3(out0, en, wire1, wire2);</span><br><span class="line">         U4(out1, en, wire1, in1);</span><br><span class="line">         U5(out2, en, in0, wire2);</span><br><span class="line">         U6(out3, en, in0, in1);<span class="comment">//三输入与非门, 输出为out, 输入为wire, in</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="开关级建模">开关级建模</h3>
<p>开关级建模指的是用输入, 输出为模拟信号的晶体管搭建硬件模型. Verilog
HDL提供了开关级建模方式, 主要用于ASIC设计. 在开关级建模方式下,
硬件结构采用开关级描述方式, 而晶体管的输入输出均被限定为数字信号.
此时晶体管表现为通断形式的开关. 由于Verilog HDL采用四值逻辑系统,
因此Verilog HDL描述的开关的输入输出可以是<code>0, 1, z, x</code>.</p>
<p>Verilog HDL提供了十几种开关级基本元件, 它们是实际MOS管的抽象表示.
这些开关级的基本元件分成两大类: 一类是MOS开关, 一类是双向开关.
每一大类又可以电阻型(前缀是r)和非电阻型. 见下表</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>关键字</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nmos</code></td>
<td>当控制信号为高时, 开关导通, 否则关闭</td>
</tr>
<tr>
<td><code>pmos</code></td>
<td>当控制信号为低时, 开关导通, 否则关闭</td>
</tr>
<tr>
<td><code>cmos</code></td>
<td>nmos控制信号和pmos控制信号互补, 当nmos控制信号为高时, 开关导通,
否则关闭</td>
</tr>
<tr>
<td><code>tran</code></td>
<td>两端可以互相驱动, 且随时保持一致</td>
</tr>
<tr>
<td><code>tranif0</code></td>
<td>当控制端为低时, 两端才能相互驱动</td>
</tr>
<tr>
<td><code>tranif1</code></td>
<td>当控制端为高时, 两端才能相互驱动</td>
</tr>
</tbody>
</table>
<p>MOS开关模拟了实际MOS器件的功能,
包括<code>nmos, pmos, cmos</code>三种</p>
<p>MOS开关调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nmos</span>/<span class="keyword">pmos</span> 实例名(out,data,control);</span><br><span class="line"><span class="keyword">cmos</span> 实例名(out,data,ncontrol,pcontrol);<span class="comment">//这里的control信号控制data信号传送到out端</span></span><br></pre></td></tr></table></figure>
<p>双向开关的每个脚都被声明为<code>inout</code>类型,
可以作为输入来驱动另一脚, 也可以作为输出被另一脚驱动.</p>
<p>双向开关包括无条件双向开关<code>tran</code>和有条件双向开关<code>tranif0, tranif1</code>,
调用格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tran</span> 实例名 (inout1, inout2);</span><br><span class="line"><span class="keyword">tranif0</span>/<span class="keyword">tranif1</span> 实例名 (inout1 ,inout2, control);</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NMOS (din,out,ctr);</span><br><span class="line">    <span class="keyword">input</span>  din,ctr;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">nmos</span> U1(out,din,ctr);</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是最基本的nmos开关，当ctr为高电平时，输入din传到out；当ctr为低电平时，输入输出断开</span></span><br></pre></td></tr></table></figure>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>用连续赋值语句描述一个4选1数据选择器</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述：通过连续赋值语句（assign）实现组合逻辑，根据选择信号sel从4个输入中选出一个作为输出</span></span><br><span class="line"><span class="keyword">module</span> mux4to1_assign(din, sel, out);</span><br><span class="line">    <span class="comment">// 输入端口声明</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] din;   <span class="comment">// 4位宽数据输入，din[0]、din[1]、din[2]、din[3]分别对应四个数据通道</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel;   <span class="comment">// 2位宽选择信号，sel[1]为高位，sel[0]为低位，共4种组合对应4个输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出端口声明</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out;   <span class="comment">// 单比特输出，根据选择信号输出对应的输入数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连续赋值语句：描述组合逻辑，当输入变化时输出立即更新</span></span><br><span class="line">    <span class="comment">// 逻辑表达式对应真值表：</span></span><br><span class="line">    <span class="comment">// sel[1] sel[0] | out</span></span><br><span class="line">    <span class="comment">//   0      0    | din[0]</span></span><br><span class="line">    <span class="comment">//   0      1    | din[1]</span></span><br><span class="line">    <span class="comment">//   1      0    | din[2]</span></span><br><span class="line">    <span class="comment">//   1      1    | din[3]</span></span><br><span class="line">    <span class="keyword">assign</span> out = (din[<span class="number">0</span>] &amp; ~sel[<span class="number">1</span>] &amp; ~sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b00时，选择din[0]</span></span><br><span class="line">                (din[<span class="number">1</span>] &amp; ~sel[<span class="number">1</span>] &amp;  sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b01时，选择din[1]</span></span><br><span class="line">                (din[<span class="number">2</span>] &amp;  sel[<span class="number">1</span>] &amp; ~sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b10时，选择din[2]</span></span><br><span class="line">                (din[<span class="number">3</span>] &amp;  sel[<span class="number">1</span>] &amp;  sel[<span class="number">0</span>]);   <span class="comment">// 当sel=2&#x27;b11时，选择din[3]</span></span><br><span class="line">    <span class="comment">// 注意：表达式中的 &amp; 表示按位与，| 表示按位或，~ 表示按位非</span></span><br><span class="line">    <span class="comment">// 由于是单比特操作，实际执行逻辑与、或、非运算</span></span><br><span class="line">    <span class="comment">// 每个条件项由三部分相与：数据位 + 选择信号的译码条件</span></span><br><span class="line">    <span class="comment">// 最后所有项相或，实现4选1功能</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>简述<code>begin-end</code>语句块和’fork-join’语句块的区别,并写出下面信号对应的程序代码.</p>
<p>串行语句块的关键字是<code>begin</code>和<code>end</code>,其中的语句按照串行方式顺序执行,既可以用于可综合电路,也可以用于仿真测试程序.并行语句块的关键字是<code>fork</code>和<code>join</code>,其中的语句并行执行,只能用于仿真测试程序,不能用于可综合电路程序.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb1;</span><br><span class="line">    <span class="keyword">reg</span> A, B;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">0</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">0</span>; B=<span class="number">0</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> wave_tb2;</span><br><span class="line">    <span class="keyword">reg</span> A, B;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">                A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T      A=<span class="number">1</span>; B=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(2*T)</span>  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(3*T)</span>  A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(4*T)</span>  A=<span class="number">0</span>; B=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(5*T)</span>  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>分别用阻塞赋值语句和非阻塞赋值语句描述的4bit移位寄存器电路.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_4bit(clk, din, out);</span><br><span class="line">    <span class="keyword">input</span>            clk;</span><br><span class="line">    <span class="keyword">input</span>            din;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out[<span class="number">3</span>] = out[<span class="number">2</span>]; <span class="comment">//先将第二位传到第三位</span></span><br><span class="line">        out[<span class="number">2</span>] = out[<span class="number">1</span>]; <span class="comment">//再将第一位传到第二位</span></span><br><span class="line">        out[<span class="number">1</span>] = out[<span class="number">0</span>]; <span class="comment">//然后将第零位传到第一位</span></span><br><span class="line">        out[<span class="number">0</span>] = din;    <span class="comment">//最后将输入传到第零位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阻塞赋值语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shift_4bit(clk, din, out);</span><br><span class="line">    <span class="keyword">input</span>            clk;</span><br><span class="line">    <span class="keyword">input</span>            din;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out &lt;= &#123;out[<span class="number">2</span>:<span class="number">0</span>], din&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//非阻塞赋值语句</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>分析以下Verilog HDL所描述的电路</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> program_if(a, b, c, d, sel, z);</span><br><span class="line">    <span class="keyword">input</span>        a,b,c,d;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] sel;</span><br><span class="line">    <span class="keyword">output</span>       z;</span><br><span class="line">    <span class="keyword">reg</span>          z;</span><br><span class="line">    <span class="keyword">always</span>@(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>       (sel[<span class="number">3</span>])     z=d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">2</span>])     z=c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">1</span>])     z=b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">0</span>])     z=a;</span><br><span class="line">            <span class="keyword">else</span>                  z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这是一个带优先级的4选1多路选择器, <code>sel[3]</code> 是最高优先级,
<code>sel[2]</code>是次高优先级, <code>sel[1]</code>是第三优先级,
<code>sel[0]</code>
是最低优先级.当所有<code>sel</code>位为0时，输出默认值0.</p></li>
<li><p>根据下面的Verilog HDL程序, 画出电路图, 并且说明其功能</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> circuit(a, b, c);</span><br><span class="line">    <span class="keyword">input</span>  a, b;</span><br><span class="line">    <span class="keyword">output</span> c;</span><br><span class="line">    <span class="keyword">wire</span>   a1, a2, anot, bnot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">and</span> U1(a1, a, b);</span><br><span class="line">    <span class="keyword">and</span> U2(a2, anot, bnot);</span><br><span class="line">    <span class="keyword">not</span> (anot, a);</span><br><span class="line">    <span class="keyword">not</span> (bnot, b);</span><br><span class="line">    <span class="keyword">or</span>  (c, a1, a2);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这是一个异或非门XNOR电路, 当输入a和b相同时(同为0或同为1), 输出c=1;
当输入a和b不同时, 输出c=0.</p></li>
<li><p>用门级描述方式描述电路,
要求:输入为<code>D0, D1, D2, D3, S1, S2</code>,
四个<code>wire T0, T1, T2, T3</code>, 一个输出<code>Z</code>,
关系如下:</p>
<p><span class="math display">\[\begin{aligned}
     &amp;T0=D0\overline{S2}\overline{S1}\\
     &amp;T1=D1S2\overline{S1}\\
     &amp;T2=D2\overline{S2}S1\\
     &amp;T3=D3S2S1\\
     &amp;Z=T0+T1+T2+T3\\
\end{aligned}\]</span></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4to1(D0, D1, D2, D3, S1, S2, Z);</span><br><span class="line">    <span class="keyword">input</span>  D0, D1, D2, D3, S1, S2;</span><br><span class="line">    <span class="keyword">output</span> Z;</span><br><span class="line">    <span class="keyword">wire</span>   T0, T1, T2, T3;</span><br><span class="line">    <span class="keyword">wire</span>   S1_not, S2_not;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span> (S1_not, S1);</span><br><span class="line">    <span class="keyword">not</span> (S2_not, S2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">and</span> (T0, D0, S2_not, S1_not);</span><br><span class="line">    <span class="keyword">and</span> (T1, D1, S2, S1_not);</span><br><span class="line">    <span class="keyword">and</span> (T2, D2, S2_not, S1);</span><br><span class="line">    <span class="keyword">and</span> (T3, D3, S2, S1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span> (Z, T0, T1, T2, T3);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%BA%8C%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%BA%8C%E7%AB%A0/" class="post-title-link" itemprop="url">第二章:Verilog HDL基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 07:34:39" itemprop="dateModified" datetime="2026-01-15T07:34:39+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="verilog-hdl的语言要素">Verilog HDL的语言要素</h2>
<p>Verilog HDL和C语言类似. 程序的语言要素也称为词法, 是由<strong>符号,
数据类型, 运算符和表达式</strong>构成的, 其中</p>
<ul>
<li><p>符号包括空白符, 注释符, 标识符, 转义标识符, 关键字,
数值等.</p></li>
<li><p>数据类型可以分成两大类, 物理数据类型,
包括连线型<code>wire, tri, wor, trior, wand, trand, trireg, tri1, tri0, supply1, supply0</code>,
寄存器型<code>reg</code>; 抽象数据类型, 包括整型<code>integer</code>,
时间型<code>time</code>, 实型<code>real</code>,
参数型<code>parameter</code></p></li>
<li><p>运算符包括算数运算符<code>+, -, *, /, %</code>,
关系运算符<code>&gt;, &lt;, &gt;=, &lt;=</code>,
相等关系运算符<code>==, !=, ===, !==</code>,
逻辑运算符<code>&amp;&amp;, ||, !</code>,
按位运算符<code>~, &amp;, |, ^, ^~</code>,
归约运算符<code>&amp;, |, ^, ~&amp;, ~|, ~^, ^~</code>,
移位运算符<code>&lt;&lt;, &gt;&gt;</code>, 条件运算符<code>?:</code>,
连接和复制运算符<code>&#123;&#125;, &#123;&#123;&#125;&#125;</code>.</p></li>
</ul>
<h2 id="符号">符号</h2>
<h3 id="空白符">空白符</h3>
<p>空白符包括空格符<code>\b</code>, 制表符<code>\t</code>,
换行符和换页符, 空白符使代码看起来结构清晰, 便于阅读. 在编译和综合时,
空白符被忽略.</p>
<h3 id="注释符">注释符</h3>
<p>单行注释</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> a=b&amp;c <span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure>
<p>多行注释</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> a[<span class="number">3</span>:<span class="number">0</span>]=b[<span class="number">3</span>:<span class="number">0</span>]&amp;c[<span class="number">3</span>:<span class="number">0</span>]  <span class="comment">/*注释行1</span></span><br><span class="line"><span class="comment">                            注释行2*/</span></span><br></pre></td></tr></table></figure>
<h3 id="标识符和转义标识符">标识符和转义标识符</h3>
<p>标识符被用来命名信号, 模块, 参数等, 它可以是任意一组字母, 数字,
<code>$</code>符号和<code>_</code>下划线的组合.
注意标识符的字母区分大小写, 并且第一个字符必须是字母或者是下划线.</p>
<p>合法标识符:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count</span><br><span class="line">COUNT <span class="comment">//和count不同</span></span><br><span class="line">_CC_G5</span><br><span class="line">B25_78</span><br><span class="line">Six</span><br></pre></td></tr></table></figure>
<p>非法标识符</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span>count <span class="comment">//标识符不能以数字开头</span></span><br><span class="line">out*    <span class="comment">//标识符不能包含*</span></span><br><span class="line">a+b-c   <span class="comment">//标识符不能包含+-</span></span><br><span class="line">n@<span class="number">234</span>   <span class="comment">//标识符不能包含@ </span></span><br></pre></td></tr></table></figure>
<p>为了使用标识符以外的字符或符号, Verilog HDL规定了转义标识符.
采用转义标识符, 可以在一条标识符中包含任何可打印的字符.
转义标识符由<code>\</code>开头, 以空白(可以是一个空格,
一个制表字符或换行符)结尾.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\a+b=c</span><br><span class="line">\<span class="number">7400</span></span><br><span class="line">\.*.$</span><br><span class="line">\&#123;***&#125;</span><br><span class="line">\~Q</span><br><span class="line">\OutGate</span><br></pre></td></tr></table></figure>
<h3 id="数值">数值</h3>
<h4 id="整数及其表示">整数及其表示</h4>
<p><code>0</code> ————&gt;低电平, 逻辑假 <code>1</code> ————&gt;高电平,
逻辑真 <code>x/X</code>————&gt;不确定或未知逻辑态
<code>z/Z</code>————&gt;高阻态</p>
<p><code>b</code>或<code>B</code>————&gt;二进制,
<code>0、1、x/X、z/Z/?、_;</code>
<code>o</code>或<code>O</code>————&gt;八进制,
<code>0~7、x/X、z/Z/?、_;</code>
<code>d</code>或<code>D</code>————&gt;十进制, <code>0~9、_;</code>
<code>h</code>或<code>H</code>————&gt;十六进制,
<code>0~9 、a/A~f/F、x/X、z/Z/?、\_;</code></p>
<h5 id="表示形式">表示形式</h5>
<p>整数的表示形式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+/-&lt;size&gt;&#x27;&lt;base&gt;&lt;number&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中<code>+/-</code>放在最前面;</li>
<li><code>size</code>是将数字<strong>换算成二进制数之后</strong>的位数,
注意这里要转换成二进制!!!;</li>
<li><code>'</code>不能省略;</li>
<li><code>base</code>可选二进制<code>b</code>, 八进制<code>o</code>,
十进制<code>d</code>, 十六进制<code>h</code>;</li>
<li><code>number</code>用所选取的进制数表示.</li>
</ul>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>较长的数字可以用下划线分开, 例如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16&#x27;b1110_1011_0011_1010</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>没有说明数字位宽时, 默认为32位</p></li>
<li><p>x或z在二进制中只代表一位的x或z, 在八进制中代表三位的x或z,
在十六进制中代表四位的x或z, 例如</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8&#x27;b1011xxxx</span>=<span class="number">8&#x27;hBx</span></span><br><span class="line"><span class="number">8&#x27;b1001zzzz</span>=<span class="number">8&#x27;h9z</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果没有定义一个整数的位宽, 那么其宽度就是相应值中定义的位数,
例如 <code>'o642</code>是9位八进制数
<code>'hBD</code>是8位十六进制数</p></li>
<li><p>若定义的位宽比实际的数要大, 则在左边自动用0补齐, 例如</p></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10&#x27;b101</span>=<span class="number">10&#x27;b0000000101</span></span><br><span class="line"><span class="number">8&#x27;bz0x1</span>=<span class="number">8&#x27;bzzzzz0x1</span></span><br></pre></td></tr></table></figure>
<p>若定义的位宽比实际的数要小，那么左边的位要被截断</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b10111011</span>=<span class="number">4&#x27;b1011</span></span><br><span class="line"><span class="number">6&#x27;HFFFB</span>=<span class="number">6&#x27;H3B</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>?</code>和<code>z/Z</code>都表示高组态,例如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>&#x27;b??=<span class="number">2&#x27;bzz</span></span><br></pre></td></tr></table></figure>
<ul>
<li>整数可以带正负号, 并且正负号应该写在最左边. 负数表示为二进制补码,
例如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">4</span>=<span class="number">4&#x27;b1100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果位宽和进制都省略, 那么就表示十进制数</li>
</ul>
<h4 id="实数及其表示">实数及其表示</h4>
<ul>
<li><p>十进制表示法:小数点两边必须都要有数字,例如0.8、4.68、9.9等</p></li>
<li><p>科学计数法:8.7e2=870.0、3E-3=0.003等</p></li>
</ul>
<h2 id="数据类型">数据类型</h2>
<p>Verilog HDL的数据类型可以分成两大类,
第一类为<strong>物理数据类型(包括连线型和寄存器型)</strong>,
第二类为<strong>抽象数据类型(包括整型, 时间型, 实型,
参数型)</strong>.</p>
<h3 id="物理数据类型">物理数据类型</h3>
<p>Verilog HDL最主要的物理数据类型是连线型, 寄存器型和存储器型,
并使用四种逻辑电平<code>0, 1, x/X, z/Z</code>和八种信号强度对实际的硬件电路建模.</p>
<p>四值逻辑电平是对信号的抽象表示方式,
信号强度表示数字电路中不同强度的驱动源,
用来解决不同驱动强度下的赋值冲突, 如下表, 驱动强度从上到下递减:</p>
<table>
<thead>
<tr>
<th>标记符</th>
<th>名称</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>supply</code></td>
<td>电源级驱动</td>
<td>驱动</td>
</tr>
<tr>
<td><code>strong</code></td>
<td>强驱动</td>
<td>驱动</td>
</tr>
<tr>
<td><code>pull</code></td>
<td>上拉级驱动</td>
<td>驱动</td>
</tr>
<tr>
<td><code>large</code></td>
<td>大容性</td>
<td>存储</td>
</tr>
<tr>
<td><code>weak</code></td>
<td>弱驱动</td>
<td>驱动</td>
</tr>
<tr>
<td><code>medium</code></td>
<td>中性驱动</td>
<td>存储</td>
</tr>
<tr>
<td><code>small</code></td>
<td>小容性</td>
<td>存储</td>
</tr>
<tr>
<td><code>highz</code></td>
<td>高容性</td>
<td>高阻</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p><strong>连线型(wire)</strong>: 连线表示逻辑单元的物理连接,
可以对应电路中的物理信号连线,
这种变量类型不能保持电荷(<code>trireg</code>除外).
连线型变量必须要有驱动源, 一种是连接到一个门或者模块的输出端,
另一种是用<code>assign</code>连续赋值语句对它进行赋值. 若没有驱动源,
则保持高阻态<code>z</code>.</p></li>
<li><p><strong>寄存器型(reg)</strong>:
<code>reg</code>型变量是最常见也是最重要的寄存器型数据类型,
它是数据储存单元的抽象类型, 其对应的硬件电路元件具有状态保持作用,
能够储存数据, 如触发器, 锁存器等.
<code>reg</code>型变量常用于行为级描述,
由过程赋值语句对其进行赋值.</p></li>
</ol>
<h4
id="连线型和寄存器型数据类型的声明">连线型和寄存器型数据类型的声明</h4>
<h5 id="连线型">连线型</h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;net_declaration&gt; &lt;drive_strength&gt; &lt;range&gt; &lt;delay&gt; [list_of_variables];</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>net_declaration</code>:
可以选择<code>wire, tri, tri0, tri1</code>等等</p></li>
<li><p><code>drive_strength</code>: 连线变量的驱动强度</p></li>
<li><p><code>range</code>: 指定数据为标量或者矢量,
默认为1位的标量</p></li>
<li><p><code>delay</code>: 指定仿真延迟时间</p></li>
<li><p><code>list_of_variables</code>: 变量名称, 可以一次定义多个,
中间用逗号隔开</p></li>
</ul>
<h5 id="寄存器型">寄存器型</h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> &lt;range&gt; [list_of_register_variables]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>range</code>: 指定寄存器的位宽, 默认为1位</p></li>
<li><p><code>list_of_register_variables</code>: 变量名称,
可以一次定义多个, 中间用逗号隔开</p></li>
</ul>
<h5 id="存储器型memory">存储器型(memory)</h5>
<p>存储器型本质上是寄存器型变量阵列, 这是因为Verilog HDL中没有多维数组,
所以就用一些<code>reg</code>类型变量组成寄存器组来实现存储器的功能,
也就是 扩展的<code>reg</code>型数据地址范围.
存储器型变量可以描述RAM型、ROM型存储器和reg文件.
数组中的每一个单元通过一个数组索引进行寻址.</p>
<p>存储器型变量的声明如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> &lt;range1&gt; &lt;list_of_register&gt; &lt;range2&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>range1</code>: 存储器中的每个寄存器的<strong>位宽</strong>,
格式为<code>[msb:lsb]</code></p></li>
<li><p><code>range2</code>: 寄存器的<strong>个数</strong>,
也就是<strong>存储器的地址范围</strong>,
格式为<code>[msb:lsb]</code></p></li>
<li><p><code>list_of_register</code>: 变量名称, 可以一次定义多个,
中间用逗号隔开</p></li>
</ul>
<p>例如</p>
<p><code>reg [7:0] mem1 [255:0];</code>
这是一个有<strong>256</strong>个<strong>8</strong>位寄存器的存储器<code>mem1</code>,
<strong>地址范围是0~255</strong></p>
<p><code>reg [15:0] mem1 [127:0], reg1, reg2;</code>
这是一个有128个16位寄存器的存储器<code>mem1</code>, 地址范围是0~128,
除此之外还有两个16位的寄存器<code>reg1</code>, <code>reg2</code></p>
<p><code>reg [15:0] a=16'b1011_0101_1001_0001;</code>
这是一个16位寄存器, 可以直接对这一个寄存器赋值</p>
<p><code>reg mem1 [15:0];</code>
这是一个有1个16位寄存器的存储器<code>mem1</code>, 不能对整个存储器赋值,
注意和上面的寄存器进行区分</p>
<p><code>mem1[2]=1'b0;</code>
给<code>mem1</code>存储器中的第三个寄存器赋值</p>
<h3 id="抽象数据类型">抽象数据类型</h3>
<p>1.整型</p>
<p>整型数据与32位寄存器型数据在实际应用上相同, 声明格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> &lt;name&gt;;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> index;   <span class="comment">//32位有符号整数</span></span><br><span class="line"><span class="keyword">integer</span> i[<span class="number">31</span>:<span class="number">0</span>]; <span class="comment">//定义了整型数组，有32个元素</span></span><br></pre></td></tr></table></figure>
<p>2.时间型</p>
<p>时间型数据是64位无符号数, 声明格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time</span> &lt;name&gt;;</span><br></pre></td></tr></table></figure>
<p>3.实型</p>
<p>实型数据为浮点数, 声明格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> &lt;name&gt;;</span><br></pre></td></tr></table></figure>
<p>4.参数型</p>
<p>参数型数据属于常量, 声明格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> 参数名<span class="number">1</span>=表达式<span class="number">1</span>，参数名<span class="number">2</span>=表达式<span class="number">2</span>，...</span><br></pre></td></tr></table></figure>
<p>其中表达式既可以是常数, 也可以是表达式.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> length=<span class="number">32</span>, weight=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">parameter</span> pi=<span class="number">3</span><span class="variable">.14</span>, load=<span class="number">4&#x27;b1101</span>;</span><br><span class="line"><span class="keyword">parameter</span> delay=(<span class="keyword">byte</span>+<span class="keyword">bit</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> arith_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] b;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">4&#x27;b1111</span>;<span class="comment">//15</span></span><br><span class="line">        b=<span class="number">4&#x27;b011</span>;<span class="comment">//3</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a*b);<span class="comment">//结果是45，但是结果必须是4位二进制数，高位被舍去</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a/b);<span class="comment">//结果是5，4&#x27;b0101</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a+b);<span class="comment">//结果是18，高位被舍去</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a-b);<span class="comment">//结果是12</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a%b);<span class="comment">//结果是0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//算数运算代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="关系运算符">关系运算符</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> rela_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]a,b,c,d;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">3</span>;</span><br><span class="line">        b=<span class="number">6</span>;</span><br><span class="line">        c=<span class="number">1</span>;</span><br><span class="line">        d=<span class="number">4&#x27;hx</span>;</span><br><span class="line">        <span class="built_in">$display</span>(a&lt;b);<span class="comment">//结果为真，输出1</span></span><br><span class="line">        <span class="built_in">$display</span>(a&gt;b);<span class="comment">//结果为假，输出0</span></span><br><span class="line">        <span class="built_in">$display</span>(a&lt;=c);<span class="comment">//结果为假，输出0</span></span><br><span class="line">        <span class="built_in">$display</span>(d&lt;=a);<span class="comment">//结果不确定，输出x</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//关系运算代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="相等关系运算符">相等关系运算符</h3>
<p><code>==</code>和<code>!=</code>是逻辑等式运算符,
其结果是由两个操作数的值决定,
由于操作数中某些位可能是不定值<code>x</code>或者高阻态值<code>z</code>,
所以结果可能是不定值<code>x</code>.</p>
<p><code>===</code>和<code>!==</code>对操作数进行按位比较,
两个操作数必须完全一样(连位数都必须一样,
比如<code>4'b0011</code>和<code>3'b011</code>不全等),
结果才为<code>1</code>, 否则为<code>0</code>. 但是,
若两个操作数对应位出现<code>x</code>或者<code>z</code>,
则可以认为是相同的.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> equal_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] a,b,c,d;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">4&#x27;b0xx1</span>;</span><br><span class="line">        b=<span class="number">4&#x27;b0xx1</span>;</span><br><span class="line">        c=<span class="number">4&#x27;b0011</span>;</span><br><span class="line">        d=<span class="number">2&#x27;b11</span>;</span><br><span class="line">        <span class="built_in">$display</span>(a==b);<span class="comment">//结果不确定，输出x</span></span><br><span class="line">        <span class="built_in">$display</span>(c==d);<span class="comment">//结果相等，输出1</span></span><br><span class="line">        <span class="built_in">$display</span>(a===b);<span class="comment">//结果全等，输出1</span></span><br><span class="line">        <span class="built_in">$display</span>(c===d);<span class="comment">//结果不全等，输出0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//相等关系代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>对于一个操作数, 如果它的<strong>每一位都是<code>0</code></strong>,
那么其逻辑就是<code>0</code>; 但凡出现一个<code>1</code>,
那么其逻辑就为<code>1</code>;</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> logic_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] a,b,c;</span><br><span class="line">    <span class="keyword">reg</span>       d,f;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">4&#x27;b0000</span>;<span class="comment">//逻辑0</span></span><br><span class="line">        b=<span class="number">4&#x27;b1011</span>;<span class="comment">//逻辑1</span></span><br><span class="line">        c=<span class="number">4&#x27;b1001</span>;<span class="comment">//逻辑1</span></span><br><span class="line">        d=<span class="number">1&#x27;b0</span>;<span class="comment">//逻辑0</span></span><br><span class="line">        f=<span class="number">1&#x27;b1</span>;<span class="comment">//逻辑1</span></span><br><span class="line">        <span class="built_in">$display</span>(!a);<span class="comment">//输出1&#x27;b1</span></span><br><span class="line">        <span class="built_in">$display</span>(!b);<span class="comment">//输出1&#x27;b0</span></span><br><span class="line">        <span class="built_in">$display</span>(!d);<span class="comment">//输出1&#x27;b1</span></span><br><span class="line">        <span class="built_in">$display</span>(!f);<span class="comment">//输出1&#x27;b0</span></span><br><span class="line">        <span class="built_in">$display</span>(a&amp;&amp;b);<span class="comment">//逻辑与运算，输出1&#x27;b0</span></span><br><span class="line">        <span class="built_in">$display</span>(b&amp;&amp;c);<span class="comment">//逻辑与运算，输出1&#x27;b1</span></span><br><span class="line">        <span class="built_in">$display</span>(c||d);<span class="comment">//逻辑或运算，输出1&#x27;b1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="按位运算符">按位运算符</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bit_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] a ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] b ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">5&#x27;b101</span>;<span class="comment">//运算的时候补成5&#x27;b00101</span></span><br><span class="line">        b=<span class="number">5&#x27;b11101</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,~a);<span class="comment">//按位取反，结果是5&#x27;b11010</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,~b);<span class="comment">//按位取反，结果是5&#x27;b00010</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a&amp;b);<span class="comment">//按位与，结果是5&#x27;b00101</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a|b);<span class="comment">//按位或，结果是5&#x27;b11101</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,a^b);<span class="comment">//按位异或，结果是5&#x27;b11000</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//按位运算代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="移位运算符">移位运算符</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_tb;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] a,b,c,d ;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] e ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">6&#x27;b101101</span>;</span><br><span class="line">        b=a&lt;&lt;<span class="number">2</span>;<span class="comment">//把a左移两位，再用0补上空位</span></span><br><span class="line">        c=a&gt;&gt;<span class="number">3</span>;<span class="comment">//把a右移三位，再用0补上空位</span></span><br><span class="line">        d=a&lt;&lt;<span class="number">7</span>;<span class="comment">//把a左移七位，再用0补上空位</span></span><br><span class="line">        e=a&lt;&lt;<span class="number">2</span>;<span class="comment">//把a左移两位，再用0补上空位</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,b);<span class="comment">//结果为6&#x27;b110100</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,c);<span class="comment">//结果为6&#x27;b000101</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,d);<span class="comment">//结果为6&#x27;b000000</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,e);<span class="comment">//结果为8&#x27;b10110100</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//移位运算代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="条件运算符">条件运算符</h3>
<p>唯一的三目运算符</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2 (in1,in2,sel,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] in1,in2;</span><br><span class="line">    <span class="keyword">input</span>        sel;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">wire</span>   [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">assign</span> out=(!sel)?in1:in2;  <span class="comment">//当sel=0时，out=in1；当sel=1时，out=in2</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//verilog里面唯一的三目条件运算符代码例</span></span><br></pre></td></tr></table></figure>
<h3 id="复制和连接运算符">复制和连接运算符</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> con_rep_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] a ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] b ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] c ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] d ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>:<span class="number">0</span>] e ;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">3&#x27;b101</span>;</span><br><span class="line">        b=<span class="number">4&#x27;b1110</span>;</span><br><span class="line">        c=&#123;a,b&#125;;            <span class="comment">//连接a和b</span></span><br><span class="line">        d=&#123;a[<span class="number">2</span>:<span class="number">1</span>],b[<span class="number">2</span>:<span class="number">0</span>]&#125;;  <span class="comment">//连接a[2:1]和b[2:0]</span></span><br><span class="line">        e=&#123;<span class="number">2</span>&#123;a&#125;&#125;;           <span class="comment">//把a复制两次</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,c);<span class="comment">//结果为8&#x27;b01011110</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,d);<span class="comment">//结果为5&#x27;b10110</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;%b&quot;</span>,e);<span class="comment">//结果为6&#x27;b101101</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//连接和复制运算符代码例</span></span><br></pre></td></tr></table></figure>
<h2 id="模块">模块</h2>
<h3 id="模块的内容">模块的内容</h3>
<p>模块包含四个部分</p>
<ol type="1">
<li>模块的开始和结束: <code>module</code>开始,
<code>endmodule</code>结束, 其中模块开始语句必须以分号结束.
开始的部分包括模块名和端口列表(各个端口名用逗号隔开);</li>
<li>模块端口定义: <code>input</code>, <code>output</code>,
<code>inout</code>, 以及位宽;</li>
<li>模块的数据类型: <code>input</code>默认为<code>wire</code>;
<code>output</code>可以是<code>wire</code>, 也可以是<code>reg</code>,
默认为<code>wire</code>(当在<code>always</code>或者<code>initial</code>语句块中被赋值时需要额外声明<code>output</code>为<code>reg</code>类型);
<code>inout</code>一般为<code>tri</code>, 表示有多个驱动源.</li>
<li>模块的逻辑功能描述: 产生各种逻辑(主要是组合逻辑和时序逻辑),
主要包括<code>initial</code>语句, <code>always</code>语句,
其他子模块实例化语句, 门实例化语句, 用户自定义原语实例化语句,
连续赋值语句<code>assign</code>, 函数(function)和任务(task).</li>
</ol>
<h3 id="模块的引用">模块的引用</h3>
<p>将信号线和被引用模块的端口连接, 有两种方式:</p>
<ol type="1">
<li><p>按照源模块定义时的端口顺序连接</p>
<p><code>模块名(连接端口1信号线名,连接端口2信号线名,...)</code></p></li>
<li><p>在引用时用小数点表明源模块定义时的端口名(更常用)</p>
<p><code>模块名(.端口1名(连接端口1信号线名),.端口2名(连接端口2信号线名),...)</code></p></li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dff (din,clk,q);</span><br><span class="line">    <span class="keyword">input</span>  din,clk;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span>    q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        q&lt;=din;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//D触发器</span></span><br></pre></td></tr></table></figure>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>Verilog HDL中, 基本的语言要素有哪些?</p>
<p>程序的语言要素也称为词法, 是由符号, 数据类型, 运算符和表达式构成的,
其中</p>
<p>符号包括空白符, 注释符, 标识符, 转义标识符, 关键字, 数值等.</p>
<p>数据类型可以分成两大类, 物理数据类型,
包括连线型<code>wire, tri, wor, trior, wand, trand, trireg, tri1, tri0, supply1, supply0</code>,
寄存器型<code>reg</code>; 抽象数据类型, 包括整型<code>integer</code>,
时间型<code>time</code>, 实型<code>real</code>,
参数型<code>parameter</code></p>
<p>运算符包括算数运算符<code>+, -, *, /, %</code>,
关系运算符<code>&gt;, &lt;, &gt;=, &lt;=</code>,
相等关系运算符<code>==, !=, ===, !==</code>,
逻辑运算符<code>&amp;&amp;, ||, !</code>,
按位运算符<code>~, &amp;, |, ^, ^~</code>,
归约运算符<code>&amp;, |, ^, ~&amp;, ~|, ~^, ^~</code>,
移位运算符<code>&lt;&lt;, &gt;&gt;</code>, 条件运算符<code>?:</code>,
连接和复制运算符<code>&#123;&#125;, &#123;&#123;&#125;&#125;</code>.</p></li>
<li><p>Verilog HDL中,空白符总是可以忽略吗?</p>
<p>不是. 在字符串中, 在标识符中(分隔不同的标识符)不能忽略.</p></li>
<li><p>Verilog HDL中, 插入注释的方法有哪两种?</p>
<p>单行注释<code>//</code>, 多行注释<code>/* */</code></p></li>
<li><p>下面的标识符哪些是非法的, 哪些是非法的?
<code>Always, 2_1mux, \din, \wait, _qout, $data, data$, c#out, \@out</code></p>
<p>合法的: <code>Always, \din, \wait, _qout, data$, \@out</code> 非法的:
<code>2_1mux, c#out, $data</code></p></li>
<li><p>下列数字的表示方法是否正确? 若正确, 表示多少?
<code>5'd20, 'B10, 4'b10x1, 'dc10, 5'b101, 6'HAAFB</code></p>
<p><code>5'd20</code>正确, 表示5位十进制数20</p>
<p><code>'B10</code>正确, 默认为32位的二进制数10(前面补0)</p>
<p><code>4'b10x1</code>正确, 表示4位二进制数10x1</p>
<p><code>'dc10</code>错误, 十进制中没有c</p>
<p><code>5'b101</code>正确, 表示5位二进制数101</p>
<p><code>6'HAAFB</code>错误,
6位十六进制数不能表示AAFB,至少需要16位</p></li>
<li><p>已知<code>a=1'b1; b=3'b011</code>,
那么<code>&#123;a,b&#125;</code>是多少?</p>
<p><code>&#123;a,b&#125; = 4'b1011</code></p></li>
<li><p>Verilog HDL中, 数据类型可以分成几类?
每一类又包含哪些具体的数据类型?</p>
<p>数据类型可以分成两大类, 物理数据类型,
包括连线型<code>wire, tri, wor, trior, wand, trand, trireg, tri1, tri0, supply1, supply0</code>,
寄存器型<code>reg</code>; 抽象数据类型, 包括整型<code>integer</code>,
时间型<code>time</code>, 实型<code>real</code>,
参数型<code>parameter</code></p></li>
<li><p>从电路角度分析<code>wire</code>和<code>reg</code>型数据的区别.</p>
<p>连线型(wire):
连线表示逻辑单元的物理连接,可以对应电路中的物理信号连线,这种变量类型不能保持电荷(<code>trireg</code>除外).
连线型变量必须要有驱动源,一种是连接到一个门或者模块的输出端,另一种是用<code>assign</code>连续赋值语句对它进行赋值.若没有驱动源,则保持高阻态<code>z</code>.</p>
<p>寄存器型(reg):
<code>reg</code>型变量是最常见也是最重要的寄存器型数据类型,它是数据储存单元的抽象类型,其对应的硬件电路元件具有状态保持作用,能够储存数据,如触发器,锁存器等.</p></li>
<li><p>Verilog
HDL中,若连线型变量的驱动强度说明被省略,则默认的驱动强度是多少?</p>
<p>默认驱动强度为 (<code>strong1</code>, <code>strong0</code>)</p></li>
<li><p>能否对<code>memory</code>型数据进行位选择和域选择?</p>
<p>不能直接对memory型数据进行位选择或域选择,
只能先选择memory中的某个元素, 再对该元素进行位选择.</p></li>
<li><p>Verilog HDL中, 定义参数<code>parameter</code>有什么用?</p>
<p>提高代码的可读性和可维护性, 方便模块的复用和参数化设计,
在模块实例化时可以重新定义参数值.</p></li>
<li><p>运算符<code>~</code>和<code>!</code>,<code>&amp;&amp;</code>和<code>&amp;</code>有什么区别?</p>
<p><code>~</code>按位取反, <code>!</code>逻辑取反
<code>&amp;</code>按位与, <code>&amp;&amp;</code>逻辑与</p></li>
<li><p>相等运算符<code>==</code>和全等运算符<code>===</code>有什么区别?
各在什么场合使用?</p>
<p><code>==</code>和<code>!=</code>是逻辑等式运算符,
其结果是由两个操作数的值决定,
由于操作数中某些位可能是不定值<code>x</code>或者高阻态值<code>z</code>,
所以结果可能是不定值<code>x</code>.</p>
<p><code>===</code>和<code>!==</code>对操作数进行按位比较,
两个操作数必须完全一样, 结果才为1, 否则为0. 但是,
若两个操作数对应位出现<code>x</code>或者<code>z</code>,
则可以认为是相同的, 常用于<code>case</code>表达式的判别.</p></li>
<li><p>任意抽象的符合语法的Verilog
HDL模块是否都可以通过综合工具转变为电路结构?</p>
<p>不能, 可综合的Verilog代码需要遵循一定的设计规则,
通常要求代码描述的硬件行为在综合后能够映射到目标工艺库(如ASIC或FPGA)的基本逻辑单元上.</p></li>
<li><p>一般来说,模块由哪些部分组成? 每一部分又由哪些语句构成?</p>
<p>模块包含四个部分</p>
<ol type="1">
<li>模块的开始和结束: <code>module</code>开始,
<code>endmodule</code>结束, 其中模块开始语句必须以分号结束.
开始的部分包括模块名和端口列表(各个端口名用逗号隔开);</li>
<li>模块端口定义: <code>input</code>, <code>output</code>,
<code>inout</code>, 以及位宽;</li>
<li>模块的数据类型: <code>input</code>默认为<code>wire</code>,
<code>output</code>可以是<code>wire</code>,
也可以是<code>reg</code>(当在<code>always</code>或者<code>initial</code>语句块中被赋值),
<code>inout</code>一般为<code>tri</code>, 表示有多个驱动源.</li>
<li>模块的逻辑功能描述: 产生各种逻辑(主要是组合逻辑和时序逻辑),
主要包括<code>initial</code>语句, <code>always</code>语句,
其他子模块实例化语句, 门实例化语句, 用户自定义原语实例化语句,
连续赋值语句<code>assign</code>, 函数(function)和任务(task).</li>
</ol></li>
<li><p>端口有哪几种? 模块的端口是如何描述的?</p>
<p>端口类型:</p>
<p><code>input</code> 输入端口</p>
<p><code>output</code> 输出端口</p>
<p><code>inout</code> 双向端口</p>
<p>描述方法:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name (</span><br><span class="line">        <span class="keyword">input</span> [msb:lsb] port1,</span><br><span class="line">        <span class="keyword">output</span> [msb:lsb] port2,</span><br><span class="line">        <span class="keyword">inout</span> [msb:lsb] port3</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">RISC-V处理器设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-22 19:54:23" itemprop="dateModified" datetime="2026-01-22T19:54:23+08:00">2026-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="chapter-1-pc计数器">Chapter 1 PC计数器</h2>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps                                                                                     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span>   AW = <span class="number">32</span>    <span class="comment">// 地址宽度参数，默认为32位（用于RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值（指令地址输出）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，用于存储当前地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主PC更新逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿或复位下降沿触发</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时PC初始化为0</span></span><br><span class="line">        <span class="comment">// RISC-V架构中复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转使能时，PC更新为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常顺序执行时，PC每次增加4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令长度为32位（4字节）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加逻辑：存储跳转前的PC值</span></span><br><span class="line"><span class="comment">// 这个寄存器可能用于异常处理或调试目的</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;  <span class="comment">// 复位清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存跳转前的PC值</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转前的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：else分支缺失，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是一个设计缺陷或未完成部分</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-2-rom">Chapter 2 ROM</h2>
<p>现在在PC计数器的基础上, 添加ROM模块.</p>
<p>现在我们有:</p>
<ol type="1">
<li>PC计数器</li>
<li>ROM</li>
<li>顶层模块</li>
</ol>
<h3 id="stage-2-pc计数器">Stage-2 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="comment">// 特点：同步复位，时钟上升沿触发，字节寻址（每次+4）</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效（低有效复位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效，1：执行跳转，0：顺序执行</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部寄存器声明</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 当前地址寄存器，暂存跳转前的PC值</span></span><br><span class="line">                              <span class="comment">// 可用于异常处理或调试接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 应用场景：分支指令、跳转指令、异常/中断处理</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可能用于：</span></span><br><span class="line"><span class="comment">//       1. 异常返回地址保存</span></span><br><span class="line"><span class="comment">//       2. 调试信息记录</span></span><br><span class="line"><span class="comment">//       3. 流水线冲刷恢复</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转使能信号有效时的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于jal指令的返回地址保存</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计缺陷，或者current_addr只在跳转时更新</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-rom模块">Stage-2 ROM模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="comment">// 特点：异步读取，支持参数化配置，从文件加载初始化数据</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位（RISC-V指令长度）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（ROM通常不需要时钟，这里提供接口用于同步设计）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,         <span class="comment">// 时钟信号（未使用，为统一接口保留）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,       <span class="comment">// 复位信号（未使用，为统一接口保留）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// 功能：构建完整的指令文件路径</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 功能：仿真开始时从文本文件加载指令到ROM存储器</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址异步读取指令</span></span><br><span class="line"><span class="comment">// 注意：由于RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 指令读取：将字节地址转换为字地址</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：原代码中注释掉的时序逻辑版本</span></span><br><span class="line"><span class="comment">// 如果希望同步读取，可以使用以下代码：</span></span><br><span class="line"><span class="comment">// always_ff @(posedge clk or negedge rst_n)</span></span><br><span class="line"><span class="comment">//   if(!rst_n)</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= &#x27;h0;      // 复位时输出0</span></span><br><span class="line"><span class="comment">//   else</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= rom_mem[instr_addr[AW-1:2]];  // 时钟上升沿读取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-顶层模块">Stage-2 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成PC计数器和ROM，构成基本的取指流水线</span></span><br><span class="line"><span class="comment">// 当前状态：最小化测试版本，仅支持顺序执行</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径（传递给ROM）</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,     <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n    <span class="comment">// 异步复位，低电平有效</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;       <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;     <span class="comment">// 跳转目标地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;    <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;   <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前版本）</span></span><br><span class="line"><span class="comment">// 功能：在当前简化版本中，固定为顺序执行模式</span></span><br><span class="line"><span class="comment">// 后续开发：这些信号将由控制单元根据指令解码结果生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;      <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;       <span class="comment">// 跳转地址固定为0（实际未使用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line"><span class="comment">// 功能：生成指令地址，控制程序流</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)                    <span class="comment">// 传递地址宽度参数</span></span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>       (clk),         <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst_n</span>     (rst_n),       <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.jump_en</span>   (jump_en),     <span class="comment">// 跳转使能（当前为0）</span></span><br><span class="line">    <span class="variable">.jump_addr</span> (jump_addr),   <span class="comment">// 跳转地址（当前为0）</span></span><br><span class="line">    <span class="variable">.pc_pointer</span>(pc_pointer)   <span class="comment">// 输出的PC值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line"><span class="comment">// 功能：存储并输出指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),              <span class="comment">// 传递指令文件路径</span></span><br><span class="line">    <span class="variable">.AW</span>  (AW),                <span class="comment">// 传递地址宽度</span></span><br><span class="line">    <span class="variable">.DW</span>  (DW)                 <span class="comment">// 传递数据宽度</span></span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),        <span class="comment">// 时钟（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),      <span class="comment">// 复位（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer), <span class="comment">// 指令地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction) <span class="comment">// 输出的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 当前模块功能说明：</span></span><br><span class="line"><span class="comment">// 1. 复位后，PC从0x00000000开始</span></span><br><span class="line"><span class="comment">// 2. 每个时钟周期，PC自动+4（顺序执行）</span></span><br><span class="line"><span class="comment">// 3. ROM根据PC值输出对应指令</span></span><br><span class="line"><span class="comment">// 4. 当前不支持跳转、分支等控制流指令</span></span><br><span class="line"><span class="comment">// 5. 这是一个最小化的测试框架，用于验证取指功能</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 后续扩展方向：</span></span><br><span class="line"><span class="comment">// 1. 添加指令解码模块</span></span><br><span class="line"><span class="comment">// 2. 添加寄存器文件</span></span><br><span class="line"><span class="comment">// 3. 添加ALU执行单元</span></span><br><span class="line"><span class="comment">// 4. 添加控制单元生成jump_en和jump_addr</span></span><br><span class="line"><span class="comment">// 5. 添加数据存储器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-3-decode">Chapter 3 DECODE</h2>
<h3 id="stage-3-pc计数器模块">Stage-3 PC计数器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是为了保存跳转前的PC值用于后续处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-rom">Stage-3 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-译码模块">Stage-3 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址（当前未使用）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据（当前未使用）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-流水线寄存器模块">Stage-3 流水线寄存器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 解决流水线冒险 3. 提高时钟频率</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的PC值</span></span><br><span class="line"><span class="comment">// 用途：可用于计算PC相对偏移或异常处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的二进制编码</span></span><br><span class="line"><span class="comment">// 用途：为译码阶段提供稳定的指令输入</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-顶层模块">Stage-3 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 后续应由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs1_data = <span class="number">&#x27;d50</span>;          <span class="comment">// 硬连线：源寄存器1数据=50</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs2_data = <span class="number">&#x27;d100</span>;         <span class="comment">// 硬连线：源寄存器2数据=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-4-register">Chapter 4 Register</h2>
<h3 id="stage-4-pc计数器">Stage-4 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-rom">Stage-4 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-译码模块">Stage-4 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前实现存在问题：源寄存器地址分配错误</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line"><span class="comment">// 存在问题：源寄存器地址分配错误（见下文）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// <span class="doctag">BUG:</span> 这里将rs1分配给了rd_rs2_addr，应该是错误的</span></span><br><span class="line">        <span class="comment">// 正确的ADDI指令格式：rd = rs1 + imm</span></span><br><span class="line">        <span class="comment">// 所以应该是：rd_rs1_addr = rs1, rd_rs2_addr = 0</span></span><br><span class="line">        rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// <span class="doctag">BUG:</span> 应该为rs1</span></span><br><span class="line">        rd_rs2_addr = rs1;                  <span class="comment">// <span class="doctag">BUG:</span> 应该为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;; <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                   <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-ifid流水线寄存器">Stage-4 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-寄存器文件">Stage-4 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-顶层模块">Stage-4 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="comment">// 当前版本：连接了PC、ROM、IF/ID寄存器、译码器和寄存器文件</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器写回信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr_reg;    <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_en   = <span class="number">1&#x27;b1</span>;          <span class="comment">// 始终允许写寄存器（可能有问题）</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_data = op2_out;       <span class="comment">// BUG：写回数据应该是ALU结果，不是立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),    <span class="comment">// 输出到寄存器文件</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-5-alu">Chapter 5 ALU</h2>
<h3 id="stage-5-pc计数器">Stage-5 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-rom">Stage-5 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-译码模块">Stage-5 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-执行模块">Stage-5 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令执行：加法操作</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">        wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">        wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：禁用写回，输出清零</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">        wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">        wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-ifid流水线寄存器">Stage-5 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// <span class="doctag">BUG:</span> 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// <span class="doctag">BUG:</span> 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-idex流水线寄存器">Stage-5 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-寄存器文件">Stage-5 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-顶层模块">Stage-5 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-6-参数定义">Chapter 6 参数定义</h2>
<h3 id="stage-6-参数定义模块">Stage-6 参数定义模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址宽度和数据宽度</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW 						32  </span><span class="comment">// 地址宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW 						32  </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE					&quot;instr_data.txt&quot;  </span><span class="comment">// 默认指令文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I 	7&#x27;b0010011  </span><span class="comment">// I-type操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI		 	3&#x27;b000       </span><span class="comment">// 加法立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI		 	3&#x27;b010       </span><span class="comment">// 有符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU		3&#x27;b011       </span><span class="comment">// 无符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI			3&#x27;b100       </span><span class="comment">// 异或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI			3&#x27;b110       </span><span class="comment">// 或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI			3&#x27;b111       </span><span class="comment">// 与立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI			3&#x27;b001       </span><span class="comment">// 逻辑左移立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI			3&#x27;b101       </span><span class="comment">// 移位右移立即数指令（SRLI/SRAI）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L 	7&#x27;b0000011  </span><span class="comment">// 加载指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB			 	3&#x27;b000       </span><span class="comment">// 加载字节（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH			 	3&#x27;b001       </span><span class="comment">// 加载半字（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW				3&#x27;b010       </span><span class="comment">// 加载字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU			3&#x27;b100       </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU			3&#x27;b101       </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S 	7&#x27;b0100011  </span><span class="comment">// 存储指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB			 	3&#x27;b000       </span><span class="comment">// 存储字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH			 	3&#x27;b001       </span><span class="comment">// 存储半字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW				3&#x27;b010       </span><span class="comment">// 存储字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M 7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB	3&#x27;b000       </span><span class="comment">// 加法/减法指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL		 	3&#x27;b001       </span><span class="comment">// 逻辑左移</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT			3&#x27;b010       </span><span class="comment">// 有符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU			3&#x27;b011       </span><span class="comment">// 无符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR			3&#x27;b100       </span><span class="comment">// 异或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR				3&#x27;b101       </span><span class="comment">// 移位右移（SRL/SRA）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR				3&#x27;b110       </span><span class="comment">// 或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND			3&#x27;b111       </span><span class="comment">// 与</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL			3&#x27;b000       </span><span class="comment">// 乘法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH		 	3&#x27;b001       </span><span class="comment">// 乘法高位（有符号×有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU		3&#x27;b010       </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU		3&#x27;b011       </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV			3&#x27;b100       </span><span class="comment">// 有符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU			3&#x27;b101       </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM			3&#x27;b110       </span><span class="comment">// 有符号取余</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU			3&#x27;b111       </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL			7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR			7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI  		7&#x27;b0110111   </span><span class="comment">// 加载高位立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC		7&#x27;b0010111   </span><span class="comment">// PC相对加载高位立即数指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP			32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP		7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET			32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET			32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE		7&#x27;b0001111    </span><span class="comment">// 内存屏障指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL		32&#x27;h00000073  </span><span class="comment">// 环境调用指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK		32&#x27;h00100073  </span><span class="comment">// 断点指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_J 	7&#x27;b1100011   </span><span class="comment">// 分支指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ			3&#x27;b000        </span><span class="comment">// 相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE		 	3&#x27;b001        </span><span class="comment">// 不相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT			3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE			3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU			3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU			3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-pc计数器">Stage-6 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-rom">Stage-6 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-译码模块">Stage-6 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    <span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">                    <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">                    op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-执行模块">Stage-6 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    <span class="comment">// ADDI指令：加法操作</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-ifid流水线寄存器">Stage-6 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="comment">// 这是一个需要修复的BUG</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_out &lt;= `INST_NOP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-idex流水线寄存器">Stage-6 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="comment">// 指令寄存器加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= `INST_NOP;  <span class="comment">// 加载NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-寄存器文件">Stage-6 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-顶层模块">Stage-6 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 注意：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-7-整体架构">Chapter 7 整体架构</h2>
<h3 id="stage-7-参数定义">Stage-7 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-sub.txt&quot;  </span><span class="comment">// 默认指令文件（SUB指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-pc计数器">Stage-7 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-rom">Stage-7 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-译码模块">Stage-7 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;  <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-执行模块">Stage-7 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-ifid流水线寄存器">Stage-7 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了（应该修复）</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-idex流水线寄存器">Stage-7 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令编码清零</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-寄存器文件">Stage-7 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-顶层模块">Stage-7 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-8-流水线">Chapter 8 流水线</h2>
<h3 id="stage-8-参数定义">Stage-8 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-andi.txt&quot;  </span><span class="comment">// 默认指令文件（ANDI指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-pc计数器">Stage-8 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号（来自执行阶段）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值（用于异常返回）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-rom">Stage-8 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-译码模块">Stage-8 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// RISC-V不同指令类型的立即数格式不同</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-执行模块">Stage-8 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令（BNE）</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-ifid流水线寄存器">Stage-8 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,         <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                                  <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 指令数据加载NOP（空操作）</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令，避免错误指令执行</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 插入NOP指令</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out  &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out       &lt;= instr_in;       <span class="comment">// 锁存指令数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-idex流水线寄存器">Stage-8 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,     <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                              <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 指令编码加载NOP（空操作）</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 插入NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-寄存器文件">Stage-8 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-顶层模块">Stage-8 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿机制处理控制冒险</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>     (jump_en),          <span class="comment">// 跳转时停顿流水线，冲刷错误指令</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>       (jump_en),              <span class="comment">// 跳转时停顿流水线</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),       <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),            <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),           <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),           <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),   <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),        <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),          <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)           <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
