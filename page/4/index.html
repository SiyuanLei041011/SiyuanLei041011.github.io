<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SiyuanLei&#39;s Blog">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="SiyuanLei&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SiyuanLei">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SiyuanLei's Blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SiyuanLei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SiyuanLei"
      src="/images/femboy.jpg">
  <p class="site-author-name" itemprop="name">SiyuanLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SiyuanLei041011" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SiyuanLei041011" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:SiyuanLei041011@gmail.com" title="E-Mail → mailto:SiyuanLei041011@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Esther041011" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Esther041011" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://arxiv.org/" title="https:&#x2F;&#x2F;arxiv.org&#x2F;" rel="noopener" target="_blank">Arxiv</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://libgen.onl/library-genesis/" title="https:&#x2F;&#x2F;libgen.onl&#x2F;library-genesis&#x2F;" rel="noopener" target="_blank">LibGen</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://down.wlwkw.cn:8888/" title="http:&#x2F;&#x2F;down.wlwkw.cn:8888&#x2F;" rel="noopener" target="_blank">EBook</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Matlab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Matlab/" class="post-title-link" itemprop="url">MATLAB基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-05-21 17:07:44" itemprop="dateModified" datetime="2025-05-21T17:07:44+08:00">2025-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/MATLAB/" itemprop="url" rel="index"><span itemprop="name">MATLAB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本指令">基本指令</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;b=<span class="number">2</span>;c=<span class="number">3</span>;                  <span class="comment">%%命令行</span></span><br><span class="line">sum=<span class="number">1</span>+<span class="number">1</span>/<span class="number">2</span>+<span class="number">1</span>/<span class="number">3</span>+<span class="number">1</span>/<span class="number">4</span>+<span class="number">1</span>/<span class="number">5</span>+<span class="number">1</span>/<span class="number">6</span>+...</span><br><span class="line">    <span class="number">1</span>/<span class="number">7</span>+<span class="number">1</span>/<span class="number">8</span>+<span class="number">1</span>/<span class="number">9</span>;              <span class="comment">%%...是续行符，可以写多行命令</span></span><br><span class="line">clc                           <span class="comment">%%清除命令</span></span><br><span class="line">clear                         <span class="comment">%%清除变量</span></span><br><span class="line">clear 变量名                  <span class="comment">%%清除某个变量</span></span><br><span class="line">format short\long\bank（保留小数点后两位）\shortE\longE\hex(<span class="number">16</span>进制)\<span class="built_in">rat</span>（分数）</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="字符和数字">字符和数字</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">abs</span>(s);                       <span class="comment">%%输出s对应字符的ASCII码</span></span><br><span class="line">char(<span class="number">65</span>);                     <span class="comment">%%输出ASCII码为65对应的字符</span></span><br><span class="line">num2str(<span class="number">65</span>);                  <span class="comment">%%输出字符‘65’</span></span><br><span class="line">str=<span class="string">&#x27;I love U&#x27;</span>;</span><br><span class="line"><span class="built_in">length</span>(str);                  <span class="comment">%%输出str的长度</span></span><br><span class="line">a=<span class="number">6</span>+<span class="number">5</span><span class="built_in">i</span>;b=<span class="number">6</span>+<span class="number">6</span><span class="built_in">j</span>                 <span class="comment">%%a，b都是复数</span></span><br><span class="line">x=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">complex</span>(<span class="number">2</span>,x)                  <span class="comment">%%生成实部为2，虚部为x的复数</span></span><br><span class="line"><span class="built_in">real</span>(a);                      <span class="comment">%%求复数的实部</span></span><br><span class="line"><span class="built_in">imag</span>(a);                      <span class="comment">%%求复数的虚部</span></span><br><span class="line"><span class="built_in">abs</span>(a);                       <span class="comment">%%求复数的模</span></span><br><span class="line"><span class="built_in">angle</span>(a);                     <span class="comment">%%求复数的辐角</span></span><br><span class="line"><span class="built_in">conj</span>(a);                      <span class="comment">%%求共轭复数</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<h4 id="矩阵基本运算">矩阵基本运算</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">B=A.&#x27;;                        <span class="comment">%%A的转置</span></span><br><span class="line">B=A&#x27;;                         <span class="comment">%%A的共轭转置</span></span><br><span class="line">C=A(:);                       <span class="comment">%%把A中的所有元素排成一列</span></span><br><span class="line">D=inv(A);                     <span class="comment">%%A的逆矩阵</span></span><br><span class="line">E=[A,A;A,A];                  <span class="comment">%%把矩阵A拼接</span></span><br><span class="line">F=<span class="built_in">rot90</span>(A,k);                 <span class="comment">%%将A矩阵逆时针旋转90°的k倍</span></span><br><span class="line">G=<span class="built_in">fliplr</span>(A);                  <span class="comment">%%左右翻转</span></span><br><span class="line">H=<span class="built_in">flipud</span>(A);                  <span class="comment">%%上下翻转</span></span><br><span class="line">A*D;                          <span class="comment">%%矩阵乘法</span></span><br><span class="line">A.*D;                         <span class="comment">%%矩阵对应元素相乘</span></span><br><span class="line">A/D;                          <span class="comment">%%相当于A*inv（D）</span></span><br><span class="line">A./D;                         <span class="comment">%%矩阵对应元素相除</span></span><br><span class="line">A+D;                          <span class="comment">%%矩阵对应元素相加</span></span><br><span class="line">A-D;                          <span class="comment">%%矩阵对应元素相减</span></span><br><span class="line">det(A);                       <span class="comment">%%计算A的行列式</span></span><br><span class="line">adj(A);                       <span class="comment">%%计算A的伴随矩阵</span></span><br><span class="line">cond(A);                      <span class="comment">%%计算A的条件数condition，数值越小越正常</span></span><br><span class="line">rank(A);                      <span class="comment">%%计算A的秩</span></span><br><span class="line">trace(A);                     <span class="comment">%%计算A的迹</span></span><br><span class="line">eig(A);                       <span class="comment">%%计算A的特征值</span></span><br><span class="line">A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br><span class="line">B=<span class="built_in">reshape</span>(A,<span class="number">3</span>,<span class="number">2</span>);             <span class="comment">%%把A按顺序变成三行两列的矩阵</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵生成">矩阵生成</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>);               <span class="comment">%%生成10行5列3层矩阵</span></span><br><span class="line">E=zero(<span class="number">10</span>,<span class="number">5</span>);                 <span class="comment">%%生成10行5列矩阵</span></span><br><span class="line">E=<span class="built_in">rand</span>(<span class="number">2</span>,<span class="number">3</span>);                  <span class="comment">%%生成0~1之间的随机数</span></span><br><span class="line">E=<span class="built_in">randn</span>(<span class="number">3</span>,<span class="number">2</span>);                 <span class="comment">%%生成均值为0，方差为1的随机数</span></span><br><span class="line">E=randi([<span class="built_in">min</span>,<span class="built_in">max</span>],m,n);       <span class="comment">%%生成在开区间[min，max]之间随机整数的m行n列矩阵</span></span><br><span class="line">A=<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>;                      <span class="comment">%%A=[1,3,5,7,9]</span></span><br><span class="line">str=<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>:<span class="string">&#x27;z&#x27;</span>;                <span class="comment">%%str=[a,b,...,z]</span></span><br><span class="line">B=<span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>);              <span class="comment">%%把A先竖着重复3次，再横着重复2次</span></span><br><span class="line">C=<span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">4</span>);                  <span class="comment">%%生成2行4列的元素全部为1的矩阵</span></span><br><span class="line">D=<span class="built_in">eye</span>(<span class="number">5</span>);                     <span class="comment">%%生成5阶单位阵</span></span><br><span class="line">E=<span class="built_in">magic</span>(<span class="number">3</span>);                   <span class="comment">%%生成3阶幻方（就是每行，每列，对角线元素之和相等的方阵）</span></span><br><span class="line">F=<span class="built_in">vander</span>([<span class="number">1</span>;<span class="number">3</span>;<span class="number">5</span>;<span class="number">8</span>]);          <span class="comment">%%生成范德蒙德矩阵，其中a1=1,a2=3,a3=5,a4=8</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵分析">矩阵分析</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="built_in">magic</span>(<span class="number">5</span>);</span><br><span class="line">B=A(<span class="number">2</span>,<span class="number">3</span>);                     <span class="comment">%%取A的第2行第3列的元素</span></span><br><span class="line">C=A(<span class="number">8</span>);                       <span class="comment">%%取A的第8个元素</span></span><br><span class="line">D=A([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);                 <span class="comment">%%取A的第1,3,5个元素作为一个行向量</span></span><br><span class="line">E=A([<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]);             <span class="comment">%%取A的第1,3行与第2,3列相交处的元素,相当于取子式！！！</span></span><br><span class="line">F=A([<span class="number">1</span>,<span class="number">3</span>;<span class="number">2</span>,<span class="number">3</span>]);               <span class="comment">%%取A的第1,3个元素作为第一行，第2,3个元素作为第二行（与D类似）</span></span><br><span class="line">G=A(<span class="number">3</span>,:);G=A(:;<span class="number">2</span>:<span class="number">4</span>);G=A(<span class="number">2</span>:<span class="number">3</span>;<span class="number">1</span>:<span class="number">2</span>:<span class="number">5</span>)            <span class="comment">%%取A的第三行;取A的2,3,4列;取A的第2,3行和第1,2,5,列交叉处的元素</span></span><br><span class="line">A(<span class="number">3</span>,:)=[];A(:,[<span class="number">2</span>,<span class="number">4</span>])=[];      <span class="comment">%%删去A的第三行;删去A的第2,4列元素</span></span><br><span class="line">H=A(:,<span class="number">4</span>);                     <span class="comment">%%取A的第四列</span></span><br><span class="line">I=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>]);       <span class="comment">%%将A中的A(1,1),A(2,1);A(2,3),A(2,2)的序号组成一个2×2的矩阵</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">ind2sub</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]);               <span class="comment">%%将矩阵A的第1,3,5个元素的下标输出</span></span><br><span class="line">J=A(<span class="keyword">end</span>,:)/J=A([<span class="number">1</span>,<span class="number">4</span>],<span class="number">3</span>:<span class="keyword">end</span>);                  <span class="comment">%%取A的最后一行的元素、取A的第1,4行与从第3~最后一列交叉处的元素</span></span><br><span class="line">K=<span class="built_in">diag</span>(A);                    <span class="comment">%%取A的主对角线上的元素</span></span><br><span class="line">L=<span class="built_in">diag</span>([<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">5</span>]);           <span class="comment">%%将1，-2,4,5排成对角阵</span></span><br><span class="line">[m,n]=<span class="built_in">find</span>(A&gt;<span class="number">20</span>);             <span class="comment">%%找出A中大于20的元素的行标（即m）和列标（即对应于m的n）</span></span><br><span class="line">I=<span class="built_in">find</span>(A==<span class="number">5</span>);                 <span class="comment">%%找出A中等于5的元素的序号</span></span><br><span class="line"><span class="built_in">max</span>(A);                       <span class="comment">%%找出A中每列的最大的元素</span></span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">max</span>(A));                  <span class="comment">%%找出A中最大的元素，min同理</span></span><br><span class="line">sum(A);                       <span class="comment">%%求A每列元素之和</span></span><br><span class="line">sum(sum(A));                  <span class="comment">%%求A所有元素之和</span></span><br><span class="line"><span class="built_in">mean</span>(A);                      <span class="comment">%%求A每列元素的平均数</span></span><br><span class="line"><span class="built_in">mean</span>(<span class="built_in">mean</span>(A));                <span class="comment">%%求A所有元素的平均数</span></span><br><span class="line"><span class="built_in">sort</span>(A);                      <span class="comment">%%每列元素按照从小到大顺序排列</span></span><br><span class="line">sortrow(A);                   <span class="comment">%%按第一列元素从小到大排列</span></span><br><span class="line"><span class="built_in">size</span>(A);                      <span class="comment">%%输出A的行数和列数</span></span><br><span class="line"><span class="built_in">length</span>(A);                    <span class="comment">%%输出A的最长维的维数</span></span><br><span class="line"><span class="built_in">numel</span>(A);                     <span class="comment">%%输出A的元素的个数</span></span><br></pre></td></tr></table></figure>
<h2 id="数学运算">数学运算</h2>
<h3 id="一般函数">一般函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>/<span class="built_in">cos</span>/<span class="built_in">tan</span>/<span class="built_in">asin</span>/<span class="built_in">acos</span>/<span class="built_in">atan</span>/<span class="built_in">sinh</span>/<span class="built_in">cosh</span>/<span class="built_in">tanh</span>;    <span class="comment">%%三角函数</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="number">9</span>);                       <span class="comment">%%9的平方根</span></span><br><span class="line"><span class="built_in">log</span>()/<span class="built_in">log10</span>()/<span class="built_in">log2</span>;            <span class="comment">%%自然对数、常用对数、以2为底的对数函数</span></span><br><span class="line"><span class="built_in">exp</span>();                         <span class="comment">%%不解释</span></span><br><span class="line"><span class="built_in">pow2</span>;                          <span class="comment">%%2的幂,相当于平方</span></span><br><span class="line"><span class="built_in">abs</span>();                         <span class="comment">%%绝对值</span></span><br><span class="line"><span class="built_in">rem</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%求模</span></span><br><span class="line"><span class="built_in">gcd</span>(<span class="number">150</span>,<span class="number">95</span>);                   <span class="comment">%%最大公约数</span></span><br><span class="line"><span class="built_in">lcm</span>(<span class="number">10</span>,<span class="number">3</span>);                     <span class="comment">%%最小公倍数</span></span><br><span class="line"><span class="built_in">factorial</span>(<span class="number">5</span>);                  <span class="comment">%%5的阶乘</span></span><br><span class="line"><span class="built_in">isprime</span>(<span class="number">6</span>);                    <span class="comment">%%判断6是不是素数，如果是输出1，否则输出0</span></span><br><span class="line"><span class="built_in">primes</span>(<span class="number">9</span>);                     <span class="comment">%%生成1~9内所有的素数</span></span><br><span class="line"><span class="built_in">perms</span>(A);                      <span class="comment">%%生成A的所有的排列，A为行向量</span></span><br><span class="line">randperm(<span class="number">10</span>);                  <span class="comment">%%生成1~10的随机排列</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵函数">矩阵函数</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrtm(A);                     <span class="comment">%%对矩阵中所有元素开方</span></span><br><span class="line">logm(A);                      <span class="comment">%%对矩阵中所有元素取自然对数</span></span><br><span class="line">expm(A);                      <span class="comment">%%对矩阵中所有元素取指数</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算">逻辑运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;/&lt;=;                         <span class="comment">%%小于、小于等于</span></span><br><span class="line">&gt;/&gt;=;                         <span class="comment">%%大于、大于等于</span></span><br><span class="line">==/~=;                        <span class="comment">%%等于、不等于</span></span><br><span class="line">eq(a,b);                      <span class="comment">%%判断a、b是否相等，相等输出1，不相等输出0</span></span><br><span class="line">a&amp;b/and(a,b);                 <span class="comment">%%“与”，a、b全部非0时，输出1；a、b只要有一个为0，输出0</span></span><br><span class="line">a|b;or(a,b);                  <span class="comment">%%a、b只要有一个不为0，输出1；a、b全为0时，输出0</span></span><br><span class="line">~a/not(a);                    <span class="comment">%%a是0时，输出1；a不为0时，输出0</span></span><br><span class="line">xor(a,b);                     <span class="comment">%%a、b值不同时，输出1；a、b值相同时，输出0</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串运算">字符串运算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;Xidian University&#x27;</span>;</span><br><span class="line">str=<span class="string">&#x27;I&#x27;&#x27;m a student&#x27;</span>;             <span class="comment">%%当字符串中含有&#x27;时，打两个&#x27;&#x27;</span></span><br><span class="line">ch=[<span class="string">&#x27;abcdef&#x27;</span>;<span class="string">&#x27;123456&#x27;</span>];           <span class="comment">%%字符串矩阵</span></span><br><span class="line">ch=<span class="string">&#x27;ABc123d4e56Fg9&#x27;</span>;</span><br><span class="line">str=ch(<span class="number">1</span>:<span class="number">5</span>);                      <span class="comment">%%取ch的前5个元素</span></span><br><span class="line">str=ch(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);                 <span class="comment">%%将ch倒着排列</span></span><br><span class="line">place=<span class="built_in">find</span>(ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;ch&lt;=<span class="string">&#x27;z&#x27;</span>);      <span class="comment">%%找到小写字母的位置</span></span><br><span class="line">ch(place)=ch(place)-<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;A&#x27;</span>;      <span class="comment">%%将小写字母换成大写字母</span></span><br><span class="line"><span class="built_in">length</span>(place);                    <span class="comment">%%计算小写字母的数量</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&#x27;MATLAB&#x27;</span>;</span><br><span class="line">a=<span class="built_in">abs</span>(str);                       <span class="comment">%%将str里面的字符转化成ASCII码</span></span><br><span class="line">b=char(a+<span class="number">32</span>);                     <span class="comment">%%将ASCII码加32后再转化成对应的字符</span></span><br><span class="line"></span><br><span class="line">ch=[str1,str2,str3];</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;www0&#x27;</span>&gt;=<span class="string">&#x27;w123&#x27;</span>;                   <span class="comment">%%比较这两个字符串中各个元素的大小，输出1110</span></span><br><span class="line">strcmp(str1,str2);                <span class="comment">%%比较两个字符串是否相等，相等输出1，否则输出0</span></span><br><span class="line">strncmp(str1,str2,n);             <span class="comment">%%比较两个字符串的前n个元素是否相等</span></span><br><span class="line">strcmpi(str1,str2);               <span class="comment">%%忽略大小写，比较两个字符串是否相等</span></span><br><span class="line">strncmpi(str1,str2,n);            <span class="comment">%%忽略大小写,比较两个字符串的前n个元素是否相等</span></span><br><span class="line"></span><br><span class="line">findstr(str1,str2);               <span class="comment">%%输出str2在str1中开始的位置</span></span><br><span class="line">strrep(str1,str2,str3);           <span class="comment">%%将str1中的str2替换为str3</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体">结构体</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">A=cell(<span class="number">1</span>,<span class="number">6</span>);                      <span class="comment">%%生成A=[][][][][][]</span></span><br><span class="line">A&#123;<span class="number">2</span>&#125;=<span class="built_in">eye</span>(<span class="number">3</span>);                      <span class="comment">%%A=[][eye(3)][][][][]</span></span><br><span class="line">A&#123;<span class="number">6</span>&#125;=<span class="built_in">magic</span>(<span class="number">5</span>);                    <span class="comment">%%A=[][eye(3)][][][][magic(5)]</span></span><br><span class="line">B=A&#123;<span class="number">6</span>&#125;;                           <span class="comment">%%取出A中第六个元素，即magic（5）</span></span><br><span class="line">   </span><br><span class="line">A=cell(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=&#123;[<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>;<span class="number">0</span>,<span class="number">5</span>,<span class="number">8</span>;<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>]&#125;;</span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=&#123;<span class="string">&#x27;Fourier&#x27;</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=&#123;<span class="number">3</span>+<span class="number">7</span><span class="built_in">i</span>&#125;;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=&#123;<span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>&#125;;</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;                           <span class="comment">%%输出[1,4,3;0,5,8;7,2,9]</span></span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125;(<span class="number">2</span>,<span class="number">3</span>);                      <span class="comment">%%取出A&#123;1,1&#125;矩阵中的第二行第三列的元素</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>);                           <span class="comment">%%输出[3x3double]</span></span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">2</span>&#125;;                           <span class="comment">%%输出[1,3,5,7,9]</span></span><br><span class="line"></span><br><span class="line">books=struct(<span class="string">&#x27;name&#x27;</span>,&#123;&#123;<span class="string">&#x27;fourier&#x27;</span>,<span class="string">&#x27;laplace&#x27;</span>&#125;&#125;,<span class="string">&#x27;price&#x27;</span>,[<span class="number">30</span>,<span class="number">40</span>]);</span><br><span class="line">books.name(<span class="number">1</span>);                    <span class="comment">%%输出‘fourier’</span></span><br><span class="line">books.name&#123;<span class="number">1</span>&#125;;                    <span class="comment">%%输出fourier</span></span><br><span class="line"></span><br><span class="line">A=struct(<span class="string">&#x27;data&#x27;</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>;<span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>],<span class="string">&#x27;nest&#x27;</span>,struct(<span class="string">&#x27;testnum&#x27;</span>,<span class="string">&#x27;test1&#x27;</span>,<span class="string">&#x27;xdata&#x27;</span>,[<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>],<span class="string">&#x27;ydata&#x27;</span>,[<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>]));</span><br><span class="line">A(<span class="number">2</span>).data=[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.testnum=<span class="string">&#x27;test2&#x27;</span>;</span><br><span class="line">A(<span class="number">2</span>).nest.xdata=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">A(<span class="number">2</span>).nest.ydata=[<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>];</span><br><span class="line">A.nest;</span><br><span class="line">A(<span class="number">1</span>).nest.testnum;</span><br><span class="line">A(<span class="number">1</span>).nest.xdata;</span><br><span class="line">A(<span class="number">2</span>).nest.ydata;</span><br></pre></td></tr></table></figure>
<h2 id="程序设计">程序设计</h2>
<h3 id="顺序结构">顺序结构</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A=input(<span class="string">&#x27;请输入A矩阵：&#x27;</span>);</span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>);            <span class="comment">%%输入字符的时候要加上&#x27;&#x27;</span></span><br><span class="line">A=input(<span class="string">&#x27;what&#x27;&#x27;s your name?&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);        <span class="comment">%%输入字符的时候不用加&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">A=<span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="built_in">disp</span>(A);                                  <span class="comment">%%输出项只能是字符串或者是矩阵，如果要输出数字的话要用num2str()将数字转化成数字字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%例题：解方程a*x^2+b*x+c=0</span></span><br><span class="line">a=input(<span class="string">&#x27;请输入a的值&#x27;</span>);</span><br><span class="line">b=input(<span class="string">&#x27;请输入b的值&#x27;</span>);</span><br><span class="line">c=input(<span class="string">&#x27;请输入c的值&#x27;</span>);</span><br><span class="line">delta=b*b<span class="number">-4</span>*a*c;</span><br><span class="line">x=[(-b+<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a),(-b-<span class="built_in">sqrt</span>(delta))/(<span class="number">2</span>*a)];</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;x1=&#x27;</span>,num2str(x(<span class="number">1</span>)),<span class="string">&#x27;，x2=&#x27;</span>,num2str(x(<span class="number">2</span>))]);</span><br></pre></td></tr></table></figure>
<h3 id="选择结构">选择结构</h3>
<h4 id="if语句">if语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x=input(<span class="string">&#x27;请输入x的值&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> x==<span class="number">10</span></span><br><span class="line">    y=<span class="built_in">cos</span>(x+<span class="number">1</span>)+<span class="built_in">sqrt</span>(x*x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y=x*<span class="built_in">sqrt</span>(x+<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=input(<span class="string">&#x27;请输入一个字符&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(lower(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(upper(c));</span><br><span class="line"><span class="keyword">elseif</span> c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="built_in">disp</span>(str2num(c)^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(c);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="switch语句">switch语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">price=input(<span class="string">&#x27;请输入商品价格&#x27;</span>);</span><br><span class="line">  <span class="keyword">switch</span> <span class="built_in">fix</span>(price/<span class="number">100</span>)             <span class="comment">%%fix函数是将数字向0的方向取整</span></span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">          rate=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">          rate=<span class="number">3</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">5</span>:<span class="number">9</span>)            <span class="comment">%%num2cell函数是将数值矩阵转化成单元矩阵&#123;5,6,7,8,9&#125;</span></span><br><span class="line">          rate=<span class="number">5</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">10</span>:<span class="number">24</span>)</span><br><span class="line">          rate=<span class="number">8</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="built_in">num2cell</span>(<span class="number">24</span>:<span class="number">49</span>)</span><br><span class="line">          rate=<span class="number">10</span>/<span class="number">100</span>;</span><br><span class="line">      <span class="keyword">otherwise</span></span><br><span class="line">          rate=<span class="number">14</span>/<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  price=price*(<span class="number">1</span>-rate)</span><br></pre></td></tr></table></figure>
<h3 id="循环结构">循环结构</h3>
<h4 id="for语句">for语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flower=[];                      <span class="comment">%%判断水仙花数，这是开一个空矩阵</span></span><br><span class="line">    <span class="keyword">for</span> m=<span class="number">100</span>:<span class="number">999</span>;</span><br><span class="line">        m1=<span class="built_in">fix</span>(m/<span class="number">100</span>);          <span class="comment">%%取百位</span></span><br><span class="line">        m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);   <span class="comment">%%取十位</span></span><br><span class="line">        m3=<span class="built_in">rem</span>(m,<span class="number">10</span>);           <span class="comment">%%取个位</span></span><br><span class="line">        <span class="keyword">if</span> m==m1^<span class="number">3</span>+m2^<span class="number">3</span>+m3^<span class="number">3</span></span><br><span class="line">            flower=[flower,m];  <span class="comment">%%这个语句的意思是将m添加到flower中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(flower)</span><br><span class="line">  </span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="number">1</span>/(<span class="built_in">i</span>*<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="while语句">while语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line">x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> x~=<span class="number">0</span></span><br><span class="line">    sum=sum+x;</span><br><span class="line">    n=n+<span class="number">1</span>;</span><br><span class="line">    x=input(<span class="string">&#x27;输入一个数（直到输入0时结束循环）&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> n&gt;<span class="number">0</span></span><br><span class="line">    sum</span><br><span class="line">    <span class="built_in">mean</span>=sum/n</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="break和continue语句">break和continue语句</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n=<span class="number">100</span>:<span class="number">200</span><span class="comment">%%求100~200之间第一个能被21整除的数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">rem</span>(n,<span class="number">21</span>)~=<span class="number">0</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="循环的嵌套">循环的嵌套</h4>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环变量=初值:步长:终值</span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> 条件表达式<span class="comment">%%(1为真，0为假)</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">1</span>；</span><br><span class="line">    执行语句<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    执行语句n；</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> 表达式(数值或字符串)</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">1</span></span><br><span class="line">        语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 数值或字符串<span class="number">2</span></span><br><span class="line">        语句<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> 数值或字符串n</span><br><span class="line">        语句n</span><br><span class="line">    <span class="keyword">otherwise</span>(可省略)</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">n=input(<span class="string">&#x27;请输入n的值&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    sum=sum+<span class="built_in">factor</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;1到&#x27;</span>,num2str(n),<span class="string">&#x27;的阶乘的和为&#x27;</span>,num2str(sum)]);</span><br></pre></td></tr></table></figure>
<h2 id="绘图">绘图</h2>
<h3 id="二维图像">二维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);<span class="comment">%%2是标量，exp和sin是矩阵，所以2和exp是数量乘法，exp和sin是点乘</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=-<span class="built_in">pi</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="built_in">pi</span>;</span><br><span class="line">x=t.*<span class="built_in">cos</span>(<span class="number">3</span>*t);</span><br><span class="line">y=t.*<span class="built_in">sin</span>(t).*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%参数方程</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);<span class="comment">%%生成0~2*pi，元素个数为100的行向量</span></span><br><span class="line">y=[<span class="built_in">sin</span>(x);<span class="built_in">cos</span>(x)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t]&#x27;;</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line"></span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">x=[t;t];</span><br><span class="line">y=[<span class="built_in">sin</span>(t);<span class="built_in">cos</span>(t)];</span><br><span class="line"><span class="built_in">plot</span>(x,y);<span class="comment">%%这是个什么玩意儿？？？</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">sin</span>(x),x,<span class="number">2</span>*<span class="built_in">sin</span>(x),x,<span class="number">3</span>*<span class="built_in">sin</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">100</span>);</span><br><span class="line">y1=<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">y3=<span class="number">3</span>*<span class="built_in">sin</span>(x);</span><br><span class="line">x=[x;x;x]&#x27;;<span class="comment">%%注意变成行向量</span></span><br><span class="line">y=[y1;y2;y3]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y,x,<span class="built_in">cos</span>(x));</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">200</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y1=<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line">y2=<span class="built_in">sin</span>(x);</span><br><span class="line">plotyy(x,y1,x,y2);<span class="comment">%%双纵坐标，左边是y1，右边是y2</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">100</span>);<span class="comment">%%产生自变量向量x</span></span><br><span class="line">y=[];<span class="comment">%%y的初始值为空</span></span><br><span class="line"><span class="keyword">for</span> x0=x<span class="comment">%%将函数值追加到y中</span></span><br><span class="line">    <span class="keyword">if</span> x0&gt;=<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">6</span>&amp;&amp;x0&lt;<span class="number">8</span></span><br><span class="line">        y=[y,<span class="number">5</span>-x0/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">4</span>&amp;&amp;x0&lt;<span class="number">6</span></span><br><span class="line">        y=[y,<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">elseif</span> x0&gt;=<span class="number">0</span>&amp;&amp;x0&lt;<span class="number">4</span></span><br><span class="line">        y=[y,<span class="built_in">sqrt</span>(x0)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">2.5</span>]);<span class="comment">%%设置坐标轴，x坐标轴是[0，10]，y坐标轴是[0,2.5]</span></span><br><span class="line">title(<span class="string">&#x27;分段函数曲线&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Variable X&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Variable Y&#x27;</span>);</span><br><span class="line">text(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="string">&#x27;y=x^&#123;1/2&#125;&#x27;</span>);<span class="comment">%%在指定位置处添加图形说明</span></span><br><span class="line">text(<span class="number">4.5</span>,<span class="number">1.9</span>,<span class="string">&#x27;y=2&#x27;</span>);</span><br><span class="line">text(<span class="number">7.3</span>,<span class="number">1.5</span>,<span class="string">&#x27;y=5-x/2&#x27;</span>);</span><br><span class="line">text(<span class="number">8.5</span>,<span class="number">0.9</span>,<span class="string">&#x27;y=1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">60</span>);</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">z=<span class="built_in">cos</span>(x);</span><br><span class="line">t=<span class="built_in">tan</span>(x);</span><br><span class="line">ct=<span class="built_in">cot</span>(x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">%%将当前图形窗口分割成2×2，并选中1号区</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;sinx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,z);</span><br><span class="line">title(<span class="string">&#x27;cosx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-1</span>,<span class="number">1</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,t);</span><br><span class="line">title(<span class="string">&#x27;tanx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,ct);</span><br><span class="line">title(<span class="string">&#x27;cotx&#x27;</span>);axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-40</span>,<span class="number">40</span>]);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="number">10</span>*x.*x;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y);title(<span class="string">&#x27;直角坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">semilogx(x,y);title(<span class="string">&#x27;x半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">semilogy(x,y);title(<span class="string">&#x27;y半对数坐标曲线&#x27;</span>);grid;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">loglog(x,y);title(<span class="string">&#x27;全对数坐标曲线&#x27;</span>);grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">figure</span>;<span class="comment">%%建立一个幕布，可以不写</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">title(<span class="string">&#x27;y=sin(x)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);<span class="comment">%%右端对齐</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on<span class="comment">%%图形保持</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">cos</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">sin</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">20</span>:<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;b:&#x27;</span>);</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">-2</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>,<span class="string">&#x27;包络线&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">20</span>;</span><br><span class="line">y1=<span class="number">200</span>*<span class="built_in">exp</span>(<span class="number">-0.05</span>*x).*<span class="built_in">sin</span>(x);</span><br><span class="line">y2=<span class="number">0.8</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">10</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">[AX,H1,H2]=plotyy(x,y1,x,y2,<span class="string">&#x27;plot&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">1</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;slow decay&#x27;</span>);</span><br><span class="line">set(get(AX(<span class="number">2</span>),<span class="string">&#x27;Ylabel&#x27;</span>),<span class="string">&#x27;String&#x27;</span>,<span class="string">&#x27;fast decay&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Time(\musec)&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;multiple decay rates&#x27;</span>);</span><br><span class="line">set(H1,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line">set(H2,<span class="string">&#x27;linestyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>)&#x27;;</span><br><span class="line">y1=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x)*[<span class="number">1</span>,<span class="number">-1</span>];<span class="comment">%%这是包络线</span></span><br><span class="line">y2=<span class="number">2</span>*<span class="built_in">exp</span>(<span class="number">-0.5</span>*x).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x);</span><br><span class="line"><span class="built_in">plot</span>(x,y1,<span class="string">&#x27;k:&#x27;</span>,x,y2,<span class="string">&#x27;b--&#x27;</span>);<span class="comment">%%控制图像的颜色和线形</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.5</span>:<span class="number">4</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);h=<span class="built_in">cos</span>(x);w=<span class="number">1.</span>/(<span class="number">1</span>+<span class="built_in">exp</span>(-x));</span><br><span class="line">g=(<span class="number">1.</span>/<span class="number">2</span>*(<span class="number">2</span>*<span class="built_in">pi</span>)^<span class="number">0.5</span>).*<span class="built_in">exp</span>((<span class="number">-1.</span>*(x<span class="number">-2</span>*<span class="built_in">pi</span>).^<span class="number">2</span>)./<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;bd-&#x27;</span>,x,h,<span class="string">&#x27;gp:&#x27;</span>,x,w,<span class="string">&#x27;rp-&#x27;</span>,x,g,<span class="string">&#x27;c^-&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin(x)&#x27;</span>,<span class="string">&#x27;cos(x)&#x27;</span>,<span class="string">&#x27;sigmoid&#x27;</span>,<span class="string">&#x27;gauss function&#x27;</span>);</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">20</span>*<span class="built_in">pi</span>;</span><br><span class="line">r1=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*t)+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;</span><br><span class="line">r2=<span class="built_in">exp</span>(<span class="built_in">cos</span>(t-<span class="built_in">pi</span>/<span class="number">2</span>))<span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">4</span>*(t-<span class="built_in">pi</span>/<span class="number">2</span>))+<span class="built_in">sin</span>(t/<span class="number">12</span>).^<span class="number">5</span>;<span class="comment">%%旋转90°</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">polar(t,r1);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">polar(t,r2);</span><br></pre></td></tr></table></figure>
<h3 id="三维图像">三维图像</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">50</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">x=<span class="number">8</span>*<span class="built_in">cos</span>(t);</span><br><span class="line">y=<span class="number">4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line">z=<span class="number">-4</span>*<span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(t);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;line in 3D space&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;origin&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>);ylabel(<span class="string">&#x27;Y&#x27;</span>);zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line">x=<span class="number">7</span>:<span class="number">29</span>;y=<span class="number">16</span>:<span class="number">35</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);<span class="comment">%%在[7,29]×[16,35]区域内生成网格坐标</span></span><br><span class="line">z=<span class="number">2</span>*x+<span class="number">5</span>*y;</span><br><span class="line">k=<span class="built_in">find</span>(z==<span class="number">126</span>);<span class="comment">%%找到z=126的位置，就是求不定方程的解</span></span><br><span class="line">x(k)&#x27;,y(k)&#x27;;</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">mesh(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维网格图&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[x,y]=<span class="built_in">meshgrid</span>(x,y);</span><br><span class="line">z=<span class="built_in">sin</span>(y).*<span class="built_in">cos</span>(x);</span><br><span class="line">surf(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;x-axis&#x27;</span>);ylabel(<span class="string">&#x27;y-axis&#x27;</span>);zlabel(<span class="string">&#x27;z-axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;三维曲面图&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="高级应用">高级应用</h2>
<h3 id="多项式计算">多项式计算</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%多项式加减</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">3</span>];</span><br><span class="line">b=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">-1</span>];</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="comment">%%多项式乘除</span></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-10</span>];</span><br><span class="line">b=[<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>];</span><br><span class="line">c=conv(a,b);            <span class="comment">%%多项式乘法</span></span><br><span class="line">d=deconv(a,b);          <span class="comment">%%多项式除法</span></span><br><span class="line"><span class="comment">%%多项式求导</span></span><br><span class="line">p=polyder(P);           <span class="comment">%%对P求导</span></span><br><span class="line">p=polyder(P,Q);         <span class="comment">%%对P,Q求导</span></span><br><span class="line">[p,q]=polyder(P,Q);     <span class="comment">%%对P/Q求导，分子储存在p，分母储存在q</span></span><br><span class="line"><span class="comment">%%多项式求值</span></span><br><span class="line">Y=polyval(A,x);         <span class="comment">%%A是多项式，x可以是数字，向量，矩阵</span></span><br><span class="line"><span class="comment">%%多项式求根</span></span><br><span class="line">roots(P);               <span class="comment">%%求多项式的根</span></span><br></pre></td></tr></table></figure>
<h3 id="数值微分">数值微分</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DX=diff(X);             <span class="comment">%%计算X的向前差分，即DX(i)=X(i+1)-X(i)</span></span><br><span class="line">DX=diff(X);             <span class="comment">%%计算X的n阶向前差分，即DX(i)=X(i+n)-X(i)</span></span><br></pre></td></tr></table></figure>
<h3 id="插值">插值</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">4</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">y=<span class="built_in">sin</span>(x);</span><br><span class="line">xq=<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">16</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>]);</span><br><span class="line"></span><br><span class="line"> x=<span class="number">1</span>:<span class="number">100</span>;</span><br><span class="line">y=<span class="built_in">randn</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">xq=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">100</span>;</span><br><span class="line">yp1=interp1(x,y,xq);            <span class="comment">%%对x线性插值,并作出xq对应的值</span></span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yp1,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;spline&#x27;</span>);   <span class="comment">%%对x样条插值,并作出xq对应的值</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq2,<span class="string">&#x27;:.&#x27;</span>);</span><br><span class="line">xlim([<span class="number">1</span>,<span class="number">100</span>]);                  <span class="comment">%%这种方法噪音太大了</span></span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">y=[<span class="number">12</span>,<span class="number">16</span>,<span class="number">31</span>,<span class="number">10</span>,<span class="number">6</span>];</span><br><span class="line">xq=[<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1.5</span>,<span class="number">5.5</span>,<span class="number">6</span>];</span><br><span class="line">yq1=interp1(x,y,xq,<span class="string">&#x27;pchip&#x27;</span>);           <span class="comment">%%高阶外插</span></span><br><span class="line">yq2=interp1(x,y,xq,<span class="string">&#x27;liner&#x27;</span>,<span class="string">&#x27;extrap&#x27;</span>);  <span class="comment">%%低阶线性外插（数据少）</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,xq,yq1,xq,yq2);</span><br></pre></td></tr></table></figure>
<h3 id="拟合">拟合</h3>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">X=[<span class="number">-1</span>,<span class="number">-0.75</span>,<span class="number">-0.50</span>,<span class="number">-0.25</span>,<span class="number">0</span>,<span class="number">0.25</span>,<span class="number">0.50</span>,<span class="number">0.75</span>,<span class="number">1.00</span>];</span><br><span class="line">X2=[<span class="number">-1</span>:<span class="number">0.01</span>:<span class="number">1</span>];</span><br><span class="line">Y=[<span class="number">-0.2209</span>,<span class="number">0.3295</span>,<span class="number">0.8826</span>,<span class="number">1.4392</span>,<span class="number">2.0003</span>,<span class="number">2.5645</span>,<span class="number">3.1334</span>,<span class="number">3.7061</span>,<span class="number">4.2836</span>];</span><br><span class="line">P1=polyfit(X,Y,<span class="number">1</span>);</span><br><span class="line">P2=polyfit(X,Y,<span class="number">2</span>);</span><br><span class="line">Y1=polyval(P1,X2);</span><br><span class="line">Y2=polyval(P2,X2);</span><br><span class="line"><span class="built_in">plot</span>(X,Y,<span class="string">&#x27;bx&#x27;</span>,X2,Y1,<span class="string">&#x27;r&#x27;</span>,X2,Y2,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-1.2</span>,<span class="number">1.2</span>]);</span><br><span class="line">ylim([<span class="number">-0.5</span>,<span class="number">4.5</span>]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;数据点&#x27;</span>,<span class="string">&#x27;一次拟合多项式&#x27;</span>,<span class="string">&#x27;二次拟合多项式&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> xdata=[<span class="number">0.9</span>,<span class="number">1.5</span>,<span class="number">13.8</span>,<span class="number">19.8</span>,<span class="number">24.1</span>,<span class="number">28.2</span>,<span class="number">35.2</span>,<span class="number">60.3</span>,<span class="number">74.6</span>,<span class="number">81.3</span>];</span><br><span class="line"> ydata=[<span class="number">455.2</span>,<span class="number">428.6</span>,<span class="number">124.1</span>,<span class="number">67.3</span>,<span class="number">43.2</span>,<span class="number">28.1</span>,<span class="number">13.1</span>,<span class="number">-0.4</span>,<span class="number">-1.3</span>,<span class="number">-1.5</span>];</span><br><span class="line"> fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line"> x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line"> options=optimoptions(<span class="string">&#x27;lsqcurvefit&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;trust-region-reflective&#x27;</span>);</span><br><span class="line"> lb=[<span class="number">-500</span>,<span class="number">-500</span>];</span><br><span class="line"> ub=[<span class="number">500</span>,<span class="number">500</span>];</span><br><span class="line"> x=lsqcurvefit(fun,x0,xdata,ydata,lb,ub,options);</span><br><span class="line"> times=<span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"> <span class="built_in">plot</span>(xdata.ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line"> <span class="built_in">legend</span>(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;fitted exponential&#x27;</span>);?????</span><br><span class="line"> </span><br><span class="line">xdata=[<span class="number">0.9</span> <span class="number">1.5</span> <span class="number">13.8</span> <span class="number">19.8</span> <span class="number">24.1</span> <span class="number">28.2</span> <span class="number">35.2</span> <span class="number">60.3</span> <span class="number">74.6</span> <span class="number">81.3</span>];</span><br><span class="line">ydata=[<span class="number">455.2</span> <span class="number">428.6</span> <span class="number">124.1</span> <span class="number">67.3</span> <span class="number">43.2</span> <span class="number">28.1</span> <span class="number">13.1</span> <span class="number">-0.4</span> <span class="number">-1.3</span> <span class="number">-1.5</span>];</span><br><span class="line">fun=@(x,xdata)x(<span class="number">1</span>)*<span class="built_in">exp</span>(x(<span class="number">2</span>)*xdata);</span><br><span class="line">x0=[<span class="number">100</span>,<span class="number">-1</span>];</span><br><span class="line">x=lsqcurvefit(fun,x0,xdata,ydata);</span><br><span class="line">times = <span class="built_in">linspace</span>(xdata(<span class="number">1</span>),xdata(<span class="keyword">end</span>));</span><br><span class="line"><span class="built_in">plot</span>(xdata,ydata,<span class="string">&#x27;ko&#x27;</span>,times,fun(x,times),<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Data&#x27;</span>,<span class="string">&#x27;Fitted exponential&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Data and Fitted Curve&#x27;</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/LC-3%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/LC-3%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">LC-3处理器设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-17 18:47:50" itemprop="dateModified" datetime="2025-11-17T18:47:50+08:00">2025-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="顶层模块">顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lc3_processor (</span><br><span class="line">    <span class="comment">// 时钟和复位信号</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统主时钟，驱动所有同步逻辑</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，将处理器恢复到初始状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存接口信号</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 从内存读取的数据输入，16位宽度</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,       <span class="comment">// 要写入内存的数据输出，16位宽度</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] address,        <span class="comment">// 内存访问地址，16位可寻址64K内存空间</span></span><br><span class="line">    <span class="keyword">output</span> mem_read,              <span class="comment">// 内存读使能信号，高电平有效时执行读操作</span></span><br><span class="line">    <span class="keyword">output</span> mem_write,             <span class="comment">// 内存写使能信号，高电平有效时执行写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调试和状态监控信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] pc,             <span class="comment">// 当前程序计数器值，用于调试和程序流跟踪</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] ir              <span class="comment">// 当前指令寄存器值，用于调试和指令分析</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部信号定义 - 数据通路相关</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] instruction;      <span class="comment">// 当前执行的指令，从指令寄存器直接输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] dr;                <span class="comment">// 目标寄存器地址，指令[11:9]，指定结果写入的寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr1;               <span class="comment">// 源寄存器1地址，指令[8:6]，ALU操作的第一操作数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr2;               <span class="comment">// 源寄存器2地址，指令[2:0]，ALU操作的第二操作数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] imm5;              <span class="comment">// 5位立即数，指令[4:0]，用于立即数指令的符号扩展</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] pc_offset9;        <span class="comment">// 9位PC偏移量，指令[8:0]，用于分支和跳转指令的地址计算</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] pc_offset11;      <span class="comment">// 11位PC偏移量，指令[10:0]，用于JSR指令的地址计算</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector;       <span class="comment">// 8位陷阱向量，指令[7:0]，用于TRAP指令的服务程序寻址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU和总线相关信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] alu_out;          <span class="comment">// ALU运算结果输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] bus_out;          <span class="comment">// 数据总线输出，连接寄存器文件写回端口</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] reg_out [<span class="number">0</span>:<span class="number">7</span>];    <span class="comment">// 寄存器文件输出数组，8个16位通用寄存器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件码寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] nzp;               <span class="comment">// 条件码标志位：N(负)、Z(零)、P(正)，用于条件分支判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 控制信号定义 - 来自控制单元</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载使能信号</span></span><br><span class="line">    <span class="keyword">wire</span> ld_ir;                   <span class="comment">// 指令寄存器加载使能，高电平有效时更新IR</span></span><br><span class="line">    <span class="keyword">wire</span> ld_reg;                  <span class="comment">// 寄存器文件写使能，控制寄存器写入时机</span></span><br><span class="line">    <span class="keyword">wire</span> ld_cc;                   <span class="comment">// 条件码寄存器加载使能，高电平有效时更新NZP标志</span></span><br><span class="line">    <span class="keyword">wire</span> ld_pc;                   <span class="comment">// 程序计数器加载使能，高电平有效时更新PC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control;       <span class="comment">// ALU操作选择：</span></span><br><span class="line">                                  <span class="comment">// 00 = ADD, 01 = ADD立即数, 10 = AND, 11 = AND立即数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多路选择器控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel;        <span class="comment">// PC多路选择器选择信号：</span></span><br><span class="line">                                  <span class="comment">// 00 = PC+1, 01 = PC+offset9, 10 = 寄存器值, 11 = 陷阱向量</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel;       <span class="comment">// 总线多路选择器选择信号：</span></span><br><span class="line">                                  <span class="comment">// 00 = 内存数据, 01 = ALU结果, 10 = PC值, 11 = LEA偏移量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据流控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> reg_write;               <span class="comment">// 寄存器文件写使能，控制是否写入目标寄存器</span></span><br><span class="line">    <span class="keyword">wire</span> mem_to_reg;              <span class="comment">// 内存到寄存器选择，选择总线数据来源（内存或ALU）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令类型标识信号（主要用于调试和控制逻辑）</span></span><br><span class="line">    <span class="keyword">wire</span> is_trap;                 <span class="comment">// TRAP指令标识，高电平表示当前为TRAP指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_jsr;                  <span class="comment">// JSR/JSRR指令标识，高电平表示子程序调用指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_br;                   <span class="comment">// BR指令标识，高电平表示条件分支指令</span></span><br><span class="line">    <span class="keyword">wire</span> is_jmp;                  <span class="comment">// JMP/RET指令标识，高电平表示无条件跳转指令</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 主要组件实例化</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制单元 - 产生所有控制信号</span></span><br><span class="line">    <span class="comment">// 根据当前指令和处理器状态生成相应的控制信号序列</span></span><br><span class="line">    control_unit ctrl (</span><br><span class="line">        <span class="comment">// 输入接口</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),                        <span class="comment">// 时钟信号</span></span><br><span class="line">        <span class="variable">.reset</span>(reset),                    <span class="comment">// 复位信号</span></span><br><span class="line">        <span class="variable">.instruction</span>(instruction),        <span class="comment">// 当前指令输入</span></span><br><span class="line">        <span class="variable">.nzp</span>(nzp),                        <span class="comment">// 条件码标志输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 寄存器控制输出</span></span><br><span class="line">        <span class="variable">.ld_ir</span>(ld_ir),                    <span class="comment">// IR加载使能</span></span><br><span class="line">        <span class="variable">.ld_reg</span>(ld_reg),                  <span class="comment">// 寄存器文件写使能</span></span><br><span class="line">        <span class="variable">.ld_cc</span>(ld_cc),                    <span class="comment">// 条件码加载使能</span></span><br><span class="line">        <span class="variable">.ld_pc</span>(ld_pc),                    <span class="comment">// PC加载使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ALU和控制逻辑输出</span></span><br><span class="line">        <span class="variable">.alu_control</span>(alu_control),        <span class="comment">// ALU操作选择</span></span><br><span class="line">        <span class="variable">.pc_mux_sel</span>(pc_mux_sel),          <span class="comment">// PC多路选择器控制</span></span><br><span class="line">        <span class="variable">.bus_mux_sel</span>(bus_mux_sel),        <span class="comment">// 总线多路选择器控制</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据流控制输出</span></span><br><span class="line">        <span class="variable">.reg_write</span>(reg_write),            <span class="comment">// 寄存器写使能</span></span><br><span class="line">        <span class="variable">.mem_to_reg</span>(mem_to_reg),          <span class="comment">// 内存到寄存器选择</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存接口控制输出</span></span><br><span class="line">        <span class="variable">.mem_read</span>(mem_read),              <span class="comment">// 内存读使能</span></span><br><span class="line">        <span class="variable">.mem_write</span>(mem_write),            <span class="comment">// 内存写使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指令类型标识输出（调试用）</span></span><br><span class="line">        <span class="variable">.is_trap</span>(is_trap),                <span class="comment">// TRAP指令标识</span></span><br><span class="line">        <span class="variable">.is_jsr</span>(is_jsr),                  <span class="comment">// JSR指令标识</span></span><br><span class="line">        <span class="variable">.is_br</span>(is_br),                    <span class="comment">// BR指令标识</span></span><br><span class="line">        <span class="variable">.is_jmp</span>(is_jmp)                   <span class="comment">// JMP指令标识</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据通路 - 执行所有算术逻辑运算和数据传输</span></span><br><span class="line">    <span class="comment">// 包含ALU、寄存器文件、PC、MAR、MDR等核心组件</span></span><br><span class="line">    datapath dp (</span><br><span class="line">        <span class="comment">// 系统信号输入</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),                        <span class="comment">// 系统时钟</span></span><br><span class="line">        <span class="variable">.reset</span>(reset),                    <span class="comment">// 系统复位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指令和数据输入</span></span><br><span class="line">        <span class="variable">.instruction</span>(instruction),        <span class="comment">// 当前执行指令</span></span><br><span class="line">        <span class="variable">.data_in</span>(data_in),                <span class="comment">// 内存数据输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 控制信号输入</span></span><br><span class="line">        <span class="variable">.alu_control</span>(alu_control),        <span class="comment">// ALU操作控制</span></span><br><span class="line">        <span class="variable">.pc_mux_sel</span>(pc_mux_sel),          <span class="comment">// PC多路选择控制</span></span><br><span class="line">        <span class="variable">.bus_mux_sel</span>(bus_mux_sel),        <span class="comment">// 总线多路选择控制</span></span><br><span class="line">        <span class="variable">.reg_write</span>(reg_write),            <span class="comment">// 寄存器写使能</span></span><br><span class="line">        <span class="variable">.mem_to_reg</span>(mem_to_reg),          <span class="comment">// 内存到寄存器选择</span></span><br><span class="line">        <span class="variable">.ld_ir</span>(ld_ir),                    <span class="comment">// IR加载使能</span></span><br><span class="line">        <span class="variable">.ld_reg</span>(ld_reg),                  <span class="comment">// 寄存器加载使能</span></span><br><span class="line">        <span class="variable">.ld_cc</span>(ld_cc),                    <span class="comment">// 条件码加载使能</span></span><br><span class="line">        <span class="variable">.ld_pc</span>(ld_pc),                    <span class="comment">// PC加载使能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内存接口输出</span></span><br><span class="line">        <span class="variable">.data_out</span>(data_out),              <span class="comment">// 内存写数据</span></span><br><span class="line">        <span class="variable">.address</span>(address),                <span class="comment">// 内存地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内部状态输出</span></span><br><span class="line">        <span class="variable">.alu_out</span>(alu_out),                <span class="comment">// ALU运算结果</span></span><br><span class="line">        <span class="variable">.bus_out</span>(bus_out),                <span class="comment">// 总线数据</span></span><br><span class="line">        <span class="variable">.nzp</span>(nzp),                        <span class="comment">// 条件码标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调试信号输出</span></span><br><span class="line">        <span class="variable">.pc</span>(pc),                          <span class="comment">// 当前PC值</span></span><br><span class="line">        <span class="variable">.ir</span>(ir)                           <span class="comment">// 当前IR值</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="控制单元">控制单元</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> control_unit (</span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 系统复位信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] instruction,     <span class="comment">// 当前执行的16位指令</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] nzp,              <span class="comment">// 条件码标志位：N(负)、Z(零)、P(正)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_ir,             <span class="comment">// 指令寄存器加载使能，控制IR更新</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_reg,            <span class="comment">// 寄存器文件加载使能，控制寄存器写入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_cc,             <span class="comment">// 条件码寄存器加载使能，控制NZP更新</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> ld_pc,             <span class="comment">// 程序计数器加载使能，控制PC更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ALU和总线控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control, <span class="comment">// ALU操作选择控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel,  <span class="comment">// PC多路选择器选择信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel, <span class="comment">// 总线多路选择器选择信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据流控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> reg_write,         <span class="comment">// 寄存器写使能，控制寄存器文件写入</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_to_reg,        <span class="comment">// 内存到寄存器选择，选择数据来源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存访问控制信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_read,          <span class="comment">// 内存读使能，控制内存读取操作</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_write,         <span class="comment">// 内存写使能，控制内存写入操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指令类型标识信号（主要用于调试）</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_trap,           <span class="comment">// TRAP指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_jsr,            <span class="comment">// JSR指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_br,             <span class="comment">// BR指令标识信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> is_jmp             <span class="comment">// JMP指令标识信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// LC-3指令操作码定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">localparam</span> [<span class="number">3</span>:<span class="number">0</span>] </span><br><span class="line">        OP_ADD = <span class="number">4&#x27;b0001</span>,  <span class="comment">// 加法指令：寄存器+寄存器 或 寄存器+立即数</span></span><br><span class="line">        OP_AND = <span class="number">4&#x27;b0101</span>,  <span class="comment">// 逻辑与指令：寄存器&amp;寄存器 或 寄存器&amp;立即数</span></span><br><span class="line">        OP_BR  = <span class="number">4&#x27;b0000</span>,  <span class="comment">// 条件分支指令：根据条件码跳转到PC+offset9</span></span><br><span class="line">        OP_JMP = <span class="number">4&#x27;b1100</span>,  <span class="comment">// 跳转指令：跳转到寄存器指定的地址（包括RET）</span></span><br><span class="line">        OP_JSR = <span class="number">4&#x27;b0100</span>,  <span class="comment">// 跳转到子程序：保存返回地址到R7并跳转</span></span><br><span class="line">        OP_LD  = <span class="number">4&#x27;b0010</span>,  <span class="comment">// 加载指令：从内存地址PC+offset9加载数据到寄存器</span></span><br><span class="line">        OP_LDI = <span class="number">4&#x27;b1010</span>,  <span class="comment">// 间接加载指令：通过指针加载数据</span></span><br><span class="line">        OP_LDR = <span class="number">4&#x27;b0110</span>,  <span class="comment">// 基址偏移加载：从地址[基址寄存器+offset6]加载</span></span><br><span class="line">        OP_LEA = <span class="number">4&#x27;b1110</span>,  <span class="comment">// 加载有效地址：将PC+offset9的地址加载到寄存器</span></span><br><span class="line">        OP_NOT = <span class="number">4&#x27;b1001</span>,  <span class="comment">// 取反指令：对寄存器值按位取反</span></span><br><span class="line">        OP_ST  = <span class="number">4&#x27;b0011</span>,  <span class="comment">// 存储指令：将寄存器值存储到内存地址PC+offset9</span></span><br><span class="line">        OP_STI = <span class="number">4&#x27;b1011</span>,  <span class="comment">// 间接存储指令：通过指针存储数据</span></span><br><span class="line">        OP_STR = <span class="number">4&#x27;b0111</span>,  <span class="comment">// 基址偏移存储：存储到地址[基址寄存器+offset6]</span></span><br><span class="line">        OP_TRAP= <span class="number">4&#x27;b1111</span>;  <span class="comment">// 系统调用指令：执行指定的陷阱服务程序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令字段提取</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] opcode = instruction[<span class="number">15</span>:<span class="number">12</span>];    <span class="comment">// 操作码字段</span></span><br><span class="line">    <span class="keyword">wire</span> imm_mode = instruction[<span class="number">5</span>];            <span class="comment">// 立即数模式标志：1=立即数模式，0=寄存器模式</span></span><br><span class="line">    <span class="keyword">wire</span> jsr_mode = instruction[<span class="number">11</span>];           <span class="comment">// JSR模式标志：1=JSRR(寄存器)，0=JSR(PC相对)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 组合逻辑：指令译码与控制信号生成</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 默认控制信号赋值 - 确保所有输出都有确定值</span></span><br><span class="line">        ld_ir = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认不加载IR（在case外统一设置）</span></span><br><span class="line">        ld_reg = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认不加载寄存器文件</span></span><br><span class="line">        ld_cc = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认不更新条件码</span></span><br><span class="line">        ld_pc = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认PC递增（PC+1）</span></span><br><span class="line">        alu_control = <span class="number">2&#x27;b00</span>;    <span class="comment">// 默认ALU执行加法</span></span><br><span class="line">        pc_mux_sel = <span class="number">2&#x27;b00</span>;     <span class="comment">// 默认PC选择PC+1</span></span><br><span class="line">        bus_mux_sel = <span class="number">2&#x27;b00</span>;    <span class="comment">// 默认总线选择内存数据</span></span><br><span class="line">        reg_write = <span class="number">1&#x27;b0</span>;       <span class="comment">// 默认不写入寄存器文件</span></span><br><span class="line">        mem_to_reg = <span class="number">1&#x27;b0</span>;      <span class="comment">// 默认总线数据来自ALU</span></span><br><span class="line">        mem_read = <span class="number">1&#x27;b0</span>;        <span class="comment">// 默认不读取内存</span></span><br><span class="line">        mem_write = <span class="number">1&#x27;b0</span>;       <span class="comment">// 默认不写入内存</span></span><br><span class="line">        is_trap = <span class="number">1&#x27;b0</span>;         <span class="comment">// 默认非TRAP指令</span></span><br><span class="line">        is_jsr = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认非JSR指令</span></span><br><span class="line">        is_br = <span class="number">1&#x27;b0</span>;           <span class="comment">// 默认非BR指令</span></span><br><span class="line">        is_jmp = <span class="number">1&#x27;b0</span>;          <span class="comment">// 默认非JMP指令</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据操作码生成相应的控制信号</span></span><br><span class="line">        <span class="keyword">case</span> (opcode)</span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// ADD指令：目标寄存器 ← 源寄存器1 + 源寄存器2/立即数</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_ADD: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：根据imm_mode选择寄存器相加或立即数相加</span></span><br><span class="line">                alu_control = (imm_mode) ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b00</span>; </span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>; </span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// AND指令：目标寄存器 ← 源寄存器1 &amp; 源寄存器2/立即数</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_AND: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：根据imm_mode选择寄存器相与或立即数相与</span></span><br><span class="line">                alu_control = (imm_mode) ? <span class="number">2&#x27;b11</span> : <span class="number">2&#x27;b10</span>;</span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// NOT指令：目标寄存器 ← ~源寄存器1（按位取反）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_NOT: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// ALU控制：NOT操作实际上使用AND逻辑的特殊处理</span></span><br><span class="line">                alu_control = <span class="number">2&#x27;b10</span>; </span><br><span class="line">                <span class="comment">// 总线选择：将ALU运算结果送到总线</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b01</span>;</span><br><span class="line">                <span class="comment">// 寄存器控制：允许写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// BR指令：条件分支，如果条件码匹配则PC ← PC + 符号扩展(offset9)</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_BR: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置BR指令标识</span></span><br><span class="line">                is_br = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 检查条件码是否匹配：instruction[11:9]对应nzp[2:0]</span></span><br><span class="line">                <span class="comment">// instruction[11]=1且N=1，或instruction[10]=1且Z=1，或instruction[9]=1且P=1</span></span><br><span class="line">                <span class="keyword">if</span> ((instruction[<span class="number">11</span>] &amp; nzp[<span class="number">2</span>]) |   <span class="comment">// 负条件匹配</span></span><br><span class="line">                    (instruction[<span class="number">10</span>] &amp; nzp[<span class="number">1</span>]) |   <span class="comment">// 零条件匹配</span></span><br><span class="line">                    (instruction[<span class="number">9</span>] &amp; nzp[<span class="number">0</span>]))     <span class="comment">// 正条件匹配</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// 条件满足：选择PC+offset9作为下一条指令地址</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b01</span>; </span><br><span class="line">                    ld_pc = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// 如果不满足条件，PC保持默认的PC+1</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// JMP指令：无条件跳转，PC ← 寄存器值（RET是JMP R7的特殊情况）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_JMP: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置JMP指令标识</span></span><br><span class="line">                is_jmp = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// PC控制：选择寄存器值作为下一条指令地址</span></span><br><span class="line">                pc_mux_sel = <span class="number">2&#x27;b10</span>; </span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// JSR/JSRR指令：跳转到子程序</span></span><br><span class="line">            <span class="comment">// JSR: PC ← PC + 符号扩展(offset11), R7 ← 当前PC（返回地址）</span></span><br><span class="line">            <span class="comment">// JSRR: PC ← 寄存器值, R7 ← 当前PC（返回地址）</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_JSR: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置JSR指令标识</span></span><br><span class="line">                is_jsr = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 保存返回地址到R7：将当前PC值通过总线写入R7</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b10</span>;     <span class="comment">// 选择PC值送到总线</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许写入寄存器</span></span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;           <span class="comment">// 加载寄存器文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据jsr_mode选择跳转方式</span></span><br><span class="line">                <span class="keyword">if</span> (jsr_mode) <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// JSRR模式：跳转到寄存器指定的地址</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b10</span>;  <span class="comment">// 选择寄存器值</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">// JSR模式：跳转到PC+offset11</span></span><br><span class="line">                    pc_mux_sel = <span class="number">2&#x27;b01</span>;  <span class="comment">// 选择PC+offset</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// TRAP指令：系统调用</span></span><br><span class="line">            <span class="comment">// R7 ← 当前PC（返回地址），PC ← 陷阱向量表[trapvect8]</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_TRAP: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 设置TRAP指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 保存返回地址到R7：将当前PC值通过总线写入R7</span></span><br><span class="line">                bus_mux_sel = <span class="number">2&#x27;b10</span>;     <span class="comment">// 选择PC值送到总线</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 允许写入寄存器</span></span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;           <span class="comment">// 加载寄存器文件</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 跳转到陷阱服务程序：通过陷阱向量表查找服务程序地址</span></span><br><span class="line">                pc_mux_sel = <span class="number">2&#x27;b11</span>;      <span class="comment">// 选择陷阱向量地址</span></span><br><span class="line">                ld_pc = <span class="number">1&#x27;b1</span>;            <span class="comment">// 允许更新PC</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 内存控制：可能需要读取陷阱向量表中的服务程序地址</span></span><br><span class="line">                mem_read = <span class="number">1&#x27;b1</span>;         <span class="comment">// 使能内存读取</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// LD指令：加载数据，目标寄存器 ← 内存[PC + 符号扩展(offset9)]</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_LD: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 内存控制：从PC+offset9地址读取数据</span></span><br><span class="line">                mem_read = <span class="number">1&#x27;b1</span>;         <span class="comment">// 使能内存读取</span></span><br><span class="line">                mem_to_reg = <span class="number">1&#x27;b1</span>;       <span class="comment">// 总线数据来自内存（而不是ALU）</span></span><br><span class="line">                <span class="comment">// 寄存器控制：将内存数据写入目标寄存器并更新条件码</span></span><br><span class="line">                reg_write = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_reg = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                ld_cc = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            <span class="comment">// ST指令：存储数据，内存[PC + 符号扩展(offset9)] ← 源寄存器</span></span><br><span class="line">            <span class="comment">// =================================================================</span></span><br><span class="line">            OP_ST: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 内存控制：向PC+offset9地址写入寄存器数据</span></span><br><span class="line">                mem_write = <span class="number">1&#x27;b1</span>;        <span class="comment">// 使能内存写入</span></span><br><span class="line">                <span class="comment">// 指令标识</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 其他指令实现（LDI, LDR, LEA, STI, STR等）...</span></span><br><span class="line">            <span class="comment">// 这里可以继续添加其他指令的case分支</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 未定义操作码或未实现指令的默认处理</span></span><br><span class="line">                <span class="comment">// 所有信号保持默认值，确保系统稳定</span></span><br><span class="line">                is_trap = <span class="number">1&#x27;b0</span>; is_jsr = <span class="number">1&#x27;b0</span>; is_br = <span class="number">1&#x27;b0</span>; is_jmp = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每个时钟周期都取指：总是加载指令寄存器</span></span><br><span class="line">        <span class="comment">// 这确保了下一条指令能够及时进入流水线</span></span><br><span class="line">        ld_ir = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="数据通路单元">数据通路单元</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> datapath (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输入端口定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，驱动所有同步逻辑</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位所有寄存器</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] instruction,     <span class="comment">// 当前执行的16位指令字</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 从内存读取的16位数据输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制信号输入</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] alu_control,      <span class="comment">// ALU操作控制信号：00=ADD,01=ADD立即数,10=AND,11=AND立即数</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] pc_mux_sel,       <span class="comment">// PC多路选择器控制：00=PC+1,01=PC+offset,10=寄存器,11=陷阱向量</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] bus_mux_sel,      <span class="comment">// 总线多路选择器控制：00=内存,01=ALU,10=PC,11=LEA偏移量</span></span><br><span class="line">    <span class="keyword">input</span> reg_write,              <span class="comment">// 寄存器写使能信号，控制是否写入寄存器文件</span></span><br><span class="line">    <span class="keyword">input</span> mem_to_reg,             <span class="comment">// 内存到寄存器选择，选择写回数据来源（内存或ALU）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器加载控制信号</span></span><br><span class="line">    <span class="keyword">input</span> ld_ir,                  <span class="comment">// 指令寄存器加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_reg,                 <span class="comment">// 寄存器文件加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_cc,                  <span class="comment">// 条件码寄存器加载使能</span></span><br><span class="line">    <span class="keyword">input</span> ld_pc,                  <span class="comment">// 程序计数器加载使能</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输出端口定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,   <span class="comment">// 要写入内存的16位数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] address,    <span class="comment">// 内存访问地址输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] alu_out,    <span class="comment">// ALU运算结果输出，用于调试和后续处理</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] bus_out,    <span class="comment">// 数据总线输出，连接寄存器写回端口</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] nzp,         <span class="comment">// 条件码标志位输出：N(负), Z(零), P(正)</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] pc,         <span class="comment">// 当前程序计数器值，用于调试</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] ir          <span class="comment">// 当前指令寄存器值，用于调试</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件定义 - 8个16位通用寄存器</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] reg_file [<span class="number">0</span>:<span class="number">7</span>];    <span class="comment">// R0-R7寄存器文件，支持同时读写</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部信号定义</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寄存器读取输出</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] sr1_out, sr2_out; <span class="comment">// 源寄存器1和源寄存器2的读取数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 符号扩展立即数</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] imm5_sext;        <span class="comment">// 5位立即数符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset9_sext;     <span class="comment">// 9位偏移量符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset11_sext;    <span class="comment">// 11位偏移量符号扩展结果</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] offset6_sext;     <span class="comment">// 6位偏移量符号扩展结果（用于LDR/STR）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] trap_vector_addr; <span class="comment">// 陷阱向量地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PC控制信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] next_pc;          <span class="comment">// 下一条指令地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 指令解码 - 从指令字中提取各个字段</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] dr = instruction[<span class="number">11</span>:<span class="number">9</span>];    <span class="comment">// 目标寄存器地址（写入结果的寄存器）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr1 = instruction[<span class="number">8</span>:<span class="number">6</span>];    <span class="comment">// 源寄存器1地址（第一个操作数）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] sr2 = instruction[<span class="number">2</span>:<span class="number">0</span>];    <span class="comment">// 源寄存器2地址（第二个操作数）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] imm5 = instruction[<span class="number">4</span>:<span class="number">0</span>];   <span class="comment">// 5位立即数（用于ADD/AND立即数模式）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">8</span>:<span class="number">0</span>] offset9 = instruction[<span class="number">8</span>:<span class="number">0</span>]; <span class="comment">// 9位偏移量（用于LD/ST/BR/LEA等指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">10</span>:<span class="number">0</span>] offset11 = instruction[<span class="number">10</span>:<span class="number">0</span>]; <span class="comment">// 11位偏移量（用于JSR指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] offset6 = instruction[<span class="number">5</span>:<span class="number">0</span>]; <span class="comment">// 6位偏移量（用于LDR/STR指令）</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector = instruction[<span class="number">7</span>:<span class="number">0</span>]; <span class="comment">// 8位陷阱向量（用于TRAP指令）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 符号扩展单元 - 将短位宽有符号数扩展为16位</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> imm5_sext = &#123;&#123;<span class="number">11</span>&#123;imm5[<span class="number">4</span>]&#125;&#125;, imm5&#125;;           <span class="comment">// 5位立即数符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset9_sext = &#123;&#123;<span class="number">7</span>&#123;offset9[<span class="number">8</span>]&#125;&#125;, offset9&#125;;   <span class="comment">// 9位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset11_sext = &#123;&#123;<span class="number">5</span>&#123;offset11[<span class="number">10</span>]&#125;&#125;, offset11&#125;; <span class="comment">// 11位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> offset6_sext = &#123;&#123;<span class="number">10</span>&#123;offset6[<span class="number">5</span>]&#125;&#125;, offset6&#125;;  <span class="comment">// 6位偏移量符号扩展</span></span><br><span class="line">    <span class="keyword">assign</span> trap_vector_addr = &#123;<span class="number">8&#x27;b0</span>, trap_vector&#125;;      <span class="comment">// 陷阱向量零扩展为16位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件读取 - 组合逻辑读取，无时钟延迟</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> sr1_out = reg_file[sr1];  <span class="comment">// 从SR1指定寄存器读取数据</span></span><br><span class="line">    <span class="keyword">assign</span> sr2_out = reg_file[sr2];  <span class="comment">// 从SR2指定寄存器读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 算术逻辑单元(ALU) - 执行所有算术和逻辑运算</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 根据ALU控制信号执行相应的运算</span></span><br><span class="line">        <span class="keyword">case</span> (alu_control)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: alu_out = sr1_out + sr2_out;           <span class="comment">// 寄存器加法：SR1 + SR2</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: alu_out = sr1_out + imm5_sext;         <span class="comment">// 立即数加法：SR1 + 立即数</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: alu_out = sr1_out &amp; sr2_out;           <span class="comment">// 寄存器逻辑与：SR1 &amp; SR2</span></span><br><span class="line">            <span class="number">2&#x27;b11</span>: alu_out = sr1_out &amp; imm5_sext;         <span class="comment">// 立即数逻辑与：SR1 &amp; 立即数</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOT指令特殊处理：对源寄存器1按位取反</span></span><br><span class="line">        <span class="comment">// NOT指令的操作码是1001，它使用ALU的AND逻辑但需要特殊处理结果</span></span><br><span class="line">        <span class="keyword">if</span> (instruction[<span class="number">15</span>:<span class="number">12</span>] == <span class="number">4&#x27;b1001</span>) <span class="keyword">begin</span> <span class="comment">// NOT指令</span></span><br><span class="line">            alu_out = ~sr1_out;  <span class="comment">// 按位取反操作</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 总线多路选择器 - 选择写入寄存器文件的数据来源</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (bus_mux_sel)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: bus_out = data_in;     <span class="comment">// 选择内存数据（用于LD/LDI/LDR指令）</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: bus_out = alu_out;     <span class="comment">// 选择ALU运算结果（用于ADD/AND/NOT指令）</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: bus_out = pc;          <span class="comment">// 选择PC值（用于JSR/TRAP保存返回地址）</span></span><br><span class="line">            <span class="number">2&#x27;b11</span>: bus_out = offset9_sext; <span class="comment">// 选择LEA偏移量（用于LEA指令加载有效地址）</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// PC多路选择器 - 决定下一条指令的地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">assign</span> next_pc = (pc_mux_sel == <span class="number">2&#x27;b00</span>) ? pc + <span class="number">16&#x27;b1</span> :           <span class="comment">// 顺序执行：PC + 1</span></span><br><span class="line">                    (pc_mux_sel == <span class="number">2&#x27;b01</span>) ? pc + offset9_sext :    <span class="comment">// 分支跳转：PC + 符号扩展offset9</span></span><br><span class="line">                    (pc_mux_sel == <span class="number">2&#x27;b10</span>) ? sr1_out :              <span class="comment">// 寄存器跳转：使用寄存器值作为目标地址</span></span><br><span class="line">                    &#123;<span class="number">8&#x27;b0</span>, trap_vector&#125;;                          <span class="comment">// 陷阱调用：使用陷阱向量作为目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 地址生成逻辑 - 计算内存访问地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (instruction[<span class="number">15</span>:<span class="number">12</span>])  <span class="comment">// 根据操作码选择地址生成方式</span></span><br><span class="line">            <span class="number">4&#x27;b0010</span>, <span class="number">4&#x27;b0011</span>: address = pc + offset9_sext;  <span class="comment">// LD/ST：PC相对寻址</span></span><br><span class="line">            <span class="number">4&#x27;b1010</span>, <span class="number">4&#x27;b1011</span>: address = pc + offset9_sext;  <span class="comment">// LDI/STI：PC相对间接寻址</span></span><br><span class="line">            <span class="number">4&#x27;b0110</span>, <span class="number">4&#x27;b0111</span>: address = sr1_out + offset6_sext; <span class="comment">// LDR/STR：基址+偏移寻址</span></span><br><span class="line">            <span class="number">4&#x27;b1111</span>: address = trap_vector_addr;            <span class="comment">// TRAP：陷阱向量表地址</span></span><br><span class="line">            <span class="keyword">default</span>: address = pc;                          <span class="comment">// 默认使用PC作为地址</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 数据输出逻辑 - 准备要写入内存的数据</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 对于存储指令(ST/STI/STR)，将要存储的寄存器值送到data_out</span></span><br><span class="line">        data_out = sr1_out; <span class="comment">// 使用源寄存器1的值作为内存写入数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 条件码逻辑 - 跟踪最近写入结果的符号状态</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时初始化条件码为零标志</span></span><br><span class="line">            nzp &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 初始化为Z(零)标志</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_cc) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当条件码加载使能有效时，根据总线数据的符号更新条件码</span></span><br><span class="line">            <span class="keyword">if</span> (bus_out[<span class="number">15</span>] == <span class="number">1&#x27;b1</span>)        <span class="comment">// 检查最高位（符号位）</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b100</span>;              <span class="comment">// 负数：设置N标志</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bus_out == <span class="number">16&#x27;b0</span>)      <span class="comment">// 检查是否为零</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b010</span>;              <span class="comment">// 零：设置Z标志</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nzp &lt;= <span class="number">3&#x27;b001</span>;              <span class="comment">// 正数：设置P标志</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果ld_cc无效，条件码保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 程序计数器(PC) - 跟踪当前执行指令的地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时PC初始化为LC-3标准起始地址0x3000</span></span><br><span class="line">            pc &lt;= <span class="number">16&#x27;h3000</span>; </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_pc) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当PC加载使能有效时，更新为多路选择器选择的下一地址</span></span><br><span class="line">            pc &lt;= next_pc;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 默认情况下，PC每个周期递增1（顺序执行）</span></span><br><span class="line">            pc &lt;= pc + <span class="number">16&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 指令寄存器(IR) - 保存当前正在执行的指令</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时清除指令寄存器</span></span><br><span class="line">            ir &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (ld_ir) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当IR加载使能有效时，锁存当前指令</span></span><br><span class="line">            ir &lt;= instruction;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果ld_ir无效，IR保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 寄存器文件写回逻辑 - 将数据写入目标寄存器</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">integer</span> i;  <span class="comment">// 循环变量，用于复位时初始化所有寄存器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时将所有8个寄存器清零</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i = i + <span class="number">1</span>)</span><br><span class="line">                reg_file[i] &lt;= <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (reg_write &amp;&amp; ld_reg) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 当寄存器写使能和加载使能都有效时，执行写回操作</span></span><br><span class="line">            <span class="keyword">if</span> (ir[<span class="number">15</span>:<span class="number">12</span>] == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> </span><br><span class="line">                <span class="comment">// TRAP指令特殊处理：总是将返回地址写入R7</span></span><br><span class="line">                reg_file[<span class="number">3&#x27;b111</span>] &lt;= bus_out; <span class="comment">// R7 = 当前PC值（返回地址）</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 普通指令：根据mem_to_reg选择数据来源写入目标寄存器</span></span><br><span class="line">                reg_file[dr] &lt;= (mem_to_reg) ? data_in : bus_out;</span><br><span class="line">                <span class="comment">// mem_to_reg=1：从内存读取的数据(data_in)</span></span><br><span class="line">                <span class="comment">// mem_to_reg=0：从总线来的数据(bus_out，可能是ALU结果或PC值)</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// 如果写使能无效，寄存器文件保持原值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="trap处理模块">TRAP处理模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// TRAP处理模块 (Trap Handler)</span></span><br><span class="line"><span class="comment">// 功能：处理LC-3处理器的系统调用(TRAP)指令，实现陷阱向量到服务程序的地址转换</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="keyword">module</span> trap_handler (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输入端口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，用于同步陷阱处理操作</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位所有内部状态</span></span><br><span class="line">    <span class="keyword">input</span> trap_enable,            <span class="comment">// TRAP使能信号，高电平表示当前正在执行TRAP指令</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] trap_vector,      <span class="comment">// 8位陷阱向量，来自TRAP指令的[7:0]字段，用于索引陷阱服务程序</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] current_pc,      <span class="comment">// 当前程序计数器值，用于保存为返回地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 输出端口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] trap_address, <span class="comment">// 16位陷阱服务程序地址，输出到PC多路选择器</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> save_pc,           <span class="comment">// 保存PC使能信号，通知数据通路保存返回地址到R7</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] return_addr   <span class="comment">// 返回地址值，即TRAP指令执行时的PC值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内部存储器：TRAP向量表</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 256x16位陷阱向量表，将8位陷阱向量映射到16位服务程序起始地址</span></span><br><span class="line">    <span class="comment">// 索引范围：0-255，对应TRAP指令的trapvect8字段的所有可能值</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] trap_vector_table [<span class="number">0</span>:<span class="number">255</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 向量表初始化 - 预定义标准LC-3陷阱服务程序地址</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 初始化所有向量表项为0（安全默认值）</span></span><br><span class="line">        <span class="comment">// 在实际实现中，可能需要更完整的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">integer</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            trap_vector_table[i] = <span class="number">16&#x27;h0000</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// LC-3标准陷阱向量定义</span></span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 字符输入陷阱服务</span></span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h20</span>] = <span class="number">16&#x27;h0430</span>; <span class="comment">// GETC - 从键盘读取单个字符到R0</span></span><br><span class="line">        <span class="comment">// 功能：等待键盘输入，将输入的ASCII字符存入R0[7:0]，R0[15:8]清零</span></span><br><span class="line">        <span class="comment">// 不回显字符到显示器</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h21</span>] = <span class="number">16&#x27;h0450</span>; <span class="comment">// OUT - 将R0[7:0]中的字符输出到显示器</span></span><br><span class="line">        <span class="comment">// 功能：将R0寄存器低8位的ASCII字符发送到显示器输出</span></span><br><span class="line">        <span class="comment">// 注意：字符必须位于R0[7:0]，高8位被忽略</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h22</span>] = <span class="number">16&#x27;h04A0</span>; <span class="comment">// PUTS - 输出以空字符结尾的字符串</span></span><br><span class="line">        <span class="comment">// 功能：从R0指定的内存地址开始，逐个输出字符直到遇到空字符(0x0000)</span></span><br><span class="line">        <span class="comment">// 输入：R0包含字符串起始地址</span></span><br><span class="line">        <span class="comment">// 输出：字符串内容显示在显示器上</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h23</span>] = <span class="number">16&#x27;h04E0</span>; <span class="comment">// IN - 输入字符并回显</span></span><br><span class="line">        <span class="comment">// 功能：等待键盘输入，将字符存入R0[7:0]并在显示器上回显该字符</span></span><br><span class="line">        <span class="comment">// 相当于GETC和OUT的组合，但作为原子操作</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h24</span>] = <span class="number">16&#x27;hFD70</span>; <span class="comment">// PUTSP - 输出打包的字节字符串</span></span><br><span class="line">        <span class="comment">// 功能：输出内存中的打包字符串（每个16位字包含2个ASCII字符）</span></span><br><span class="line">        <span class="comment">// 输入：R0包含字符串起始地址</span></span><br><span class="line">        <span class="comment">// 输出：解包后的字符串显示在显示器上</span></span><br><span class="line">        </span><br><span class="line">        trap_vector_table[<span class="number">8&#x27;h25</span>] = <span class="number">16&#x27;hFD00</span>; <span class="comment">// HALT - 停止程序执行</span></span><br><span class="line">        <span class="comment">// 功能：停止处理器执行，通常通过设置特定的状态位来实现</span></span><br><span class="line">        <span class="comment">// 在模拟器中会停止模拟，在实际硬件中可能进入低功耗状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// 可扩展的其他陷阱向量（根据需要添加）</span></span><br><span class="line">        <span class="comment">// =====================================================================</span></span><br><span class="line">        <span class="comment">// trap_vector_table[8&#x27;h26] = 16&#x27;hXXXX; // 预留用户自定义陷阱</span></span><br><span class="line">        <span class="comment">// trap_vector_table[8&#x27;h27] = 16&#x27;hXXXX; // 预留用户自定义陷阱</span></span><br><span class="line">        <span class="comment">// ... 可以继续添加其他陷阱服务程序地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// TRAP处理状态机 - 同步逻辑</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位处理：清除所有输出信号和状态</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            trap_address &lt;= <span class="number">16&#x27;b0</span>;    <span class="comment">// 复位陷阱地址输出</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b0</span>;          <span class="comment">// 复位保存PC使能信号</span></span><br><span class="line">            return_addr &lt;= <span class="number">16&#x27;b0</span>;     <span class="comment">// 复位返回地址寄存器</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TRAP指令使能处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (trap_enable) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 阶段1：保存返回地址</span></span><br><span class="line">            <span class="comment">// 将当前PC值（TRAP指令地址+1）保存到返回地址寄存器</span></span><br><span class="line">            return_addr &lt;= current_pc;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 产生保存PC使能信号，通知数据通路将返回地址写入R7寄存器</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 阶段2：查找陷阱服务程序地址</span></span><br><span class="line">            <span class="comment">// 使用8位陷阱向量作为索引，从陷阱向量表中查找对应的服务程序起始地址</span></span><br><span class="line">            <span class="comment">// trap_vector的范围是0-255，正好对应向量表的256个条目</span></span><br><span class="line">            trap_address &lt;= trap_vector_table[trap_vector];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：这里假设陷阱向量表已经正确初始化，包含了有效的服务程序地址</span></span><br><span class="line">            <span class="comment">// 如果访问未初始化的向量表项，将返回0，可能导致处理器执行地址0的指令</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非TRAP状态处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 清除保存PC使能信号，避免在其他指令执行时误保存PC</span></span><br><span class="line">            save_pc &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：trap_address和return_addr保持它们之前的值</span></span><br><span class="line">            <span class="comment">// 这确保在TRAP处理期间输出稳定性</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 模块功能详细说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TRAP处理模块在LC-3系统中的作用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. TRAP指令执行流程：</span></span><br><span class="line"><span class="comment">   - 当处理器遇到TRAP指令时，控制单元产生trap_enable信号</span></span><br><span class="line"><span class="comment">   - TRAP处理模块接收trap_vector（来自指令低8位）和current_pc</span></span><br><span class="line"><span class="comment">   - 模块执行两个主要操作：</span></span><br><span class="line"><span class="comment">        a. 保存返回地址（current_pc）到return_addr，并产生save_pc信号</span></span><br><span class="line"><span class="comment">        b. 通过向量表查找对应的陷阱服务程序地址到trap_address</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 陷阱向量表机制：</span></span><br><span class="line"><span class="comment">   - 类似于现代操作系统中的中断向量表或系统调用表</span></span><br><span class="line"><span class="comment">   - 将用户可见的8位陷阱号映射到系统内部的服务程序入口地址</span></span><br><span class="line"><span class="comment">   - 提供硬件与操作系统服务之间的标准化接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 标准LC-3陷阱服务：</span></span><br><span class="line"><span class="comment">   - GETC (0x20): 输入单个字符，用于实现getchar()类似功能</span></span><br><span class="line"><span class="comment">   - OUT  (0x21): 输出单个字符，用于实现putchar()类似功能  </span></span><br><span class="line"><span class="comment">   - PUTS (0x22): 输出字符串，用于实现printf()类似功能</span></span><br><span class="line"><span class="comment">   - IN   (0x23): 输入并回显，用于实现交互式输入</span></span><br><span class="line"><span class="comment">   - PUTSP(0x24): 输出打包字符串，优化存储空间</span></span><br><span class="line"><span class="comment">   - HALT (0x25): 停止执行，用于程序正常退出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 关键时序：</span></span><br><span class="line"><span class="comment">   - 所有操作在时钟上升沿同步进行</span></span><br><span class="line"><span class="comment">   - trap_enable有效后，在下一个时钟周期即可获得服务程序地址</span></span><br><span class="line"><span class="comment">   - save_pc信号仅在一个时钟周期内有效，确保返回地址正确保存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 扩展性：</span></span><br><span class="line"><span class="comment">   - 可以通过添加更多向量表条目来支持自定义陷阱服务</span></span><br><span class="line"><span class="comment">   - 支持用户定义的操作系统服务调用</span></span><br><span class="line"><span class="comment">   - 为高级语言运行时库提供底层支持</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 在汇编程序中使用TRAP指令的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ; 输出字符串 &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment">        LEA R0, HELLO_STR  ; 将字符串地址加载到R0</span></span><br><span class="line"><span class="comment">        TRAP x22           ; 调用PUTS陷阱服务（陷阱向量0x22）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ; 停止程序执行</span></span><br><span class="line"><span class="comment">        TRAP x25           ; 调用HALT陷阱服务（陷阱向量0x25）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">HELLO_STR .STRINGZ &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 对应的处理器操作：</span></span><br><span class="line"><span class="comment">// 1. 执行TRAP x22指令时，trap_vector = 8&#x27;h22</span></span><br><span class="line"><span class="comment">// 2. TRAP处理模块查找向量表，得到trap_address = 16&#x27;h04A0</span></span><br><span class="line"><span class="comment">// 3. PC跳转到0x04A0执行PUTS服务程序</span></span><br><span class="line"><span class="comment">// 4. 同时将返回地址（TRAP指令地址+1）保存到R7</span></span><br><span class="line"><span class="comment">// 5. 服务程序执行完成后，通过RET（JMP R7）返回主程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 注意事项</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 陷阱向量表必须在系统启动时正确初始化，否则可能导致未定义行为</span></span><br><span class="line"><span class="comment">2. 陷阱服务程序地址应该指向有效的可执行代码区域</span></span><br><span class="line"><span class="comment">3. 在真实的LC-3实现中，陷阱服务程序通常存储在系统ROM中</span></span><br><span class="line"><span class="comment">4. 该模块假设单周期TRAP处理，在实际多周期实现中可能需要更复杂的状态机</span></span><br><span class="line"><span class="comment">5. 复位时确保所有信号处于已知状态，避免系统启动时意外触发陷阱处理</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="内存接口模块">内存接口模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 内存接口模块 (Memory Interface)</span></span><br><span class="line"><span class="comment">// 功能：LC-3处理器的内存子系统，管理64Kx16位的内存空间</span></span><br><span class="line"><span class="comment">// 特性：同步读写操作，支持从文件加载程序，提供内存就绪状态信号</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="keyword">module</span> memory_interface (</span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 系统控制信号</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> clk,                    <span class="comment">// 系统时钟信号，同步所有内存操作</span></span><br><span class="line">    <span class="keyword">input</span> reset,                  <span class="comment">// 全局复位信号，高电平有效，复位内存接口状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 处理器内存访问接口</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] address,         <span class="comment">// 16位内存地址总线，可寻址64K字空间 (0x0000-0xFFFF)</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] data_in,         <span class="comment">// 16位内存写入数据总线，处理器要写入内存的数据</span></span><br><span class="line">    <span class="keyword">input</span> mem_read,               <span class="comment">// 内存读使能信号，高电平有效时执行读操作</span></span><br><span class="line">    <span class="keyword">input</span> mem_write,              <span class="comment">// 内存写使能信号，高电平有效时执行写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存响应信号</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] data_out,   <span class="comment">// 16位内存读取数据总线，从内存读取的数据输出</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> mem_ready          <span class="comment">// 内存操作完成标志，高电平表示当前操作已完成</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存存储体定义 - 64Kx16位主内存</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 声明65536个16位存储单元，构成64K字的内存空间</span></span><br><span class="line">    <span class="comment">// 地址范围：0x0000 到 0xFFFF</span></span><br><span class="line">    <span class="comment">// 每个地址存储一个16位字，符合LC-3架构的字寻址特性</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] memory [<span class="number">0</span>:<span class="number">65535</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存初始化 - 从文件加载程序和数据</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 使用系统任务$readmemh从十六进制文件加载程序到内存</span></span><br><span class="line">        <span class="comment">// &quot;program.mem&quot;文件应包含LC-3机器码的十六进制表示</span></span><br><span class="line">        <span class="comment">// 文件格式：每行一个16位的十六进制值，从地址0开始顺序存储</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;program.mem&quot;</span>, memory); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：在真实的FPGA实现中，可能需要使用不同的内存初始化方法</span></span><br><span class="line">        <span class="comment">// 例如使用Block RAM的初始化文件或硬编码的初始值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="comment">// 内存访问控制逻辑 - 同步时序逻辑</span></span><br><span class="line">    <span class="comment">// =========================================================================</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位处理：清除所有输出信号</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            data_out &lt;= <span class="number">16&#x27;b0</span>;    <span class="comment">// 复位数据输出总线</span></span><br><span class="line">            mem_ready &lt;= <span class="number">1&#x27;b0</span>;    <span class="comment">// 复位内存就绪标志</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常操作处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 内存读操作处理</span></span><br><span class="line">            <span class="keyword">if</span> (mem_read) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 从指定地址读取数据并输出到data_out总线</span></span><br><span class="line">                <span class="comment">// 注意：这里假设内存读取在一个时钟周期内完成</span></span><br><span class="line">                <span class="comment">// 在实际系统中，可能需要考虑内存访问延迟</span></span><br><span class="line">                data_out &lt;= memory[address];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置内存就绪标志，表示读操作已完成</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 内存写操作处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mem_write) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 将数据写入指定内存地址</span></span><br><span class="line">                <span class="comment">// 注意：写操作在时钟上升沿生效</span></span><br><span class="line">                memory[address] &lt;= data_in;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置内存就绪标志，表示写操作已完成</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 无内存操作状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 清除内存就绪标志，表示当前没有进行中的内存操作</span></span><br><span class="line">                mem_ready &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 注意：data_out保持之前的值，直到下一次读操作</span></span><br><span class="line">                <span class="comment">// 这确保数据总线在非读操作期间保持稳定</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 模块功能详细说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">内存接口模块在LC-3系统中的作用：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 内存组织特性：</span></span><br><span class="line"><span class="comment">   - 64K字（128K字节）地址空间，符合LC-3架构规范</span></span><br><span class="line"><span class="comment">   - 字寻址（16位为单位），而非字节寻址</span></span><br><span class="line"><span class="comment">   - 大端序或小端序取决于具体实现（LC-3通常为大端序）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 访问时序：</span></span><br><span class="line"><span class="comment">   - 同步设计：所有操作在时钟上升沿同步进行</span></span><br><span class="line"><span class="comment">   - 单周期访问：假设内存可以在一个时钟周期内完成读写</span></span><br><span class="line"><span class="comment">   - 就绪信号：mem_ready指示操作完成，便于处理器流水线控制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 内存映射区域：</span></span><br><span class="line"><span class="comment">   在标准LC-3中，特定地址区域有特殊功能：</span></span><br><span class="line"><span class="comment">   - 0x0000-0x2FFF: 用户程序区域</span></span><br><span class="line"><span class="comment">   - 0x3000-0xFDFF: 用户数据区域  </span></span><br><span class="line"><span class="comment">   - 0xFE00-0xFFFF: 设备寄存器区域（内存映射IO）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 文件加载机制：</span></span><br><span class="line"><span class="comment">   - 支持从program.mem文件加载初始程序</span></span><br><span class="line"><span class="comment">   - 文件格式：每行一个16位十六进制值</span></span><br><span class="line"><span class="comment">   - 典型用途：加载操作系统、用户程序或测试向量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 错误处理考虑：</span></span><br><span class="line"><span class="comment">   - 当前实现未包含地址越界检查</span></span><br><span class="line"><span class="comment">   - 在实际系统中可能需要添加访问权限检查</span></span><br><span class="line"><span class="comment">   - 对于不存在的内存区域应返回错误或默认值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 内存映射IO扩展示例</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 如果需要支持内存映射IO，可以扩展模块如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module memory_interface_with_io (</span></span><br><span class="line"><span class="comment">    input clk, reset,</span></span><br><span class="line"><span class="comment">    input [15:0] address, data_in,</span></span><br><span class="line"><span class="comment">    input mem_read, mem_write,</span></span><br><span class="line"><span class="comment">    output reg [15:0] data_out,</span></span><br><span class="line"><span class="comment">    output reg mem_ready,</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 设备接口</span></span><br><span class="line"><span class="comment">    input [15:0] kbsr_data,       // 键盘状态寄存器</span></span><br><span class="line"><span class="comment">    input [15:0] kbdr_data,       // 键盘数据寄存器  </span></span><br><span class="line"><span class="comment">    output reg [15:0] ddr_data,   // 显示数据寄存器</span></span><br><span class="line"><span class="comment">    output reg [15:0] dsr_data    // 显示状态寄存器</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    reg [15:0] memory [0:65535];</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    initial begin</span></span><br><span class="line"><span class="comment">        $readmemh(&quot;program.mem&quot;, memory);</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    always @(posedge clk or posedge reset) begin</span></span><br><span class="line"><span class="comment">        if (reset) begin</span></span><br><span class="line"><span class="comment">            data_out &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">            mem_ready &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">            ddr_data &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">            dsr_data &lt;= 16&#x27;b0;</span></span><br><span class="line"><span class="comment">        end else begin</span></span><br><span class="line"><span class="comment">            if (mem_read) begin</span></span><br><span class="line"><span class="comment">                // 内存映射IO处理</span></span><br><span class="line"><span class="comment">                case (address)</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE00: data_out &lt;= kbsr_data;  // 键盘状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE02: data_out &lt;= kbdr_data;  // 键盘数据</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE04: data_out &lt;= dsr_data;   // 显示状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE06: data_out &lt;= ddr_data;   // 显示数据</span></span><br><span class="line"><span class="comment">                    default: data_out &lt;= memory[address];</span></span><br><span class="line"><span class="comment">                endcase</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b1;</span></span><br><span class="line"><span class="comment">            end else if (mem_write) begin</span></span><br><span class="line"><span class="comment">                // 内存映射IO处理</span></span><br><span class="line"><span class="comment">                case (address)</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE00: ; // KBSR只读</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE02: ; // KBDR只读</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE04: dsr_data &lt;= data_in;   // 写显示状态</span></span><br><span class="line"><span class="comment">                    16&#x27;hFE06: ddr_data &lt;= data_in;   // 写显示数据</span></span><br><span class="line"><span class="comment">                    default: memory[address] &lt;= data_in;</span></span><br><span class="line"><span class="comment">                endcase</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b1;</span></span><br><span class="line"><span class="comment">            end else begin</span></span><br><span class="line"><span class="comment">                mem_ready &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">            end</span></span><br><span class="line"><span class="comment">        end</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">endmodule</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 使用示例和测试模式</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 测试内存接口的简单测试平台：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module test_memory_interface;</span></span><br><span class="line"><span class="comment">    reg clk, reset, mem_read, mem_write;</span></span><br><span class="line"><span class="comment">    reg [15:0] address, data_in;</span></span><br><span class="line"><span class="comment">    wire [15:0] data_out;</span></span><br><span class="line"><span class="comment">    wire mem_ready;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    memory_interface uut (</span></span><br><span class="line"><span class="comment">        .clk(clk), .reset(reset),</span></span><br><span class="line"><span class="comment">        .address(address), .data_in(data_in),</span></span><br><span class="line"><span class="comment">        .mem_read(mem_read), .mem_write(mem_write),</span></span><br><span class="line"><span class="comment">        .data_out(data_out), .mem_ready(mem_ready)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 时钟生成</span></span><br><span class="line"><span class="comment">    always #5 clk = ~clk;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    initial begin</span></span><br><span class="line"><span class="comment">        // 初始化</span></span><br><span class="line"><span class="comment">        clk = 0; reset = 1; </span></span><br><span class="line"><span class="comment">        mem_read = 0; mem_write = 0;</span></span><br><span class="line"><span class="comment">        address = 0; data_in = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 复位释放</span></span><br><span class="line"><span class="comment">        #10 reset = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 测试写操作</span></span><br><span class="line"><span class="comment">        #10 mem_write = 1; address = 16&#x27;h3000; data_in = 16&#x27;h1234;</span></span><br><span class="line"><span class="comment">        #10 mem_write = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 测试读操作  </span></span><br><span class="line"><span class="comment">        #10 mem_read = 1; address = 16&#x27;h3000;</span></span><br><span class="line"><span class="comment">        #10 mem_read = 0;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // 验证读取的数据应为0x1234</span></span><br><span class="line"><span class="comment">        if (data_out === 16&#x27;h1234)</span></span><br><span class="line"><span class="comment">            $display(&quot;Test PASSED: Write and read successful&quot;);</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            $display(&quot;Test FAILED: Expected 0x1234, got 0x%h&quot;, data_out);</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        #10 $finish;</span></span><br><span class="line"><span class="comment">    end</span></span><br><span class="line"><span class="comment">endmodule</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 性能优化考虑</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 访问延迟优化：</span></span><br><span class="line"><span class="comment">   - 当前设计假设单周期内存访问</span></span><br><span class="line"><span class="comment">   - 对于高速系统，可以考虑流水线内存访问</span></span><br><span class="line"><span class="comment">   - 对于大容量内存，可能需要多周期访问</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 资源优化：</span></span><br><span class="line"><span class="comment">   - 在FPGA中，可以使用Block RAM替代分布式RAM</span></span><br><span class="line"><span class="comment">   - 对于大内存，可以分块实现并按需激活</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 功耗优化：</span></span><br><span class="line"><span class="comment">   - 添加时钟门控，在不访问内存时关闭时钟</span></span><br><span class="line"><span class="comment">   - 实现内存分块，只激活被访问的内存区域</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 错误检测：</span></span><br><span class="line"><span class="comment">   - 添加奇偶校验或ECC错误检测校正</span></span><br><span class="line"><span class="comment">   - 实现地址范围检查，防止越界访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// 文件格式说明</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">program.mem 文件格式示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// LC-3机器码的十六进制表示</span></span><br><span class="line"><span class="comment">// 地址 0x0000: 程序起始</span></span><br><span class="line"><span class="comment">3000    // 0x3000: 程序起始地址（通常）</span></span><br><span class="line"><span class="comment">1261    // ADD R1, R1, #1</span></span><br><span class="line"><span class="comment">14A1    // ADD R2, R1, R1</span></span><br><span class="line"><span class="comment">F025    // TRAP HALT (系统调用停止)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 注释以//开始，空行被忽略</span></span><br><span class="line"><span class="comment">// 每行一个16位十六进制值，从地址0开始顺序存储</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Python%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Python%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Python基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-27 17:47:13" itemprop="dateModified" datetime="2026-01-27T17:47:13+08:00">2026-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装">安装</h2>
<h3 id="python解释器的安装">Python解释器的安装</h3>
<p>进入Python官网, 找到需要的版本,
点击<code>Download Windows installer(64-bit)</code>, 安装完成后,
点击exe文件,
注意要勾选上<code>Add Python to PATH</code>和<code>Install Python for all users</code>.</p>
<p>我下载的版本是Python 3.13, 放在C盘根目录下,
也就是文件夹<code>Python313</code>, 如果需要多版本共存,
那么下载的其他版本也要放在C盘根目录下,
比如<code>Python311, Python310</code>等.</p>
<p>如果忘记勾选添加环境变量, 可以自己手动修改: 右键点击”此电脑”,
点击”属性”, 点击”高级系统设置”, 点击”环境变量”, 找到系统变量里面的PATH,
打开后添加两个路径<code>C:\Python313</code>和<code>C:\Python313\Scripts\</code>,
对于其他的版本也这样操作. 设置完成后, 可以按下<code>Win+R</code>,
输入cmd, 输入<code>Python --version</code>就可以看到当前的版本信息了.
输入<code>python</code>, 就可以运行Python了.</p>
<p>如果要切换多个版本的解释器, 那么就<code>C:\Python313</code>目录下,
添加一个<code>Python.exe</code>的副本, 命名为<code>Python313.exe</code>,
对于其他版本也这样操作. 然后在命令行窗口,
输入<code>Python313/Python311/Python310 --version</code>,
就可以分别看见不同版本的信息了.</p>
<h3 id="vs-code-python配置">VS Code + Python配置</h3>
<p>在插件栏搜索Python, 直接安装Python插件.</p>
<p>下载好之后, 可以新建一个py文件, 在右下角可以看到解释器相应的版本,
点击可以切换. 写好代码后点击右上角的三角符号就可以运行了.</p>
<p>运行时, 我们可以看到运行的终端是powershell,
点击上面的小加号旁边的箭头, 可以切换运行终端为Git bash, Command
Prompt等其他终端, 然后把之前的powershell删掉即可.</p>
<h2 id="getting-started">Getting Started</h2>
<h3 id="first-program">First Program</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代码规范">代码规范</h3>
<p>代码的规范化, 搜索Python PEPs, 就可以看到相应的规范文档了,
一般情况下, 我们遵守PEP8. 在插件栏中搜索autopep8, 安装好这个插件后,
点击”查看”, 点击”命令面板”, 输入”format document”,
就可以自动把代码规范化了.</p>
<h2 id="基本类型">基本类型</h2>
<p>整数, 浮点数, 布尔代数<code>True/False</code>,
字符串<code>"Hello, world!"</code>(可以使用单引号或者双引号,
也可以使用三个双引号输入多行字符串).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(course))</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(course[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(course[<span class="number">0</span>:])</span><br><span class="line"><span class="built_in">print</span>(course[:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(course[:])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;Python \&quot; \&#x27; \\ \nProgramming&quot;</span></span><br><span class="line"><span class="built_in">print</span>(course)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="string">&quot;Siyuan&quot;</span></span><br><span class="line">last = <span class="string">&quot;Lei&quot;</span></span><br><span class="line">full1 = first + <span class="string">&quot; &quot;</span> + last</span><br><span class="line">full2 = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">full3 = <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">len</span>(first)&#125;</span> <span class="subst">&#123;<span class="number">2</span> + <span class="number">2</span>&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(full1)</span><br><span class="line"><span class="built_in">print</span>(full2)</span><br><span class="line"><span class="built_in">print</span>(full3)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;   python programming!   &quot;</span></span><br><span class="line"><span class="built_in">print</span>(course.upper())</span><br><span class="line"><span class="built_in">print</span>(course.lower())</span><br><span class="line"><span class="built_in">print</span>(course.title())</span><br><span class="line"><span class="built_in">print</span>(course.strip())</span><br><span class="line"><span class="built_in">print</span>(course.rstrip())</span><br><span class="line"><span class="built_in">print</span>(course.lstrip())</span><br><span class="line"><span class="built_in">print</span>(course.find(<span class="string">&quot;pro&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(course.replace(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;j&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pro&quot;</span> <span class="keyword">in</span> course)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pro&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> course)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">floating_number = <span class="number">1.2</span></span><br><span class="line">imaginary_number = <span class="number">3</span> + <span class="number">9j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> + <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> - <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> * <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> // <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> % <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> ** <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">x = x + <span class="number">3</span></span><br><span class="line">x += <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">2.6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">4.5</span>))</span><br><span class="line"><span class="built_in">print</span>(math.ceil(<span class="number">2.2</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&quot;x: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x))</span><br><span class="line">y = <span class="built_in">int</span>(x) + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x: <span class="subst">&#123;x&#125;</span>, y: <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(-<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&quot;False&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&quot;B&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bag&quot;</span> &gt; <span class="string">&quot;apple&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bag&quot;</span> == <span class="string">&quot;BAG&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="控制流">控制流</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperature = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> temperature &gt; <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is warm&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Drink water&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> temperature &gt; <span class="number">20</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is nice&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It is cold&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line">message = <span class="string">&quot;Eligible&quot;</span> <span class="keyword">if</span> age &gt;= <span class="number">18</span> <span class="keyword">else</span> <span class="string">&quot;Not eligible&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">high_income = <span class="literal">False</span></span><br><span class="line">good_credit = <span class="literal">True</span></span><br><span class="line">student = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (high_income <span class="keyword">or</span> good_credit) <span class="keyword">and</span> (<span class="keyword">not</span> student):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eligible&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not eligible&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">22</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">18</span>&lt;= age &lt;<span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;eligible&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, number)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, number + <span class="number">1</span>, (number + <span class="number">1</span>) * <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, i, i * <span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, j)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>, j, j * <span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">successful = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> successful:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Successful&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Attempt 3 times and failed&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;Python&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">    number //= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> command.lower() != <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ECHO&quot;</span>, command)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ECHO&quot;</span>, command)</span><br><span class="line">    <span class="keyword">if</span> command.lower() == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hi, <span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Wick&quot;</span>)</span><br><span class="line">greet(<span class="string">&quot;Siyuan&quot;</span>, <span class="string">&quot;Lei&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hi <span class="subst">&#123;name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">message = get_greeting(<span class="string">&quot;Siyuan&quot;</span>)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;content.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">file.write(message)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">number, by</span>):</span><br><span class="line">    <span class="keyword">return</span> number + by</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">2</span>, by=<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span>  <span class="title function_">increment</span>(<span class="params">number, by = <span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> number + by</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(increment(<span class="number">3</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">*numbers</span>):</span><br><span class="line">    total = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        total *= number</span><br><span class="line">    <span class="keyword">return</span>(total)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(multiply(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_user</span>(<span class="params">**user</span>):</span><br><span class="line">    <span class="built_in">print</span>(user)</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;id&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;age&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(user[<span class="string">&quot;gender&quot;</span>])</span><br><span class="line"></span><br><span class="line">save_user(<span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;Siyuan&quot;</span>, age=<span class="number">20</span>, gender=<span class="string">&quot;Female&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="调试">调试</h2>
<p>将.py文件放入一个文件夹中, 比如<code>Python Code</code>,
然后把这个文件放进VS Code的工作区. 在VS Code的左边一栏点击Debug选项,
点击齿轮形状的选项, 然后就会出现一个<code>launch.json</code>的文件,
关闭它, 然后就可以开始Debug了.</p>
<p>先设置一个断点, 按下<code>F5</code>进入调试模式,
这时程序从断点处执行, 按下<code>F10</code>执行下一条语句,
如果这一条语句里面有函数的调用, 就可以按下<code>F11</code>进入该函数,
在函数内部按<code>F10</code>可以单步执行.</p>
<h2 id="数据结构">数据结构</h2>
<h3 id="列表">列表</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line">matrix = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">zeros = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(zeros)</span><br><span class="line">combined = zeros + letters</span><br><span class="line"><span class="built_in">print</span>(combined)</span><br><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">chars = <span class="built_in">list</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(chars))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers[:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(numbers[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">19</span>]</span><br><span class="line">first, second, third, *other1 = numbers</span><br><span class="line"><span class="built_in">print</span>(first)</span><br><span class="line"><span class="built_in">print</span>(second)</span><br><span class="line"><span class="built_in">print</span>(third)</span><br><span class="line"><span class="built_in">print</span>(other1)</span><br><span class="line"></span><br><span class="line">one, *other2, last = numbers</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(one)</span><br><span class="line"><span class="built_in">print</span>(other2)</span><br><span class="line"><span class="built_in">print</span>(last)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">enumerate</span>(letters):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(letters):</span><br><span class="line">    <span class="built_in">print</span>(index, letter)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line">letters.append(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.insert(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"></span><br><span class="line">letters.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.remove(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line"><span class="keyword">del</span> letters[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br><span class="line">letters.clear()</span><br><span class="line"><span class="built_in">print</span>(letters)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(letters.count(<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.count(<span class="string">&quot;d&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(letters.index(<span class="string">&quot;a&quot;</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">78</span>, <span class="number">54</span>, <span class="number">3</span>, <span class="number">10</span>]</span><br><span class="line">numbers.sort()</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">numbers.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">new_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(new_numbers)</span><br><span class="line">new_numbers = <span class="built_in">sorted</span>(numbers, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(new_numbers)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_item</span>(<span class="params">items</span>):</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">items.sort(key=sort_item)</span><br><span class="line"><span class="built_in">print</span>(items)</span><br><span class="line"></span><br><span class="line">items.sort(key=<span class="keyword">lambda</span> items:items[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(items)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">price = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    price.append(items[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(price)</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">map</span>(<span class="keyword">lambda</span> items: items[<span class="number">1</span>], items)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">filter</span>(<span class="keyword">lambda</span> items: items[<span class="number">1</span>]&gt;=<span class="number">10</span>, items)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">items = [</span><br><span class="line">    (<span class="string">&quot;Product1&quot;</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="string">&quot;Product2&quot;</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="string">&quot;Product3&quot;</span>, <span class="number">18</span>),</span><br><span class="line">    (<span class="string">&quot;Product4&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    (<span class="string">&quot;Product5&quot;</span>, <span class="number">7</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">prices = [item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> items]</span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span> = [item <span class="keyword">for</span> item <span class="keyword">in</span> items <span class="keyword">if</span> item[<span class="number">1</span>]&gt;=<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">new_list = <span class="built_in">zip</span>(<span class="string">&quot;abc&quot;</span>, list1, list2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(new_list))</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列">栈和队列</h3>
<h3 id="tuples">Tuples</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chars = <span class="built_in">tuple</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>) * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">x, y, z = z, x, y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>, x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:&quot;</span>, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;z:&quot;</span>, z)</span><br></pre></td></tr></table></figure>
<h3 id="向量array">向量Array</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">numbers = array(<span class="string">&quot;i&quot;</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h3 id="集合set">集合set</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line">uniques = <span class="built_in">set</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(uniques)</span><br><span class="line"></span><br><span class="line">second = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">second.add(<span class="number">6</span>)</span><br><span class="line">second.remove(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">len</span>(second)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">second = &#123;<span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(first | second)</span><br><span class="line"><span class="built_in">print</span>(first &amp; second)</span><br><span class="line"><span class="built_in">print</span>(first - second)</span><br><span class="line"><span class="built_in">print</span>(first ^ second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> first:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="字典">字典</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">point = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">point = <span class="built_in">dict</span>(x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(point[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">point[<span class="string">&quot;z&quot;</span>] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(point)</span><br><span class="line"><span class="built_in">print</span>(point.get(<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(point.get(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">del</span> point[<span class="string">&quot;x&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> point:</span><br><span class="line">    <span class="built_in">print</span>(key, point[key])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> point.items():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> point.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = &#123;x: x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure>
<h3 id="生成元">生成元</h3>
<h3 id="解包算符">解包算符</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(*numbers)</span><br><span class="line"></span><br><span class="line">values = [*<span class="built_in">range</span>(<span class="number">5</span>), *<span class="string">&quot;Hello&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"></span><br><span class="line">first = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">second = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">10</span>, <span class="string">&quot;y&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">combined = &#123;**first, **second, <span class="string">&quot;z&quot;</span>: <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(combined)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">RISC-V体系结构编程与实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-08 13:16:24" itemprop="dateModified" datetime="2025-08-08T13:16:24+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/RISC-V/" itemprop="url" rel="index"><span itemprop="name">RISC-V</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="实验环境搭建">实验环境搭建</h2>
<p>在VMware中安装完Ubuntu Linux 20.04
系统后,打开终端,可以通过如下命令安装需要的软件包:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt update -y</span></span><br><span class="line"></span><br><span class="line">[sudo] siyuanlei 的密码： 123456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt install net-tools libncurses5-dev libssl-dev build-essential openssl qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu git bison flex bc vim universal-ctags cscope gdb-multiarch libsdl2-dev libreadline-dev</span></span><br></pre></td></tr></table></figure>
<p>我们再克隆GitHub上的<code>runninglinuxkernel/riscv_ programming_ practice</code>仓库到当前目录下,在Linux系统中,使用<code>git clone</code>命令克隆的GitHub仓库默认会保存在当前工作目录下具体位置取决于你执行命令时所在的目录:</p>
<ol type="1">
<li>默认存储位置:如果你没有切换目录就直接执行<code>git clone</code>,仓库会保存在当前用户的主目录(/home/你的用户名/),例如：/home/ubuntu/riscv_programming_practice/</li>
<li>如果你先切换了目录再执行克隆,仓库会保存在你切换后的目录,例如:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp  # 先切换到 /tmp 目录</span><br><span class="line">git clone https://github.com/xxx/yyy.git  # 仓库会保存在 /tmp/yyy/</span><br></pre></td></tr></table></figure>
<p>下面我们进行克隆</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Git</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt install git -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆仓库</span></span><br><span class="line">git clone https://github.com/runninglinuxkernel/riscv_programming_practice.git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入 chapter2</span></span><br><span class="line">cd riscv_programming_practice/chapter2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录内容（验证）</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h3 id="实验2-1输出welcome-to-risc-v">实验2-1:输出”Welcome to
RISC-V!”</h3>
<p>在Linux主机中安装相关工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt-get install qemu-system-misc libncurses5-dev gcc-riscv64-linux-gnu build-essential git bison flex libssl-dev</span></span><br></pre></td></tr></table></figure>
<p>下面我们在QEMU上运行BenOS</p>
<p>我们首先在Linux主机上使用make命令编译BenOS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">export</span> board=qemu</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make clean</span></span><br></pre></td></tr></table></figure>
<p>想要编译可以在QEMU模拟器上运行的可执行二进制文件,需要先设置<code>board=qemu</code>.</p>
<p>直接输入<code>make run</code>命令并运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlk@master:benos$ make run</span><br></pre></td></tr></table></figure>
<p>我们可以看到QEMU输出”Welcome
RISC-V!“.要关闭QEMU,可以按下<code>Ctrl+A</code>键,松开后再快速按下<code>X</code>键.</p>
<h3 id="实验2-2单步调试benos和mysbi">实验2-2:单步调试BenOS和MySBI</h3>
<p>使用<code>make debug</code>命令在终端启动QEMU虚拟机的gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cd</span> riscv_programming_practice/chapter_2/benos</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">make debug</span></span><br></pre></td></tr></table></figure>
<p>或者直接使用如下命令启动gdbserver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">qemu-system-riscv64 -nographic -machine virt -m 128M -bios mysbi.bin -kernel benos.elf -S -s</span></span><br></pre></td></tr></table></figure>
<p>在另一个终端使用如下命令启动GDB工具</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gdb-multiarch --tui benos.elf</span></span><br></pre></td></tr></table></figure>
<p>在GDB命令行中执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/SUSY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/SUSY/" class="post-title-link" itemprop="url">Notes on Supersymmetry</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-15 00:54:15" itemprop="dateModified" datetime="2025-07-15T00:54:15+08:00">2025-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%A9%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">物理</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%A9%E7%90%86/%E8%B6%85%E5%AF%B9%E7%A7%B0/" itemprop="url" rel="index"><span itemprop="name">超对称</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="weyl-spinors">Weyl Spinors</h2>
<h3
id="brief-review-of-the-dirac-equation-and-of-some-matrix-properties">Brief
Review of the Dirac Equation and of Some Matrix Properties</h3>
<p>Dirac Equation:</p>
<p><span class="math display">\[\gamma^\mu P_\mu\Psi=m\Psi~~\rm{or}~~
\not{\rm{P}}\Psi=m\Psi(\rm{use~Feynman&#39;s~slash~notation})\]</span></p>
<p>Here, <span class="math inline">\(P_\mu\)</span> represents the
differential operator <span
class="math inline">\(i\partial_\mu\)</span>. Throughout this note we
use natural unit, in which <span
class="math inline">\(c=\hbar=1\)</span>.</p>
<p>Dirac Lagrangian:</p>
<p><span class="math display">\[\mathcal{L}=\overline{\Psi}(\gamma^\mu
P_\mu-m)\Psi\]</span></p>
<p>where the bar over the spinor denotes the Dirac adjoint <span
class="math inline">\(\overline{\Psi}=\Psi^\dagger\gamma^0\)</span>.</p>
<p>Dirac matrix:</p>
<p>There are several different representations for the Dirac matrix
<span class="math inline">\(\gamma^0\)</span> and <span
class="math inline">\(\vec{\gamma}\)</span>. We choose
representation</p>
<p><span class="math display">\[\gamma^0=\begin{pmatrix}
    0 &amp; \boldsymbol{1}\\
    \boldsymbol{1}&amp;0
\end{pmatrix}~~\vec{\gamma}=\begin{pmatrix}
    0&amp; -\vec{\sigma}\\
    \vec{\sigma}&amp;0\\
\end{pmatrix}\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{1}\)</span> stands for
the <span class="math inline">\(2\times 2\)</span> identity matrix.
These can be used to define <span
class="math inline">\(\gamma^\mu=(\gamma^0,\vec{\gamma})\)</span>. The
corresponding quatity with a covariant index is defined as <span
class="math inline">\(\gamma_\mu=\eta_{\mu\nu}\gamma^\nu=(\gamma^0,-\vec{\gamma})\)</span>,
where <span
class="math inline">\(\eta_{\mu\nu}=\rm{diag}(1,-1,-1,-1)\)</span>.</p>
<p>For <span class="math inline">\(\gamma_5\)</span>, we choose the
chiral or Weyl representation</p>
<p><span class="math display">\[\gamma_5=\begin{pmatrix}
    \boldsymbol{1}&amp;0\\
    0&amp;-\boldsymbol{1}
\end{pmatrix}\]</span></p>
<p>Pauli matrices:</p>
<p><span class="math display">\[\sigma^1=\begin{pmatrix}
    0&amp;1\\
    1&amp;0\\
\end{pmatrix}~~~~
\sigma^2=\begin{pmatrix}
    0&amp;-i\\
    i&amp;0\\
\end{pmatrix}~~~~
\sigma^3=\begin{pmatrix}
    1&amp;0\\
    0&amp;-1
\end{pmatrix}\]</span></p>
<p>They have the follwing properties:</p>
<ol type="1">
<li>They are hermitian, i.e., <span
class="math inline">\((\sigma^i)^\dagger=\sigma^i\)</span></li>
<li>The product of any two Pauli matrix is given by <span
class="math inline">\(\sigma^i\sigma^j=\boldsymbol{1}\delta^{ij}+i\epsilon^{ijk}\sigma^k\)</span></li>
<li>The commutator of two Pauli matrices is <span
class="math inline">\([\sigma^1,\sigma^j]=2i\epsilon^{ijk}\sigma^k\)</span></li>
<li>The anticommutator of two Pauli matries is <span
class="math inline">\(\{\sigma^i,\sigma^j\}=2\delta^{ij}\boldsymbol{1}\)</span></li>
<li><span
class="math inline">\(\sigma^2\vec{\sigma}^T=-\vec{\sigma}\sigma^2,~~\sigma^2\vec{\sigma}^*=-\vec{\sigma}\sigma^2\)</span></li>
</ol>
<h3 id="weyl-versus-dirac-spinors">Weyl versus Dirac Spinors</h3>
<p>We now wirte the four-component Dirac spinor in terms of
two-component spinors:</p>
<p><span class="math display">\[\Psi=\begin{pmatrix}
    \eta\\
    \chi
\end{pmatrix}\]</span></p>
<p>where the two-component spinors are called Weyl spinors. The reason
it makes sense to decompose a Dirac spinor this way is that, as we will
see, <span class="math inline">\(\eta\)</span> and <span
class="math inline">\(\chi\)</span> transform independently under
Lorentz transformations, i.e., they don’t mix. The technical way to
express this is to say that a Dirac spinor forms a reducible
representationpf the Lorentz group, whereas the Weyl spinors form
irreducible representations.</p>
<p>Note that setting either <span class="math inline">\(\eta\)</span> or
<span class="math inline">\(\chi\)</span> equal to zero in a Dirac
spinor yields eigenstates of <span
class="math inline">\(\gamma_5\)</span>:</p>
<p><span class="math display">\[\gamma_5\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}=+\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}~~~~\gamma_5\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}=-\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}\]</span></p>
<p>The eigenvalue of <span class="math inline">\(\gamma_5\)</span> is
called the chirality of the spinor, so we say that the upper
two-component spinor <span class="math inline">\(\eta\)</span> has a
chirality of <span class="math inline">\(+1\)</span> and <span
class="math inline">\(\chi\)</span> has a chirality of <span
class="math inline">\(-1\)</span>. A Weyl spinor with positive chirality
is sometimes referred to as a right-chiral spinor, and a Weyl spinor
with negative chirality is referred to as a right-chiral spinor.</p>
<p>However, some references replace the adjectives right-chiral and
left-chiral by right-handed and left-handed, but in general, knowing the
chirality doesn’t tell us the handedness of a particle.</p>
<p>We will discuss how the handedness, or to be more technical, the
helicity of a spinor is defined.</p>
<p>The key point is to make here is that the notions of chirality and
the helicity of a spinor coincide only when a particle is massless. For
a massive particle, both the left-chiral and the right-chiral states
are, in general, linear combinations of left-handed and right-handed
states.</p>
<p>It’s chirality that tells us how a spinor behaves under Lorentz
transformations. For a massive spinor, it’s the chirality that specifies
what representation of the Lorentz group it belongs to, not its
helicity, so we will care more about chirality than about helicity.</p>
<p>It is convenint to introduce the operators <span
class="math inline">\(P_R\)</span> and <span
class="math inline">\(P_L\)</span>, which, when applied to a fuul Dirac
spinor, project out the right-chiral and left-chiral Weyl spinors:</p>
<p><span class="math display">\[P_R\Psi=P_R\begin{pmatrix}
    \eta\\
    \chi\\
\end{pmatrix}=\begin{pmatrix}
    \eta\\
    0
\end{pmatrix}~~~~P_L\Psi=P_L\begin{pmatrix}
    \eta\\
    \chi\\
\end{pmatrix}=\begin{pmatrix}
    0\\
    \chi
\end{pmatrix}\]</span></p>
<p>The explicit representations of these opeartors are obviously</p>
<p><span class="math display">\[P_R=\begin{pmatrix}
    \boldsymbol{1}&amp;0\\
    0&amp;0
\end{pmatrix}=\frac{\boldsymbol{1}+\gamma_5}{2}~~~~P_L=\begin{pmatrix}
    0&amp;0\\
    0&amp;\boldsymbol{1}
\end{pmatrix}=\frac{\boldsymbol{1}-\gamma_5}{2}\]</span></p>
<p>If we substitute <span class="math inline">\(\Psi=\begin{pmatrix}
    \eta\\
    \chi
\end{pmatrix}\)</span> to the Dirac equation, we can obtain two coupled
equations for the Weyl spinors:</p>
<p><span class="math display">\[\begin{aligned}
    (E\boldsymbol{1}-\vec{\sigma}\cdot\vec{p})\eta=m\chi\\
    (E\boldsymbol{1}+\vec{\sigma}\cdot\vec{p})\chi=m\eta
\end{aligned}\]</span></p>
<p>Now we introduce some useful notations:</p>
<p><span
class="math display">\[\sigma^\mu=(\boldsymbol{1},\vec{\sigma}),~~\overline{\sigma}^\mu=(1,-\vec{\sigma})\]</span></p>
<p>we can check that they have the following properties:</p>
<ol type="1">
<li><span
class="math inline">\(\sigma^2(\sigma^\mu)^T\sigma^2=\overline{\sigma}^\mu,~~\sigma^2(\overline{\sigma}^\mu)^T\sigma^2=\sigma^\mu\)</span></li>
<li><span
class="math inline">\(\sigma^2\sigma^\mu\sigma^2=(\overline{\sigma}^\mu)^T,~~\sigma^2\overline{\sigma}^\mu\sigma^2=(\sigma^\mu)^T\)</span></li>
<li><span
class="math inline">\(\sigma^\mu\overline{\sigma}^\nu+\sigma^\nu\overline{\sigma}^\mu=2\eta^{\mu\nu}\boldsymbol{1}\)</span></li>
<li><span
class="math inline">\(\overline{\sigma}^\mu\sigma^\nu+\overline{\sigma}^\nu\sigma^\mu=2\eta^{\mu\nu}\boldsymbol{1}\)</span></li>
<li><span class="math inline">\(\gamma^\mu=\begin{pmatrix}
0&amp;\overline{\sigma}^\mu\\
\sigma^\mu&amp;0
\end{pmatrix}\)</span></li>
</ol>
<p>So the two coupled equations may be written as</p>
<p><span class="math display">\[\begin{aligned}
    P_\mu\sigma^\mu\eta=m\chi\\
    P_\mu\overline{\sigma}^\mu\chi=m\eta\\
\end{aligned}\]</span></p>
<p>and we can also write the Dirac lagrangianin terms of Weyl
spinors:</p>
<p><span class="math display">\[\mathcal{L}=\eta^\dagger\sigma^\mu
i\partial_\mu\eta+\chi^\dagger\overline{\sigma}^\mu
i\partial_\mu\chi-m\eta^\dagger\chi-m\chi^\dagger\eta\]</span></p>
<p>Note that despide the fact that <span
class="math inline">\(\sigma^\mu\)</span> and <span
class="math inline">\(\overline{\sigma}^\mu\)</span> carry a Lorentz
index, they are not themselves four-vectors (for the same reason that
<span class="math inline">\(\gamma^\mu\)</span> is not a four-vector).
However, we can form quantities with well-defined Lorentz properties by
sandwiching them between Weyl spinors.</p>
<h3 id="helicity">Helicity</h3>
<p>For massless particles, the two equations for Weyl spinors decouple
to give:</p>
<p><span class="math display">\[\begin{aligned}
    (E\boldsymbol{1}-\vec{\sigma}\cdot\vec{p})\eta=0\\
    (E\boldsymbol{1}+\vec{\sigma}\cdot\vec{p})\chi=0
\end{aligned}~~\Rightarrow~~\begin{aligned}
    \frac{\vec{\sigma}\cdot\vec{p}}{|\vec{p}|}\eta=\eta\\
    \frac{\vec{\sigma}\cdot\vec{p}}{|\vec{p}|}\chi=-\chi
\end{aligned}\]</span></p>
<p>where we have set <span class="math inline">\(E=|\vec{p}|\)</span>,
which is valid for massless particles. We see that for a massless
particle, the Dirac equation breaks up into two independent equations
acting on two defferent two-component spinors. These two equations are
known as the Weyl equations.</p>
<p>If we multiply those equations by <span
class="math inline">\(\hbar/2\)</span> and use the fact that <span
class="math inline">\(\hbar\vec{\sigma}/2\)</span> is the spin operator
<span class="math inline">\(\vec{S}\)</span>, we get</p>
<p><span
class="math display">\[\vec{S}\cdot\hat{p}\eta=\frac{\hbar}{2}\eta~~~~\vec{S}\cdot\hat{p}\chi=-\frac{\hbar}{2}\chi\]</span></p>
<p>The operator <span class="math inline">\(\vec{S}\cdot\hat{p}\)</span>
is called the helicity operator, and the corresponding eigenvalue is the
helicity of the state. This eigenvalue corresponds to the component of
the spin along the direction of the motion of the particle. We see that,
in massless limit, thw Weyl spinors are eigenstates of the helicity
operator.</p>
<h3 id="lorentz-transformations-and-invariants">Lorentz Transformations
and Invariants</h3>
<p>The infinitesimal transformations of the two Weyl spinors are:</p>
<p><span class="math display">\[\begin{aligned}
    \eta\rightarrow\eta&#39;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)\eta\\
    \chi\rightarrow\chi&#39;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)\chi\\
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\vec{\epsilon}\)</span> is the
infinitesimal rotation vector (the direction of <span
class="math inline">\(\vec{\epsilon}\)</span> gives the axis of
rotation, and its magnitude gives the amount of rotation), and <span
class="math inline">\(\vec{\beta}\)</span> is the infinitesimal boost
parameter.</p>
<p>This transformations show that the left-chiral and right-chiral
spinors transform independently under Lorentz transformations. They are
therefore inequivalent irreducible representations of the Lorentz group
and are the fundamental “building blocks” from which any other spinor
representation can be constructed. Because Lorentz algebra is equivalent
to the algebra <span
class="math inline">\(\mathfrak{su}(2)\times\mathfrak{su}(2)\)</span>,
all representations can be labeled by two numbers that are multiples of
one-half. The two fundamental representations then are described by the
quantum numbers <span class="math inline">\((\frac{1}{2},0)\)</span> and
<span class="math inline">\((0,\frac{1}{2})\)</span>, which describe the
left-chiral and right-chiral spinors respectively. By the way, even
though the algebra acting on the Weyl spinors is <span
class="math inline">\(\mathfrak{su}(2)\times\mathfrak{su}(2)\)</span>,
the group under which they transform is not <span
class="math inline">\(SO(2)\times SO(2)\)</span> but instead <span
class="math inline">\(SL(2,\mathbb{C})\)</span>, the universal covering
group of the Lorentz group <span
class="math inline">\(SO(3,1)\)</span>.</p>
<p>Now consider the kinetic term of the Dirac lagrangian <span
class="math inline">\(\overline{\Psi}\gamma^\mu P_\mu\Psi\)</span>.
Since this is invariant and <span class="math inline">\(P_\mu\)</span>
is a four-vector, the quantity <span
class="math inline">\(\overline{\Psi}\gamma^\mu\Psi\)</span> must
transform as a four-vector, so we find that</p>
<p><span
class="math display">\[\overline{\Psi}\gamma^\mu\Psi=\eta^\dagger\sigma^\mu\eta+\chi^\dagger\overline{\sigma}^\mu\chi\]</span></p>
<p>transform as a four-vector under Lorentz transformations, and it
turns out that each term on the right separately transform as a
four-vector.</p>
<h3 id="building-more-lorentz-invariants-out-of-weyl-spinors">Building
More Lorentz Invariants Out of Weyl Spinors</h3>
<p>First we consider <span class="math inline">\(\chi^{\dagger
T}\)</span>, we find that it transforms as</p>
<p><span class="math display">\[\begin{aligned}
   \chi^{\dagger T}\rightarrow (\chi^{\dagger
T})&#39;=(\chi&#39;)^{\dagger T}
&amp;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)^*\chi^{\dagger
T}\\
    &amp;=\left(\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}^*+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}^*\right)\chi^{\dagger
T}
\end{aligned}\]</span></p>
<p>This doesn’t transform like a right-chiral spinor. Now we use the
equation <span
class="math inline">\(\sigma^2\vec{\sigma}^*=-\vec{\sigma}\sigma^2\)</span>
and consider</p>
<p><span class="math display">\[\begin{aligned}
   i\sigma^2\chi^{\dagger T}\rightarrow (i\sigma^2\chi^{\dagger T})&#39;
&amp;=(i\sigma^2)^*\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)^*\chi^{\dagger
T}\\
    &amp;=(i\sigma^2)\left(\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}^*+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}^*\right)\chi^{\dagger
T}\\
    &amp;=\left(\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\right)i\sigma^2\chi^{\dagger
T}
\end{aligned}\]</span></p>
<p>which is the transformation of right-chiral spinor! Since the
expression <span class="math inline">\(\eta^\dagger\chi\)</span> is
invariant under Lorentz tranformations and <span
class="math inline">\(i\sigma^2\chi^{\dagger T}\)</span> transforms like
<span class="math inline">\(\eta\)</span>, we can know that the
following expression is also invariant:</p>
<p><span class="math display">\[\begin{aligned}
    (i\sigma^2\chi^{\dagger
T})^T\chi&amp;=\chi^T(i\sigma^2)^\dagger\chi\\
    &amp;=\chi^T(-i\sigma^2)\chi
\end{aligned}\]</span></p>
<p>We also know that <span
class="math inline">\(\chi^\dagger\eta\)</span> is invariant, we obtain
a second invariant containing only left-chiral spinors:</p>
<p><span class="math display">\[\chi^\dagger i\sigma\chi^{\dagger
T}\]</span></p>
<p>Similarly, it’s easy to check that <span
class="math inline">\(-i\sigma^2\eta^{\dagger T}\)</span> transforms
like a left-chiral spinor.</p>
<p>Define the matrix <span class="math inline">\(A\)</span> as</p>
<p><span
class="math display">\[A=\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>so we have</p>
<p><span
class="math display">\[A^\dagger=\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}-\frac{1}{2}\vec{\beta}\cdot\vec{\sigma},~~A^{-1}=\boldsymbol{1}-\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>In turn, this implies</p>
<p><span
class="math display">\[(A^{-1})^\dagger=(A^\dagger)^{-1}=\boldsymbol{1}+\frac{i}{2}\vec{\epsilon}\cdot\vec{\sigma}+\frac{1}{2}\vec{\beta}\cdot\vec{\sigma}\]</span></p>
<p>We can write:</p>
<p><span class="math display">\[\begin{aligned}
    \eta&amp;\rightarrow A\eta\\
    i\sigma^2\chi^{\dagger T}&amp;\rightarrow A(i\sigma^2\chi^{\dagger
T})\\
    \chi&amp;\rightarrow (A^\dagger)^{-1}\chi\\
    -i\sigma^2\eta^{\dagger T}&amp;\rightarrow
(A^\dagger)^{-1}(-i\sigma\eta^{\dagger T})
\end{aligned}\]</span></p>
<p>This gives eight combinations, but it turns out that only six of
those are independent, which be taken to be</p>
<p><span class="math display">\[\boxed{\begin{aligned}
    -\chi^T i\sigma^2\chi~~~~&amp;\chi^\dagger i\sigma^2\chi^{\dagger
T}\\
    \chi^\dagger \eta~~~~&amp;\eta^\dagger\chi\\
    -\eta i\sigma^2\eta^{\dagger T}~~~~&amp;\eta^Ti\sigma^2\eta
\end{aligned}}\]</span></p>
<h3 id="invariants-containing-lorentz-indeces">Invariants Containing
Lorentz Indeces</h3>
<p>We have seen, by looking at the Dirac equation written in terms of
Weyl spinors, that <span class="math inline">\(\sigma^\mu
i\partial_\mu\eta\)</span> transforms like a left-chiral spinor and
<span class="math inline">\(\overline{\sigma}^\mu
i\partial_\mu\chi\)</span> transforms like a right-chiral spinor.</p>
<p>To build Lorentz invariants containing derivatives, we simply have to
use the expressions in the box above with the <span
class="math inline">\(\chi\)</span> appearing in those equations
replaced by <span class="math inline">\(\sigma^\mu
i\partial_\mu\eta\)</span> or the <span
class="math inline">\(\eta\)</span> replaced by <span
class="math inline">\(\overline{\sigma}^\mu
i\partial_\mu\chi\)</span>.</p>
<p>As examples, we have</p>
<p><span class="math display">\[\begin{aligned}
    \chi^\dagger\eta&amp;\rightarrow \chi^\dagger\overline{\sigma}^\mu
i\partial_\mu \chi\\
    \eta^\dagger\chi&amp;\rightarrow(\overline{\sigma}^\mu
i\partial_\mu\chi)^\dagger\chi=-i(\partial_\mu\chi^\dagger)\overline{\sigma}^\mu\chi
\end{aligned}\]</span></p>
<p>As part of a lagrangian density, however, an integration by parts can
be used to show that the terms above are equivalent to each other after
discarding a surface term. We will always assume that the surface terms
vanish so that we may write</p>
<p><span class="math display">\[\int \mathrm{d}^4xA\partial_\mu
B=-\int\mathrm{d}^4x(\partial_\mu A)B\]</span></p>
<h3 id="introduce-a-new-notation">Introduce a New Notation</h3>
<p>In practice, SUSY theorists work almost exclusively with left-chiral
spinors, even when considering supersymmetric extensions of the standard
model, so we really only need to focus on the two invariants built out
of a left-chiral spinor:</p>
<p><span class="math display">\[\chi^\dagger i\sigma^2\chi^{\dagger
T},~~\chi^T(-i\sigma^2)\chi\]</span></p>
<p>We define two new types of spinor dot products between left-chiral
Weyl spinors:</p>
<p><span
class="math display">\[\chi\cdot\chi=\chi^T(-i\sigma^2)\chi,~~\overline{\chi}\cdot\overline{\chi}=\chi^\dagger
i\sigma^2\chi^{\dagger T}\]</span></p>
<h2 id="the-physics-of-weyl-majorana-and-dirac-spinors">The Physics of
Weyl, Majorana, and Dirac Spinors</h2>
<p>Supersymmetric theories are often written in terms of Majorana
spinors, instead of Weyl spinors or Dirac spinors.</p>
<h3 id="charge-conjugation-and-antiparticles-for-dirac-spinors">Charge
Conjugation and Antiparticles for Dirac Spinors</h3>
<p>Charge conjugation is the operation that turns a field describing a
certain particle into a field describing the corresponding
antiparticle.</p>
<p>Consider a Dirac spinor corresponding to a certain particle <span
class="math inline">\(p\)</span>:</p>
<p><span class="math display">\[\Psi_p=\begin{pmatrix}
    \eta_p\\
    \chi_p
\end{pmatrix}\]</span></p>
<p>The antiparticle spinor is obtained by applying the
charge-conjugation operator to the particle state, we may write</p>
<p><span
class="math display">\[\Psi_p^c=\Psi_{\overline{p}}=\begin{aligned}
    \eta_{\overline{p}}\\
    \chi_{\overline{p}}
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(c\)</span> denotes charge
conjugation.</p>
<h2 id="the-supersymmetric-charges-and-their-algebra">The Supersymmetric
Charges and Their Algebra</h2>
<p>When a lagrangian is observed to possess some continuous symmetry,
the natural thing to do is to find the charges generating the symmetry,
also called the generators of the symmetry. Actually, as we will see,
what really matters is the algebra obeyed by the charges, i.e., the
commutation or anticommutation rules, not the charges themselves (as an
aside, when the algebra involves anticommutators, it is often referred
to as a graded Lie algebra).</p>
<h3 id="charges-general-discussion">Charges: General Discussion</h3>
<p>We firet consider a scalar field operator <span
class="math inline">\(\phi\)</span>. If a certain transformation is a
symmetry of the theory, it must leave unchanged the expectation value
<span class="math inline">\(\langle a|\phi|b\rangle\)</span>. Let us
focus now on spacetime transformations, and we have <span
class="math inline">\(\langle a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|\phi(x)|b\rangle\)</span>. We now introduce a new field operator <span
class="math inline">\(\phi&#39;\)</span> that we define by <span
class="math inline">\(\langle a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|\phi&#39;(x&#39;)|b\rangle\)</span>, so we get <span
class="math inline">\(\langle a|\phi&#39;(x&#39;)|b\rangle=\langle
a|\phi(x)|b\rangle\)</span>, thus <span
class="math inline">\(\phi&#39;(x&#39;)=\phi(x)\)</span>. This is
exactly how a scalar field behaves under a Lorentz transformation. We
write <span class="math inline">\(x&#39;=x-\delta x\)</span>, so we have
<span class="math inline">\(\phi&#39;(x-\delta x)=\phi(x)\)</span> or
<span class="math inline">\(\phi&#39;(x)=\phi(x+\delta x)\)</span>.</p>
<p>We now consider a field operator <span
class="math inline">\(\mathcal{F}\)</span> that transforms under some
representations of the Lorentz group (a vector, a spinor, etc.). Then we
have <span class="math inline">\(\langle
a&#39;|\mathcal{F}(x)|b&#39;\rangle=S(\Lambda)\langle
a|\mathcal{F}(x)|b\rangle\)</span>, where <span
class="math inline">\(S(\Lambda)\)</span> is the Lorentz transformation
matrix corresponding to the representation of the field operator.
Correspondingly, we have <span
class="math inline">\(\mathcal{F}&#39;(x)=S(\Lambda)\mathcal{F}(x+\delta
x)\)</span>.</p>
<p>Physically meaningful transformations preserve the norm of states and
therefore can be written in the form of unitary operators (or
antiunitary operators in the case of time inversal), namely, operators
satisfying <span class="math inline">\(U^\dagger=U^{-1}\)</span>. We
will take the transformation of states to be</p>
<p><span class="math display">\[|a\rangle\rightarrow
|a&#39;\rangle=U^\dagger|a\rangle,~~|b\rangle\rightarrow
|b&#39;\rangle=U^\dagger|b\rangle\]</span></p>
<p>We now have <span class="math inline">\(\langle
a&#39;|\phi(x&#39;)|b&#39;\rangle=\langle
a|U\phi(x&#39;)U^\dagger|b\rangle=\langle
a|\phi&#39;(x&#39;)|b\rangle\)</span>, which implies <span
class="math inline">\(\phi&#39;(x)=U\phi(x)U^\dagger\)</span>.</p>
<p>Now we are ready to introduce the charges generating the
transformations. Assume that the transformation we are interested in are
parametrized by a set of <span class="math inline">\(n\)</span>
infinitesimal parameters <span
class="math inline">\(\epsilon_1,\epsilon_2,\cdots,\epsilon_n\)</span>,
in which case there are necessarily <span
class="math inline">\(n\)</span> charges <span
class="math inline">\(Q_1,Q_2,\cdots,Q_n\)</span>. The charges are
defined through</p>
<p><span class="math display">\[U=\exp(\pm i\epsilon_iQ_i)=\exp(\pm
i\epsilon\cdot Q)\]</span></p>
<p>We get</p>
<p><span class="math display">\[\begin{aligned}
    \phi&#39;(x)&amp;\approx(1+\pm i\epsilon\cdot Q)\phi(x)(1\mp
i\epsilon\cdot Q)\\
            &amp;=\phi(x)\pm i\epsilon\cdot Q\phi(x)\mp
i\phi(x)\epsilon\cdot Q\\
            &amp;=\phi(x)\pm i[\epsilon\cdot Q,\phi(x)]
\end{aligned}\]</span></p>
<p>Let’s define <span
class="math inline">\(\delta\phi(x)=\phi&#39;(x)-\phi(x)\)</span>, we
obtain a very useful result:</p>
<p><span class="math display">\[\pm[\epsilon\cdot
Q,\phi]=-i\delta\phi\]</span></p>
<p>where the sign on the left-hand side is the same sign as the argument
of the exponential in the operator <span
class="math inline">\(U\)</span>.</p>
<p>In the case of spacetime symmetries, for a scalar field, we have
<span class="math inline">\(\delta\phi=\phi(x+\delta
x)-\phi(x)\)</span>, for a general field <span
class="math inline">\(\mathcal{F}\)</span>, we have instead <span
class="math inline">\(\delta\mathcal{F}(x)=S(\Lambda)\mathcal{F}(x+\delta
x)-\mathcal{F}(x)\)</span>.</p>
<p>As a simple example, consider a lagrangian density that is a function
of a single real scalar field <span
class="math inline">\(\mathcal{L}(\phi)\)</span>. The action <span
class="math inline">\(S=i\int \mathrm{d}^4x\mathcal{L}\)</span> is
obviously invariant under a transformation of the field</p>
<p><span class="math display">\[\phi(x^\mu)\rightarrow
\phi&#39;(x^\mu)=\phi(x^\mu+a^\mu)\]</span></p>
<p>where <span class="math inline">\(a^\mu\)</span> is a
constant-displacement four-vector. Therefore</p>
<p><span
class="math display">\[\delta\phi(x^\mu)=\phi(x^\mu+a^\mu)-\phi(x^\mu)\approx
a^\mu\partial_\mu\phi\]</span></p>
<p>Since there are four parameters, the four <span
class="math inline">\(a_\mu\)</span>, we introduce four charges that we
suggestively call <span class="math inline">\(P^\mu\)</span>, and write
the unitary operator as</p>
<p><span class="math display">\[U=\exp(ia^\mu P_\mu)\]</span></p>
<p>so we get</p>
<p><span
class="math display">\[a^\mu[P_\mu,\phi]=-ia^\mu\partial_\mu\phi\Rightarrow
[P_\mu,\phi]=-i\partial_\mu\phi\]</span></p>
<p>We next consider Lorentz transformation <span
class="math inline">\(x^\mu\rightarrow \Lambda^\mu_\nu x^\nu\)</span>,
for an infinitesimal transformation, we may write</p>
<p><span class="math display">\[\begin{aligned}
    \Lambda^\mu_\nu x^\nu&amp;\approx x^\mu+\omega^\mu_\nu x^\nu\\
                         &amp;=x^\mu+\omega^{\mu\nu}x_\nu
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\omega^{\mu\nu}\)</span> is
antisymmetric, <span
class="math inline">\(\omega^{\mu\nu}=-\omega^{\nu\mu}\)</span>.</p>
<p>We write the unitary operator implementing Lorentz transformation on
a scalar field as</p>
<p><span
class="math display">\[U=\exp\left(-\frac{i}{2}\omega^{\mu\nu}M_{\mu\nu}\right)\]</span></p>
<p>where the charges <span class="math inline">\(M^{\mu\nu}\)</span> are
also antisymmetric.</p>
<p>The transformation og the field is given by <span
class="math inline">\(\delta\phi=\phi(x+\omega^{\mu\nu}x_\nu)-\phi(x^\mu)\)</span>,
and <span
class="math inline">\(\delta\phi=\frac{1}{2}\omega^{\mu\nu}(x_\nu\partial_\mu-x_\mu\partial_\nu)\phi\)</span>,
so we have</p>
<p><span
class="math display">\[[M_{\mu\nu},\phi]=i(x_\nu\partial_\nu-x_\mu\partial_\nu)\phi\]</span></p>
<p>We finally consider the <span class="math inline">\(U(1)\)</span>
transformation <span class="math inline">\(\phi\rightarrow
e^{i\alpha}\phi\)</span> with <span
class="math inline">\(\alpha\)</span> being a constant parameter, in
this case, <span class="math inline">\(\delta\phi=i\alpha\phi\)</span>.
Writing <span class="math inline">\(U=\exp(i\alpha Q)\)</span>, we
have</p>
<p><span class="math display">\[[Q,\phi]=\phi\]</span></p>
<h3
id="explict-representations-of-the-charges-and-the-charge-algebra">Explict
Representations of the Charges and the Charge Algebra</h3>
<p>The first strategy thet one can work out the algebra of the charges
are the following steps:</p>
<p><span class="math display">\[\rm{Field~ transformations}\Rightarrow
\rm{currents}\Rightarrow\rm{charges~as~quantum~fields}\Rightarrow\rm{algebra}\]</span></p>
<p>It consists of building a set of currents <span
class="math inline">\(J_\mu^i\)</span> associated with the symmetry from
which the corresponding charges are found by integrating over space
thezeroth component of the currents:</p>
<p><span
class="math display">\[Q^i=\int\mathrm{d}^3xJ_0^i(\vec{x},t)\]</span></p>
<p>It is important to note that in this approach, the charges (and the
currents) are themselves quantum field operators. The algebra of the
charges then can be found using the equal time commutation relations of
the fields present in the theory.</p>
<p>In the case of spacetime symmetries, there is a second explict
representation of the charges available: as differential operators (not
quantum field operators) acting on the fields. The differential operator
representation of the charge is defined via</p>
<p><span class="math display">\[\begin{aligned}
    \phi(x&#39;)&amp;=\exp(\pm i\epsilon_i\hat{Q}_i)\phi(x)\\
            &amp;\approx\phi(x)\pm i\epsilon_i\hat{Q}_i\phi(x)
\end{aligned}\]</span></p>
<p>We first consider <span class="math inline">\(U=\exp(-ia^\mu
\hat{P}_\mu)\)</span>, we have <span
class="math inline">\(\phi(x)+a^\mu\partial_\mu\phi(x)=\phi(x)-ia^\mu\hat{P}_\mu\phi(x)\)</span>,
which leads to</p>
<p><span class="math display">\[\hat{P}_\mu=i\partial_\mu\]</span></p>
<p>For the differential operators <span
class="math inline">\(\hat{M}_{\mu\nu}\)</span> on a scalar field, we
have</p>
<p><span
class="math display">\[\phi(x&#39;)=\exp\left(\frac{i}{2}\omega^{\mu\nu}\hat{M}_{\mu\nu}\right)\phi\]</span></p>
<p>we can prove that</p>
<p><span
class="math display">\[\hat{M}_{\mu\nu}=i(x_\mu\partial_\nu-x_\nu\partial_\mu)\]</span></p>
<p>Finally, we can use the representations of the operators <span
class="math inline">\(P^\mu\)</span> and <span
class="math inline">\(M^{\mu\nu}\)</span> as differential operators to
show that they obey the so-called Poincare algebra:</p>
<p><span class="math display">\[\begin{aligned}
    [P_\mu,P_\nu]&amp;=0\\
    [M_{\mu\nu},P_\lambda]&amp;=i(\eta_{\nu\lambda}P_\mu-\eta_{\lambda\mu}P_{\nu})\\
    [M_{\mu\nu},M_{\rho\sigma}]&amp;=i(\eta_{\nu\rho}M_{\mu\sigma}-\eta_{\nu\sigma}M_{\mu\rho}-\eta_{\mu\rho}M_{\nu\sigma}+\eta_{\mu\sigma}M_{\nu\rho})
\end{aligned}\]</span></p>
<h3 id="finding-the-algebra-without-the-explicit-charges">Finding the
Algebra Without the Explicit Charges</h3>
<p>In this section, all the charges have to be thought of as quantum
field operators, not differential operators.</p>
<p>We first consider two successive transformations applied to a field
<span class="math inline">\(\phi\)</span>: the first transformation with
parameters <span class="math inline">\(\alpha_i\)</span>, followed by
the second tranformation with parameters <span
class="math inline">\(\beta_j\)</span>. We have:</p>
<p><span class="math display">\[\begin{aligned}
    U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger&amp;=\exp(i\beta\cdot Q)\exp(i\alpha\cdot
Q)\phi\exp(-i\alpha\cdot Q)\exp(-i\beta\cdot Q)\\
    &amp;\approx \phi+i[\beta\cdot Q,\phi]+i[\alpha\cdot
Q,\phi]-[\beta\cdot Q,[\alpha\cdot Q,\phi]]+\cdots
\end{aligned}\]</span></p>
<p>We write</p>
<p><span class="math display">\[U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger=\delta_\beta\delta_\alpha\phi\]</span></p>
<p>Consider</p>
<p><span
class="math display">\[\delta_\beta\delta_\alpha\phi-\delta_\alpha\delta_\beta\phi\]</span></p>
<p>which is equal to</p>
<p><span class="math display">\[U_\beta U_\alpha\phi U_\alpha^\dagger
U_\beta^\dagger- U_\alpha U_\beta\phi  U_\beta^\dagger
U_\alpha^\dagger\approx -[\beta\cdot Q,[\alpha\cdot
Q,\phi]]+[\alpha\cdot Q,[\beta\cdot Q,\phi]]\]</span></p>
<p>If we expand this out, being careful about the order of all the
quantities involved, we find that half the terms cancel out, leaving</p>
<p><span
class="math display">\[\delta_\beta\delta_\alpha\phi-\delta_\alpha\delta_\beta\phi=[[\alpha\cdot
Q,\beta\cdot Q],\phi]\]</span></p>
<h3 id="the-susy-algebra">The SUSY Algebra</h3>
<p>There is the two-component spinor <span
class="math inline">\(\zeta\)</span> and its complex conjugate <span
class="math inline">\(\zeta^*\)</span> for a total of four parameters.
We therefore need four charges <span
class="math inline">\(Q_1,Q_2,Q_1^\dagger,Q_2^\dagger\)</span>, which we
can group into a Weyl spinor, that we will call <span
class="math inline">\(Q\)</span>, and its hermitian conjugate <span
class="math inline">\(Q^\dagger\)</span>. These SUSY charges are also
referred to as supercharges.</p>
<p>We choose to make <span class="math inline">\(Q\)</span> a
left-chiral spinor, so we have</p>
<p><span
class="math display">\[Q\cdots\zeta=Q(-i\sigma^2)\zeta,~~\overline{Q}\cdot\overline{\zeta}=Q^\dagger
i\sigma^2\zeta^*\]</span></p>
<p>(recall that <span class="math inline">\(\zeta\)</span> is not a
quantum field operator, so we write <span
class="math inline">\(\zeta^{\dagger T}\)</span> simply as <span
class="math inline">\(\zeta^*\)</span>).</p>
<p>The unitary operator <span class="math inline">\(U\)</span>
generating SUSY transformations therefore is given by</p>
<p><span
class="math display">\[U_\zeta=\exp(iQ\cdot\zeta+i\overline{Q}\cdot\overline{\zeta})\]</span></p>
<p>We get</p>
<p><span class="math display">\[\begin{aligned}
    [Q\cdot\zeta+\overline{Q}\cdot\overline{\zeta},\phi]&amp;=-i\zeta\cdot\chi\\
    [Q\cdot\zeta+\overline{Q}\cdot\overline{\zeta},\chi]&amp;=-i(\partial_\mu\phi)\sigma^\mu\sigma^2\zeta^*\\
\end{aligned}\]</span></p>
<p>which implies</p>
<p><span class="math display">\[\begin{aligned}
    [Q\cdot\zeta,\phi]&amp;=-i\zeta\cdot\chi\\
    [\overline{Q}\cdot\overline{\zeta},\chi]&amp;=-i(\partial_\mu\phi)\sigma^\mu\sigma^2\zeta^*\\
    [\overline{Q}\cdot\overline{\zeta},\phi]&amp;=[Q\cdot\zeta,\chi]=0
\end{aligned}\]</span></p>
<h2 id="applications-of-the-susy-algebra">Applications of the SUSY
Algebra</h2>
<h3
id="classification-of-states-using-the-algebra-review-of-the-poincare-group">Classification
of States Using the Algebra: Review of the Poincare Group</h3>
<p>We first briefly review some basic representations og the Poincare
group on one particle states.</p>
<p>Casimir operator are operators that commute with all the generators
of the group. These operators are of key importance in building
representations because their eigenvalues can be used to classify the
representations of the group. One Casimir operator of the Poincare group
is the squared momentum generator <span class="math inline">\(P^\mu
P_\mu\)</span>, and this obviously commutes with the momentum
generators. The eigenvalue of <span class="math inline">\(P^\mu
P_\mu\)</span> is <span class="math inline">\(m^2\)</span>, which is
therefore one of the parameters used to classify one-particle
states.</p>
<p>The second Casimir operator is build out of the so-called
Pauli-Lubanski operator <span class="math inline">\(W_\mu\)</span>,
defined as</p>
<p><span
class="math display">\[W^\mu=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu\]</span></p>
<p>where <span
class="math inline">\(\epsilon^{\mu\nu\rho\sigma}\)</span> is the
totally antisymmetric Levi-Civita symbol in four dimensions. We will use
the normalization <span
class="math inline">\(\epsilon_{0123}=1\)</span>, which implies <span
class="math inline">\(\epsilon^{0123}=-1\)</span>. With this
normalization, it’s clear that <span
class="math inline">\(\epsilon^{0ijk}=-\epsilon^{ijk}\)</span>.</p>
<p>Note that we have</p>
<p><span class="math display">\[W^\mu
P_\mu=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu
P_\mu=0\]</span></p>
<p>which is obvious beacuse <span class="math inline">\(P_\nu
P_\mu\)</span> is symmetric. But it is not as obvious that <span
class="math inline">\(P_\mu W^\mu\)</span> is also equal to zero, and we
have <span class="math inline">\([P_\mu,W^\mu]=0\)</span>.</p>
<p>With some effort, one can show that <span class="math inline">\(W^\mu
W_\mu\)</span> also commutes with all the generators of the Poincare
group, so it is our second Casimir operator.</p>
<p>To uncover the physicial signification of the Pauli-Lubanski
operator, consider first massive particles. In that case, we can choose
to work in the rest frame of the particle, where its four-momentum is
simply <span class="math inline">\(p^\mu=p_\mu=(m,\vec{0})\)</span>, so
we have</p>
<p><span
class="math display">\[P_\mu|p\rangle=P_0|p\rangle=m|p\rangle\]</span></p>
<p>Let us now apply the Pauli-Lubanski operator to this state</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu|p\rangle&amp;=\frac{1}{2}\epsilon^{\mu\nu\rho\sigma}M_{\rho\sigma}P_\nu|p\rangle\\
    &amp;=\frac{1}{2}\epsilon^{\mu
0\rho\sigma}M_{\rho\sigma}P_0|p\rangle\\
    &amp;=\frac{m}{2}\epsilon^{\mu 0\rho\sigma}M_{\rho\sigma}|p\rangle\\
\end{aligned}\]</span></p>
<p>We can essily see that</p>
<p><span class="math display">\[W^0|p\rangle=0\]</span></p>
<p>and</p>
<p><span class="math display">\[\begin{aligned}
    W^i|p\rangle&amp;=\frac{m}{2}\epsilon^{i0jk}M_{jk}|p\rangle\\
    &amp;=-\frac{m}{2}\epsilon^{0ijk}M_{jk}|p\rangle\\
    &amp;=\frac{m}{2}\epsilon^{ijk}M_{jk}|p\rangle\\
\end{aligned}\]</span></p>
<p>It turns out that the operator <span
class="math inline">\(frac{1}{2}\epsilon^{ijk}M_{jk}\)</span> is simply
the total angular momentum of the particle, i.e.,</p>
<p><span
class="math display">\[\frac{1}{2}\epsilon^{ijk}M_{jk}=L^i+S^i\]</span></p>
<p>We therefore have</p>
<p><span
class="math display">\[W^i|p\rangle=m(S^i+L^i)|p\rangle\]</span></p>
<p>which, in the rest frame, reduced to</p>
<p><span class="math display">\[W^i|p\rangle=mS^i|p\rangle\]</span></p>
<p>So the Casimir operator <span class="math inline">\(W_\mu
W^\mu\)</span> acting on this state gives</p>
<p><span class="math display">\[W_\mu W^\mu|p\rangle=W^0
W^0|p\rangle-W^iW^i|p\rangle=-m^2\vec{S}^2|p\rangle=-m^2s(s+1)|p\rangle\]</span></p>
<p>We now see that the second porperty that can be used to specify the
masssive representation of the Lorentz group is the spin (or total
angular momentum, if we are not working in the rest frame).</p>
<p>To classify all these possible states of a massive particle at rest,
we need a complete set of commuting observables. In addition to the
four-momentum squared (whose eigenvalue is <span
class="math inline">\(m^2\)</span>) and the square of the spin, we also
may use the component of the spin along the z axis, <span
class="math inline">\(S_z\)</span>, because this operator obviously
commutes with <span class="math inline">\(P_\mu P^\mu\)</span> and with
<span class="math inline">\(\vec{S}^2\)</span>. Note that</p>
<p><span class="math display">\[W^3=m(L_z+S_z)\]</span></p>
<p>which, in the rest frame of the particle, reduces to <span
class="math inline">\(W^3=mS_z\)</span>.</p>
<p>Therefore, massive states are labeled in their rest frame by three
quantum numbers: <span class="math inline">\(p,s,s_z\)</span>, with</p>
<p><span class="math display">\[\begin{aligned}
    P^\mu|p,s,s_z\rangle&amp;=m|p,s,s_z\rangle\\
    W_\mu W^\mu|p,s,s_z\rangle&amp;=-m^2\vec{S}^2|p,s,s_z\rangle\\
    &amp;=-m^2s(s+1)|p,s,s_z\rangle\\
    \frac{W^3}{m}|p,s,s_z\rangle&amp;=S_z|p,s,s_z\rangle=s_z|p,s,s_z\rangle
\end{aligned}\]</span></p>
<p>As we know from quantum mechanics, <span
class="math inline">\(s_z\)</span> may take <span
class="math inline">\(2s+1\)</span> values, ranging from <span
class="math inline">\(-s\)</span> to <span
class="math inline">\(+s\)</span> in integer steps.</p>
<p>Now consider massless particles. In this case, we cannot go to the
rest frame of the particle, but we may choose to work in a frame where
the four-momentum is given by</p>
<p><span class="math display">\[p^\mu=(E,0,0,E)\]</span></p>
<p>We will denote the corresponding stste by <span
class="math inline">\(|p\rangle_0\)</span>. We then have</p>
<p><span class="math display">\[\begin{aligned}
    P^\mu|p\rangle_0&amp;=(P^0,P^1,P^2,P^3)|p\rangle_0\\
                    &amp;=(E,0,0,E)|p\rangle_0
\end{aligned}\]</span></p>
<p>or</p>
<p><span class="math display">\[\begin{aligned}
    &amp;P^1|p\rangle_0=P^2|p\rangle_0=0\\
    &amp;P^0|p\rangle_0=P^3|p\rangle_0=E|p\rangle_0
\end{aligned}\]</span></p>
<p>We can write <span
class="math inline">\(P^\mu|p\rangle_0=(P^3,0,0,P^3)|p\rangle_0\)</span>.</p>
<p>It turns out that like <span class="math inline">\(P^\mu P_\mu, W^\mu
W_\mu\)</span> gives zero when acting on a massless one-particle state.
The proof can be found in Wigner’s original paper. The fact that <span
class="math inline">\(W^\mu W_\mu\)</span> gives zero when applied to a
one-particle massless state, together with <span
class="math inline">\(W^\mu P_\mu=0\)</span>, implies that when acting
on such a state, the operator <span class="math inline">\(W^\mu\)</span>
is proportional to the four-momentum operator</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=hP^\mu|p\rangle_0\]</span></p>
<p>Now we prove this, consider</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu
P_\mu|p\rangle_0&amp;=(W^0P^0-W^1P^1-W^2P^2-W^3P^3)|p\rangle_0\\
    &amp;=(W^0P^0-W^3P^3)|p\rangle_0\\
    &amp;=E(W^0-W^3)|p\rangle_0=0
\end{aligned}\]</span></p>
<p>so we conclude that</p>
<p><span
class="math display">\[W^0|p\rangle_0=W^3|p\rangle_0\]</span></p>
<p>Using this we have</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu W_\mu&amp;=(W^0W_0-W^1W_1-W^2W_2-W^3W_3)|p\rangle_0\\
               &amp;=-(W^1W_1+W^2W_2)|p\rangle_0=0
\end{aligned}\]</span></p>
<p>so we obtain</p>
<p><span
class="math display">\[W^1|p\rangle_0=W^2|p\rangle_0=0\]</span></p>
<p>Therefore, when acting on the state, the action of the operator <span
class="math inline">\(W^\mu\)</span> reduces to</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=(W^3,0,0,W^3)|p\rangle_0\]</span></p>
<p>From <span class="math inline">\([P_\mu,W^\mu]=0\)</span> we know
that <span class="math inline">\(W^3\)</span> commutes with <span
class="math inline">\(P^3\)</span>, so we may take <span
class="math inline">\(|p\rangle_0\)</span> to be a common eigenstate of
these two operators. This implise that we may write</p>
<p><span
class="math display">\[W^3|p\rangle_0=hP^3|p\rangle_0\]</span></p>
<p>Using <span
class="math inline">\(P^\mu|p\rangle_0=(P^3,0,0,P^3)|p\rangle_0\)</span>
and <span
class="math inline">\(W^\mu|p\rangle_0=(W^3,0,0,W^3)|p\rangle_0\)</span>
we can conclude that</p>
<p><span
class="math display">\[W^\mu|p\rangle_0=hP^\mu|p\rangle_0\]</span></p>
<p>as we had set out to prove.</p>
<p>To find out what the constant <span class="math inline">\(h\)</span>
represents, we consider</p>
<p><span class="math display">\[\begin{aligned}
    W^\mu|p\rangle_0&amp;=(hE,0,0,hE)|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~~W^3|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow E(S_z+L_z)|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~Es_z|p\rangle_0&amp;=hE|p\rangle_0\\
    \Leftrightarrow ~~~~~~~~~~~~~~~~~~~~~~~h&amp;=s_z
\end{aligned}\]</span></p>
<p>Since our state has its momentum along the z direction, we may
write</p>
<p><span class="math display">\[h=\vec{s}\cdot\hat{p}\]</span></p>
<p>which is nothing other than the helicity of the perticle.</p>
<p>So massless representations of the Lorentz group are therefore
completely specified by only two numbers: their energy (which then
specifies their four-momentum) and their helicity <span
class="math inline">\(h\)</span>. The reason we don’t have <span
class="math inline">\(2s+1\)</span> states lies in <span
class="math inline">\(W^1|p\rangle_0=W^2|p\rangle_0=0\)</span>, which
reveals that we do not have any ladder operators to change the z
component of the spin. Therefore, there is only one spin state.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/RISC-V%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">RISC-V处理器设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-22 19:54:23" itemprop="dateModified" datetime="2026-01-22T19:54:23+08:00">2026-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="chapter-1-pc计数器">Chapter 1 PC计数器</h2>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps                                                                                     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span>   AW = <span class="number">32</span>    <span class="comment">// 地址宽度参数，默认为32位（用于RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值（指令地址输出）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，用于存储当前地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主PC更新逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿或复位下降沿触发</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时PC初始化为0</span></span><br><span class="line">        <span class="comment">// RISC-V架构中复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转使能时，PC更新为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常顺序执行时，PC每次增加4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令长度为32位（4字节）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加逻辑：存储跳转前的PC值</span></span><br><span class="line"><span class="comment">// 这个寄存器可能用于异常处理或调试目的</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;  <span class="comment">// 复位清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存跳转前的PC值</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转前的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：else分支缺失，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是一个设计缺陷或未完成部分</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-2-rom">Chapter 2 ROM</h2>
<p>现在在PC计数器的基础上, 添加ROM模块.</p>
<p>现在我们有:</p>
<ol type="1">
<li>PC计数器</li>
<li>ROM</li>
<li>顶层模块</li>
</ol>
<h3 id="stage-2-pc计数器">Stage-2 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="comment">// 特点：同步复位，时钟上升沿触发，字节寻址（每次+4）</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效（低有效复位）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效，1：执行跳转，0：顺序执行</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部寄存器声明</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 当前地址寄存器，暂存跳转前的PC值</span></span><br><span class="line">                              <span class="comment">// 可用于异常处理或调试接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 应用场景：分支指令、跳转指令、异常/中断处理</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可能用于：</span></span><br><span class="line"><span class="comment">//       1. 异常返回地址保存</span></span><br><span class="line"><span class="comment">//       2. 调试信息记录</span></span><br><span class="line"><span class="comment">//       3. 流水线冲刷恢复</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 注意：这里保存的是跳转使能信号有效时的pc_pointer值</span></span><br><span class="line">        <span class="comment">// 可用于jal指令的返回地址保存</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计缺陷，或者current_addr只在跳转时更新</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-rom模块">Stage-2 ROM模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="comment">// 特点：异步读取，支持参数化配置，从文件加载初始化数据</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位（RISC-V指令长度）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（ROM通常不需要时钟，这里提供接口用于同步设计）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,         <span class="comment">// 时钟信号（未使用，为统一接口保留）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,       <span class="comment">// 复位信号（未使用，为统一接口保留）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// 功能：构建完整的指令文件路径</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 功能：仿真开始时从文本文件加载指令到ROM存储器</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址异步读取指令</span></span><br><span class="line"><span class="comment">// 注意：由于RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 指令读取：将字节地址转换为字地址</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：原代码中注释掉的时序逻辑版本</span></span><br><span class="line"><span class="comment">// 如果希望同步读取，可以使用以下代码：</span></span><br><span class="line"><span class="comment">// always_ff @(posedge clk or negedge rst_n)</span></span><br><span class="line"><span class="comment">//   if(!rst_n)</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= &#x27;h0;      // 复位时输出0</span></span><br><span class="line"><span class="comment">//   else</span></span><br><span class="line"><span class="comment">//     inst_out &lt;= rom_mem[instr_addr[AW-1:2]];  // 时钟上升沿读取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-2-顶层模块">Stage-2 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成PC计数器和ROM，构成基本的取指流水线</span></span><br><span class="line"><span class="comment">// 当前状态：最小化测试版本，仅支持顺序执行</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径（传递给ROM）</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,     <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n    <span class="comment">// 异步复位，低电平有效</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;       <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;     <span class="comment">// 跳转目标地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;    <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;   <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前版本）</span></span><br><span class="line"><span class="comment">// 功能：在当前简化版本中，固定为顺序执行模式</span></span><br><span class="line"><span class="comment">// 后续开发：这些信号将由控制单元根据指令解码结果生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;      <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;       <span class="comment">// 跳转地址固定为0（实际未使用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line"><span class="comment">// 功能：生成指令地址，控制程序流</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)                    <span class="comment">// 传递地址宽度参数</span></span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>       (clk),         <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst_n</span>     (rst_n),       <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.jump_en</span>   (jump_en),     <span class="comment">// 跳转使能（当前为0）</span></span><br><span class="line">    <span class="variable">.jump_addr</span> (jump_addr),   <span class="comment">// 跳转地址（当前为0）</span></span><br><span class="line">    <span class="variable">.pc_pointer</span>(pc_pointer)   <span class="comment">// 输出的PC值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line"><span class="comment">// 功能：存储并输出指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),              <span class="comment">// 传递指令文件路径</span></span><br><span class="line">    <span class="variable">.AW</span>  (AW),                <span class="comment">// 传递地址宽度</span></span><br><span class="line">    <span class="variable">.DW</span>  (DW)                 <span class="comment">// 传递数据宽度</span></span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),        <span class="comment">// 时钟（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),      <span class="comment">// 复位（ROM中未使用）</span></span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer), <span class="comment">// 指令地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction) <span class="comment">// 输出的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 当前模块功能说明：</span></span><br><span class="line"><span class="comment">// 1. 复位后，PC从0x00000000开始</span></span><br><span class="line"><span class="comment">// 2. 每个时钟周期，PC自动+4（顺序执行）</span></span><br><span class="line"><span class="comment">// 3. ROM根据PC值输出对应指令</span></span><br><span class="line"><span class="comment">// 4. 当前不支持跳转、分支等控制流指令</span></span><br><span class="line"><span class="comment">// 5. 这是一个最小化的测试框架，用于验证取指功能</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 后续扩展方向：</span></span><br><span class="line"><span class="comment">// 1. 添加指令解码模块</span></span><br><span class="line"><span class="comment">// 2. 添加寄存器文件</span></span><br><span class="line"><span class="comment">// 3. 添加ALU执行单元</span></span><br><span class="line"><span class="comment">// 4. 添加控制单元生成jump_en和jump_addr</span></span><br><span class="line"><span class="comment">// 5. 添加数据存储器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-3-decode">Chapter 3 DECODE</h2>
<h3 id="stage-3-pc计数器模块">Stage-3 PC计数器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位（RV32架构）</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 功能：在每个时钟上升沿更新程序计数器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是为了保存跳转前的PC值用于后续处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-rom">Stage-3 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-译码模块">Stage-3 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址（当前未使用）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据（当前未使用）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-流水线寄存器模块">Stage-3 流水线寄存器模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 解决流水线冒险 3. 提高时钟频率</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的PC值</span></span><br><span class="line"><span class="comment">// 用途：可用于计算PC相对偏移或异常处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// 功能：锁存当前指令的二进制编码</span></span><br><span class="line"><span class="comment">// 用途：为译码阶段提供稳定的指令输入</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-3-顶层模块">Stage-3 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据（当前硬连线）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 后续应由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs1_data = <span class="number">&#x27;d50</span>;          <span class="comment">// 硬连线：源寄存器1数据=50</span></span><br><span class="line"><span class="keyword">assign</span> rd_rs2_data = <span class="number">&#x27;d100</span>;         <span class="comment">// 硬连线：源寄存器2数据=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-4-register">Chapter 4 Register</h2>
<h3 id="stage-4-pc计数器">Stage-4 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-rom">Stage-4 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-译码模块">Stage-4 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前实现存在问题：源寄存器地址分配错误</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到执行单元：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line"><span class="comment">// 存在问题：源寄存器地址分配错误（见下文）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// <span class="doctag">BUG:</span> 这里将rs1分配给了rd_rs2_addr，应该是错误的</span></span><br><span class="line">        <span class="comment">// 正确的ADDI指令格式：rd = rs1 + imm</span></span><br><span class="line">        <span class="comment">// 所以应该是：rd_rs1_addr = rs1, rd_rs2_addr = 0</span></span><br><span class="line">        rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// <span class="doctag">BUG:</span> 应该为rs1</span></span><br><span class="line">        rd_rs2_addr = rs1;                  <span class="comment">// <span class="doctag">BUG:</span> 应该为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;; <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">        wr_reg_addr = rd;                   <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        wr_reg_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-ifid流水线寄存器">Stage-4 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-寄存器文件">Stage-4 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-4-顶层模块">Stage-4 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成两阶段流水线（取指+译码）</span></span><br><span class="line"><span class="comment">// 当前版本：连接了PC、ROM、IF/ID寄存器、译码器和寄存器文件</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 目的寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out;            <span class="comment">// 操作数1输出</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out;            <span class="comment">// 操作数2输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器写回信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr_reg;    <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en     = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr   = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_en   = <span class="number">1&#x27;b1</span>;          <span class="comment">// 始终允许写寄存器（可能有问题）</span></span><br><span class="line"><span class="keyword">assign</span> wr_reg_data = op2_out;       <span class="comment">// BUG：写回数据应该是ALU结果，不是立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),    <span class="comment">// 输出到寄存器文件</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (op1_out),</span><br><span class="line">    <span class="variable">.op2_out</span>      (op2_out)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-5-alu">Chapter 5 ALU</h2>
<h3 id="stage-5-pc计数器">Stage-5 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-rom">Stage-5 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// 例如：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-译码模块">Stage-5 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令（操作码0010011，func3=000）</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// RISC-V指令格式：[31:25] func7 | [24:20] rs2 | [19:15] rs1 | [14:12] func3 | [11:7] rd | [6:0] opcode</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令：寄存器+立即数加法</span></span><br><span class="line"><span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令：操作码=0010011(I-type)，func3=000</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令处理</span></span><br><span class="line">        rd_rs1_addr = rs1;                 <span class="comment">// 设置源寄存器1地址</span></span><br><span class="line">        rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">        op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">        <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">        op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;  <span class="comment">// 符号扩展：复制最高位20次</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：所有输出置零（默认处理）</span></span><br><span class="line">        rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-执行模块">Stage-5 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 当前仅支持ADDI指令的加法操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 检查是否为ADDI指令</span></span><br><span class="line">    <span class="keyword">if</span> ((opcode == <span class="number">7&#x27;b0010011</span>) &amp;&amp; (func3 == <span class="number">3&#x27;b000</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ADDI指令执行：加法操作</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">        wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">        wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 非ADDI指令：禁用写回，输出清零</span></span><br><span class="line">        wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">        wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">        wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-ifid流水线寄存器">Stage-5 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// <span class="doctag">BUG:</span> 应该是[AW-1:0]</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// <span class="doctag">BUG:</span> 应该是[DW-1:0]</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;      <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;           <span class="comment">// 复位时清零</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        instr_out &lt;= instr_in;      <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-idex流水线寄存器">Stage-5 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-寄存器文件">Stage-5 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-5-顶层模块">Stage-5 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 问题：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-6-参数定义">Chapter 6 参数定义</h2>
<h3 id="stage-6-参数定义模块">Stage-6 参数定义模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址宽度和数据宽度</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW 						32  </span><span class="comment">// 地址宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW 						32  </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE					&quot;instr_data.txt&quot;  </span><span class="comment">// 默认指令文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I 	7&#x27;b0010011  </span><span class="comment">// I-type操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI		 	3&#x27;b000       </span><span class="comment">// 加法立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI		 	3&#x27;b010       </span><span class="comment">// 有符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU		3&#x27;b011       </span><span class="comment">// 无符号比较立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI			3&#x27;b100       </span><span class="comment">// 异或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI			3&#x27;b110       </span><span class="comment">// 或立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI			3&#x27;b111       </span><span class="comment">// 与立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI			3&#x27;b001       </span><span class="comment">// 逻辑左移立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI			3&#x27;b101       </span><span class="comment">// 移位右移立即数指令（SRLI/SRAI）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L 	7&#x27;b0000011  </span><span class="comment">// 加载指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB			 	3&#x27;b000       </span><span class="comment">// 加载字节（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH			 	3&#x27;b001       </span><span class="comment">// 加载半字（有符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW				3&#x27;b010       </span><span class="comment">// 加载字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU			3&#x27;b100       </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU			3&#x27;b101       </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S 	7&#x27;b0100011  </span><span class="comment">// 存储指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB			 	3&#x27;b000       </span><span class="comment">// 存储字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH			 	3&#x27;b001       </span><span class="comment">// 存储半字</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW				3&#x27;b010       </span><span class="comment">// 存储字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M 7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB	3&#x27;b000       </span><span class="comment">// 加法/减法指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL		 	3&#x27;b001       </span><span class="comment">// 逻辑左移</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT			3&#x27;b010       </span><span class="comment">// 有符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU			3&#x27;b011       </span><span class="comment">// 无符号比较</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR			3&#x27;b100       </span><span class="comment">// 异或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR				3&#x27;b101       </span><span class="comment">// 移位右移（SRL/SRA）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR				3&#x27;b110       </span><span class="comment">// 或</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND			3&#x27;b111       </span><span class="comment">// 与</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL			3&#x27;b000       </span><span class="comment">// 乘法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH		 	3&#x27;b001       </span><span class="comment">// 乘法高位（有符号×有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU		3&#x27;b010       </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU		3&#x27;b011       </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV			3&#x27;b100       </span><span class="comment">// 有符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU			3&#x27;b101       </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM			3&#x27;b110       </span><span class="comment">// 有符号取余</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU			3&#x27;b111       </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL			7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR			7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI  		7&#x27;b0110111   </span><span class="comment">// 加载高位立即数指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC		7&#x27;b0010111   </span><span class="comment">// PC相对加载高位立即数指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP			32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP		7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET			32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET			32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE		7&#x27;b0001111    </span><span class="comment">// 内存屏障指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL		32&#x27;h00000073  </span><span class="comment">// 环境调用指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK		32&#x27;h00100073  </span><span class="comment">// 断点指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_J 	7&#x27;b1100011   </span><span class="comment">// 分支指令操作码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ			3&#x27;b000        </span><span class="comment">// 相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE		 	3&#x27;b001        </span><span class="comment">// 不相等时分支</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT			3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE			3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU			3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU			3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-pc计数器">Stage-6 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-rom">Stage-6 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-译码模块">Stage-6 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器的指令</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,  <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,  <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,  <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,      <span class="comment">// 操作数1（寄存器值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out       <span class="comment">// 操作数2（立即数）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）- I-type格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr_in[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数（I-type）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    <span class="comment">// ADDI指令格式：rd = rs1 + sign-extend(imm)</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2，设为0</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：源寄存器1的值</span></span><br><span class="line">                    <span class="comment">// 操作数2：符号扩展的立即数（20位符号扩展 + 12位立即数）</span></span><br><span class="line">                    op2_out     = &#123;&#123;<span class="number">20</span>&#123;imm[<span class="number">11</span>]&#125;&#125;, imm&#125;;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-执行模块">Stage-6 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,         <span class="comment">// 操作数1（来自寄存器）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data   <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] imm;     <span class="comment">// 立即数（12位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"><span class="keyword">assign</span> imm    = instr[<span class="number">31</span>:<span class="number">20</span>];  <span class="comment">// 位31-20：立即数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 使用case语句支持更多指令类型的扩展</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 根据操作码分类处理</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span>  <span class="comment">// I-type指令处理</span></span><br><span class="line">            <span class="comment">// 根据功能码3进一步区分具体指令</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    <span class="comment">// ADDI指令：加法操作</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;           <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;             <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;      <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他类型指令暂不支持</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;           <span class="comment">// 禁止寄存器写回</span></span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;           <span class="comment">// 目的寄存器地址置零</span></span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;            <span class="comment">// 结果数据置零</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-ifid流水线寄存器">Stage-6 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="comment">// 这是一个需要修复的BUG</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_out &lt;= `INST_NOP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-idex流水线寄存器">Stage-6 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="comment">// 指令寄存器加载NOP指令，避免未定义行为</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        instr_out      &lt;= `INST_NOP;  <span class="comment">// 加载NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line">        instr_out      &lt;= instr_in;</span><br><span class="line">        op1_out        &lt;= op1_in;</span><br><span class="line">        op2_out        &lt;= op2_in;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-寄存器文件">Stage-6 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-6-顶层模块">Stage-6 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（当前固定为0）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 控制信号硬连线（当前简化版本）</span></span><br><span class="line"><span class="comment">// 注意：这些信号应该由控制单元动态生成</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">assign</span> jump_en   = <span class="number">1&#x27;b0</span>;          <span class="comment">// 禁止跳转，始终顺序执行</span></span><br><span class="line"><span class="keyword">assign</span> jump_addr = <span class="number">&#x27;h0</span>;           <span class="comment">// 跳转地址固定为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),</span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),</span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),</span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),</span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_in</span>     (instr_reg),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.op1_out</span>      (decode_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>      (decode_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),</span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),</span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),</span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),</span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),</span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),</span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),</span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr),</span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),</span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),</span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),</span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),</span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),</span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-7-整体架构">Chapter 7 整体架构</h2>
<h3 id="stage-7-参数定义">Stage-7 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-sub.txt&quot;  </span><span class="comment">// 默认指令文件（SUB指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-pc计数器">Stage-7 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-rom">Stage-7 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-译码模块">Stage-7 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;  <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-执行模块">Stage-7 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-ifid流水线寄存器">Stage-7 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// <span class="doctag">BUG:</span> 这里的数据类型定义反了（应该修复）</span></span><br><span class="line">    <span class="comment">// instr_addr_out应该是AW位，instr_out应该是DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令地址流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存地址</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令数据流水线寄存器</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_out &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存指令</span></span><br><span class="line">        instr_out &lt;= instr_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-idex流水线寄存器">Stage-7 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 作用：1. 同步信号传递 2. 提高时钟频率 3. 隔离译码和执行阶段</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在每个时钟上升沿锁存译码阶段的所有输出信号</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 指令编码清零</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;    <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 时钟上升沿锁存所有信号</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-寄存器文件">Stage-7 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-7-顶层模块">Stage-7 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),     <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),          <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),         <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),         <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr), <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),      <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),        <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)         <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="chapter-8-流水线">Chapter 8 流水线</h2>
<h3 id="stage-8-参数定义">Stage-8 参数定义</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V处理器宏定义文件</span></span><br><span class="line"><span class="comment">// 包含所有指令操作码、功能码和系统常量的定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局参数定义</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> AW                         32      </span><span class="comment">// 地址宽度：32位（RV32架构）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> DW                         32      </span><span class="comment">// 数据宽度：32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> FILE                       &quot;rv32ui-p-andi.txt&quot;  </span><span class="comment">// 默认指令文件（ANDI指令测试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// I-type指令定义（立即数算术/逻辑指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_I                7&#x27;b0010011  </span><span class="comment">// I-type操作码（立即数运算指令）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADDI                  3&#x27;b000      </span><span class="comment">// 加法立即数指令：rd = rs1 + imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTI                  3&#x27;b010      </span><span class="comment">// 有符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTIU                 3&#x27;b011      </span><span class="comment">// 无符号比较立即数指令：rd = (rs1 &lt; imm) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XORI                  3&#x27;b100      </span><span class="comment">// 异或立即数指令：rd = rs1 ^ imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ORI                   3&#x27;b110      </span><span class="comment">// 或立即数指令：rd = rs1 | imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ANDI                  3&#x27;b111      </span><span class="comment">// 与立即数指令：rd = rs1 &amp; imm</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLLI                  3&#x27;b001      </span><span class="comment">// 逻辑左移立即数指令：rd = rs1 &lt;&lt; imm[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SRI                   3&#x27;b101      </span><span class="comment">// 移位右移立即数指令：包含SRLI（逻辑右移）和SRAI（算术右移）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// L-type指令定义（加载指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_L                7&#x27;b0000011  </span><span class="comment">// 加载指令操作码（从内存读取数据到寄存器）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LB                    3&#x27;b000      </span><span class="comment">// 加载字节（有符号扩展）：从内存读取1字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LH                    3&#x27;b001      </span><span class="comment">// 加载半字（有符号扩展）：从内存读取2字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LW                    3&#x27;b010      </span><span class="comment">// 加载字：从内存读取4字节</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LBU                   3&#x27;b100      </span><span class="comment">// 加载字节（无符号扩展）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LHU                   3&#x27;b101      </span><span class="comment">// 加载半字（无符号扩展）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// S-type指令定义（存储指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_S                7&#x27;b0100011  </span><span class="comment">// 存储指令操作码（将寄存器数据写入内存）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SB                    3&#x27;b000      </span><span class="comment">// 存储字节：将1字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SH                    3&#x27;b001      </span><span class="comment">// 存储半字：将2字节写入内存</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SW                    3&#x27;b010      </span><span class="comment">// 存储字：将4字节写入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// R/M-type指令定义（寄存器-寄存器指令和乘除指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_R_M              7&#x27;b0110011  </span><span class="comment">// R-type和M-type操作码（寄存器间运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// R-type指令功能码</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ADD_SUB               3&#x27;b000      </span><span class="comment">// 加法/减法指令：由func7[5]区分(0=ADD, 1=SUB)</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLL                   3&#x27;b001      </span><span class="comment">// 逻辑左移：rd = rs1 &lt;&lt; rs2[4:0]</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLT                   3&#x27;b010      </span><span class="comment">// 有符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SLTU                  3&#x27;b011      </span><span class="comment">// 无符号比较：rd = (rs1 &lt; rs2) ? 1 : 0</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_XOR                   3&#x27;b100      </span><span class="comment">// 异或：rd = rs1 ^ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_SR                    3&#x27;b101      </span><span class="comment">// 移位右移：包含SRL（逻辑右移）和SRA（算术右移）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_OR                    3&#x27;b110      </span><span class="comment">// 或：rd = rs1 | rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_AND                   3&#x27;b111      </span><span class="comment">// 与：rd = rs1 &amp; rs2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M-type指令功能码（乘除扩展，RV32M标准）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MUL                   3&#x27;b000      </span><span class="comment">// 乘法：rd = rs1 * rs2（低32位）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULH                  3&#x27;b001      </span><span class="comment">// 乘法高位（有符号×有符号）：获取64位结果的高32位</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHSU                3&#x27;b010      </span><span class="comment">// 乘法高位（有符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MULHU                 3&#x27;b011      </span><span class="comment">// 乘法高位（无符号×无符号）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIV                   3&#x27;b100      </span><span class="comment">// 有符号除法：rd = rs1 ÷ rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_DIVU                  3&#x27;b101      </span><span class="comment">// 无符号除法</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REM                   3&#x27;b110      </span><span class="comment">// 有符号取余：rd = rs1 % rs2</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_REMU                  3&#x27;b111      </span><span class="comment">// 无符号取余</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// J-type指令定义（无条件跳转指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JAL                   7&#x27;b1101111  </span><span class="comment">// 跳转并链接指令：rd = PC+4, PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_JALR                  7&#x27;b1100111  </span><span class="comment">// 跳转并链接寄存器指令：rd = PC+4, PC = rs1 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// U-type指令定义（长立即数指令）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUI                   7&#x27;b0110111  </span><span class="comment">// 加载高位立即数指令：rd = imm &lt;&lt; 12</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_LUIPC                 7&#x27;b0010111  </span><span class="comment">// PC相对加载高位立即数指令：rd = PC + (imm &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 特殊指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP                   32&#x27;h00000013  </span><span class="comment">// NOP指令编码（ADDI x0, x0, 0）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_NOP_OP                7&#x27;b0000001    </span><span class="comment">// NOP操作码（简化表示，实际应为INST_TYPE_I）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_MRET                  32&#x27;h30200073  </span><span class="comment">// 机器模式异常返回指令</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_RET                   32&#x27;h00008067  </span><span class="comment">// 返回指令（JALR x0, x1, 0）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 系统指令定义</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_FENCE                 7&#x27;b0001111    </span><span class="comment">// 内存屏障指令：同步内存访问</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_ECALL                 32&#x27;h00000073  </span><span class="comment">// 环境调用指令：触发异常进入监控模式</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_EBREAK                32&#x27;h00100073  </span><span class="comment">// 断点指令：用于调试器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// B-type指令定义（分支指令）- 注意宏命名修正为INST_TYPE_B</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_TYPE_B                7&#x27;b1100011   </span><span class="comment">// 分支指令操作码（条件跳转）</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BEQ                   3&#x27;b000        </span><span class="comment">// 相等时分支：if(rs1 == rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BNE                   3&#x27;b001        </span><span class="comment">// 不相等时分支：if(rs1 != rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLT                   3&#x27;b100        </span><span class="comment">// 小于时分支（有符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGE                   3&#x27;b101        </span><span class="comment">// 大于等于时分支（有符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BLTU                  3&#x27;b110        </span><span class="comment">// 小于时分支（无符号）：if(rs1 &lt; rs2) PC = PC + offset</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> INST_BGEU                  3&#x27;b111        </span><span class="comment">// 大于等于时分支（无符号）：if(rs1 &gt;= rs2) PC = PC + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-pc计数器">Stage-8 PC计数器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器模块 - RISC-V处理器取指阶段核心组件</span></span><br><span class="line"><span class="comment">// 功能：生成指令存储器地址，支持顺序执行和跳转控制</span></span><br><span class="line"><span class="keyword">module</span> pc_counter #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>  <span class="comment">// 地址宽度参数，默认32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,        <span class="comment">// 系统时钟，上升沿有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,      <span class="comment">// 异步复位信号，低电平有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳转控制信号（来自执行阶段）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           jump_en,    <span class="comment">// 跳转使能信号，高电平有效</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,  <span class="comment">// 跳转目标地址，32位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer  <span class="comment">// 当前PC值，输出到指令存储器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] current_addr;  <span class="comment">// 内部寄存器，暂存跳转前的PC值（用于异常返回）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// PC更新主逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位状态：PC初始化为0x00000000</span></span><br><span class="line">        <span class="comment">// RISC-V规范：复位后从0x00000000地址开始执行</span></span><br><span class="line">        pc_pointer &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 跳转状态：更新PC为跳转目标地址</span></span><br><span class="line">        <span class="comment">// 用于处理分支、跳转、异常和中断</span></span><br><span class="line">        pc_pointer &lt;= jump_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺序执行状态：PC值递增4（字节寻址）</span></span><br><span class="line">        <span class="comment">// RISC-V指令固定为32位（4字节），所以+4</span></span><br><span class="line">        pc_pointer &lt;= pc_pointer + <span class="number">&#x27;h4</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 辅助逻辑 - 记录跳转前的PC值</span></span><br><span class="line"><span class="comment">// 功能：保存跳转发生时的PC值，可用于异常返回</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        current_addr &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jump_en)</span><br><span class="line">        <span class="comment">// 发生跳转时，保存当前PC值（跳转前的地址）</span></span><br><span class="line">        <span class="comment">// 可用于返回地址保存（如jal指令）</span></span><br><span class="line">        current_addr &lt;= pc_pointer;</span><br><span class="line">    <span class="comment">// 注意：缺少else分支，非跳转时current_addr保持不变</span></span><br><span class="line">    <span class="comment">// 这可能是设计选择，只记录跳转时的PC值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-rom">Stage-8 ROM</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读存储器（ROM）模块 - RISC-V指令存储器</span></span><br><span class="line"><span class="comment">// 功能：存储处理器指令，根据地址输出对应指令</span></span><br><span class="line"><span class="keyword">module</span> rom #(</span><br><span class="line">    <span class="keyword">parameter</span> FILE = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>,  <span class="comment">// 指令文件路径参数</span></span><br><span class="line">    <span class="keyword">parameter</span> AW   = <span class="number">32</span>,                   <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW   = <span class="number">32</span>                    <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位（为统一接口保留，实际未使用）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,</span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 地址输入</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,  <span class="comment">// 指令地址输入（字节地址）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据输出</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out    <span class="comment">// 指令数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 文件路径配置</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> path      = <span class="string">&quot;../test_data/&quot;</span>;      <span class="comment">// 相对路径前缀</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">string</span> full_path = &#123;path, FILE&#125;;         <span class="comment">// 完整文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 初始化块 - 加载指令到ROM</span></span><br><span class="line"><span class="comment">// 注意：$readmemh只在仿真时执行，综合时忽略</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 从十六进制文本文件读取指令到ROM存储器</span></span><br><span class="line">    <span class="comment">// 文件格式：每行一个32位十六进制指令</span></span><br><span class="line">    <span class="built_in">$readmemh</span>(full_path, rom_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ROM存储器声明</span></span><br><span class="line"><span class="comment">// 容量：4096个32位单元 = 16KB存储空间</span></span><br><span class="line"><span class="comment">// 地址范围：0x00000000 - 0x00003FFF（字节地址）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rom_mem [<span class="number">0</span>:<span class="number">4095</span>];  <span class="comment">// 4096个32位存储单元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令读取逻辑 - 组合逻辑（异步读取）</span></span><br><span class="line"><span class="comment">// 功能：根据输入地址读取指令</span></span><br><span class="line"><span class="comment">// 注意：RISC-V指令按字对齐，需要将字节地址转换为字地址</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 将字节地址转换为字地址（右移2位，除以4）</span></span><br><span class="line">    <span class="comment">// instr_addr[AW-1:2]：取地址的高30位（右移2位）</span></span><br><span class="line">    <span class="comment">// 因为每个存储单元是32位（4字节），所以需要将字节地址转换为字索引</span></span><br><span class="line">    instr_out = rom_mem[instr_addr[AW-<span class="number">1</span>:<span class="number">2</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 示例：</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000000 -&gt; 字索引0（第1个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000004 -&gt; 字索引1（第2个32位指令）</span></span><br><span class="line">    <span class="comment">// 字节地址0x00000008 -&gt; 字索引2（第3个32位指令）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-译码模块">Stage-8 译码模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块 - RISC-V指令译码器</span></span><br><span class="line"><span class="comment">// 功能：解析32位指令，提取操作码、寄存器地址和立即数</span></span><br><span class="line"><span class="comment">// 支持指令类型：I-type, R-type, B-type, J-type, U-type</span></span><br><span class="line"><span class="keyword">module</span> decode #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自IF/ID流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令数据（32位编码）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到寄存器文件：源寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr,    <span class="comment">// 源寄存器1地址（rs1）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr,    <span class="comment">// 源寄存器2地址（rs2）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入来自寄存器文件：源寄存器数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data,    <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data,    <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出到ID/EX流水线寄存器：操作数</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 操作数1（寄存器值或PC值）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// RISC-V指令字段提取</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;  <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;      <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;   <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs1;     <span class="comment">// 源寄存器1地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rs2;     <span class="comment">// 源寄存器2地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;   <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;     <span class="comment">// 符号扩展后的立即数（32位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取（RISC-V标准指令格式）</span></span><br><span class="line"><span class="keyword">assign</span> opcode = instr_in[<span class="number">6</span>:<span class="number">0</span>];    <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd     = instr_in[<span class="number">11</span>:<span class="number">7</span>];   <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3  = instr_in[<span class="number">14</span>:<span class="number">12</span>];  <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> rs1    = instr_in[<span class="number">19</span>:<span class="number">15</span>];  <span class="comment">// 位19-15：源寄存器1</span></span><br><span class="line"><span class="keyword">assign</span> rs2    = instr_in[<span class="number">24</span>:<span class="number">20</span>];  <span class="comment">// 位24-20：源寄存器2</span></span><br><span class="line"><span class="keyword">assign</span> func7  = instr_in[<span class="number">31</span>:<span class="number">25</span>];  <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 立即数提取与符号扩展逻辑 - 根据指令类型处理</span></span><br><span class="line"><span class="comment">// RISC-V不同指令类型的立即数格式不同</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type, L-type, JALR指令：imm[11:0] = instr[31:20]</span></span><br><span class="line">        `INST_TYPE_I, `INST_TYPE_L, `INST_JALR:</span><br><span class="line">            <span class="comment">// 符号扩展12位立即数到32位</span></span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">20</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// S-type指令：imm[11:0] = &#123;instr[31:25], instr[11:7]&#125;</span></span><br><span class="line">        `INST_TYPE_S:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">31</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">7</span>]&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令：imm[12:1] = &#123;instr[31], instr[7], instr[30:25], instr[11:8]&#125;</span></span><br><span class="line">        <span class="comment">// 最低位为0（2字节对齐）</span></span><br><span class="line">        `INST_TYPE_B:</span><br><span class="line">            imm = &#123;&#123;<span class="number">20</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">7</span>], instr_in[<span class="number">30</span>:<span class="number">25</span>], instr_in[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令：imm[20:1] = &#123;instr[31], instr[19:12], instr[20], instr[30:21]&#125;</span></span><br><span class="line">        `INST_JAL:</span><br><span class="line">            imm = &#123;&#123;<span class="number">12</span>&#123;instr_in[<span class="number">31</span>]&#125;&#125;, instr_in[<span class="number">19</span>:<span class="number">12</span>], instr_in[<span class="number">20</span>], instr_in[<span class="number">30</span>:<span class="number">21</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// U-type指令（LUI, AUIPC）：imm[31:12] = instr[31:12]</span></span><br><span class="line">        `INST_LUI, `INST_LUIPC:</span><br><span class="line">            imm = &#123;instr_in[<span class="number">31</span>:<span class="number">12</span>], <span class="number">12&#x27;h0</span>&#125;;  <span class="comment">// 低12位补零</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令：立即数为0</span></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            imm = <span class="number">32&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令译码逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码生成寄存器地址和操作数</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = <span class="number">5&#x27;h0</span>;                <span class="comment">// ADDI不使用源寄存器2</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = imm;                 <span class="comment">// 操作数2：立即数（已符号扩展）</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令</span></span><br><span class="line">                    rd_rs1_addr = rs1;                 <span class="comment">// 源寄存器1地址</span></span><br><span class="line">                    rd_rs2_addr = rs2;                 <span class="comment">// 源寄存器2地址</span></span><br><span class="line">                    op1_out     = rd_rs1_data;         <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">                    op2_out     = rd_rs2_data;         <span class="comment">// 操作数2：寄存器rs2的值</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：跳转偏移量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = rs1;                  <span class="comment">// 源寄存器1地址</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器2</span></span><br><span class="line">            op1_out     = rd_rs1_data;          <span class="comment">// 操作数1：寄存器rs1的值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;                <span class="comment">// 操作数1：0</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数（高位）</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;                 <span class="comment">// 不使用源寄存器</span></span><br><span class="line">            op1_out     = instr_addr_in;        <span class="comment">// 操作数1：当前PC值</span></span><br><span class="line">            op2_out     = imm;                  <span class="comment">// 操作数2：立即数偏移</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">32&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            rd_rs1_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            rd_rs2_addr = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op1_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">            op2_out     = <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-执行模块">Stage-8 执行模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块 - RISC-V算术逻辑单元（ALU）和控制逻辑</span></span><br><span class="line"><span class="comment">// 功能：执行算术和逻辑运算，生成结果和写回控制信号</span></span><br><span class="line"><span class="comment">// 支持指令：ADDI, ADD, SUB, BNE, JAL, JALR, LUI, AUIPC</span></span><br><span class="line"><span class="keyword">module</span> execute #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 输入：来自ID/EX流水线寄存器</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr,   <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr,        <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1,          <span class="comment">// 操作数1（来自寄存器或PC）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2,          <span class="comment">// 操作数2（立即数或寄存器值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到寄存器文件</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           wr_reg_en,    <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr,  <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data,  <span class="comment">// 写入寄存器的数据（ALU结果）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到控制单元（PC计数器）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_en,      <span class="comment">// 跳转使能信号（1=需要跳转）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr,    <span class="comment">// 跳转目标地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span>           jump_hold     <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 指令字段提取（执行阶段需要重新提取以确定操作类型）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  opcode;   <span class="comment">// 操作码（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]  rd;       <span class="comment">// 目的寄存器地址（5位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]  func3;    <span class="comment">// 功能码3（3位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]  func7;    <span class="comment">// 功能码7（7位）</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] imm;      <span class="comment">// 分支指令立即数（已符号扩展）</span></span><br><span class="line"><span class="keyword">logic</span>        equal;    <span class="comment">// 比较结果：操作数1是否等于操作数2</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>] jump_imm;  <span class="comment">// 分支跳转地址：PC + 立即数偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令字段提取</span></span><br><span class="line"><span class="keyword">assign</span> opcode   = instr[<span class="number">6</span>:<span class="number">0</span>];     <span class="comment">// 最低7位：操作码</span></span><br><span class="line"><span class="keyword">assign</span> rd       = instr[<span class="number">11</span>:<span class="number">7</span>];    <span class="comment">// 位11-7：目的寄存器</span></span><br><span class="line"><span class="keyword">assign</span> func3    = instr[<span class="number">14</span>:<span class="number">12</span>];   <span class="comment">// 位14-12：功能码3</span></span><br><span class="line"><span class="keyword">assign</span> func7    = instr[<span class="number">31</span>:<span class="number">25</span>];   <span class="comment">// 最高7位：功能码7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支指令立即数计算（B-type格式）</span></span><br><span class="line"><span class="keyword">assign</span> imm = &#123;&#123;<span class="number">20</span>&#123;instr[<span class="number">31</span>]&#125;&#125;, instr[<span class="number">7</span>], instr[<span class="number">30</span>:<span class="number">25</span>], instr[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1&#x27;b0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等比较器：用于条件分支指令（BNE）</span></span><br><span class="line"><span class="keyword">assign</span> equal = (op1 == op2) ? <span class="number">1&#x27;b1</span> : <span class="number">1&#x27;b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支跳转地址计算：PC + 立即数偏移</span></span><br><span class="line"><span class="keyword">assign</span> jump_imm = instr_addr + imm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 执行逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 根据操作码和功能码执行相应操作</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(opcode)</span><br><span class="line">        <span class="comment">// I-type指令处理</span></span><br><span class="line">        `INST_TYPE_I: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADDI: <span class="keyword">begin</span>  <span class="comment">// ADDI指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b1</span>;            <span class="comment">// 使能寄存器写回</span></span><br><span class="line">                    wr_reg_addr = rd;              <span class="comment">// 目的寄存器地址</span></span><br><span class="line">                    wr_reg_data = op1 + op2;       <span class="comment">// ALU操作：寄存器值 + 立即数</span></span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;            <span class="comment">// 不跳转</span></span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;             <span class="comment">// 跳转地址为0</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;            <span class="comment">// 跳转保持为0</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他I-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// R/M-type指令处理</span></span><br><span class="line">        `INST_TYPE_R_M: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_ADD_SUB: <span class="keyword">begin</span>  <span class="comment">// ADD/SUB指令</span></span><br><span class="line">                    <span class="keyword">if</span>(func7 == <span class="number">7&#x27;b000_0000</span>) <span class="keyword">begin</span>  <span class="comment">// ADD指令（func7=0000000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 + op2;    <span class="comment">// 加法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">begin</span>  <span class="comment">// SUB指令（func7=0100000）</span></span><br><span class="line">                        wr_reg_en   = <span class="number">1&#x27;b1</span>;</span><br><span class="line">                        wr_reg_addr = rd;</span><br><span class="line">                        wr_reg_data = op1 - op2;    <span class="comment">// 减法运算</span></span><br><span class="line">                        jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                        jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                        jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他R-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B-type指令处理（条件分支）</span></span><br><span class="line">        `INST_TYPE_B: <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(func3)</span><br><span class="line">                `INST_BNE: <span class="keyword">begin</span>  <span class="comment">// BNE指令执行</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 分支指令不写寄存器</span></span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = ~equal;                  <span class="comment">// 不相等时跳转</span></span><br><span class="line">                    jump_addr   = ~equal ? jump_imm : <span class="number">&#x27;h0</span>; <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">begin</span>  <span class="comment">// 其他B-type指令暂不支持</span></span><br><span class="line">                    wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">                    wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                    jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">                    jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JAL指令（无条件跳转并链接）</span></span><br><span class="line">        `INST_JAL: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = instr_addr + op2;        <span class="comment">// 跳转地址：PC + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// JALR指令（寄存器跳转并链接）</span></span><br><span class="line">        `INST_JALR: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器（返回地址）</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = instr_addr + <span class="number">32&#x27;h4</span>;      <span class="comment">// 返回地址：PC + 4</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要跳转</span></span><br><span class="line">            jump_addr   = op1 + op2;               <span class="comment">// 跳转地址：rs1 + 偏移</span></span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LUI指令（加载高位立即数）</span></span><br><span class="line">        `INST_LUI: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op2;                     <span class="comment">// 结果：立即数本身（已左移12位）</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// AUIPC指令（PC相对加载高位立即数）</span></span><br><span class="line">        `INST_LUIPC: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b1</span>;                    <span class="comment">// 需要写寄存器</span></span><br><span class="line">            wr_reg_addr = rd;                      <span class="comment">// 目的寄存器</span></span><br><span class="line">            wr_reg_data = op1 + op2;               <span class="comment">// 结果：PC + (imm &lt;&lt; 12)</span></span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;                    <span class="comment">// 不跳转</span></span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// NOP指令（空操作）</span></span><br><span class="line">        `INST_NOP_OP: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他指令暂不支持</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">            wr_reg_en   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            wr_reg_addr = <span class="number">5&#x27;h0</span>;</span><br><span class="line">            wr_reg_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_en     = <span class="number">1&#x27;b0</span>;</span><br><span class="line">            jump_addr   = <span class="number">&#x27;h0</span>;</span><br><span class="line">            jump_hold   = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-ifid流水线寄存器">Stage-8 IF/ID流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在取指阶段和译码阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> if2id #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,                <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,              <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,         <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                                  <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自取指阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,      <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,           <span class="comment">// 指令数据（来自ROM）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到译码阶段</span></span><br><span class="line">    <span class="comment">// 注意：输出信号类型有误，instr_addr_out应为AW位，instr_out应为DW位</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out,     <span class="comment">// 锁存的指令地址（应为[AW-1:0]）</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_out           <span class="comment">// 锁存的指令数据（应为[DW-1:0]）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时清零</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 指令数据加载NOP（空操作）</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令，避免错误指令执行</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out  &lt;= <span class="number">&#x27;h0</span>;          <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out       &lt;= `INST_NOP;    <span class="comment">// 插入NOP指令</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out  &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out       &lt;= instr_in;       <span class="comment">// 锁存指令数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-idex流水线寄存器">Stage-8 ID/EX流水线寄存器</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器模块</span></span><br><span class="line"><span class="comment">// 功能：在译码阶段和执行阶段之间插入流水线寄存器</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿（instr_hold）机制</span></span><br><span class="line"><span class="keyword">module</span> id2ex #(</span><br><span class="line">    <span class="keyword">parameter</span> AW = <span class="number">32</span>,  <span class="comment">// 地址宽度，32位</span></span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>   <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 流水线控制信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>           instr_hold,     <span class="comment">// 指令保持信号（高电平有效）</span></span><br><span class="line">                                              <span class="comment">// 用于处理流水线冒险，使流水线停顿</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入：来自译码阶段</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_in,  <span class="comment">// 指令地址（PC值）</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_in,       <span class="comment">// 指令编码</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_in,         <span class="comment">// 操作数1</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_in,         <span class="comment">// 操作数2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出：到执行阶段</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_out, <span class="comment">// 锁存的指令地址</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_out,      <span class="comment">// 锁存的指令编码</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op1_out,        <span class="comment">// 锁存的操作数1</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  op2_out         <span class="comment">// 锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 支持流水线停顿：当instr_hold有效时，插入NOP指令</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 指令地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 指令编码加载NOP（空操作）</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (instr_hold) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 流水线停顿状态：插入NOP指令</span></span><br><span class="line">        <span class="comment">// 用于处理控制冒险（分支预测失败时冲刷流水线）</span></span><br><span class="line">        instr_addr_out &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 地址清零</span></span><br><span class="line">        instr_out      &lt;= `INST_NOP;      <span class="comment">// 插入NOP指令</span></span><br><span class="line">        op1_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数1清零</span></span><br><span class="line">        op2_out        &lt;= <span class="number">&#x27;h0</span>;            <span class="comment">// 操作数2清零</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 正常流水线推进状态</span></span><br><span class="line">        instr_addr_out &lt;= instr_addr_in;  <span class="comment">// 锁存指令地址</span></span><br><span class="line">        instr_out      &lt;= instr_in;       <span class="comment">// 锁存指令编码</span></span><br><span class="line">        op1_out        &lt;= op1_in;         <span class="comment">// 锁存操作数1</span></span><br><span class="line">        op2_out        &lt;= op2_in;         <span class="comment">// 锁存操作数2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-寄存器文件">Stage-8 寄存器文件</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件模块 - RISC-V 32个通用寄存器</span></span><br><span class="line"><span class="comment">// 功能：提供读写接口，支持数据转发（前推）解决数据冒险</span></span><br><span class="line"><span class="keyword">module</span> register #(</span><br><span class="line">    <span class="keyword">parameter</span> DW = <span class="number">32</span>  <span class="comment">// 数据宽度，32位</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       clk,            <span class="comment">// 系统时钟</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       rst_n,          <span class="comment">// 异步复位信号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自译码阶段：读端口地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs1_addr,    <span class="comment">// 源寄存器1地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] rd_rs2_addr,    <span class="comment">// 源寄存器2地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 到译码阶段：读端口数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs1_data, <span class="comment">// 源寄存器1数据</span></span><br><span class="line">    <span class="keyword">output</span>  <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] rd_rs2_data, <span class="comment">// 源寄存器2数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自执行阶段：写端口控制</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span>       wr_reg_en,      <span class="comment">// 寄存器写使能信号</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] wr_reg_addr,    <span class="comment">// 目的寄存器地址</span></span><br><span class="line">    <span class="keyword">input</span>   <span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] wr_reg_data  <span class="comment">// 写入寄存器的数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器数组声明</span></span><br><span class="line"><span class="comment">// RISC-V有32个32位通用寄存器，x0-x31</span></span><br><span class="line"><span class="comment">// 其中x0是硬连线的0寄存器（只读，始终为0）</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>] regs [<span class="number">0</span>:<span class="number">31</span>];  <span class="comment">// 32个32位寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器1读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 支持数据转发：如果正在写入的寄存器是当前要读取的，直接使用写入数据</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        <span class="comment">// 复位时输出0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs1_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0，无论写入什么值都读为0</span></span><br><span class="line">        <span class="comment">// RISC-V规范：x0寄存器恒为0</span></span><br><span class="line">        rd_rs1_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs1_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发（前推）：如果要读取的寄存器正在被写入，使用写入数据</span></span><br><span class="line">        <span class="comment">// 解决RAW（写后读）数据冒险，避免流水线停顿</span></span><br><span class="line">        rd_rs1_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取寄存器值</span></span><br><span class="line">        rd_rs1_data = regs[rd_rs1_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 源寄存器2读取逻辑 - 组合逻辑</span></span><br><span class="line"><span class="comment">// 与源寄存器1相同，支持数据转发</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rd_rs2_addr == <span class="number">5&#x27;h0</span>)</span><br><span class="line">        <span class="comment">// x0寄存器硬连线为0</span></span><br><span class="line">        rd_rs2_data = <span class="number">&#x27;h0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (rd_rs2_addr == wr_reg_addr))</span><br><span class="line">        <span class="comment">// 数据转发</span></span><br><span class="line">        rd_rs2_data = wr_reg_data;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 正常读取</span></span><br><span class="line">        rd_rs2_data = regs[rd_rs2_addr];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 寄存器写逻辑 - 同步时序逻辑</span></span><br><span class="line"><span class="comment">// 在时钟上升沿更新寄存器值</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 复位时所有寄存器清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="keyword">begin</span></span><br><span class="line">            regs[i] &lt;= <span class="number">&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wr_reg_en &amp;&amp; (wr_reg_addr != <span class="number">5&#x27;h0</span>)) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 写使能有效且不是x0寄存器时，写入数据</span></span><br><span class="line">        <span class="comment">// x0是只读寄存器，始终为0，不能写入</span></span><br><span class="line">        regs[wr_reg_addr] &lt;= wr_reg_data;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 其他情况保持寄存器值不变</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="stage-8-顶层模块">Stage-8 顶层模块</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps  </span><span class="comment">// 时间单位1ns，时间精度1ps</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="keyword">include</span> &quot;<span class="keyword">define</span>.sv&quot;  </span><span class="comment">// 包含宏定义文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RISC-V处理器顶层模块</span></span><br><span class="line"><span class="comment">// 功能：集成所有子模块，构成三阶段流水线（取指+译码+执行）</span></span><br><span class="line"><span class="comment">// 新增：支持流水线停顿机制处理控制冒险</span></span><br><span class="line"><span class="keyword">module</span> riscv #(</span><br><span class="line">    <span class="keyword">parameter</span> AW    = <span class="number">32</span>,                       <span class="comment">// 地址宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> DW    = <span class="number">32</span>,                       <span class="comment">// 数据宽度</span></span><br><span class="line">    <span class="keyword">parameter</span> FILE  = <span class="string">&quot;rv32ui-p-addi.txt&quot;</span>       <span class="comment">// 指令文件路径</span></span><br><span class="line">)(</span><br><span class="line">    <span class="comment">// 全局时钟与复位</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> rst_n</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 内部信号声明</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取指阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           jump_en;            <span class="comment">// 跳转使能信号（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  jump_addr;          <span class="comment">// 跳转地址（来自执行阶段）</span></span><br><span class="line"><span class="keyword">logic</span>           jump_hold;          <span class="comment">// 跳转保持信号（暂未使用）</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  pc_pointer;         <span class="comment">// PC值，连接到ROM地址输入</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instruction;        <span class="comment">// 从ROM读取的指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  instr_addr_reg;     <span class="comment">// 锁存的指令地址（PC值）- 注意类型错误</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  instr_reg;          <span class="comment">// 锁存的指令数据 - 注意类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码阶段信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs1_addr;        <span class="comment">// 源寄存器1地址</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     rd_rs2_addr;        <span class="comment">// 源寄存器2地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs1_data;        <span class="comment">// 源寄存器1数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  rd_rs2_data;        <span class="comment">// 源寄存器2数据</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op1;         <span class="comment">// 译码阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  decode_op2;         <span class="comment">// 译码阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器信号</span></span><br><span class="line"><span class="keyword">logic</span> [AW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr_addr; <span class="comment">// 执行阶段指令地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_instr;      <span class="comment">// 执行阶段指令编码</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op1;        <span class="comment">// 执行阶段操作数1</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  execute_op2;        <span class="comment">// 执行阶段操作数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行阶段信号</span></span><br><span class="line"><span class="keyword">logic</span>           wr_reg_en;          <span class="comment">// 寄存器写使能信号</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>]     wr_reg_addr;        <span class="comment">// 写回寄存器地址</span></span><br><span class="line"><span class="keyword">logic</span> [DW-<span class="number">1</span>:<span class="number">0</span>]  wr_reg_data;        <span class="comment">// 写回数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"><span class="comment">// 模块实例化</span></span><br><span class="line"><span class="comment">// ====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PC计数器实例化</span></span><br><span class="line">pc_counter #(</span><br><span class="line">    <span class="variable">.AW</span>(AW)</span><br><span class="line">) u_pc_counter_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.jump_en</span>    (jump_en),      <span class="comment">// 跳转使能来自执行阶段</span></span><br><span class="line">    <span class="variable">.jump_addr</span>  (jump_addr),    <span class="comment">// 跳转地址来自执行阶段</span></span><br><span class="line">    <span class="variable">.pc_pointer</span> (pc_pointer)    <span class="comment">// PC值输出到ROM</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ROM存储器实例化</span></span><br><span class="line">rom #(</span><br><span class="line">    <span class="variable">.FILE</span>(FILE),</span><br><span class="line">    <span class="variable">.AW</span>  (AW),</span><br><span class="line">    <span class="variable">.DW</span>  (DW)</span><br><span class="line">) u_rom_inst (</span><br><span class="line">    <span class="variable">.clk</span>        (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>      (rst_n),</span><br><span class="line">    <span class="variable">.instr_addr</span> (pc_pointer),   <span class="comment">// 地址来自PC计数器</span></span><br><span class="line">    <span class="variable">.instr_out</span>  (instruction)   <span class="comment">// 指令输出到IF/ID寄存器</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IF/ID流水线寄存器实例化</span></span><br><span class="line">if2id #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_if2id_inst (</span><br><span class="line">    <span class="variable">.clk</span>            (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>          (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>     (jump_en),          <span class="comment">// 跳转时停顿流水线，冲刷错误指令</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (pc_pointer),       <span class="comment">// 输入：PC值</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instruction),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span> (instr_addr_reg),   <span class="comment">// 输出：锁存的PC值（类型错误）</span></span><br><span class="line">    <span class="variable">.instr_out</span>      (instr_reg)         <span class="comment">// 输出：锁存的指令（类型错误）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译码模块实例化</span></span><br><span class="line">decode #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_decode_inst (</span><br><span class="line">    <span class="variable">.instr_addr_in</span>  (instr_addr_reg),   <span class="comment">// 输入：指令地址（PC值）</span></span><br><span class="line">    <span class="variable">.instr_in</span>       (instr_reg),        <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>    (rd_rs1_addr),      <span class="comment">// 输出：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>    (rd_rs2_addr),      <span class="comment">// 输出：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>    (rd_rs1_data),      <span class="comment">// 输入：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>    (rd_rs2_data),      <span class="comment">// 输入：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.op1_out</span>        (decode_op1),       <span class="comment">// 输出：操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>        (decode_op2)        <span class="comment">// 输出：操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器文件实例化</span></span><br><span class="line">register #(</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_register_inst (</span><br><span class="line">    <span class="variable">.clk</span>          (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>        (rst_n),</span><br><span class="line">    <span class="variable">.rd_rs1_addr</span>  (rd_rs1_addr),        <span class="comment">// 输入：源寄存器1地址</span></span><br><span class="line">    <span class="variable">.rd_rs2_addr</span>  (rd_rs2_addr),        <span class="comment">// 输入：源寄存器2地址</span></span><br><span class="line">    <span class="variable">.rd_rs1_data</span>  (rd_rs1_data),        <span class="comment">// 输出：源寄存器1数据</span></span><br><span class="line">    <span class="variable">.rd_rs2_data</span>  (rd_rs2_data),        <span class="comment">// 输出：源寄存器2数据</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输入：写使能</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输入：写地址</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data)         <span class="comment">// 输入：写数据</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ID/EX流水线寄存器实例化</span></span><br><span class="line">id2ex #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_id2ex_inst (</span><br><span class="line">    <span class="variable">.clk</span>              (clk),</span><br><span class="line">    <span class="variable">.rst_n</span>            (rst_n),</span><br><span class="line">    <span class="variable">.instr_hold</span>       (jump_en),              <span class="comment">// 跳转时停顿流水线</span></span><br><span class="line">    <span class="variable">.instr_addr_in</span>    (instr_addr_reg),       <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr_in</span>         (instr_reg),            <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1_in</span>           (decode_op1),           <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2_in</span>           (decode_op2),           <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.instr_addr_out</span>   (execute_instr_addr),   <span class="comment">// 输出：锁存的指令地址</span></span><br><span class="line">    <span class="variable">.instr_out</span>        (execute_instr),        <span class="comment">// 输出：锁存的指令编码</span></span><br><span class="line">    <span class="variable">.op1_out</span>          (execute_op1),          <span class="comment">// 输出：锁存的操作数1</span></span><br><span class="line">    <span class="variable">.op2_out</span>          (execute_op2)           <span class="comment">// 输出：锁存的操作数2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块实例化</span></span><br><span class="line">execute #(</span><br><span class="line">    <span class="variable">.AW</span>(AW),</span><br><span class="line">    <span class="variable">.DW</span>(DW)</span><br><span class="line">) u_execute_inst (</span><br><span class="line">    <span class="variable">.instr_addr</span>   (execute_instr_addr), <span class="comment">// 输入：指令地址</span></span><br><span class="line">    <span class="variable">.instr</span>        (execute_instr),      <span class="comment">// 输入：指令编码</span></span><br><span class="line">    <span class="variable">.op1</span>          (execute_op1),        <span class="comment">// 输入：操作数1</span></span><br><span class="line">    <span class="variable">.op2</span>          (execute_op2),        <span class="comment">// 输入：操作数2</span></span><br><span class="line">    <span class="variable">.wr_reg_en</span>    (wr_reg_en),          <span class="comment">// 输出：写使能到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_addr</span>  (wr_reg_addr),        <span class="comment">// 输出：写地址到寄存器文件</span></span><br><span class="line">    <span class="variable">.wr_reg_data</span>  (wr_reg_data),        <span class="comment">// 输出：写数据到寄存器文件</span></span><br><span class="line">    <span class="variable">.jump_en</span>      (jump_en),            <span class="comment">// 输出：跳转使能到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_addr</span>    (jump_addr),          <span class="comment">// 输出：跳转地址到PC计数器</span></span><br><span class="line">    <span class="variable">.jump_hold</span>    (jump_hold)           <span class="comment">// 输出：跳转保持信号（暂未使用）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">第一章:Verilog HDL数字集成电路设计方法概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 05:46:54" itemprop="dateModified" datetime="2026-01-15T05:46:54+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2
id="数字集成电路的发展和设计方法的演变">数字集成电路的发展和设计方法的演变</h2>
<p>几十个逻辑门的小规模集成电路(Small Scale Integrated,
SSI)–&gt;单芯片数千万个逻辑门的极大规模集成电路(Ultra Large Scale
Integrated, ULSI), 单芯片可以集成几十亿只晶体管.</p>
<h2 id="集成电路的发展">集成电路的发展</h2>
<h3 id="第一次变革时期">第一次变革时期</h3>
<p>20世纪70年代, 是以加工制造为主导的IC(Integrated
Circuit)产业发展的初级阶段, 主流产品是微处理器(Micro Processor Unit,
MPU), 存储器以及标准通用逻辑电路. 这一时期, IC整合原件厂(Integrated
Device Manufacturer, IDM)在IC市场中充当主要角色,
设计只作为附属部门而存在. 芯片设计和半导体工艺密切相关, 设计以人工为主,
计算机辅助为辅(Computer Aided Design,
CAD)系统只作为数据处理和图形编程。</p>
<h3 id="第二次变革时期">第二次变革时期</h3>
<p>20世纪80年代, 标准工艺加工线(Foundry)公司和IC设计公司共同发展,
主流产品是MPU, 微控制器(Micro Control Unit,
MCU)以及专用IC(Application-Specific IC, ASIC).
这时Foundry和IC设计公司相结合的方式开始成为集成电路产业发展的新模式.
IC产业开始进入以客户为 导向的阶段. 超大规模集成电路(Very Large Scale
Integrated, VLSI)开始成为主流芯片; 电子设计自动化(Eletronic Design
Automation, EDA) 快速发展, 设计过程和生产工艺可以各自独立存在,
没有生产线的IC设计公司(Fabless)和设计部门纷纷建立并快速发展,
同时以制造业为主的Foundry 工厂也迅速发展. 1987年,
全球第一个Foundry工厂————台积电成立,
其创始人张忠谋被誉为”芯片加工之父”.</p>
<h3 id="第三次变革时期">第三次变革时期</h3>
<p>20世纪90年代, IC产业的”四业”(设计业, 制造业, 封装业, 测试业)开始分离,
功能强大的通用性中央处理器(Central Processing Unit,
CPU)和信号处理器(Digital Signal Processing, DSP)成为产业新的增长点.</p>
<p>进入21世纪, 首先CMOS模拟技术的发展使得数模混合单芯片集成技术迅速发展,
在设计和成本方面体现了巨大优势. 其次, 应用需求使得储存器在USLI
芯片中的作业越来越明显, 高密度存储器及其SoC设计成为设计的焦点. 再次,
大规模多内核处理器结构成为通用型芯片和SoC芯片的主流设计方式.</p>
<p>在设计方法方面, 采用功能复用的IP(Intelligent Property)的设计方式,
成为IC设计和商业化的一种主要方式, 极大提高了ULSI芯片的设计效率和
可扩展性.</p>
<h2 id="ip核">IP核</h2>
<p>IP核是具有知识产权核的集成电路芯核总称, 是经过反复验证的,
具有特定功能的宏模块, 与芯片制作工艺无关,
可以移植到不同的半导体工艺中.</p>
<p>到了SoC阶段,
向用户提供IP核服务已经成为可编程逻辑器件提供商的重要任务.
在SoC芯片的设计生产过程中, 芯片的生产厂家只需根据设计需要购入
相应功能的IP核, 再将这些IP核按照设计需要进行组合,
即可完成所需功能的设计.</p>
<p><strong>软核</strong>经过功能验证, 5000门以上的可综合Verilog
HDL或VHDL模型. 软核通常与设计方法和电路所采用的工艺无关,
具有很强的可综合性和可重用性. 由软核构成的器件称为虚拟器件,
通过EDA综合工具可以把它和其他数字逻辑电路结合起来, 构成新的功能电路;</p>
<p><strong>固核</strong>在FPGA器件上, 经过综合验证,
大于5000门的电路网表文件;</p>
<p><strong>硬核</strong>在ASIC器件上, 经过验证正确的,
大于5000门的电路结构版图掩模.</p>
<p>其中软核是可读性较高的可综合HDL实现, 因此其可维护性和可重用性较高,
更加灵活和简便. 固核和硬核是针对不同平台的功能单元, 性能稳定,
不易修改.</p>
<h2 id="verilog-hdl在数字集成电路设计流程中的作用">Verilog
HDL在数字集成电路设计流程中的作用</h2>
<p>一般的数字集成电路设计流程如下:</p>
<p>总体方案————&gt;系统建模————&gt;RTL编码————&gt;功能验证————&gt;综合————&gt;时序验证————&gt;物理综合/布局布线————&gt;物理验证————&gt;原型建立和测试————&gt;工艺实现</p>
<p>数字集成电路和FPGA设计过程总体可以分成4个阶段</p>
<p><strong>第一阶段</strong>是<strong>系统设计阶段</strong>,
包括总体方案和系统建模.
<strong>第二阶段</strong>是<strong>数字电路设计和代码编写阶段</strong>,
即RTL代码编写阶段.
<strong>第三阶段</strong>是<strong>电路验证阶段</strong>,
包括对硬件描述语言的程序代码的功能验证和经过EDA综合工具之后的时序验证两个部分.
<strong>第四阶段</strong>是集成电路的<strong>后端设计阶段</strong>,
主要通过EDA工具和进行物理综合, 布局布线, 物理验证, 原型建立和测试,
最终交付工艺实现.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/VMware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/VMware/" class="post-title-link" itemprop="url">VMware</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-28 19:35:24" itemprop="dateModified" datetime="2025-10-28T19:35:24+08:00">2025-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="vmware的安装">VMware的安装</h2>
<p>在百度网盘中下载好, 打开exe文件安装, 安装完成后输入密钥.</p>
<h2 id="linux操作系统的安装">Linux操作系统的安装</h2>
<p>假设电脑中已经安装了VMware,我们只需要进入Linux官方网站,可以看到网站中有Ubuntu,CentOS等操作系统,以Ubuntu为例,点击Download
Ubuntu,可以看到有很多版本,我们选择桌面版,点击Download Ubuntu
Desktop,然后下载想要的版本,这里以ubuntu-20.04.6-desktop-amd64.iso为例,下载好之后我们可以得到后缀为.iso的光盘映像文件.</p>
<p>打开VMware,点击”创建新的虚拟机-&gt;下一步”,在”安装程序光盘映像文件(iso)(M):“一栏中选择刚刚下载好的Ubuntu
iso文件,再点击”下一步”,用户名,密码等选项可以随便填,这里用户名填写siyuanlei,密码填写123456,点击”下一步”,给虚拟机命名Ubuntu
20.04,点击”下一步”,设置磁盘大小,点击”下一步”,取消勾选”创建后开启此虚拟机”,点击”完成”.</p>
<p>创建完成后,点击”编辑虚拟机设置”,可以更改内存,处理器数量以及每个处理器的内核数量等</p>
<p>设置完成后点击”开启此虚拟机”,打开后,选择”Try or Install
Ubuntu”,然后按回车,就会出现Ubuntu安装界面.根据自己需求设置即可.</p>
<h2 id="ic617618的安装">IC617/618的安装</h2>
<p>打开已经下载好的镜像文件<code>IC618.vms</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%B8%89%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%B8%89%E7%AB%A0/" class="post-title-link" itemprop="url">第三章:Verilog HDL程序设计语句和描述方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 06:25:45" itemprop="dateModified" datetime="2026-01-15T06:25:45+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据流建模">数据流建模</h2>
<p>数据流建模只有一种方式, 就是<strong>连续赋值语句</strong>,
连续赋值语句<strong>只能对wire赋值</strong>,
<strong>不能对reg赋值</strong>.</p>
<p>连续赋值语句包括显式连续赋值语句和隐式连续赋值语句,
通常使用显式连续赋值语句, 其格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> &lt;range&gt; &lt;name&gt;;<span class="comment">//声明wire型变量，定义位宽和连线名</span></span><br><span class="line"><span class="keyword">assign</span> #&lt;delay&gt;&lt;name&gt; = 表达式;<span class="comment">//delay是从表达式内信号发生变化的时刻到wire型变量取值被更新时的时间延迟</span></span><br></pre></td></tr></table></figure>
<p>隐式赋值语句为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;net_declaration&gt;&lt;drive_strength&gt;&lt;range&gt;#&lt;delay&gt;&lt;name&gt;=assignment expression;</span><br></pre></td></tr></table></figure>
<p>注意<code>&lt;drive_strength&gt;</code>只能在隐式赋值语句中被指定,
用来对连线型变量受到的驱动强度进行指定.
例如<code>wire(weak0, strong1)out=in1&amp;in2</code>表示给<code>out</code>赋<code>0</code>时的驱动强度为<code>weak</code>,
赋<code>1</code>时的驱动强度为<code>strong</code>. 如果赋值驱动强度缺省,
那么默认为<code>(strong1, strong0)</code>.</p>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>连续赋值语句只能对<code>wire</code>赋值,
不能对<code>reg</code>赋值;</li>
<li>在连续赋值语句中, 只要赋值语句右边表达式发生变化,
则表达式立即被计算然后赋给左边的<code>wire</code>型变量(如果没有定义延时量),
这种特性正是组合逻辑电路的特点;</li>
<li>连续赋值语句不能出现在过程块中;</li>
<li>多个连续赋值语句是并行关系;</li>
<li>数据流建模所有变量均为<code>wire</code>型.</li>
</ul>
<h2 id="行为级建模">行为级建模</h2>
<p>行为级建模就是从电路外部特性进行描述, 和C语言类似,
行为描述模块称为描述体</p>
<p><strong>描述体 = 过程块 + 连续赋值语句</strong> <strong>过程块 =
过程语句(initial、always) +
语句块(过程赋值语句、高级程序语句)</strong></p>
<p>行为级建模所有变量均为<code>reg</code>型,
包括过程语句(<code>initial</code>，<code>always</code>),
语句块(<code>begin-end</code>, <code>fork-join</code>),
赋值语句(阻塞或非阻塞), 条件分支语句(<code>if-else</code>,
<code>case</code>), 循环语句(<code>forever</code>, <code>repeat</code>,
<code>while</code>, <code>for</code>)等,
这里面只有过程连续赋值语句(<code>assign-deassign</code>,
<code>force-release</code>)可以对<code>wire</code>型变量赋值.</p>
<h3 id="过程语句initial和always">过程语句：initial和always</h3>
<p>过程语句具有很强的功能, 大多数高级程序语句都是在过程中使用的.
它既可以描述时序逻辑电路, 也可以描述组合逻辑电路.
采用过程语句进行程序设计时, 需要遵循一定的设计要求和规范.</p>
<p>在信号的形式定义方面, 无论是时序还是组合逻辑电路,
在过程语句(<code>initial</code>和<code>always</code>)中,
被赋值的变量必须是<code>reg</code>类型的.</p>
<p>在敏感事件列表方面:</p>
<p>对于<strong>组合电路</strong>,
需要把<strong>全部的输入信号</strong>列入敏感事件列表.</p>
<p>对于<strong>时序电路</strong>,
需要把<strong>时间信号</strong><code>clk</code>和<strong>部分输入信号</strong>列入敏感事件列表.</p>
<h4 id="initial的用法">initial的用法</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">          语句<span class="number">1</span>;</span><br><span class="line">          语句<span class="number">2</span>;</span><br><span class="line">          ...;</span><br><span class="line">          语句n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>initial</code>过程块在仿真时从模拟0时刻开始执行, 只执行一次.
在执行完以后该<code>initial</code>过程块就被挂起, 不再执行.
如果一个模块中存在多个<code>initial</code>过程块,
那么每个<code>initial</code>过程块都是从0时刻开始并行执行的.
<code>initial</code>过程块内部的多条行为语句可以是顺序执行,
也可以是并行执行.</p>
<p><code>initial</code>过程语句通常用于仿真模块中对激励向量的描述,
或用于给寄存器赋初值.</p>
<h4 id="always的用法">always的用法</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(&lt;敏感事件列表&gt;)</span><br><span class="line">    语句块;</span><br></pre></td></tr></table></figure>
<p>敏感事件列表就是触发条件, 当敏感事件列表中的变量改变时,
语句块立即执行. 因此, 敏感事件列表中必须列出影响块内取值的所有信号.
若有两个或者两个以上的信号,
则它们之间可以用<code>or</code>或者<code>,</code>来连接.
敏感信号可以分为两种类型, 一种是边沿敏感型, 另一种是电平敏感型.
对于时序电路, 事件通常是由时钟边沿触发的.
<code>posedge</code>和<code>negedge</code>分别表示信号的上升沿和下降沿.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span>@(a <span class="keyword">or</span> b);</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst);</span><br></pre></td></tr></table></figure>
<h4 id="例子">例子</h4>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> initial_tb1;</span><br><span class="line">    <span class="keyword">reg</span> A,B,C;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        A=<span class="number">0</span>;B=<span class="number">1</span>;C=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> A=<span class="number">1</span>;B=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> A=<span class="number">0</span>;C=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> B=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> B=<span class="number">0</span>;C=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//initial语句代码例1，可以用modelsim仿真</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> initial_tb2;</span><br><span class="line">    <span class="keyword">reg</span> S1;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        S1=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">100</span> S1=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span> S1=<span class="number">0</span>;</span><br><span class="line">        #<span class="number">50</span>  S1=<span class="number">1</span>;</span><br><span class="line">        #<span class="number">100</span> <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//initial语句代码例2，可以用modelsim仿真</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4_1 (out,in0,in1,in2,in3,sel);</span><br><span class="line">    <span class="keyword">input</span>           in0,in1,in2,in3;</span><br><span class="line">    <span class="keyword">input</span>   [<span class="number">1</span>:<span class="number">0</span>]   sel;</span><br><span class="line">    <span class="keyword">output</span>          out;</span><br><span class="line">    <span class="keyword">reg</span>             out;</span><br><span class="line">        <span class="keyword">always</span> @(in0 <span class="keyword">or</span> in1 <span class="keyword">or</span> in2 <span class="keyword">or</span> in3 <span class="keyword">or</span> sel)<span class="comment">//只要括号里面的信号发生改变，就会执行下面的语句块</span></span><br><span class="line">            <span class="keyword">case</span> (sel)</span><br><span class="line">                <span class="number">2&#x27;b00</span>: out=in0;</span><br><span class="line">                <span class="number">2&#x27;b01</span>: out=in1;</span><br><span class="line">                <span class="number">2&#x27;b10</span>: out=in2;</span><br><span class="line">                <span class="number">2&#x27;b11</span>: out=in3;</span><br><span class="line">                <span class="keyword">default</span>:  out=<span class="number">2&#x27;bx</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现4选1数据选择器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter1 (out,data,load,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]    data;</span><br><span class="line">    <span class="keyword">input</span>           load,clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (!rst)       out=<span class="number">8&#x27;h00</span>;<span class="comment">//注意这是同步清零，因为只有在clk上升时，rst信号才有效</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(load)   out=data;</span><br><span class="line">            <span class="keyword">else</span>            out=out+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现同步置数，同步清零计数器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter2 (rst,clk,out);</span><br><span class="line">    <span class="keyword">input</span>           clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)<span class="comment">//这是异步清零</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(!rst)    out=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>        out=out+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//always语句实现异步清零计数器,异步清零的触发信号rst放在always@的括号里面,这样,只要rst发生变化,就会发生清零.</span></span><br></pre></td></tr></table></figure>
<h3 id="语句块">语句块</h3>
<p>在过程语句中, 如果语句数<strong>超过一条</strong>时, 就要采用语句块.
用<code>begin-end</code>和<code>fork-join</code>将一组行为打包起来.</p>
<h4 id="串行语句块和并行语句块">串行语句块和并行语句块</h4>
<p>串行语句块的关键字是<code>begin</code>和<code>end</code>,
其中的语句按照串行方式顺序执行, 既可以用于可综合电路,
也可以用于仿真测试程序.</p>
<p>串行语句块的特点是:</p>
<ol type="1">
<li>串行语句块中的每条指令语句依据块中的排列顺序<strong>依次逐条执行</strong>.
每条语句的延迟时间都是相对于前一条语句执行结束的时间.</li>
<li>串行语句块的起始时间就是第一条语句开始执行的时间,
结束时间就是最后一条语句执行结束的时间.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb1;</span><br><span class="line">    <span class="keyword">reg</span> wave;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">           wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">        #T wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">        #T wave=<span class="number">0</span>;</span><br><span class="line">        #T wave=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用begin和end串行语句块生成一个波形</span></span><br></pre></td></tr></table></figure>
<p>并行语句块的关键字是<code>fork</code>和<code>join</code>,
其中的语句并行执行, 只能用于仿真测试程序, 不能用于可综合电路程序.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb2;</span><br><span class="line">    <span class="keyword">reg</span> wave;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">               wave=<span class="number">0</span>;</span><br><span class="line">        #T     wave=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(2*T)</span> wave=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(3*T)</span> wave=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(4*T)</span> wave=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(5*T)</span> wave=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用fork和join并行语句块生成一个波形，这个波形和上面是一样的</span></span><br></pre></td></tr></table></figure>
<h3 id="过程赋值语句">过程赋值语句</h3>
<p>过程块中的赋值语句就是过程赋值语句,
过程性赋值是指在<code>initial</code>和<code>always</code>语句内的赋值,
即只能对<code>reg</code>类型的变量赋值.</p>
<p>对于多个位宽的<code>reg</code>类型变量,
还可以对其中的一位或者几位进行赋值. 对于存储器类型的,
则只能通过选定的地址单元, 对某个字进行赋值.
还可以将前面各类变量拼接起来进行赋值.</p>
<h4 id="阻塞和非阻塞赋值语句">阻塞和非阻塞赋值语句</h4>
<p>过程赋值语句包括阻塞和非阻塞赋值语句两种,
这两种赋值语句只针对串行语句块而言.</p>
<h5 id="阻塞赋值语句">阻塞赋值语句</h5>
<p>阻塞赋值语句用<code>=</code>进行赋值, 有如下特点:</p>
<ol type="1">
<li>一个语句块中有多条阻塞赋值语句时, 如果前面的赋值语句没有完成,
则后面的语句就不能执行;</li>
<li>在串行语句块(<code>begin-end</code>)中,
各条阻塞语句将按照排列顺序依次执行;
在并行语句块(<code>fork-join</code>)中, 各条阻塞语句同时执行;</li>
<li>对于一条阻塞赋值语句, 先计算等号右边的值,
然后立即赋给左边的变量.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> block1 (din,clk,out1,out2);</span><br><span class="line">    <span class="keyword">input</span>   din,clk;</span><br><span class="line">    <span class="keyword">output</span>  out1,out2;</span><br><span class="line">    <span class="keyword">reg</span>     out1,out2;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out1=din;</span><br><span class="line">        out2=out1;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阻塞赋值语句，din的值先传给out1，然后out1的值再传给out2，最终结果是out2=out1=din</span></span><br></pre></td></tr></table></figure>
<h5 id="非阻塞赋值语句">非阻塞赋值语句</h5>
<p>非阻塞赋值语句用<code>&lt;=</code>进行赋值, 有如下特点:</p>
<ol type="1">
<li>一个语句块中有多条非阻塞赋值语句时,
后面语句的执行不会受到前面语句的限制;</li>
<li>在串行语句块(<code>begin-end</code>)中,
各条非阻塞语句的执行没有先后之分, 各条语句并行执行;</li>
<li>对于一条非阻塞赋值语句, 先计算等号右边的值, 然后等待延迟时间结束,
再赋给左边的变量.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> non_block1 (din,clk,out1,out2);</span><br><span class="line">    <span class="keyword">input</span>   din,clk;</span><br><span class="line">    <span class="keyword">output</span>  out1,out2;</span><br><span class="line">    <span class="keyword">reg</span>  out1,out2;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out1&lt;=din;</span><br><span class="line">        out2&lt;=out1;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//非阻塞赋值语句，在同一时刻，din的值传给out1，out1的值传给out2，最终结果是out2=原来的out1，out1=din</span></span><br></pre></td></tr></table></figure>
<h3 id="过程连续赋值语句">过程连续赋值语句</h3>
<p>前面已经讲过, 连续赋值(<code>assign</code>,
显式和隐式)只能对<code>wire</code>型变量赋值,
而过程语句(<code>initial</code>, <code>always</code>,
阻塞和非阻塞)只能对<code>reg</code>型变量赋值.
而过程连续赋值语句则可以在<code>initial</code>和<code>always</code>语句块中对<code>wire</code>和<code>reg</code>类型变量进行赋值.</p>
<p>过程连续赋值语句也有两种:</p>
<ol type="1">
<li>赋值语句和重新赋值语句(<code>assign</code>,
<code>deassign</code>);</li>
<li>强制, 释放语句(<code>force</code>, <code>release</code>).</li>
</ol>
<p>注意过程连续赋值语句不能对<code>reg</code>型变量进行位操作.</p>
<h4 id="赋值语句和重新赋值语句">赋值语句和重新赋值语句</h4>
<p>格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> &lt;<span class="keyword">reg</span>型变量&gt;=&lt;赋值表达式&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deassign</span> &lt;<span class="keyword">reg</span>型变量&gt;;</span><br></pre></td></tr></table></figure>
<p>赋值语句<code>assign</code>此时对<code>reg</code>型变量赋值,
此后该<code>reg</code>型变量一直保持被赋的值,
直到遇到<code>deassgin</code>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> assign_dff(d,clr,clk,q);</span><br><span class="line">    <span class="keyword">input</span>  d,clr,clk;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q;</span><br><span class="line">    <span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!clr) <span class="keyword">assign</span> q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>     <span class="keyword">deassign</span> q;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">negedge</span> clk) q=d;</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">/*当clr=0时，reg型变量q通过赋值语句被赋值为0，这时无论clk怎么变化，q始终等于0；</span></span><br><span class="line"><span class="comment">当clr=1时，q的强制赋值为0被解除，所以可以随着clk的变化将d赋给q*/</span></span><br></pre></td></tr></table></figure>
<h4 id="强制和释放语句">强制和释放语句</h4>
<p>格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">force</span> &lt;<span class="keyword">wire</span>型或<span class="keyword">reg</span>型变量&gt;=&lt;赋值表达式&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">release</span> &lt;<span class="keyword">wire</span>型或<span class="keyword">reg</span>型变量&gt;;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>force</code>的优先级高于<code>assign</code>;</li>
<li>当<code>force</code>对<code>reg</code>型变量进行赋值时,
<code>reg</code>型变量的当前值被<code>force</code>赋给它的值覆盖,
且不再改变, 直到遇到<code>release</code>.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> force_release (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>  a,b;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    <span class="keyword">and</span>(out,a,b);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">force</span> out=a|b;</span><br><span class="line">        #<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">release</span> out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//注意，在测试的0时刻，and和initial同时生效，但是force语句强制使out=a|b,5个时间单位之后，out被释放，此时and起作用，out=a&amp;b。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> release_tb;</span><br><span class="line">    <span class="keyword">reg</span> a,b;</span><br><span class="line">    <span class="keyword">wire</span> out;</span><br><span class="line">    force_release U1(a,b,out);</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="条件分支语句">条件分支语句</h3>
<p>条件分支语句包括<code>if</code>, <code>case</code>语句</p>
<h4 id="if">if</h4>
<p><code>if</code>语句的格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式<span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span>(条件表达式) 语句块;</span><br><span class="line"></span><br><span class="line">格式<span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span>(条件表达式) 语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>          语句块<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">格式<span class="number">3</span>:</span><br><span class="line"><span class="keyword">if</span>      (条件表达式<span class="number">1</span>)  语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>)  语句块<span class="number">2</span>;</span><br><span class="line">    ...;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n)  语句块n;</span><br><span class="line"><span class="keyword">else</span>                  语句块n+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>只有当<code>if</code>后面的条件表达式为1时才执行后面的语句块.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2_1 (a,b,sel,out);</span><br><span class="line">    <span class="keyword">input</span>   a,b,sel;</span><br><span class="line">    <span class="keyword">output</span>  out;</span><br><span class="line">    <span class="keyword">reg</span>     out;</span><br><span class="line">    <span class="keyword">always</span> @(a,b,sel) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(sel) out=a;</span><br><span class="line">        <span class="keyword">else</span>    out=b;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是二选一数据选择器，当sel=1时，输出a；当sel=0时，输出b</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> compare_a_b (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>           a,b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">1</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(a,b) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)       out=<span class="number">2&#x27;b01</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==b) out=<span class="number">2&#x27;b10</span>;</span><br><span class="line">        <span class="keyword">else</span>          out=<span class="number">2&#x27;b11</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是数字比较器</span></span><br></pre></td></tr></table></figure>
<h4 id="case">case</h4>
<p>case语句的格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(控制表达式)</span><br><span class="line">      值<span class="number">1</span>:     语句块<span class="number">1</span>;</span><br><span class="line">      值<span class="number">2</span>:     语句块<span class="number">2</span>;</span><br><span class="line">      ...;</span><br><span class="line">      值n:     语句块n;</span><br><span class="line">      <span class="keyword">default</span>: 语句块n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>原理：当<code>case</code>后面括号里的<code>控制表达式</code>的值和<code>值i(i=1~n)</code>相等时,
就执行对应<code>语句块i</code>.
如果控制表达式的值和<code>值i(i=1~n)</code>都不相等时,
就执行<code>default</code>里面的<code>语句块n+1</code>. 注意,
当用<code>case</code>语句对控制表达式和其后的值进行比较时,
必须是一种全等的比较. 真值表如下:</p>
<table>
<thead>
<tr>
<th><code>case</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> BCD_decoder(in,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>]    in;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">6</span>:<span class="number">0</span>]    out;</span><br><span class="line">    <span class="keyword">always</span> @(in) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(in)</span><br><span class="line">        <span class="number">4&#x27;b0000</span>:out=<span class="number">7&#x27;b1111110</span>;</span><br><span class="line">        <span class="number">4&#x27;b0001</span>:out=<span class="number">7&#x27;b0110000</span>;</span><br><span class="line">        <span class="number">4&#x27;b0010</span>:out=<span class="number">7&#x27;b1101101</span>;</span><br><span class="line">        <span class="number">4&#x27;b0011</span>:out=<span class="number">7&#x27;b1111001</span>;</span><br><span class="line">        <span class="number">4&#x27;b0100</span>:out=<span class="number">7&#x27;b0110011</span>;</span><br><span class="line">        <span class="number">4&#x27;b0101</span>:out=<span class="number">7&#x27;b1011011</span>;</span><br><span class="line">        <span class="number">4&#x27;b0110</span>:out=<span class="number">7&#x27;b1011111</span>;</span><br><span class="line">        <span class="number">4&#x27;b0111</span>:out=<span class="number">7&#x27;b1110000</span>;</span><br><span class="line">        <span class="number">4&#x27;b1000</span>:out=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">        <span class="number">4&#x27;b1001</span>:out=<span class="number">7&#x27;b1111011</span>;   </span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是一个BCD数码管译码，见教材P51</span></span><br></pre></td></tr></table></figure>
<p>除了<code>case</code>外, 还有<code>casez</code>, <code>casex</code>,
真值表如下:</p>
<table>
<thead>
<tr>
<th><code>casez</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>casex</code></th>
<th>0</th>
<th>1</th>
<th>x</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>x</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>z</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="循环语句">循环语句</h3>
<p>循环语句包括<code>forever</code>, <code>repeat</code>,
<code>while</code>, <code>for</code>语句</p>
<h4 id="forever">forever</h4>
<p><code>forever</code>的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forever</span> 语句块;</span><br></pre></td></tr></table></figure>
<p><code>forever</code>不能单独出现在程序中,
必须放在<code>initial</code>语句块里面,
这样<code>forever</code>就可以从0时刻开始无限循环执行其后面的语句块下去,
除非遇到<code>$finish</code>.</p>
<p>如果需要从<code>finish</code>中退出,
则需要使用<code>disable</code>语句.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> forever_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">50</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用forever生成时钟信号，每50个时间单位翻转一次，即100个时间单位为一个周期</span></span><br></pre></td></tr></table></figure>
<h4 id="repeat">repeat</h4>
<p><code>repeat</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span>&lt;循环次数表达式&gt;</span><br><span class="line">  语句块;</span><br></pre></td></tr></table></figure>
<p>循环次数表达式可以是一个常数, 一个变量, 或者是一个信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> repeat_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">8</span>) </span><br><span class="line">          #<span class="number">25</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用repeat生成时钟信号</span></span><br></pre></td></tr></table></figure>
<h4 id="while">while</h4>
<p><code>while</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式) 语句块;</span><br></pre></td></tr></table></figure>
<p>在每一次执行<code>while</code>循环体之前,
都需要先判断条件表达式是否等于1, 如果是1, 就执行后面的语句块; 如果不是1,
就不执行.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> while_tb;</span><br><span class="line">    <span class="keyword">reg</span> clock;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clock=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        #<span class="number">50</span> clock=~clock;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用while生成时钟信号</span></span><br></pre></td></tr></table></figure>
<h4 id="for">for</h4>
<p><code>for</code>的格式为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量初值:循环条件:循环变量增值) 语句块;</span><br></pre></td></tr></table></figure>
<p>先给循环变量赋初值, 然后判断循环条件是否为1, 若为1则执行语句块,
随后变量自增, 继续判断循环条件是否为1, 直至当循环条件为0.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> for_clk;</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">integer</span> i;      <span class="comment">//整型变量就是这么用的，就是用来给for循环计数</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i=i+<span class="number">1</span>)</span><br><span class="line">        #<span class="number">50</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用for生成时钟信号，注意这里循环条件一直是1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_register1 (Q,D,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>        D,rst,clk;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst) Q&lt;=<span class="number">8&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">else</span>      Q&lt;=&#123;Q[<span class="number">6</span>:<span class="number">0</span>],D&#125;;<span class="comment">//把后七位向前移动一位，空出来的一位留给D</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用if语句实现8位移位寄存器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_register2 (Q,D,rst,clk);</span><br><span class="line">    <span class="keyword">input</span>        D,rst,clk;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Q;</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst) Q&lt;=<span class="number">8&#x27;b000000</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">7</span>;i&gt;<span class="number">0</span>;i=i-<span class="number">1</span>) Q[i]&lt;=Q[i-<span class="number">1</span>];<span class="comment">//把后七位向前移动一位，最后一位留给D</span></span><br><span class="line">            Q[<span class="number">0</span>]&lt;=D;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//用for循环实现8位移位寄存器</span></span><br></pre></td></tr></table></figure>
<h2 id="结构化建模">结构化建模</h2>
<p>结构化建模包括</p>
<ol type="1">
<li>模块级建模: 调用用户之前设计的<code>module</code>;</li>
<li>门级建模: 调用Verilog HDL内部的基本门级原件;</li>
<li>开关级建模: 调用Verilog HDL内部的基本开关级原件.</li>
</ol>
<h3 id="模块级建模">模块级建模</h3>
<h4 id="模块调用">模块调用</h4>
<p>模块调用的基本方式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名&lt;参数值列表&gt; 实例名(端口名列表);</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>“模块名”是用户已经写好的<code>module</code>的名字;
“参数值列表”基本没用过;</li>
<li>“实例名”是<code>module</code>被调用到当前程序的标志,
一般命名为<code>U1, U2, ...</code>等;</li>
<li>“端口名列表”是被调用模块的端口对应, 后面会细说.</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and_2 (a,b,c);</span><br><span class="line">    <span class="keyword">input</span>  a,b;</span><br><span class="line">    <span class="keyword">output</span> c;</span><br><span class="line">    <span class="keyword">assign</span> c=a&amp;b;  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这里先定义一个二输入与门的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="keyword">logic</span> (in1,in2,q);</span><br><span class="line">    <span class="keyword">input</span>  in1,in2;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    and_2 U1(in1,in2,q);<span class="comment">//这是模块实例语句，U1是实例名，调用了上面写的二输入与门，其中in1，in2分别对应输入a，b；q对应输出c</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//简单模块调用</span></span><br></pre></td></tr></table></figure>
<h4 id="阵列调用">阵列调用</h4>
<p>阵列调用格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名[阵列左边界,阵列右边界](端口名列表)</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND (andout,ina,inb);</span><br><span class="line">    <span class="keyword">input</span>  ina,inb;</span><br><span class="line">    <span class="keyword">output</span> andout;</span><br><span class="line">    <span class="keyword">assign</span> andout=ina&amp;inb;  </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是一个二输入与门的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ex_arrey (a,b,out);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>]a,b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>]out;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>]out;  </span><br><span class="line">    AND AND_ARREY[<span class="number">15</span>:<span class="number">0</span>](out,a,b);<span class="comment">//该语句对模块AND进行阵列调用，[15:0]表明调用了16次</span></span><br><span class="line">    <span class="comment">/*这个代码相当于</span></span><br><span class="line"><span class="comment">    AND AND_ARREY15(out[15],a[15],b[15]);</span></span><br><span class="line"><span class="comment">    AND AND_ARREY14(out[14],a[14],b[14]);</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    AND AND_ARREY1(out[1],a[1],b[1]);</span></span><br><span class="line"><span class="comment">    AND AND_ARREY0(out[0],a[0],b[0]);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阵列调用</span></span><br></pre></td></tr></table></figure>
<h4 id="模块端口对应方式">模块端口对应方式</h4>
<p><strong>端口位置对应方式</strong>的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名(&lt;信号名<span class="number">1</span>&gt;,&lt;信号名<span class="number">2</span>&gt;,...,&lt;信号名n&gt;);</span><br></pre></td></tr></table></figure>
<p>注意这种对应方式需要把括号里面信号的顺序和用户定义的<code>module</code>的端口顺序依次对应.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> halfadder (a,b,s,c);</span><br><span class="line">    <span class="keyword">input</span> a,b;</span><br><span class="line">    <span class="keyword">output</span> s,c;</span><br><span class="line">    <span class="keyword">assign</span> s=a^b;<span class="comment">//异或，s是本位 </span></span><br><span class="line">    <span class="keyword">assign</span> c=a&amp;b;<span class="comment">//c是进位</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fulladder (p,q,ci,co,sum);</span><br><span class="line">    <span class="keyword">input</span> p,q,ci;</span><br><span class="line">    <span class="keyword">output</span> co,sum;</span><br><span class="line">    <span class="keyword">wire</span> w1,w2,w3;</span><br><span class="line">    halfadder U1(p,q,w1,w2);</span><br><span class="line">    halfadder U2(ci,w1,sum,w3);</span><br><span class="line">    <span class="keyword">or</span> U3(co,w2,w3); </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//全加器模块，见教材P58</span></span><br></pre></td></tr></table></figure>
<p><strong>端口名对应</strong>方式(更常用)的格式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名 实例名(.端口名<span class="number">1</span>&lt;信号名<span class="number">1</span>&gt;,.端口名<span class="number">2</span>&lt;信号名<span class="number">2</span>&gt;,.端口名<span class="number">3</span>&lt;信号名<span class="number">3</span>&gt;,.端口名<span class="number">4</span>&lt;信号名<span class="number">4</span>&gt;)</span><br></pre></td></tr></table></figure>
<p>这种方式将端口的对应方式直观地呈现出来, 排列顺序可以随意</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Dff(d,clk,clr,q);</span><br><span class="line">    <span class="keyword">input</span> d,clk,clr;</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">reg</span> q;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> clr) <span class="keyword">begin</span><span class="comment">//敏感条件：clk上升沿，clr下降沿</span></span><br><span class="line">        <span class="keyword">if</span> (!clr) q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>      q=d;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//D触发器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shifter_D (din,clock,clear,out);</span><br><span class="line">    <span class="keyword">input</span>  din,clock,clear;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]out;</span><br><span class="line">    Dff U1(<span class="variable">.q</span>(out[<span class="number">0</span>]),<span class="variable">.d</span>(din),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U2(<span class="variable">.q</span>(out[<span class="number">1</span>]),<span class="variable">.d</span>(out[<span class="number">0</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U3(<span class="variable">.q</span>(out[<span class="number">2</span>]),<span class="variable">.d</span>(out[<span class="number">1</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    Dff U4(<span class="variable">.q</span>(out[<span class="number">3</span>]),<span class="variable">.d</span>(out[<span class="number">2</span>]),<span class="variable">.clk</span>(clock),<span class="variable">.clr</span>(clear));</span><br><span class="line">    <span class="comment">/*当clock上升沿到来时，U1~U4执行，把din的值赋给out[0]，把out[0]的值赋给out[1]，把out[1]的值赋给out[2],把out[2]的值赋给out[3],这几条同时执行;</span></span><br><span class="line"><span class="comment">    当clear下降沿到来时，out[0]~out[3]全部清零*/</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//利用D触发器构成四位移位寄存器</span></span><br></pre></td></tr></table></figure>
<h3 id="门级建模">门级建模</h3>
<h4 id="verilog-hdl基本门级元件类型">Verilog HDL基本门级元件类型</h4>
<p>Verilog HDL内置26个基本元件, 其中14个是门级原件, 12个为开关级元件,
见下表</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>元件</th>
</tr>
</thead>
<tbody>
<tr>
<td>多输入门(基本门), 第一个端口是输出端口, 后面的全是输入端口</td>
<td><code>and, nand, or, nor, xor, xnor</code></td>
</tr>
<tr>
<td>多输出门(基本门), 最后一个端口是输入端口, 前面的全是输出端口</td>
<td><code>buf, not</code></td>
</tr>
<tr>
<td>允许定义驱动强度(三态门)</td>
<td><code>bufif0, bufif1, notif0, notif1</code></td>
</tr>
<tr>
<td>无驱动强度(MOS开关)</td>
<td><code>nmos, pmos, cmos, rnmos, rpmos, rcmos</code></td>
</tr>
<tr>
<td>无驱动强度(双向开关)</td>
<td><code>tran, tranif0, tranif1, rtran, rtranif0, rtranif1</code></td>
</tr>
<tr>
<td>允许定义驱动强度(上拉,下拉电阻)</td>
<td><code>pullup, pulldown</code></td>
</tr>
</tbody>
</table>
<h4 id="门级模块调用">门级模块调用</h4>
<p><strong>多输入门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;输出端口&gt;,&lt;输入端口<span class="number">1</span>&gt;,&lt;输入端口<span class="number">2</span>&gt;,...,&lt;输入端口n&gt;);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> A1(out1,in1,in2,in3);</span><br><span class="line"><span class="keyword">or</span> O2(a,b,c,d);</span><br><span class="line"><span class="keyword">xor</span> X1(x_out,p1,p2);</span><br></pre></td></tr></table></figure>
<p><strong>多输出门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;输出端口<span class="number">1</span>&gt;,&lt;输出端口<span class="number">2</span>&gt;,...,&lt;输出端口n&gt;,&lt;输入端口&gt;);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> NOT_1(out1,out2,in);</span><br><span class="line"><span class="keyword">buf</span> BUF_1(bufout1,bufout2,bufout3,bufin);</span><br></pre></td></tr></table></figure>
<p><strong>三态门</strong>调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元件名&lt;实例名&gt;(&lt;数据输出端口&gt;, &lt;数据输入端口&gt;, &lt;控制输入端口&gt;);</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bufif1</span> BF1(data_bus, mem_data, enable);</span><br><span class="line"><span class="keyword">bufif0</span> BF0(a, b, c);</span><br><span class="line"><span class="keyword">notif1</span> NT1(out, in, ctrl);</span><br><span class="line"><span class="keyword">notif1</span> NT0(addr, a_bus, select);</span><br></pre></td></tr></table></figure>
<p>例: 调用门级元件实现2线-4线译码器</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decoder2_4(in0, in1, en, out0, out1, out2, out3);</span><br><span class="line">    <span class="keyword">input</span>  in0, in1, en;</span><br><span class="line">    <span class="keyword">output</span> out0, out1, out2, out3;</span><br><span class="line">    <span class="keyword">wire</span>   wire1, wire2;<span class="comment">//中间变量定义成wire类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span>  U1(wire1, in0);</span><br><span class="line">         U2(wire2, in1);<span class="comment">//非门, 输出为wire, 输入为in</span></span><br><span class="line">    <span class="keyword">nand</span> U3(out0, en, wire1, wire2);</span><br><span class="line">         U4(out1, en, wire1, in1);</span><br><span class="line">         U5(out2, en, in0, wire2);</span><br><span class="line">         U6(out3, en, in0, in1);<span class="comment">//三输入与非门, 输出为out, 输入为wire, in</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="开关级建模">开关级建模</h3>
<p>开关级建模指的是用输入, 输出为模拟信号的晶体管搭建硬件模型. Verilog
HDL提供了开关级建模方式, 主要用于ASIC设计. 在开关级建模方式下,
硬件结构采用开关级描述方式, 而晶体管的输入输出均被限定为数字信号.
此时晶体管表现为通断形式的开关. 由于Verilog HDL采用四值逻辑系统,
因此Verilog HDL描述的开关的输入输出可以是<code>0, 1, z, x</code>.</p>
<p>Verilog HDL提供了十几种开关级基本元件, 它们是实际MOS管的抽象表示.
这些开关级的基本元件分成两大类: 一类是MOS开关, 一类是双向开关.
每一大类又可以电阻型(前缀是r)和非电阻型. 见下表</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>关键字</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nmos</code></td>
<td>当控制信号为高时, 开关导通, 否则关闭</td>
</tr>
<tr>
<td><code>pmos</code></td>
<td>当控制信号为低时, 开关导通, 否则关闭</td>
</tr>
<tr>
<td><code>cmos</code></td>
<td>nmos控制信号和pmos控制信号互补, 当nmos控制信号为高时, 开关导通,
否则关闭</td>
</tr>
<tr>
<td><code>tran</code></td>
<td>两端可以互相驱动, 且随时保持一致</td>
</tr>
<tr>
<td><code>tranif0</code></td>
<td>当控制端为低时, 两端才能相互驱动</td>
</tr>
<tr>
<td><code>tranif1</code></td>
<td>当控制端为高时, 两端才能相互驱动</td>
</tr>
</tbody>
</table>
<p>MOS开关模拟了实际MOS器件的功能,
包括<code>nmos, pmos, cmos</code>三种</p>
<p>MOS开关调用格式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nmos</span>/<span class="keyword">pmos</span> 实例名(out,data,control);</span><br><span class="line"><span class="keyword">cmos</span> 实例名(out,data,ncontrol,pcontrol);<span class="comment">//这里的control信号控制data信号传送到out端</span></span><br></pre></td></tr></table></figure>
<p>双向开关的每个脚都被声明为<code>inout</code>类型,
可以作为输入来驱动另一脚, 也可以作为输出被另一脚驱动.</p>
<p>双向开关包括无条件双向开关<code>tran</code>和有条件双向开关<code>tranif0, tranif1</code>,
调用格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tran</span> 实例名 (inout1, inout2);</span><br><span class="line"><span class="keyword">tranif0</span>/<span class="keyword">tranif1</span> 实例名 (inout1 ,inout2, control);</span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NMOS (din,out,ctr);</span><br><span class="line">    <span class="keyword">input</span>  din,ctr;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">nmos</span> U1(out,din,ctr);</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这是最基本的nmos开关，当ctr为高电平时，输入din传到out；当ctr为低电平时，输入输出断开</span></span><br></pre></td></tr></table></figure>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>用连续赋值语句描述一个4选1数据选择器</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述：通过连续赋值语句（assign）实现组合逻辑，根据选择信号sel从4个输入中选出一个作为输出</span></span><br><span class="line"><span class="keyword">module</span> mux4to1_assign(din, sel, out);</span><br><span class="line">    <span class="comment">// 输入端口声明</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] din;   <span class="comment">// 4位宽数据输入，din[0]、din[1]、din[2]、din[3]分别对应四个数据通道</span></span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel;   <span class="comment">// 2位宽选择信号，sel[1]为高位，sel[0]为低位，共4种组合对应4个输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出端口声明</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out;   <span class="comment">// 单比特输出，根据选择信号输出对应的输入数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连续赋值语句：描述组合逻辑，当输入变化时输出立即更新</span></span><br><span class="line">    <span class="comment">// 逻辑表达式对应真值表：</span></span><br><span class="line">    <span class="comment">// sel[1] sel[0] | out</span></span><br><span class="line">    <span class="comment">//   0      0    | din[0]</span></span><br><span class="line">    <span class="comment">//   0      1    | din[1]</span></span><br><span class="line">    <span class="comment">//   1      0    | din[2]</span></span><br><span class="line">    <span class="comment">//   1      1    | din[3]</span></span><br><span class="line">    <span class="keyword">assign</span> out = (din[<span class="number">0</span>] &amp; ~sel[<span class="number">1</span>] &amp; ~sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b00时，选择din[0]</span></span><br><span class="line">                (din[<span class="number">1</span>] &amp; ~sel[<span class="number">1</span>] &amp;  sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b01时，选择din[1]</span></span><br><span class="line">                (din[<span class="number">2</span>] &amp;  sel[<span class="number">1</span>] &amp; ~sel[<span class="number">0</span>]) |  <span class="comment">// 当sel=2&#x27;b10时，选择din[2]</span></span><br><span class="line">                (din[<span class="number">3</span>] &amp;  sel[<span class="number">1</span>] &amp;  sel[<span class="number">0</span>]);   <span class="comment">// 当sel=2&#x27;b11时，选择din[3]</span></span><br><span class="line">    <span class="comment">// 注意：表达式中的 &amp; 表示按位与，| 表示按位或，~ 表示按位非</span></span><br><span class="line">    <span class="comment">// 由于是单比特操作，实际执行逻辑与、或、非运算</span></span><br><span class="line">    <span class="comment">// 每个条件项由三部分相与：数据位 + 选择信号的译码条件</span></span><br><span class="line">    <span class="comment">// 最后所有项相或，实现4选1功能</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>简述<code>begin-end</code>语句块和’fork-join’语句块的区别,并写出下面信号对应的程序代码.</p>
<p>串行语句块的关键字是<code>begin</code>和<code>end</code>,其中的语句按照串行方式顺序执行,既可以用于可综合电路,也可以用于仿真测试程序.并行语句块的关键字是<code>fork</code>和<code>join</code>,其中的语句并行执行,只能用于仿真测试程序,不能用于可综合电路程序.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> wave_tb1;</span><br><span class="line">    <span class="keyword">reg</span> A, B;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">0</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T  A=<span class="number">0</span>; B=<span class="number">0</span>;</span><br><span class="line">        #T  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> wave_tb2;</span><br><span class="line">    <span class="keyword">reg</span> A, B;</span><br><span class="line">    <span class="keyword">parameter</span> T=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">fork</span></span><br><span class="line">                A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        #T      A=<span class="number">1</span>; B=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(2*T)</span>  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(3*T)</span>  A=<span class="number">0</span>; B=<span class="number">1</span>;</span><br><span class="line">        <span class="variable">#(4*T)</span>  A=<span class="number">0</span>; B=<span class="number">0</span>;</span><br><span class="line">        <span class="variable">#(5*T)</span>  A=<span class="number">1</span>; B=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>分别用阻塞赋值语句和非阻塞赋值语句描述的4bit移位寄存器电路.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shift_4bit(clk, din, out);</span><br><span class="line">    <span class="keyword">input</span>            clk;</span><br><span class="line">    <span class="keyword">input</span>            din;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out[<span class="number">3</span>] = out[<span class="number">2</span>]; <span class="comment">//先将第二位传到第三位</span></span><br><span class="line">        out[<span class="number">2</span>] = out[<span class="number">1</span>]; <span class="comment">//再将第一位传到第二位</span></span><br><span class="line">        out[<span class="number">1</span>] = out[<span class="number">0</span>]; <span class="comment">//然后将第零位传到第一位</span></span><br><span class="line">        out[<span class="number">0</span>] = din;    <span class="comment">//最后将输入传到第零位</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//阻塞赋值语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shift_4bit(clk, din, out);</span><br><span class="line">    <span class="keyword">input</span>            clk;</span><br><span class="line">    <span class="keyword">input</span>            din;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        out &lt;= &#123;out[<span class="number">2</span>:<span class="number">0</span>], din&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//非阻塞赋值语句</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>分析以下Verilog HDL所描述的电路</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> program_if(a, b, c, d, sel, z);</span><br><span class="line">    <span class="keyword">input</span>        a,b,c,d;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] sel;</span><br><span class="line">    <span class="keyword">output</span>       z;</span><br><span class="line">    <span class="keyword">reg</span>          z;</span><br><span class="line">    <span class="keyword">always</span>@(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>       (sel[<span class="number">3</span>])     z=d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">2</span>])     z=c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">1</span>])     z=b;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>  (sel[<span class="number">0</span>])     z=a;</span><br><span class="line">            <span class="keyword">else</span>                  z=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这是一个带优先级的4选1多路选择器, <code>sel[3]</code> 是最高优先级,
<code>sel[2]</code>是次高优先级, <code>sel[1]</code>是第三优先级,
<code>sel[0]</code>
是最低优先级.当所有<code>sel</code>位为0时，输出默认值0.</p></li>
<li><p>根据下面的Verilog HDL程序, 画出电路图, 并且说明其功能</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> circuit(a, b, c);</span><br><span class="line">    <span class="keyword">input</span>  a, b;</span><br><span class="line">    <span class="keyword">output</span> c;</span><br><span class="line">    <span class="keyword">wire</span>   a1, a2, anot, bnot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">and</span> U1(a1, a, b);</span><br><span class="line">    <span class="keyword">and</span> U2(a2, anot, bnot);</span><br><span class="line">    <span class="keyword">not</span> (anot, a);</span><br><span class="line">    <span class="keyword">not</span> (bnot, b);</span><br><span class="line">    <span class="keyword">or</span>  (c, a1, a2);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这是一个异或非门XNOR电路, 当输入a和b相同时(同为0或同为1), 输出c=1;
当输入a和b不同时, 输出c=0.</p></li>
<li><p>用门级描述方式描述电路,
要求:输入为<code>D0, D1, D2, D3, S1, S2</code>,
四个<code>wire T0, T1, T2, T3</code>, 一个输出<code>Z</code>,
关系如下:</p>
<p><span class="math display">\[\begin{aligned}
     &amp;T0=D0\overline{S2}\overline{S1}\\
     &amp;T1=D1S2\overline{S1}\\
     &amp;T2=D2\overline{S2}S1\\
     &amp;T3=D3S2S1\\
     &amp;Z=T0+T1+T2+T3\\
\end{aligned}\]</span></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux4to1(D0, D1, D2, D3, S1, S2, Z);</span><br><span class="line">    <span class="keyword">input</span>  D0, D1, D2, D3, S1, S2;</span><br><span class="line">    <span class="keyword">output</span> Z;</span><br><span class="line">    <span class="keyword">wire</span>   T0, T1, T2, T3;</span><br><span class="line">    <span class="keyword">wire</span>   S1_not, S2_not;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span> (S1_not, S1);</span><br><span class="line">    <span class="keyword">not</span> (S2_not, S2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">and</span> (T0, D0, S2_not, S1_not);</span><br><span class="line">    <span class="keyword">and</span> (T1, D1, S2, S1_not);</span><br><span class="line">    <span class="keyword">and</span> (T2, D2, S2_not, S1);</span><br><span class="line">    <span class="keyword">and</span> (T3, D3, S2, S1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">or</span> (Z, T0, T1, T2, T3);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/04/Verilog%E7%AC%AC%E4%BA%94%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/femboy.jpg">
      <meta itemprop="name" content="SiyuanLei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | SiyuanLei's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/04/Verilog%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="post-title-link" itemprop="url">第五章:仿真验证和Testbench编写</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-04T00:00:00+08:00">2025-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-15 07:56:37" itemprop="dateModified" datetime="2026-01-15T07:56:37+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/" itemprop="url" rel="index"><span itemprop="name">EE</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">数字设计</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/EE/%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="verilog-hdl电路仿真和验证概述">Verilog
HDL电路仿真和验证概述</h2>
<p>仿真, 也称模拟, 是通过EDA仿真工具, 对所设计的电路或系统输入测试信号,
然后根据输出信号(如波形, 文本或者VCD文件)与期望值进行比较,
来确认是否得到与所期望一致的设计结果, 从而验证设计的正确性.</p>
<p>在设计过程中, 仿真是在综合之前完成的, 这就是通常所说的行为级仿真,
RTL仿真或者前仿真. 在RTL设计阶段只包含了时钟和时序,
并未包含门延时和线延时. 因此RTL仿真对于时钟来说是正确的,
并且不用考虑竞争冒险, 毛刺, 建立和保持时间以及其他一些详细的问题.</p>
<p>验证则是一系列测试平台的集合,
是一个证明设计思路如何实现及保证设计在功能上正确的过程. 验证在Verilog
HDL设计中分为4个阶段:</p>
<ol type="1">
<li>功能验证</li>
<li>综合后验证</li>
<li>时序验证</li>
<li>板级验证</li>
</ol>
<p>前三个验证是在PC平台上依靠EDA工具来完成的,
最后一个阶段则需要在真正的硬件平台(如FPGA, CPLD等)上进行,
需要借助一些调试工具和专业的分析仪来测试.</p>
<p>常用的功能验证有黑盒法, 白盒法, 灰盒法.</p>
<ol type="1">
<li>黑盒法: 把测试代码看成一个黑盒, 不需要考虑内部逻辑结构和特性,
只需要根据程序的需求规格说明书, 检查程序的功能是否符合其功能的说明.</li>
<li>白盒法: 白盒法又称为结构测试或逻辑驱动测试,
它是按照RTL级代码内部结构进行测试,
通过测试来检验RTL级代码内部实现是否按照设计规格说明书的规定正常运行,
检验RTL代码的每条路径是否能按照预定要求正确工作.</li>
<li>灰盒法: 介于黑盒法和白盒法之间的一种测试方法.</li>
</ol>
<h2 id="verilog-hdl测试程序设计基础">Verilog HDL测试程序设计基础</h2>
<h3 id="testbench及其结构">Testbench及其结构</h3>
<p>在Verilog HDL中, 常采用测试平台(Testbench)方式进行仿真和验证. 仿真时,
Testbench用来产生测试激励给待验证设计(Design Under Verification, DUV),
或者称为待测试设计(Design Under Test, DUT),
同时检查DUV/DUT的输出是否与期望一致, 从而达到验证设计功能的目的.</p>
<p>编写Testbench需要注意的问题:</p>
<ol type="1">
<li>Testbench代码不需要可综合性, 不会被实现为电路.</li>
<li>行为级描述效率高. Verilog HDL有5个描述层次, 分别为开关级, 门级,
RTL级, 算法级, 系统级.</li>
<li>结构化, 程式化的描述方式</li>
</ol>
<h3 id="测试平台举例">测试平台举例</h3>
<h4 id="组合逻辑电路仿真环境的搭建">组合逻辑电路仿真环境的搭建</h4>
<p>组合逻辑电路的仿真验证, 主要是检查设计结果是否符合电路真值表的功能,
因此在搭建仿真环境时,
用<code>initial</code>语句把被测试电路的输入按照真值表提供的数据变化作为测试条件.
组合逻辑电路的特点决定了仿真中只需对输入信号进行设计即可, 没有时序,
定时信息和全局复位, 置位等需求.</p>
<p>下面搭建全加器的仿真环境</p>
<table>
<thead>
<tr>
<th style="text-align: center;">a</th>
<th style="text-align: center;">b</th>
<th style="text-align: center;">ci</th>
<th style="text-align: center;">so</th>
<th style="text-align: center;">co</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder1(a,b,ci,so,co);</span><br><span class="line">    <span class="keyword">input</span>   a,b,ci;</span><br><span class="line">    <span class="keyword">output</span>  so,co;</span><br><span class="line">    <span class="keyword">assign</span>  &#123;co,so&#125;=a+b+ci;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> adder1_tb;</span><br><span class="line">    <span class="keyword">wire</span>    so,co;</span><br><span class="line">    <span class="keyword">reg</span>     a,b,ci;</span><br><span class="line">    adder1  U1(a,b,ci,so,so);<span class="comment">//模块实例化</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">0</span>;b=<span class="number">0</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">0</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">1</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">0</span>;b=<span class="number">1</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">0</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">0</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">1</span>;ci=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">20</span> a=<span class="number">1</span>;b=<span class="number">1</span>;ci=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">200</span> <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="时序逻辑电路仿真环境的搭建">时序逻辑电路仿真环境的搭建</h4>
<p>时序逻辑电路仿真环境的搭建要求与组合逻辑电路基本相同,
但是需要考虑时序, 定时信息和全局复位, 置位等信号要求,
并定义这些信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cnt10(clk,rst,ena,q,cnt)</span><br><span class="line">    <span class="keyword">input</span>           clk,rst,ena;</span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">3</span>:<span class="number">0</span>]   q;</span><br><span class="line">    <span class="keyword">output</span>          cnt;</span><br><span class="line">    <span class="keyword">reg</span>     [<span class="number">3</span>:<span class="number">0</span>]   q;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(rst)         q=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ena)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(q&lt;<span class="number">9</span>) q=q+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>    q=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">assign</span>  cnt=q[<span class="number">3</span>]&amp;q[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt10_tb;</span><br><span class="line">    <span class="keyword">reg</span>         clk,rst,ena;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>]  q;</span><br><span class="line">    <span class="keyword">wire</span>        cnt;</span><br><span class="line">    cnt10 U1(clk,rst,ena,q,cnt);</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">50</span>  clk=~clk;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            clk=<span class="number">0</span>;rst=<span class="number">0</span>;ena=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">1200</span>   rst=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">120</span>    rst=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">2000</span>   ena=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">200</span>    ena=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">20000</span>  <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span>   </span><br></pre></td></tr></table></figure>
<h2 id="与仿真相关的系统任务">与仿真相关的系统任务</h2>
<h3 id="display与write">$display与$write</h3>
<p>Verilog HDL有两种主要的标准输出任务: <code>$display</code>和
<code>$write</code>. 这两个系统函数用来输出信息且语法格式相同.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>,&lt;signal1,signal2,...,signaln&gt;);</span><br><span class="line"><span class="built_in">$write</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>,&lt;signal1,signal2,...,signaln&gt;);</span><br></pre></td></tr></table></figure>
<p>其中<code>"&lt;format_specifiers&gt;"</code>称为格式控制,
<code>&lt;signal1,signal2,...,signaln&gt;</code>称为信号控制列表.</p>
<p><code>$display</code>将特定信息输入到标准输出设备,
并且带有行结束字符,
即自动地在输出后进行换行;但是<code>$write</code>输出特点信息时不自动换行,
如果想要在一行中输出多个信息, 可以使用<code>$write</code>.</p>
<p>输出格式说明由<code>%</code>和格式字符组成,
其作用是将输出的数据转换成指定的格式输出,
格式说明总是由<code>%</code>开始, 后面加上一个字母选择特定的输出格式.
见下表</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>输出格式</th>
<th>说明</th>
<th>输出格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%h %H</code></td>
<td>以十六进制数输出</td>
<td><code>%m %M</code></td>
<td>输出等级层次的名字</td>
</tr>
<tr>
<td><code>%d %D</code></td>
<td>以十进制数输出</td>
<td><code>%s %S</code></td>
<td>以字符串的形式输出</td>
</tr>
<tr>
<td><code>%o %O</code></td>
<td>以八进制数输出</td>
<td><code>%t %T</code></td>
<td>以当前的时间格式输出</td>
</tr>
<tr>
<td><code>%b %B</code></td>
<td>以二进制数输出</td>
<td><code>%e %E</code></td>
<td>以指数的形式输出实数型</td>
</tr>
<tr>
<td><code>%c %C</code></td>
<td>以ASCII码字符的形式输出</td>
<td><code>%f %F</code></td>
<td>以十进制数的形式输出实型数</td>
</tr>
<tr>
<td><code>%v %V</code></td>
<td>输出wire型数据信号强度</td>
<td><code>%g %G</code></td>
<td>以指数或十进制数的形式输出实型数</td>
</tr>
</tbody>
</table>
<p>下面是一些特殊的字符</p>
<table>
<thead>
<tr>
<th>换码序列</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>横向跳格, 即调到下一个输出区</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠字符<code>\</code></td>
</tr>
<tr>
<td><code>\"</code></td>
<td>双引号字符<code>"</code></td>
</tr>
<tr>
<td><code>\o</code></td>
<td>1到3位的八进制数代表的字符</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分符号<code>%</code></td>
</tr>
</tbody>
</table>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> disp_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] rval;</span><br><span class="line">    <span class="keyword">pulldown</span>(pd);</span><br><span class="line">        intial</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                rval=<span class="number">101</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;\\\t%%\n\&quot;\123&quot;</span>);     <span class="comment">//八进制数123就是字符S</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval=%h hex %d decimal&quot;</span>, rval, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval=%o otal %b binary&quot;</span>, rval, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;rval has %c ASCII character value&quot;</span>, rval);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;pd strength value is %v&quot;</span>, pd);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;current scope is %m&quot;</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;%s is ASCII value for 101&quot;</span>, <span class="number">101</span>);</span><br><span class="line">                <span class="built_in">$write</span>(<span class="string">&quot;simulation time is&quot;</span>);</span><br><span class="line">                <span class="built_in">$write</span>(<span class="string">&quot;%t\n&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\%</span><br><span class="line"><span class="string">&quot;S</span></span><br><span class="line"><span class="string">rval=00000065 hex 101 decimal</span></span><br><span class="line"><span class="string">rval=00000000145 otal 00000000000000000000000001100101 binary</span></span><br><span class="line"><span class="string">rval has e ASCII character value</span></span><br><span class="line"><span class="string">pd strength value is StX</span></span><br><span class="line"><span class="string">current scope is disp</span></span><br><span class="line"><span class="string">e is ASCII value for 101</span></span><br><span class="line"><span class="string">simulation time is 0</span></span><br></pre></td></tr></table></figure>
<h3 id="monitor与strobe">$monitor与$strobe</h3>
<p><code>$monitor</code>和<code>$strobe</code>都属于信号的输出显示的系统任务,
同时它们也提供了监控和输出参数列表中字符或变量的值的功能.</p>
<p><code>$monitor</code>的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$monitor</span>(<span class="string">&quot;&lt;format_specifiers&gt;&quot;</span>, &lt;signal1, signal2, ..., signaln&gt;);</span><br></pre></td></tr></table></figure>
<p><code>$monitor</code>提供了监控和输出参数列表中的表达式或变量值的功能.
其参数列表中输出控制格式字符串和输出列表的规则与<code>$display</code>一样.
当启动一个带有一个或者多个参数的<code>$monitor</code>任务时,
仿真器则会建立一个处理机制,
使得每当参数列表中变量或者表达式的值<strong>发生变化</strong>时,
<strong>整个</strong>参数列表中变量或表达式的值都会被输出显式.
如果同一时刻多个参数的值发生变化, 那么在该时刻只输出一次.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$monitor</span>(<span class="built_in">$time</span>, , <span class="string">&quot;rxd=%b txd=%b&quot;</span>, rxd, rxd);</span><br></pre></td></tr></table></figure>
<p>说明: <code>$monitor</code>中, 参数可以是<code>$time</code>系统函数,
这样参数列表中变量或者表达式的值发生变化时,
对应的时刻可以通过标明同一时刻的多行输出来显示.
上面的语句中<code>, ,</code>表示一个空参数, 输出一个空格.</p>
<p><code>$monitor</code>还提供了两个常用的系统任务<code>$monitoron</code>和<code>$monitoroff</code>,
它们的作用是通过打开和关闭监控标志来控制监控任务<code>$monitor</code>的启动和停止.
通常在通过调用<code>$monitoron</code>启动<code>$monitor</code>时,
不管参数列表中的值是否发生变化, 总是立刻输出当前时刻参数列表中的值,
这在用于监控的初始时刻设定初始比较值. 缺省情况下,
控制标准在仿真的起始时刻就已经打开了. 在多模块调试的情况下,
许多模块中都调用了<code>$monitor</code>,
但是因为任何一个时刻都只能有一个<code>$monitor</code>工作,
因此需要配合<code>$monitoron</code>和<code>$monitoroff</code>使用,
也就是说, 把需要监视的模块用<code>$monitoron</code>打开,
在监视完毕之后及时用<code>$monitoroff</code>关闭,
以便把<code>$monitor</code>让给其他模块使用.</p>
<p><code>$monitor</code>和<code>$display</code>的不同之处还在于前者往往在<code>initial</code>块中调用,
只要不调用<code>$monitoroff</code>,
<code>$monitor</code>就会不间断地对所设定的信号进行监控.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> monitor_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">2</span>;</span><br><span class="line">                b=<span class="number">4</span>;</span><br><span class="line">                <span class="keyword">forever</span></span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        #<span class="number">5</span> a=a+b;</span><br><span class="line">                        #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$finish</span>;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    a=<span class="number">2</span>,  b=<span class="number">4</span></span><br><span class="line"><span class="number">5</span>    a=<span class="number">6</span>,  b=<span class="number">4</span></span><br><span class="line"><span class="number">10</span>   a=<span class="number">6</span>,  b=<span class="number">5</span></span><br><span class="line"><span class="number">15</span>   a=<span class="number">11</span>, b=<span class="number">5</span></span><br><span class="line"><span class="number">20</span>   a=<span class="number">11</span>, b=<span class="number">10</span></span><br><span class="line"><span class="number">25</span>   a=<span class="number">21</span>, b=<span class="number">10</span></span><br><span class="line"><span class="number">30</span>   a=<span class="number">21</span>, b=<span class="number">20</span></span><br><span class="line"><span class="number">35</span>   a=<span class="number">41</span>, b=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<p><code>$strobe</code>的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$strobe</span>(&lt;functions_or_signals&gt;);</span><br><span class="line"><span class="built_in">$strobe</span>(<span class="string">&quot;&lt;string_and/or_variables&gt;&quot;</span>, &lt;functions_or_signals&gt;);</span><br></pre></td></tr></table></figure>
<p><code>$strobe</code>系统任务用于某时刻所有时间处理完后,
在这个时间步的结尾输出一行格式化的文本. Verilog
HDL提供了除<code>$strobe</code>外的其他几个相关的扩展系统任务,
见下表</p>
<table>
<thead>
<tr>
<th>系统任务</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$strobe</code></td>
<td>在所有时间处理完后, 以十进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeb</code></td>
<td>在所有时间处理完后, 以二进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeo</code></td>
<td>在所有时间处理完后, 以八进制格式输出一行格式化的文本</td>
</tr>
<tr>
<td><code>$strobeh</code></td>
<td>在所有时间处理完后, 以十六进制格式输出一行格式化的文本</td>
</tr>
</tbody>
</table>
<p>这些系统任务在指定时间显示模拟数据,
但是这种任务的执行是在该特定时间步结束时才显示模拟数据.
“时间步结束”指的是对于指定时间步内的所有时间都已经处理了.
<code>$strobe</code>任务的参数定义和<code>$monitor</code>相同,
但是<code>$strobe</code>任务在被调用时刻所有的赋值语句都完成后,
才输出相应的文字信息.
因此<code>$strobe</code>任务提供了另一种数据显示机制,
可以保证数据只在所有赋值语句执行完毕之后才被显示.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> strobe_tb;</span><br><span class="line">    <span class="keyword">reg</span> a, b;</span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                a=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;a by display is: &quot;</span>, a);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;a by strobe is: &quot;</span>, a);</span><br><span class="line">                a=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">initial</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                b&lt;=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;b by display is: &quot;</span>, b);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;b by strobe is: &quot;</span>, b);</span><br><span class="line">                #<span class="number">5</span>;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;#5 b by display is: &quot;</span>, b);</span><br><span class="line">                <span class="built_in">$strobe</span>(<span class="string">&quot;#5 b by strobe is: &quot;</span>, b);</span><br><span class="line">                b&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a by display is: <span class="number">0</span></span><br><span class="line">b by display is: x</span><br><span class="line">a by strobe is: <span class="number">1</span></span><br><span class="line">b by strobe is: <span class="number">0</span></span><br><span class="line">#<span class="number">5</span> b by display is: <span class="number">0</span></span><br><span class="line">#<span class="number">5</span> b by strobe is: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="time与realtime">$time与$realtime</h3>
<p><code>$time</code>和<code>$realtime</code>这两个函数被调用后都返回当前时刻相对开始仿真时的时间值,
前者以64位整数值的形式返回, 后者以实型数据的形式返回仿真时间.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> time_tb;</span><br><span class="line">    <span class="keyword">reg</span> ts;</span><br><span class="line">    <span class="keyword">parameter</span> delay=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            #delay ts=<span class="number">1</span>;</span><br><span class="line">            #delay ts=<span class="number">0</span>;</span><br><span class="line">            #delay ts=<span class="number">1</span>;</span><br><span class="line">            #delay ts=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, , , <span class="string">&quot;ts=%b&quot;</span>, ts);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  ts=x</span><br><span class="line"><span class="number">2</span>  ts=<span class="number">1</span></span><br><span class="line"><span class="number">4</span>  ts=<span class="number">0</span></span><br><span class="line"><span class="number">6</span>  ts=<span class="number">1</span></span><br><span class="line"><span class="number">8</span>  ts=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> realtime_tb;</span><br><span class="line">    <span class="keyword">reg</span> set;</span><br><span class="line">    <span class="keyword">parameter</span> p=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$realtime</span>, , <span class="string">&quot;set=%b&quot;</span>, set);</span><br><span class="line">            #p set=<span class="number">0</span>;</span><br><span class="line">            #p set=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>输出为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> set=x</span><br><span class="line"><span class="number">2</span> set=<span class="number">0</span></span><br><span class="line"><span class="number">4</span> set=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="finish与stop">$finish与$stop</h3>
<p>系统任务<code>\$finish</code>和<code>\$stop</code>用于对仿真过程的控制,
分别表示结束仿真和中断仿真. 语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$finish</span></span><br><span class="line"><span class="built_in">$finish</span>(n)</span><br><span class="line"><span class="built_in">$stop</span></span><br><span class="line"><span class="built_in">$stop</span>(n)</span><br></pre></td></tr></table></figure>
<p>其中参数n的含义如下表:</p>
<table>
<thead>
<tr>
<th>n的取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>不输出任何信息</td>
</tr>
<tr>
<td>1</td>
<td>给出仿真时间和位置</td>
</tr>
<tr>
<td>2</td>
<td>给出仿真时间和位置,同时还有所用memory及CPU时间的统计</td>
</tr>
</tbody>
</table>
<p>系统任务<code>$finish</code>的作用是退出仿真器, 返回主操作系统,
也就是结束仿真过程. 可以带上参数, 输出不同的信息. 如果不带参数,
则默认设置为1.</p>
<p>系统任务<code>$stop</code>的作用是把EDA工具暂停,
在仿真环境下给出一个交互式的命令提示符, 将控制权交给用户.</p>
<p>使用举例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> finish_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">2</span>;</span><br><span class="line">            b=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">forever</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    #<span class="number">5</span> a=a+b;</span><br><span class="line">                    #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$finish</span>;    <span class="comment">//程序执行到第40个时间单位时退出仿真器</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> stop_tb;</span><br><span class="line">    <span class="keyword">integer</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">2</span>;</span><br><span class="line">            b=<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">forever</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    #<span class="number">5</span> a=a+b;</span><br><span class="line">                    #<span class="number">5</span> b=a-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> #<span class="number">40</span> <span class="built_in">$stop</span>;  <span class="comment">//程序执行到第40个时间单位时停止仿真，将EDA仿真器设置为暂停模式</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$monitor</span>(<span class="built_in">$time</span>, <span class="string">&quot;a=%d, b=%d&quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="readmemh与readmemb">$readmemh与$readmemb</h3>
<p><code>$readmemh</code>和<code>$readmemb</code>用来从文件中读取数据到存储器中.
这两个系统任务可以在仿真的任何时刻被执行使用, 其语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;);</span><br><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;,&lt;finish_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;);</span><br><span class="line"><span class="built_in">$readmemh</span>(<span class="string">&quot;&lt;file_name&gt;&quot;</span>,&lt;memory_name&gt;,&lt;start_addr&gt;,&lt;finish_addr&gt;);</span><br></pre></td></tr></table></figure>
<p>在这两个任务系统中, 被读取的数据文件的内容只能包含空白位置(空格,
换行符, 制表符(tab)和form-feeds),
注释行(<code>//</code>和<code>/**/</code>形式), 二进制或十六进制数字.
数字中不能包含位宽说明和格式说明, 对于<code>$readmemb</code>,
每个数字必须是二进制; 对于<code>$readmemh</code>,
每个数字必须是十六进制. 不定值<code>x/X</code>,
高阻值<code>z/Z</code>和下划线<code>_</code>的使用方法与Verilog
HDL中的一样. 数字必须用空白位置或者注释行分开.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> read_mem_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory_b [<span class="number">0</span>:<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] memory_h [<span class="number">0</span>:<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">integer</span>   i;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;init_b.txt&quot;</span>, memory_b);<span class="comment">//把数据文件init_b.txt读取到存储器中给定的地址</span></span><br><span class="line">        <span class="built_in">$readmemh</span>(<span class="string">&quot;init_h.txt&quot;</span>, memory_h);<span class="comment">//把数据文件init_h.txt读取到存储器中给定的地址</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i=i+<span class="number">1</span>)<span class="comment">//显示存储器中的内容</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;memory_b [%0d]=%b&quot;</span>, i, memory_b[i]);</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;memory_h [%0h]=%h&quot;</span>, i, memory_h[i]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>文件init_b.txt和init_h.txt包含初始化数据.
用<code>@&lt;address&gt;</code>在数据文件中指定地址如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">init_b<span class="variable">.txt</span>文件:</span><br><span class="line">    @<span class="number">002</span></span><br><span class="line">    <span class="number">11111111</span> <span class="number">01010101</span></span><br><span class="line">    <span class="number">00000000</span> <span class="number">10101010</span></span><br><span class="line">    @<span class="number">006</span></span><br><span class="line">    <span class="number">1111</span>zzzz <span class="number">00001111</span></span><br><span class="line">init_h<span class="variable">.txt</span>文件:</span><br><span class="line">    @<span class="number">001</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_0011</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_0111</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0000_1111</span></span><br><span class="line">    <span class="number">0000_0000_0000_0000_0000_0000_0001_1111</span></span><br></pre></td></tr></table></figure>
<p>其中”init_b.txt”指定二进制数据从第二位地址开始写入,
“init_h.txt”指定十六进制数据从第一位地址开始写入.</p>
<h3 id="random">$random</h3>
<p><code>$random</code>是产生随机数的系统函数,
每次使用该函数都会返回一个32位的随机数, 该随机数是一个带符号的整型数.
语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$random</span>%&lt;number&gt;;</span><br></pre></td></tr></table></figure>
<p>当该函数被调用时, 就会返回一个32位的有符号整数.</p>
<p>一般用法为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$random</span> % b;</span><br></pre></td></tr></table></figure>
<p>其中<code>b</code>是一个常数且要求大于零,
它给出了一个范围在<code>-b+1~b-1</code>之间的随机数.</p>
<p>利用位拼接操作符<code>&#123;&#125;</code>可以将函数<code>$random</code>返回的有符号整数变为无符号整数,
用法为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">$random</span>&#125;%b;</span><br></pre></td></tr></table></figure>
<p>其中<code>b</code>是一个常数且要求大于零,
它给出了一个范围在<code>0~b-1</code>之间的随机数.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> random_pulse(dout);</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">9</span>:<span class="number">0</span>] dout;</span><br><span class="line">    <span class="keyword">reg</span>          dout;</span><br><span class="line">    <span class="keyword">integer</span> delay1, delay2, k;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span> dout=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="number">100</span>; k=k+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                delay1=<span class="number">20</span>*(&#123;<span class="built_in">$random</span>&#125;%<span class="number">6</span>);        <span class="comment">//delay1在0~100ns范围内变化</span></span><br><span class="line">                delay2=<span class="number">20</span>*(<span class="number">1</span>+&#123;<span class="built_in">$random</span>&#125;%<span class="number">3</span>);      <span class="comment">//delay2在20~60ns范围内变化</span></span><br><span class="line">                #delay1 dout=<span class="number">1</span>&lt;&lt;(&#123;<span class="built_in">$random</span>&#125;%<span class="number">10</span>); <span class="comment">//dout的0~9位中随机出现1，且出现的时间在0~100ns范围内变化</span></span><br><span class="line">                #delay2 dout=<span class="number">0</span>;                 <span class="comment">//脉冲的宽度在20~60ns的范围变化</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="值变转储文件系统任务">值变转储文件系统任务</h3>
<h2 id="信号时间赋值语句">信号时间赋值语句</h2>
<p>在集成电路设计和验证阶段,
经常需要对特定信号进行延时来实现相应的时序控制,
或者避免信号冲突形成电路中的热点.</p>
<p>信号的时间延迟可以通过两类方式完成: 一类是延时控制,
它是行为语句的执行指定一个延迟时间的信号时间延迟方式,
可以分成串行延时控制, 并行延时控制, 阻塞式延时控制, 非阻塞延时控制;
另一类是事件控制, 它是行为语句的执行指定触发事件的信号延迟方式,
可以分成边沿触发事件控制和电平敏感事件控制.</p>
<ul>
<li>延时控制
<ul>
<li>串行延时控制</li>
<li>并行延时控制</li>
<li>阻塞式延时控制</li>
<li>非阻塞式延时控制</li>
</ul></li>
<li>事件控制
<ul>
<li>边沿触发事件控制</li>
<li>电平敏感事件控制</li>
</ul></li>
</ul>
<h3 id="时间延迟的语法说明">时间延迟的语法说明</h3>
<p>Verilog HDL的延时控制的语法格式有如下两类:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&lt;延迟时间&gt;行为语句;</span><br><span class="line">#&lt;延迟时间&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>#</code>是延时控制的关键字符, 后面跟需要延时的时间.</p>
<p>根据时间控制部分在过程赋值语句中出现的位置,
可以把过程赋值语句的时间控制分成外部时间控制方式和内部时间控制方式.</p>
<p>外部时间控制方式: 时间控制出现在整个过程赋值语句的最左端,
也就是出现在赋值目标变量的左边的时间控制方式. 例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">5</span> a=b;</span><br></pre></td></tr></table></figure>
<p>这等价于</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">5</span>;</span><br><span class="line">        a=b;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">//这就是说先等5个时间单位，然后把b赋给a</span></span><br></pre></td></tr></table></figure>
<p>内部时间控制方式:
过程赋值语句中的时间控制部分还可以出现在”赋值操作符”和”赋值表达式”之间的时间控制方式.
例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=#<span class="number">5</span>b;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        temp=b;<span class="comment">//先求b的值</span></span><br><span class="line">        $<span class="number">5</span>;</span><br><span class="line">        a=temp;</span><br><span class="line">    <span class="keyword">end</span><span class="comment">//这就是说先把b求出来之后，等5个时间单位，然后赋给a</span></span><br></pre></td></tr></table></figure>
<h3 id="时间延迟的描述形式">时间延迟的描述形式</h3>
<h4 id="串行延时控制">串行延时控制</h4>
<p>串行延时控制是最常用的信号延时控制,
它是由<code>begin-end</code>过程块加上延时赋值语句构成,
其中延时赋值语句可以是外部时间控制方式, 也可以是内部时间控制方式.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> serial_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">                     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">50</span>      q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="并行延时控制">并行延时控制</h4>
<p>并行延时控制是由<code>fork-join</code>过程块加上延时赋值语句构成,
其中延时赋值语句可以是外部时间控制方式, 也可以是内部时间控制方式.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> parallel_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">                    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">50</span>     q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">150</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">250</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">300</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">400</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">450</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">500</span>    q0_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">600</span>    q0_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">                     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">100</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">200</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">250</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">350</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">400</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">500</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">            #<span class="number">550</span>     q1_out=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">600</span>     q1_out=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">join</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这个波形和串行延时控制中的例子的波形相同</span></span><br></pre></td></tr></table></figure>
<h4 id="阻塞式延时控制">阻塞式延时控制</h4>
<p>以赋值操作符<code>=</code>来标识的赋值操作称为”阻塞式过程赋值”,
阻塞式延时控制就是在阻塞式过程赋值的基础上加上延时控制.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        a=      <span class="number">0</span>;</span><br><span class="line">        a=#<span class="number">5</span>    <span class="number">1</span>;</span><br><span class="line">        a=#<span class="number">10</span>   <span class="number">0</span>;</span><br><span class="line">        a=#<span class="number">15</span>   <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>说明: 仿真开始时刻将0赋给<code>a</code>,
这条赋值语句完成后才执行下一条语句; 在第一条语句执行完后,
等待5个时间单位, 把1赋给<code>a</code>;
第三条赋值语句在第二条赋值语句执行完后等待10个时间单位后,
把0赋给<code>a</code>;
最后一条赋值语句在第三条赋值语句执行完后等待15个时间单位后,
将1赋给<code>a</code>.</p>
<h4 id="非阻塞式延时控制">非阻塞式延时控制</h4>
<p>以赋值操作符<code>&lt;=</code>来标识的赋值操作称为”非阻塞式过程赋值”,
非阻塞式延时控制就是在非阻塞式过程赋值的基础上加上延时控制.</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        a&lt;=<span class="number">0</span>;</span><br><span class="line">        a&lt;=#<span class="number">5</span> <span class="number">1</span>;</span><br><span class="line">        a&lt;=#<span class="number">10</span> <span class="number">0</span>;</span><br><span class="line">        a&lt;=#<span class="number">15</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>说明: 在仿真进程开始时刻同时执行四条延时赋值语句. 在仿真进程开始时,
把0赋给<code>a</code>; 在距离仿真开始时刻5个时间单位时,
将1赋给<code>a</code>; 在距离仿真开始时刻10个时间单位时,
将0赋给<code>a</code>; 在距离仿真开始时刻15个时间单位时,
将1赋给<code>a</code>;</p>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> non_blocking_delay(q0_out, q1_out);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q0_out, q1_out;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q0_out&lt;=         <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">50</span>      <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">150</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">250</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">300</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">400</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">450</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">500</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q0_out&lt;=#<span class="number">600</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q1_out&lt;=         <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">100</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">200</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">250</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">350</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">400</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">500</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">550</span>     <span class="number">1&#x27;b1</span>;</span><br><span class="line">            q1_out&lt;=#<span class="number">600</span>     <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//这个波形和串行延时控制中的例子的波形相同</span></span><br></pre></td></tr></table></figure>
<p>说明:
每一条延时赋值语句的执行不需要等待上一条延时赋值语句执行完之后再执行,
而是从仿真开始的时刻同时执行.</p>
<h3 id="边沿触发事件控制">边沿触发事件控制</h3>
<p>边沿事件控制方式是在指定的信号变化时刻,
即指定的信号跳变边沿才触发语句的执行,
而当信号处于稳定状态时则不会触发语句的执行.</p>
<p>边沿触发事件的语法格式有如下四种形式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@(&lt;事件表达式&gt;)行为语句;</span><br><span class="line">@(&lt;事件表达式&gt;);</span><br><span class="line">@(&lt;事件表达式<span class="number">1</span>&gt; <span class="keyword">or</span> &lt;事件表达式<span class="number">2</span>&gt; <span class="keyword">or</span> ... <span class="keyword">or</span> &lt;事件表达式n&gt;)行为语句;</span><br><span class="line">@(&lt;事件表达式<span class="number">1</span>&gt; <span class="keyword">or</span> &lt;事件表达式<span class="number">2</span>&gt; <span class="keyword">or</span> ... <span class="keyword">or</span> &lt;事件表达式n&gt;);</span><br></pre></td></tr></table></figure>
<p>其中<code>@</code>是边沿触发事件控制的标识符,
<code>事件表达式</code>表示触发事件,
<code>行为语句</code>表示触发时需要执行的操作.
而`事件表达式有如下三种形式:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;信号名&gt;</span><br><span class="line"><span class="keyword">posedge</span>&lt;信号名&gt;</span><br><span class="line"><span class="keyword">negedge</span>&lt;信号名&gt;</span><br></pre></td></tr></table></figure>
<p>逻辑信号的正负跳变定义如下表:</p>
<table>
<thead>
<tr>
<th>正跳变<code>posedge</code></th>
<th>负跳变<code>negedge</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>0<span class="math inline">\(\to\)</span>x</td>
<td>1<span class="math inline">\(\to\)</span>x</td>
</tr>
<tr>
<td>0<span class="math inline">\(\to\)</span>z</td>
<td>1<span class="math inline">\(\to\)</span>z</td>
</tr>
<tr>
<td>0$<span class="math inline">\(1|1\)</span><span
class="math inline">\(0|
|x\)</span><span class="math inline">\(1|x\)</span><span
class="math inline">\(0|
|z\)</span><span class="math inline">\(1|z\)</span>$0</td>
<td></td>
</tr>
</tbody>
</table>
<p>边沿触发的4种形式:</p>
<ol type="1">
<li><code>@(&lt;事件表达式&gt;)行为语句;</code>: 只包含一个触发事件,
只有这个事件发生后, 后面的行为语句才能执行. 在仿真进程中遇到这种语句时,
如果指定的触发事件还没有发生, 则仿真进程就会停留在此处等待,
直到指定触发事件发生后才执行后面的行为语句, 仿真进制继续向下进行.</li>
<li><code>@(&lt;事件表达式&gt;);</code>: 在仿真进程中遇到这种语句时,
如果指定的触发事件还没有发生, 则仿真进程就会停留在此处等待,
直到指定触发事件发生后才开始下一条语句的执行.</li>
<li><code>@(&lt;事件表达式1&gt; or &lt;事件表达式2&gt; or ... or &lt;事件表达式n&gt;)行为语句;</code>:
只要其中任意一个触发事件发生, 后面的行为语句就会执行.</li>
<li><code>@(&lt;事件表达式1&gt; or &lt;事件表达式2&gt; or ... or &lt;事件表达式n&gt;);</code>:
只要其中任意一个触发事件发生, 仿真进程就会继续进行.</li>
</ol>
<h3 id="电平敏感事件控制">电平敏感事件控制</h3>
<p>电平敏感事件控制是在指定的条件表达式为真时启动需要执行的语句.
电平敏感事件控制是用关键词<code>wait</code>来表示的.</p>
<p>电平敏感事件控制的语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wait</span>(条件表达式) 行为语句;</span><br><span class="line"><span class="keyword">wait</span>(条件表达式);</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>电平敏感事件控制的第一种形式中包含了行为语句,
它可以是串行块也可以是并行块,
也可以是单条行为语句.行为语句执行条件是条件表达式的值为真.
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为真,
那么语句块立即执行,
否则语句块要一直等到条件表达式的值变成真时才会执行.</li>
<li>电平敏感事件控制的第二种形式中没有包含行为语句.
在这种电平敏感事件控制下,
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为真,
那么那么立即结束该<code>wait</code>事件控制语句的执行, 仿真进程继续进行;
当仿真进程执行到这条电平敏感事件控制语句时条件表达式的值为假,
那么仿真进程进入等待状态, 一直到条件表达式变成真时才退出等待状态,
同时结束<code>wait</code>语句的执行, 仿真进程继续进行.</li>
</ol>
<h2 id="任务和函数">任务和函数</h2>
<p>在行为级设计中, 设计者经常需要在程序的多个地方实现相同的功能.
因此有必要把这些相同的部分提取出来组成子程序, 然后直接调用即可.</p>
<p>任务具有输入, 输出, 输入输出双向变量, 而函数具有输入变量,
这样数据能够传入任务和函数, 并且能够将结果输出.</p>
<h3 id="任务">任务</h3>
<p>Verilog
HDL使用关键字<code>task</code>和<code>endtask</code>对任务进行声明.
如果子程序满足以下任一条件,
则公共子程序的描述必须使用任务而不是函数:</p>
<ol type="1">
<li>子程序中包含延时, 时序或者事件控制结构</li>
<li>没有输出或者输出变量的数量大于一</li>
<li>没有输入变量</li>
</ol>
<p>任务定义的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span>&lt;任务名&gt;;</span><br><span class="line">    端口类型声明</span><br><span class="line">    局部变量声明</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            语句<span class="number">1</span>;</span><br><span class="line">            语句<span class="number">2</span>;</span><br><span class="line">            ...</span><br><span class="line">            语句n;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>任务定义在<code>task</code>和<code>endtask</code>之间,
任务名之后是分号.</li>
<li>端口和类型声明用于对各个端口的类型和宽度进行声明,
其语法和在模块中声明端口的格式一样.</li>
<li>局部变量声明用来对<strong>任务内</strong>用到的局部变量进行类型和宽度的声明.</li>
<li>任务中由<code>begin</code>和<code>end</code>关键词定义的一系列语句指明了任务被调用时需要进行的操作.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> read_mem;              <span class="comment">//任务名为read_mem</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>] address;  <span class="comment">//输入端口声明</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data;     <span class="comment">//输出端口声明</span></span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]  counter;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>]  temp [<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(counter=<span class="number">1</span>; counter&lt;=<span class="number">4</span>; counter=counter+<span class="number">1</span>)</span><br><span class="line">            temp[counter]=mem[address+counter-<span class="number">1</span>];</span><br><span class="line">            data=&#123;temp[<span class="number">1</span>], temp[<span class="number">2</span>], temp[<span class="number">3</span>], temp[<span class="number">4</span>]&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span>  </span><br></pre></td></tr></table></figure>
<p>说明: 这个例子定义了一个名为<code>read_mem</code>的任务,
用来读取存储器<code>mem</code>中的数据,
该任务由一个16位的输入端口<code>address</code>,
一个32位的输出端口<code>data</code>,
一个4位的局部变量<code>counter</code>和一个8位的存储器<code>temp</code>构成.
当该例的任务被调用时,
<code>begin</code>和<code>end</code>之间的语句得到执行,
它们用来执行对存储器<code>mem</code>进行的四次读操作,
将其结果合并后输出到32位的输出端口<code>data</code>.</p>
<p>任务的调用是用任务语句实现的,
任务调用语句列出了传入任务和传出任务的参数值, 格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;任务名&gt;(端口<span class="number">1</span>, 端口<span class="number">2</span>, ...,端口n);</span><br></pre></td></tr></table></figure>
<p>任务调用时, 任务调用语句只能出现在过程块内,
任务调用语句就像一条普通的行为语句得到处理.
当被调用的任务有输入和输出端口时, 任务调用语句必须包含端口名的列表,
这个列表内各个端口名出现的顺序和类型必须与任务定义结构中端口说明部分的端口顺序和类型一致.
注意, 只有寄存器类型的变量才能和任务的输出端口相对应.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> demo_task_invo_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem [<span class="number">127</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] a;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">0</span>;</span><br><span class="line">            read_mem(a,b);<span class="comment">//第一次调用任务，a与address对应，b与data对应</span></span><br><span class="line">            #<span class="number">10</span>;</span><br><span class="line">            a=<span class="number">64</span>;</span><br><span class="line">            read_mem(a,b);<span class="comment">//第二次调用任务</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">task</span> read_mem;</span><br><span class="line">        <span class="keyword">input</span>  [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">        <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">        <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]  counter;</span><br><span class="line">        <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] temp [<span class="number">1</span>:<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span>(counter=<span class="number">1</span>; counter&lt;=<span class="number">4</span>; counter=counter+<span class="number">1</span>)</span><br><span class="line">            temp[counter]=mem[address+counter-<span class="number">1</span>];</span><br><span class="line">            data=&#123;temp[<span class="number">1</span>], temp[<span class="number">2</span>], temp[<span class="number">3</span>], temp[<span class="number">4</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>Verilog
HDL使用关键字<code>function</code>和<code>endfunction</code>对函数进行声明.
对于一个子程序来说, 如果下面的所有条件都成立, 则可以调用函数来完成:</p>
<ol type="1">
<li>子程序内不含有延时, 时序或者事件控制结构</li>
<li>子程序只有一个返回值</li>
<li>至少有一个输入变量</li>
<li>没有输出或者双向变量</li>
<li>不含有非阻塞赋值语句</li>
</ol>
<p>函数定义的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>&lt;返回值或者返回类型&gt;&lt;函数名&gt;;</span><br><span class="line">    &lt;输入参量与类型声明&gt;</span><br><span class="line">    &lt;局部变量声明&gt;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        语句n;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol type="1">
<li>函数定义是嵌入在<code>function</code>和<code>endfunction</code>之间的,
函数名后面要加上分号;</li>
<li>返回值类型或者位宽是一个可选项,
用来对函数调用返回数据的类型或宽度进行说明, 它有如下三种形式:
<ul>
<li><code>[msb,lsb]</code>:
这种形式说明返回值是一个多位的寄存器变量</li>
<li><code>integer</code>: 这种形式说明返回值是一个整型变量</li>
<li><code>real</code>: 这种形式说明返回值是一个实型变量</li>
</ul></li>
<li>输入参量与类型声明是函数对各个输入端口的宽度和类型进行声明.
在函数定义中, 至少必须有一个输入端口<code>input</code>的声明,
不能有输出端口<code>output</code>的声明.</li>
<li>局部变量声明是对函数内部局部变量进行宽度和类型的声明.</li>
<li>由<code>begin</code>和<code>end</code>关键词界定的一系列语句同任务一样,
用来指明函数被调用时要执行的操作.</li>
</ol>
<p>函数的调用是通过将函数作为表达式中的操作数来实现的,
函数调用的格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数名&gt;(&lt;输入表达式<span class="number">1</span>&gt;, &lt;输入表达式<span class="number">2</span>&gt;, ...,&lt;输入表达式n&gt;);</span><br></pre></td></tr></table></figure>
<p>其中输入表达式应该与函数定义结构中声明的输入端口顺序一一对应,
它们代表着各个输入端口的输入数据.</p>
<p>函数调用时的注意事项:</p>
<ol type="1">
<li>函数的调用不能作为单独的一条语句出现, 它相当于一个操作数</li>
<li>函数的调用既可以出现在过程块中,
也可以出现在<code>assign</code>连续赋值语句中</li>
<li>函数定义中声明的所有局部寄存器都是静态的,
即函数中的局部寄存器在函数的多个调用之间保持它们的值.</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tryfact_tb;</span><br><span class="line">    <span class="keyword">function</span> [<span class="number">31</span>:<span class="number">0</span>] factorial;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] operand;</span><br><span class="line">        <span class="keyword">reg</span>   [<span class="number">3</span>:<span class="number">0</span>] index;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            factorial=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(index=<span class="number">1</span>; index&lt;=operand; index=index+<span class="number">1</span>)</span><br><span class="line">            factorial=index*factorial;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] result;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]  n;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            result=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;=<span class="number">9</span>; n=n+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                result=factoial(n);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;n=%d result=%d&quot;</span>, n, result);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="任务与函数的区别">任务与函数的区别</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>函数</th>
<th>任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数可以调用另一个函数, 但是不能调用另一个任务</td>
<td>任务可以调用另一个任务或函数</td>
</tr>
<tr>
<td>函数在仿真0时刻就开始执行</td>
<td>任务可以在非0仿真时刻执行</td>
</tr>
<tr>
<td>函数绝对不能包含任何延时, 时序或者事件控制声明语句</td>
<td>任务可以包含延时, 时序或者事件控制声明语句</td>
</tr>
<tr>
<td>函数至少有一个输入变量</td>
<td>任务可以没有输入或者多个输入, 输出, 双向变量</td>
</tr>
<tr>
<td>函数只能返回一个值, 函数不能有输出或者双向变量</td>
<td>任务不返回任何值, 但是可以通过输出或者双向变量传递多个值</td>
</tr>
<tr>
<td>函数不能作为一条单独的语句出现, 它只能作为语句的一部分出现</td>
<td>任务的调用是通过一条单独的语句实现</td>
</tr>
<tr>
<td>函数的调用可以出现在过程块或连续赋值语句中</td>
<td>任务调用只能出现在过程块中</td>
</tr>
<tr>
<td>函数的执行不能由<code>disable</code>语句中断</td>
<td>任务的执行可以由<code>disable</code>语句中断</td>
</tr>
</tbody>
</table>
<h2 id="典型测试向量的设计">典型测试向量的设计</h2>
<h3 id="变量初始化">变量初始化</h3>
<p>在Verilog HDL中, 有两种方法可以初始化变量:
一种是利用<code>initial</code>, 一种是在定义变量时直接赋值初始化.
这两种初始化任务是不可综合的, 主要用于仿真过程.</p>
<p><code>initial</code>初始化方式是最常用的,
<code>initial</code>语句只执行一次,
即在设计被开始模拟执行时开始(0时刻)直到过程结束,
专门用于对输入信号进行初始化和产生特定的信号波形.
一个Testbench可以有多个<code>initial</code>过程语句块,
但是所有的<code>initial</code>都是同时执行的. 注意,
<code>initial</code>语句中的变量必须是<code>reg</code>类型的.
定义变量时初始化直接用等号<code>=</code>在变量右端赋值即可.</p>
<h3 id="数据信号测试向量的产生">数据信号测试向量的产生</h3>
<p>数据信号的产生有两种方式:
一是初始化和产生都在单个<code>initial</code>块中进行;
其二是初始化在<code>initial</code>语句中完成,
而产生在<code>always</code>语句块中完成. 前者时候不规则数据序列,
并且要求长度较短; 后者适合有一定规律的数据序列, 长度不限.</p>
<p>例: 产生位宽为4的质数序列{1, 2, 3, 5, 7, 11, 13}, 并且重复两次,
其中样值间隔为4个仿真时间单位.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> sequence_tb;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] q_out;</span><br><span class="line">    <span class="keyword">parameter</span> sample_period=<span class="number">4</span>;  <span class="comment">//间隔4个时间单位</span></span><br><span class="line">    <span class="keyword">parameter</span> queue_num=<span class="number">2</span>;      <span class="comment">//重复两次</span></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            q_out=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">repeat</span>(queue_num) <span class="keyword">begin</span></span><br><span class="line">                # sample_period q_out=<span class="number">1</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">2</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">3</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">5</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">7</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">11</span>;</span><br><span class="line">                # sample_period q_out=<span class="number">13</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="时钟信号测试向量的产生">时钟信号测试向量的产生</h3>
<p>例: 产生占空比为50%的时钟信号.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk1(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> <span class="variable">#(clk_period/2)</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk2(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(clk_period/2)</span> clk=~clk;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例: 生成占空比可以设置的信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk3(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> high_time=<span class="number">5</span>;<span class="comment">//高电平持续时间</span></span><br><span class="line">    <span class="keyword">parameter</span> low_time=<span class="number">20</span>;<span class="comment">//低电平持续时间</span></span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">1</span>;</span><br><span class="line">        # high_time;</span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        # low_time;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>例: 产生具有相位偏移的信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk4(clk);</span><br><span class="line">    <span class="keyword">output</span> clk_a, clk_b;</span><br><span class="line">    <span class="keyword">reg</span> clk_a;</span><br><span class="line">    <span class="keyword">wire</span> clk_b;</span><br><span class="line">    <span class="keyword">parameter</span> high_time=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> low_time=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> shift_time=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        clk_a=<span class="number">1</span>;</span><br><span class="line">        # high_time;</span><br><span class="line">        clk_a=<span class="number">0</span>;</span><br><span class="line">        # low_time;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> # shift_time clk_b=clk_a;<span class="comment">//相当于把a时钟延迟两个时间单位后赋给b时钟</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里偏移的相位可以用下式计算</p>
<p><span class="math display">\[\rm{phase}=360\times
\rm{shift\_time}\%(high\_time+low\_time)\]</span></p>
<p>其中<code>%</code>是取模运算.</p>
<p>例: 产生固定数目的时钟信号</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> clk5(clk);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">parameter</span> clk_cnt=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> clk_period=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span> (clk_cnt)<span class="comment">//重复5次</span></span><br><span class="line">            # clk_period/<span class="number">2</span> clk=~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="总线信号测试向量的产生">总线信号测试向量的产生</h3>
<p>总线是运算部件之间数据流通的公共通道. 在RTL级描述中,
总线指的是由逻辑单元, 寄存器, 存储器,
电路输入或其他总线驱动的一个共享向量.
而总线功能模型则是一种将物理接口的时序操作转化成更高抽象层次接口的总线模型.</p>
<p>在总线中, 对于每个请求端, 有一个输入来选择驱动该总线所对应的请求端.
选择多个请求端时会发生总线冲突, 根据不同的总线类型,
会发生不同的冲突结果. 当有多个请求端发出请求时,
相应的操作由总线的类型决定. 在Verilog HDL测试中,
总线测试信号通常是将片选信号, 读(或写)使能信号, 地址信号,
数据信号以task任务的形式来描述,
并通过调用task形式的总线信号测试向量来完成相应的总线功能.</p>
<p>例: 产生一组具有写操作的AHB总线功能模型</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bus_wr_tb;</span><br><span class="line">    <span class="keyword">reg</span>        clk;</span><br><span class="line">    <span class="keyword">reg</span>        cs;</span><br><span class="line">    <span class="keyword">reg</span>        wr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            cs=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            wr=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            #<span class="number">30</span>;</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h1100008a</span>, <span class="number">32&#x27;h11113000</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h1100009a</span>, <span class="number">32&#x27;h11113001</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000aa</span>, <span class="number">32&#x27;h11113002</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000ba</span>, <span class="number">32&#x27;h11113003</span>);</span><br><span class="line">            bus_wr(<span class="number">32&#x27;h110000ca</span>, <span class="number">32&#x27;h11113004</span>);</span><br><span class="line">            addr=<span class="number">32&#x27;bx</span>;</span><br><span class="line">            data=<span class="number">32&#x27;bx</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> clk=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> #<span class="number">5</span> clk=~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> bus_wr;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] ADDR;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] DATA;</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                cs=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                wr=<span class="number">1&#x27;b0</span>;</span><br><span class="line">                addr=ADDR;</span><br><span class="line">                data=DATA;</span><br><span class="line">                #<span class="number">30</span>;</span><br><span class="line">                cs=<span class="number">1&#x27;b1</span>;</span><br><span class="line">                wr=<span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="用户自定义元件模型">用户自定义元件模型</h2>
<h2 id="基本门级元件和模块的延时建模">基本门级元件和模块的延时建模</h2>
<h3 id="门级延时建模">门级延时建模</h3>
<p>在实际的电路中, 任何一个逻辑门都有延时,
信号从逻辑门的输入到输出的传输延时可以通过门延时来定义.</p>
<p>门级延时可以分成如下四类:</p>
<ol type="1">
<li>上升延时: 表示信号从0, x, z状态变化到1状态时受到的门传输延时</li>
<li>下降延时: 表示信号从1, x, z状态变化到0状态时受到的门传输延时</li>
<li>到不定态的延时: 表示信号从0, 1,
z状态变化到x状态时受到的门传输延时</li>
<li>截止延时: 表示信号从0, 1, x状态变化到z状态时受到的门传输延时</li>
</ol>
<ul>
<li>由于多输入门(and, nand, or, nor, xor, xnor)和多输出门(buf,
not)的输出不可能是高阻态z,
所以这两类元件<strong>没有”到不定态的延时”</strong>.</li>
<li>对于三态门(bufif1， bufif2, notif1, notif0),
由于其输出可以取四种可能的逻辑状态(0, 1, x, z),
所以<strong>具有全部的延时种类</strong>.</li>
<li>对于上拉电阻(pullup)和下拉电阻(pulldown), 由于它们没有输入端口，
所以<strong>没有任何形式的门级延时</strong>.</li>
</ul>
<p>实例引用带延时的参数门的语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gate_type #delay instance_name(terminal_list);</span><br></pre></td></tr></table></figure>
<p>其中<code>#delay</code>就是门的延时. 如果没有指定门延时,
那么就默认为0. 同时<code>delay</code>是由一个或者多个延时值组成的,
可以有<strong>基本延时表达</strong>和<strong>最小, 典型,
最大延迟表达</strong>两种形式.</p>
<h4 id="门级延时的基本延时表达形式">门级延时的基本延时表达形式</h4>
<p>在门级延时的基本延时表达形式下,
<code>delay</code>内可以包含0~3个参数值,
如下表给出了指定的不同延时值个数时<code>delay</code>的4种表示形式:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>无延时</th>
<th>1个延时值(d)</th>
<th>2个延时值(d1, d2)</th>
<th>3个延时值(dA, dB, dC)</th>
</tr>
</thead>
<tbody>
<tr>
<td>rise</td>
<td>0</td>
<td>d</td>
<td>d1</td>
<td>dA</td>
</tr>
<tr>
<td>fall</td>
<td>0</td>
<td>d</td>
<td>d2</td>
<td>dB</td>
</tr>
<tr>
<td>to_x</td>
<td>0</td>
<td>d</td>
<td>min(d1,d2)</td>
<td>min(dA,dB,dC)</td>
</tr>
<tr>
<td>turn_off</td>
<td>0</td>
<td>d</td>
<td>min(d1,d2)</td>
<td>dC</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ol type="1">
<li>当<code>delay</code>没有指定门延时, 默认的延时值为0, 即上升, 下降,
截止, 到不定态的延时值都是0.</li>
<li>当<code>delay</code>包含了1个延时值时,
给定的延时值d将同时代表着元件实例的上升, 下降, 截止,
到不定态的延时.</li>
<li>当<code>delay</code>包含了2个延时值时, 原件的上升延时值由d1决定,
下降延时值由d2决定, 而截止和到不定态的延时值由min(d1,d2)决定</li>
<li>当<code>delay</code>包含了3个延时值时, 原件的上升延时值由dA决定,
下降延时值由dB决定, 截止延时值由dC决定,
到不定态的延时由min(dA,dB,dC)决定</li>
</ol>
<h4 id="门级延时的最小-典型-最大延时表达形式">门级延时的最小, 典型,
最大延时表达形式</h4>
<p>采用门级延时的最小, 典型, 最大延时表达形式时,
门级延时量中的每一项由最小延时, 典型延时, 最大延时三个值来表示.
语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">#(d_min:d_type:d_max)</span></span><br></pre></td></tr></table></figure>
<p>采用最小, 典型, 最大延时表达形式时,
<code>delay</code>内可以包含1~3个延时值, 例如</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#delay(dA_min:dA_typ:dA_max)</span><br><span class="line">#delay(dA_min:dA_typ:dA_max,dB_min:dB_typ:dB_max)</span><br><span class="line">#delay(dA_min:dA_typ:dA_max,dB_min:dB_typ:dB_max,dC_min:dC_typ:dC_max)</span><br></pre></td></tr></table></figure>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(4:5:6) U1(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<p>1个延时值的结果如下表:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>典型延时值</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>最大延时值</td>
<td>6</td>
<td>6</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(3:4:5,5:6:7) U2(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<p>2个延时值的结果如下表:</p>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>3</td>
<td>5</td>
<td>min(3,5)</td>
<td>min(3,5)</td>
</tr>
<tr>
<td>典型延时值</td>
<td>4</td>
<td>6</td>
<td>min(4,6)</td>
<td>min(4,6)</td>
</tr>
<tr>
<td>最大延时值</td>
<td>5</td>
<td>7</td>
<td>min(5,7)</td>
<td>min(5,7)</td>
</tr>
</tbody>
</table>
<p>例:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="variable">#(2:3:4,3:4:5,4:5:6) U3(out, i1, i2)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>延时值</th>
<th>上升延时值</th>
<th>下降延时值</th>
<th>到不定态的延时值</th>
<th>截止延时值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小延时值</td>
<td>2</td>
<td>3</td>
<td>min(2,3,4)</td>
<td>4</td>
</tr>
<tr>
<td>典型延时值</td>
<td>3</td>
<td>4</td>
<td>min(3,4,5)</td>
<td>5</td>
</tr>
<tr>
<td>最大延时值</td>
<td>4</td>
<td>5</td>
<td>min(4,5,6)</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="模块延时建模">模块延时建模</h3>
<p>对于由用户自己设计的模块, 可以采用”加入门级延时说明”的方法,
通过”延时说明模块”的结构来对模块的传输延时进行说明. 注意,
延时说明模块既可以出现在行为描述模块内, 也可以出现在结构描述模块内.</p>
<h4 id="延时说明块">延时说明块</h4>
<p>在模块输入和输出引脚之间的延时称为模块路径延时. 在Verilog HDL中,
在关键字<code>specify</code>和<code>endspecipy</code>之间给出路径延时赋值,
关键字之间的语句组成<code>specify</code>块(即指定块).
<code>specify</code>和<code>endspecify</code>分别是延时说明块的起始标识符和终止标识符.</p>
<p><code>specify</code>块中包含下列操作语句:</p>
<ol type="1">
<li>定义穿过模块的所有路径延时</li>
<li>在电路中设置时序检查</li>
<li>定义<code>specparam</code>常量</li>
</ol>
<p>例: 考虑电路:“<code>e=a&amp;b, f=d&amp;c, out=e&amp;f</code>”,
路径延时如下表:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>延时</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a--e--out</code></td>
<td>9</td>
</tr>
<tr>
<td><code>b--e--out</code></td>
<td>9</td>
</tr>
<tr>
<td><code>c--f--out</code></td>
<td>11</td>
</tr>
<tr>
<td><code>d--f--out</code></td>
<td>11</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M(out, a, b, c, d);</span><br><span class="line">    <span class="keyword">input</span>  a,b,c,d;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span> e, f;</span><br><span class="line">    <span class="keyword">assign</span> out=(a&amp;b)&amp;(c&amp;d);</span><br><span class="line">    <span class="keyword">specify</span></span><br><span class="line">        (a=&gt;out)=<span class="number">9</span>;</span><br><span class="line">        (b=&gt;out)=<span class="number">9</span>;</span><br><span class="line">        (c=&gt;out)=<span class="number">11</span>;</span><br><span class="line">        (d=&gt;out)=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">endspecify</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4 id="路径延时的描述方式">路径延时的描述方式</h4>
<p>路径延时有两种描述方式, 并行连接和全连接.</p>
<p>并行连接: 每一条路径延时都有源域和目标域, 在<code>specify</code>块中,
用<code>=&gt;</code>表示并行连接, 语法格式如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;source_field&gt;=&gt;&lt;destination_field&gt;)=&lt;delay_value&gt;;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;delay_value&gt;</code>可以包含1~3个延时量,
也可以采用最小, 典型, 最大延时表达式. 当延时量超过一个时,
应该使用括号括起来, 例如:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a=&gt;out)=(<span class="number">8</span>:<span class="number">9</span>:<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>表示的是输入<code>a</code>到输出<code>out</code>的最小, 典型,
最大延时分别是8, 9, 10个时间单位.</p>
<p>在并行连接中, 源域中的每一位与目标域中的相应位连接.
如果源域和目标域是向量, 那么必须有相同的位数, 否则会出现不匹配.
并行连接说明了源域的每一位到目标域每一位之间的延时.</p>
<p>全连接: 在<code>specify</code>块中,
用符号<code>*&gt;</code>表示全连接, 其语法格式如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;source_field&gt;*&gt;&lt;destination_field&gt;)=&lt;delay_value&gt;;</span><br></pre></td></tr></table></figure>
<p>全连接中, 源域的每一位与目标域中的每一位相连接.
如果源域和目标域是向量, 那么它们的位数不必相同.
全连接描述了源域的每一位到目标域的每一位之间的延时.</p>
<h4 id="specparam声明语句">specparam声明语句</h4>
<p><code>specparam</code>用来定义<code>specify</code>块中的参数.</p>
<p>示例如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> parallel_connected(out, a, b);</span><br><span class="line">    <span class="keyword">input</span>  a, b;</span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">wire</span>   out;</span><br><span class="line">        <span class="keyword">assign</span> out=a&amp;b;</span><br><span class="line">        <span class="keyword">specify</span></span><br><span class="line">            <span class="keyword">specparam</span> a_to_out=<span class="number">9</span>;</span><br><span class="line">            <span class="keyword">specparam</span> b_to_out=<span class="number">11</span>;</span><br><span class="line">            (a=&gt;out)=a_to_out;</span><br><span class="line">            (b=&gt;out)=b_to_out;</span><br><span class="line">        <span class="keyword">endspecify</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><code>specparam</code>和<code>parameter</code>的区别如下:</p>
<ol type="1">
<li><code>specparam</code>语句只能在<code>specify</code>块中使用,
而<code>parameter</code>语句不能在<code>specify</code>块中使用.</li>
<li><code>specparam</code>语句定义的参数是延时参数,
而<code>parameter</code>定义的参数可以是任意数据类型的常参数.</li>
<li><code>specparam</code>语句定义的延时参数只能在<code>specify</code>块中使用,
而<code>parameter</code>定义的参数可以在模块内的任意位置处使用.</li>
</ol>
<h2 id="编译预处理语句">编译预处理语句</h2>
<p>编译预处理是Verilog HDL编译系统的一个组成部分,
指的是编译系统会对一些命令进行一些预处理,
然后将预处理结果和源程序一起再进行通常的编译处理.
以反引号”`“开始的某些标识符是编译预处理语句.</p>
<h3 id="宏定义">宏定义</h3>
<p><code>define</code>指令是一个宏定义命令,
通过一个指定的标识符来代表一个字符串.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span></span></span><br></pre></td></tr></table></figure>
<h2 id="verilog-hdl测试方法简介">Verilog HDL测试方法简介</h2>
<ol type="1">
<li>完全测试法</li>
<li>随机测试法</li>
<li>自动测试法</li>
</ol>
<h2 id="习题">习题</h2>
<ol type="1">
<li><p>用Verilog HDL的门级建模描述如下电路, 要求:
输入为<code>a, b, s</code>, 三个<code>wire sa, sb, s0</code>,
输出为<code>y</code>, 满足如下关系:</p>
<p><span class="math display">\[\begin{aligned}
     &amp;s0=\overline{s}\\
     &amp;sa=s0\cdot a\\
     &amp;sb=s\cdot b\\
     &amp;y=sa+sb\\
\end{aligned}\]</span></p>
<p>且延迟时间设定如下表所示:</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>最小值min</th>
<th>典型值type</th>
<th>最大值max</th>
</tr>
</thead>
<tbody>
<tr>
<td>a-sa-y</td>
<td>10</td>
<td>12</td>
<td>14</td>
</tr>
<tr>
<td>s-s0-sa-y</td>
<td>15</td>
<td>17</td>
<td>19</td>
</tr>
<tr>
<td>s-sb-y</td>
<td>11</td>
<td>13</td>
<td>15</td>
</tr>
<tr>
<td>b-sb-y</td>
<td>10</td>
<td>12</td>
<td>14</td>
</tr>
</tbody>
</table>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2to1(a, b, s, y);</span><br><span class="line">    <span class="keyword">input</span>  a, b, s;</span><br><span class="line">    <span class="keyword">output</span> y;</span><br><span class="line">    <span class="keyword">wire</span>   sa, sb, s0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">not</span> <span class="variable">#(4, 5, 6) (s0, s)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(6, 7, 8) (sa, s0, a)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(6, 7, 8) (sb, s, b)</span>;</span><br><span class="line">    <span class="keyword">or</span> <span class="variable">#(5, 6, 7) (y, sa, sb)</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>在Verilog HDL中产生如下信号</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr>
<th>信号名</th>
<th>0~5ns</th>
<th>5~10ns</th>
<th>10~15ns</th>
<th>15~20ns</th>
<th>20~25ns</th>
<th>25~30ns</th>
<th>30~35ns</th>
<th>35~40ns</th>
<th>40~45ns</th>
<th>＞45ns</th>
</tr>
</thead>
<tbody>
<tr>
<td>clk</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>in1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>in2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> signal_tb;</span><br><span class="line">    <span class="keyword">reg</span> clk, in1, in2;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">5</span> clk = ~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">10</span> in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">            in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">5</span>  in2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>根据下面的程序, 画出产生的信号波形</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> para(a,b);</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> a, b;</span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            a=<span class="number">1</span>;</span><br><span class="line">            b=<span class="number">1</span>;</span><br><span class="line">            #<span class="number">100</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                b=<span class="number">0</span>;</span><br><span class="line">                #<span class="number">50</span> b=<span class="number">1</span>;</span><br><span class="line">                #<span class="number">150</span> a=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">join</span></span><br><span class="line">            #<span class="number">100</span> b=<span class="number">0</span>;</span><br><span class="line">            #<span class="number">50</span> a=<span class="number">0</span>;</span><br><span class="line">            b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>0~100ns</th>
<th>100~150ns</th>
<th>150~250ns</th>
<th>250~350ns</th>
<th>350~400ns</th>
<th>&gt;400ns</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>b</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table></li>
<li><p>用任务方式编写4 bit行波加法器, 再调用此任务完成8
bit行波进位加法器. 要求: 输入有三个:<code>A[3:0], B[3:0], Cin</code>,
这三个输入经过4
bit行波加法器后产生两个输出<code>SUM[4:0], Cout</code>.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_8bit(A, B, Cin, SUM, Cout);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] A, B;</span><br><span class="line">    <span class="keyword">input</span>        Cin;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] SUM;</span><br><span class="line">    <span class="keyword">output</span>       Cout;</span><br><span class="line">    <span class="keyword">wire</span> carry_out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> adder_4bit;</span><br><span class="line">        <span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] A4, B4;</span><br><span class="line">        <span class="keyword">input</span>        Cin4;</span><br><span class="line">        <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] SUM5;</span><br><span class="line">        <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] sum_temp;</span><br><span class="line">        <span class="keyword">reg</span>          cout_temp;</span><br><span class="line">        <span class="keyword">integer</span> i;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            cout_temp=Cin4;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i=i+<span class="number">1</span>) </span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    sum_temp[i]=A4[i]^B4[i]^cout_temp;</span><br><span class="line">                    cout_temp=(A4[i]&amp;B4[i])|(A4[i]&amp;cout_temp)|(B4[i]&amp;cout_temp);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            SUM5 = &#123;cout_temp, sum_temp&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] sum_low, sum_high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        adder_4bit(A[<span class="number">3</span>:<span class="number">0</span>], B[<span class="number">3</span>:<span class="number">0</span>], Cin, sum_low);</span><br><span class="line">        adder_4bit(A[<span class="number">7</span>:<span class="number">4</span>], B[<span class="number">7</span>:<span class="number">4</span>], sum_low[<span class="number">4</span>], sum_high);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> SUM = &#123;sum_high[<span class="number">3</span>:<span class="number">0</span>], sum_low[<span class="number">3</span>:<span class="number">0</span>]&#125;;</span><br><span class="line">    <span class="keyword">assign</span> Cout = sum_high[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用函数编写2 bit 2-1多路选择器, 再调用此函数完成2 bit
4-1多路选择器. 要求: 输入有两个<code>A[1:0], B[1:0]</code>,
这两个输入经过2 bit 2-1MUX后得到一个输出<code>Y[1:0]</code>.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux_4to1_2bit(A, B, C, D, Sel, Y);</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] A, B, C, D;</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] Sel;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>] Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> [<span class="number">1</span>:<span class="number">0</span>] mux_2to1_2bit;</span><br><span class="line">        <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] in0, in1;</span><br><span class="line">        <span class="keyword">input</span>       sel;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            mux_2to1_2bit=sel?in1:in0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] mux0_out, mux1_out;</span><br><span class="line">    <span class="keyword">assign</span> mux0_out=mux_2to1_2bit(A, B, Sel[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> mux1_out=mux_2to1_2bit(C, D, Sel[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">assign</span> Y=mux_2to1_2bit(mux0_out, mux1_out, Sel[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>用Verilog HDL为如下的环形移位寄存器编写Testbench,
并利用系统函数<code>$display</code>把当前时间显示出来.</p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> shiftregist1(D, clk, reset);</span><br><span class="line">    <span class="keyword">parameter</span> shiftregist_width=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [shiftregist_width-<span class="number">1</span>:<span class="number">0</span>] D;</span><br><span class="line">    <span class="keyword">input</span>                              clk, reset;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(!reset)</span><br><span class="line">            D&lt;=<span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            D&lt;=&#123;D[shiftregist_width-<span class="number">2</span>:<span class="number">0</span>], D[shiftregist_width-<span class="number">1</span>]&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> tb_shiftregist1;</span><br><span class="line">    <span class="keyword">reg</span>        clk, reset;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] D;</span><br><span class="line"></span><br><span class="line">    shiftregist1 U1 (<span class="variable">.D</span>(D), <span class="variable">.clk</span>(clk), <span class="variable">.reset</span>(reset));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">forever</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        reset = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset asserted&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        #<span class="number">20</span> reset = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset deasserted&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        U1<span class="variable">.D</span> = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Initial value set to %b&quot;</span>, <span class="built_in">$time</span>, U1<span class="variable">.D</span>);</span><br><span class="line">        #<span class="number">200</span>;</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Test completed&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Clock posedge, D = %b&quot;</span>, <span class="built_in">$time</span>, D);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Time = %0t: Reset changed to %b&quot;</span>, <span class="built_in">$time</span>, reset);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SiyuanLei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
